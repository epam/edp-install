{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-do-i-set-parallel-reconciliation-for-a-number-of-codebase-branches","title":"How Do I Set Parallel Reconciliation for a Number of Codebase Branches?","text":"<p>Set the CODEBASE_BRANCH_MAX_CONCURRENT_RECONCILES Env variable in codebase-operator by updating Deployment template. For example:</p> <pre><code>          ...\n          env:\n            - name: WATCH_NAMESPACE\n          ...\n\n            - name: CODEBASE_BRANCH_MAX_CONCURRENT_RECONCILES\n              value: 10\n...\n</code></pre> <p>It's not recommended to set the value above 10.</p>"},{"location":"faq/#how-to-change-the-lifespan-of-an-access-token-that-is-used-for-headlamp-and-oidc-login-plugin","title":"How To Change the Lifespan of an Access Token That Is Used for Headlamp and 'oidc-login' Plugin?","text":"<p>Change the Access Token Lifespan: go to your Keycloak and select Openshift realm &gt; Realm settings &gt; Tokens &gt; Access Token Lifespan &gt; set a new value to the field and save this change.</p> <p>By default, \"Access Token Lifespan\" value is 5 minutes.</p> <p> Access Token Lifespan </p>"},{"location":"features/","title":"Basic Concepts","text":"<p>Consult EDP Glossary section for definitions mentioned on this page and EDP Toolset to have a full list of tools used with the Platform. The below table contains a full list of features provided by EDP.</p> Features Description Cloud Agnostic EDP runs on Kubernetes cluster, so any Public Cloud Provider which provides Kubernetes can be used. Kubernetes clusters deployed on-premises work as well CI/CD for Microservices EDP is initially designed to support CI/CD for Microservices running as containerized applications inside Kubernetes Cluster. EDP also supports CI for:- Terraform Modules, - Open Policy Rules,- Workflows for Java (8,11,17), JavaScript (React, Vue, Angular, Express, Antora), C# (.NET 6.0), Python (FastAPI, Flask, 3.8), Go (Beego, Operator SDK) Version Control System (VCS) EDP installs Gerrit as a default Source Code Management (SCM) tool. EDP also supports GitHub and GitLab integration Branching Strategy EDP supports Trunk-based development as well as GitHub/GitLab flow. EDP creates two Pipelines per each codebase branch (see Pipeline Framework): Code Review and Build Repository Structure EDP provides separate Git repository per each Codebase and doesn't work with Monorepo. However, EDP does support customization and runs helm-lint, dockerfile-lint steps using Monorepo approach. Artifacts Versioning EDP supports two approaches for Artifacts versioning: - default (BRANCH-[TECH_STACK_VERSION]-BUILD_ID)- EDP (MAJOR.MINOR.PATCH-BUILD_ID), which is SemVer.Custom versioning can be created by implementing get-version stage Application Library EDP provides baseline codebase templates for Microservices, Libraries, within create strategy while onboarding new Codebase Stages Library Each EDP Pipeline consists of pre-defined steps (stages). Consult library documentation for more details CI Pipelines EDP provides CI Pipelines for first-class citizens: - Applications (Microservices) based on Java (8,11,17), JavaScript (React, Vue, Angular, Express, Antora), C# (.NET 6.0), Python (FastAPI, Flask, 3.8), Go (Beego, Operator SDK)- Libraries based on Java (8,11,17), JavaScript (React, Vue, Angular, Express), Python (FastAPI, Flask, 3.8), Groovy Pipeline (Codenarc), Terraform, Rego (OPA), Container (Docker), Helm (Pipeline), C#(.NET 6.0)- Autotests based on Java8, Java11, Java17 CD Pipelines EDP provides capabilities to design CD Pipelines (in Admin Console) for Microservices and defines logic for artifacts flow (promotion) from env to env. Artifacts promotion is performed automatically (Autotests), manually (User Approval) or combining both approaches Autotests EDP provides CI pipeline for autotest implemented in Java. Autotests can be used as Quality Gates in CD Pipelines Custom Pipeline Library EDP can be extended by introducing Custom Pipeline Library Dynamic Environments Each EDP CD Pipeline creates/destroys environment upon user requests"},{"location":"getting-started/","title":"Quick Start","text":""},{"location":"getting-started/#software-requirements","title":"Software Requirements","text":"<ul> <li>Kubernetes cluster 1.23+ or OpenShift 4.9+;</li> <li>Kubectl tool;</li> <li>Helm 3.10.x+;</li> <li>Keycloak 18.0+;</li> <li>Kiosk 0.2.11.</li> </ul>"},{"location":"getting-started/#minimal-hardware-requirements","title":"Minimal Hardware Requirements","text":"<p>The system should have the following specifications to run properly:</p> <ul> <li>CPU: 8 Core</li> <li>Memory: 32 Gb</li> </ul>"},{"location":"getting-started/#edp-toolset","title":"EDP Toolset","text":"<p>EPAM Delivery Platform supports the following tools:</p> Domain Related Tools/Solutions Artifacts Management Nexus Repository, Jfrog Artifactory AWS IRSA, AWS ECR, AWS EFS, Parameter Store, S3, ALB/NLB, Route53 Build .NET, Go, Apache Gradle, Apache Maven, NPM Cluster Backup Velero Code Review Gerrit, GitLab, GitHub Container Registry AWS ECR, OpenShift Registry, Harbor, DockerHub Containers Hadolint, Kaniko, Crane Documentation as Code MkDocs, Antora (AsciiDoc) Infrastructure as Code Terraform, TFLint, Terraform Docs, Crossplane, AWS Controllers for Kubernetes Kubernetes Deployment Kubectl, Helm, Helm Docs, Chart Testing, Argo CD, Argo Rollout Kubernetes Multitenancy Kiosk Logging OpenSearch, EFK, ELK, Loki, Splunk Monitoring Prometheus, Grafana, VictoriaMetrics Pipeline Orchestration Tekton, Jenkins Policies/Rules Open Policy Agent Secrets Management External Secret Operator, Vault Secure Development SonarQube, DefectDojo, Dependency Track,  Semgrep, Grype, Trivy, Clair, GitLeaks, CycloneDX Generator, tfsec, checkov SSO Keycloak, oauth2-proxy Test Report Tool ReportPortal, Allure Tracing OpenTelemetry, Jaeger"},{"location":"getting-started/#install-edp","title":"Install EDP","text":"<p>To install EDP with the necessary parameters, please refer to the Install EDP section of the Operator Guide. Mind the parameters in the EDP installation chart. For details, please refer to the values.yaml.</p> <p>Find below the example of the installation command:</p> <pre><code>    helm install edp epamedp/edp-install --wait --timeout=900s \\\n    --version &lt;edp_version&gt; \\\n    --set global.edpName=&lt;edp-project&gt; \\\n    --set global.dnsWildCard=&lt;cluster_DNS_wilcdard&gt; \\\n    --set global.webConsole.url=&lt;kubeconfig.clusters.cluster.server&gt; \\\n    --set global.platform=&lt;platform_type&gt; \\\n    --set awsRegion=&lt;region&gt; \\\n    --set global.dockerRegistry.url=&lt;aws_account_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com \\\n    --set keycloak-operator.keycloak.url=&lt;keycloak_endpoint&gt; \\\n    --set global.gerritSSHPort=&lt;gerrit_ssh_port&gt; \\\n    --namespace &lt;edp-project&gt;\n</code></pre> <p>Warning</p> <p>Please be aware that the command above is an example.</p>"},{"location":"getting-started/#related-articles","title":"Related Articles","text":"<p>Getting Started</p>"},{"location":"glossary/","title":"Glossary","text":"<p>Get familiar with the definitions and context for the most useful EDP terms presented in table below.</p> Terms Details EDP Component - an item used in CI/CD process EDP Headlamp UI - an EDP component that helps to manage, set up, and control the business entities. Artifactory - an EDP component that stores all the binary artifacts. NOTE: Nexus is used as a possible implementation of a repository. CI/CD Server - an EDP component that launches pipelines that perform the build, QA, and deployment code logic. NOTE: Jenkins is used as a possible implementation of a CI/CD server. Code Review tool - an EDP component that collaborates with the changes in the codebase. NOTE: Gerrit is used as a possible implementation of a code review tool. Identity Server - an authentication server providing a common way to verify requests to all of the applications. NOTE: Keycloak is used as a possible implementation of an identity server. Security Realm Tenant - a realm in identity server (e.g Keycloak) where all users' accounts and their access permissions are managed. The realm is unique for the identity server instance. Static Code Analyzer - an EDP component that inspects continuously a code quality before the necessary changes appear in a master branch. NOTE: SonarQube is used as a possible implementation of a static code analyzer. VCS (Version Control System) - a replication of the Gerrit repository that displays all the changes made by developers. NOTE: GitHub and GitLab are used as the possible implementation of a repository with the version control system. EDP Business Entity - a part of the CI/CD process (the integration, delivery, and deployment of any codebase changes) Application - a codebase type that is built as the binary artifact and deployable unit with the code that is stored in VCS. As a result, the application becomes a container and can be deployed in an environment. Autotests - a codebase type that inspects a product (e.g. an application set) on a stage. Autotests are not deployed to any container and launched from the respective code stage. CD Pipeline (Continuous Delivery Pipeline) - an EDP business entity that describes the whole delivery process of the selected application set via the respective stages. The main idea of the CD pipeline is to promote the application version between the stages by applying the sequential verification (i.e. the second stage will be available if the verification on the first stage is successfully completed). NOTE: The CD pipeline can include the essential set of applications with its specific stages as well. CD Pipeline Stage - an EDP business entity that is presented as the logical gate required for the application set inspection. Every stage has one OpenShift project where the selected application set is deployed. All stages are sequential and promote applications one-by-one. Codebase - an EDP business entity that possesses a code. Codebase Branch - an EDP business entity that represents a specific version in a Git branch. Every codebase branch has a Codebase Docker Stream entity. Codebase Docker Stream - a deployable component that leads to the application build and displays that the last build was verified on the specific stage. Every CD pipeline stage accepts a set of Codebase Docker Streams (CDS) that are input and output. SAMPLE: if an application1 has a master branch, the input CDS will be named as [app name]-[pipeline name]-[stage name]-[master] and the output after the passing of the DEV stage will be as follows: [app name]-[pipeline name]-[stage name]-[dev]-[verified]. Library - a codebase type that is built as the binary artifact, i.e. it`s stored in the Artifactory and can be uploaded by other applications, autotests or libraries. Quality Gate - an EDP business entity that represents the minimum acceptable results after the testing. Every stage has a quality gate that should be passed to promote the application. The stage quality gate can be a manual approve from a QA specialist OR a successful autotest launch. Quality Gate Type - this value defines trigger type that promotes artifacts (images) to the next environment in CD Pipeline. There are manual and automatic types of quality gates. The manual type means that the promoting process should be confirmed in Jenkins. The automatic type promotes the images automatically in case there are no errors in the Allure Report. NOTE: If any of the test types is not passed, the CD pipeline will fail. Trigger Type - a value that defines a trigger type used for the CD pipeline triggering. There are manual and automatic types of triggering. The manual type means that the CD pipeline should be triggered manually. The automatic type triggers the CD pipeline automatically as soon as the Codebase Docker Stream was changed. EDP CI/CD Pipelines Framework - a library that allows extending the Jenkins pipelines and stages to develop an application. Pipelines are presented as the shared library that can be connected in Jenkins. The library is connected using the Git repository link (a public repository that is supported by EDP) on the GitHub. Allure Report- a tool that represents test results in one brief report in a clear form. Automated Tests - different types of automated tests that can be run on the environment for a specific stage. Build Pipeline - a Jenkins pipeline that builds a corresponding codebase branch in the Codebase. Build Stage - a stage that takes place after the code has been submitted/merged to the repository of the main branch (the pull request from the feature branch is merged to the main one, the Patch set is submitted in Gerrit). Code Review Pipeline - a Jenkins pipeline that inspects the code candidate in the Code Review tool. Code Review Stage - a stage where code is reviewed before it goes to the main branch repository of the version control system (the commit to the feature branch is pushed, the Patch set is created in Gerrit). Deploy Pipeline - a Jenkins pipeline that is responsible for the CD Pipeline Stage deployment with the full set of applications and autotests. Deployment Stage - a part of the Continuous Delivery where artifacts are being deployed to environments. EDP CI/CD Pipelines - an orchestrator for stages that is responsible for the common technical events, e.g. initialization, in Jenkins pipeline. The set of stages for the pipeline is defined as an input JSON file for the respective Jenkins job. NOTE: There is the ability to create the necessary realization of the library pipeline on your own as well. EDP CI/CD Stages - a repository that is launched in the Jenkins pipeline. Every stage is presented as an individual Groovy file in a corresponding repository. Such single responsibility realization allows rewriting of one essential stage without changing the whole pipeline. Environment - a part of the stage where the built and packed into an image application are deployed for further testing. It`s possible to deploy several applications to several environments (Team and Integration environments) within one stage. Integration Environment - an environment type that is always deployed as soon as the new application version is built in order to launch the integration test and promote images to the next stages. The Integration Environment can be triggered manually or in case a new image appears in the Docker registry. Jenkinsfile - a text file that keeps the definition of a Jenkins Pipeline and is checked into source control. Every Job has its Jenkinsfile that is stored in the specific application repository and in Jenkins as the plain text. Jenkins Node - a machine that is a part of the Jenkins environment that is capable of executing a pipeline. Jenkins Pipeline - a user-defined model of a CD pipeline. The pipeline code defines the entire build process. Jenkins Stage - a part of the whole CI/CD process that should pass the source code in order to be released and deployed on the production. Team Environment - an environment type that can be deployed at any time by the manual trigger of the Deploy pipeline where team or developers can check out their applications. NOTE: The promotion from such kind of environment is prohibited and developed only for the local testing. OpenShift / Kubernetes (K8S) ConfigMap - a resource that stores configuration data and processes the strings that do not contain sensitive information. Docker Container - is a lightweight, standalone, and executable package. Docker Registry - a store for the Docker Container that is created for the application after the Build pipeline performance. OpenShift Web Console - a web console that enables to view, manage, and change OpenShift / K8S resources using browser. Operator Framework - a deployable unit in OpenShift that is responsible for one or a set of resources and performs its life circle (adding, displaying, and provisioning). Path - a route component that helps to find a specified path (e.g. /api) at once and skip the other. Pod - the smallest deployable unit of the large microservice application that is responsible for the application launch. The pod is presented as the one launched Docker container. When the Docker container is collected, it will be kept in Docker Registry and then saved as Pod in the OpenShift project. NOTE: The Deployment Config is responsible for the Pod push, restart, and stop processes. PV (Persistent Volume) - a cluster resource that captures the details of the storage implementation and has an independent lifecycle of any individual pod. PVC (Persistent Volume Claim) - a user request for storage that can request specific size and access mode. PV resources are consumed by PVCs. Route - a resource in OpenShift that allows getting the external access to the pushed application. Secret - an object that stores and manages all the sensitive information (e.g. passwords, tokens, and SSH keys). Service - an external connection point with Pod that is responsible for the network. A specific Service is connected to a specific Pod using labels and redirects all the requests to Pod as well. Site - a route component (link name) that is created from the indicated application name and applies automatically the project name and a wildcard DNS record."},{"location":"overview/","title":"Overview","text":"<p>EPAM Delivery Platform (EDP) is an open-source cloud-agnostic SaaS/PaaS solution for software development, licensed under Apache License 2.0. It provides a pre-defined set of CI/CD patterns and tools, which allow a user to start product development quickly with established code review, release, versioning, branching, build processes. These processes include static code analysis, security checks, linters, validators, dynamic feature environments provisioning. EDP consolidates the top Open-Source CI/CD tools by running them on Kubernetes/OpenShift, which enables web/app development either in isolated (on-prem) or cloud environments.</p> <p>EPAM Delivery Platform, which is also called \"The Rocket\", is a platform that allows shortening the time that is passed before an active development can be started from several months to several hours.</p> <p>EDP consists of the following:</p> <ul> <li>The platform based on managed infrastructure and container orchestration</li> <li>Security covering authentication, authorization, and SSO for platform services</li> <li>Development and testing toolset</li> <li>Well-established engineering process and EPAM practices (EngX) reflected in CI/CD pipelines, and delivery analytics</li> <li>Local development with debug capabilities</li> </ul>"},{"location":"overview/#features","title":"Features","text":"<ul> <li>Deployed and configured CI/CD toolset (Tekton, ArgoCD, Jenkins, Nexus, SonarQube, DefectDojo)</li> <li>Gerrit, GitLab or GitHub as a version control system for your code</li> <li>Tekton is a default pipeline orchestrator</li> <li>Jenkins is an optional pipeline orchestrator</li> <li> <p>CI pipelines</p> Tekton (by default)Jenkins (optional) Language Framework Build Tool Application Library Autotest Java Java 8, Java 11, Java 17 Gradle, Maven Python Python 3.8, FastAPI, Flask Python C# .Net 3.1, .Net 6.0 .Net Go Beego, Gin, Operator SDK Go JavaScript React, Vue, Angular, Express, Next.js, Antora NPM HCL Terraform Terraform Helm Helm, Pipeline Helm Groovy Codenarc Codenarc Rego OPA OPA Container Docker Kaniko Language Framework Build Tool Application Library Autotest Java Java 8, Java 11 Gradle, Maven Python Python 3.8 Python .Net .Net 3.1 .Net Go Beego, Operator SDK Go JavaScript React NPM HCL Terraform Terraform Groovy Codenarc Codenarc Rego OPA OPA Container Docker Kaniko </li> </ul> <ul> <li>Headlamp UI as a single entry point</li> <li>CD pipeline for Microservice Deployment</li> <li>Kubernetes native approach (CRD, CR) to declare CI/CD pipelines</li> </ul>"},{"location":"overview/#whats-inside","title":"What's Inside","text":"<p>EPAM Delivery Platform (EDP) is suitable for all aspects of delivery starting from development including the capability to deploy production environment. EDP architecture is represented on a diagram below.</p> <p> Architecture </p> <p>EDP consists of four cross-cutting concerns:</p> <ol> <li>Infrastructure as a Service;</li> <li>GitOps approach;</li> <li>Container orchestration and centralized services;</li> <li>Security.</li> </ol> <p>On the top of these indicated concerns, EDP adds several blocks that include:</p> <ul> <li>EDP CI/CD Components. EDP component enables a feature in CI/CD or an instance artifacts storage and distribution (Nexus or Artifactory), static code analysis (Sonar), etc.;</li> <li>EDP Artifacts. This element represents an artifact that is being delivered through EDP and presented as a code. <p>Artifact samples: frontend, backend, mobile, applications, functional and non-functional autotests, workloads for 3rd party components that can be deployed together with applications.</p> </li> </ul> <ul> <li>EDP development and production environments that share the same logic. Environments wrap a set of artifacts with a specific version, and allow performing SDLC routines in order to be sure of the artifacts quality;</li> <li>Pipelines. Pipelines cover CI/CD process, production rollout and updates. They also connect three elements indicated above via automation allowing SDLC routines to be non-human;</li> </ul>"},{"location":"overview/#technology-stack","title":"Technology Stack","text":"<p>Explore the EDP technology stack diagram</p> <p> Technology stack </p> <p>The EDP IaaS layer supports most popular public clouds AWS, Azure and GCP keeping the capability to be deployed on private/hybrid clouds based on OpenStack. EDP containers are based on Docker technology, orchestrated by Kubernetes compatible solutions.</p> <p>There are two main options for Kubernetes provided by EDP:</p> <ul> <li>Managed Kubernetes in Public Clouds to avoid installation and management of Kubernetes cluster, and get all benefits of scaling, reliability of this solution;</li> <li>OpenShift that is a Platform as a Service on the top of Kubernetes from Red Hat. OpenShift is the default option for on-premise installation and it can be considered whether the solution built on the top of EDP should be cloud-agnostic or require enterprise support;</li> </ul> <p>There is no limitation to run EDP on vanilla Kubernetes.</p>"},{"location":"overview/#related-articles","title":"Related Articles","text":"<ul> <li>Quick Start</li> <li>Basic Concepts</li> <li>Glossary</li> <li>Supported Versions and Compatibility</li> </ul>"},{"location":"roadmap/","title":"RoadMap","text":"<p>RoadMap consists of three streams:</p> <ul> <li>Community</li> <li>Architecture</li> <li>Building Blocks</li> <li>Admin Console</li> <li>Documentation</li> </ul>"},{"location":"roadmap/#i-community","title":"I. Community","text":"<p>Goals:</p> <ul> <li>Innovation Through Collaboration</li> <li>Improve OpenSource Adoption</li> <li>Build Community around technology solutions EDP is built on</li> </ul>"},{"location":"roadmap/#deliver-operators-on-operatorhub","title":"Deliver Operators on OperatorHub","text":"<p>OperatorHub is a defacto leading solution which consolidates Kubernetes Community around Operators. EDP follows the best practices of delivering Operators in a quick and reliable way. We want to improve Deployment and Management experience for our Customers by publishing all EDP operators on this HUB.</p> <p>Another artifact aggregator which is used by EDP - ArtifactHub, that holds description for both components: stable and under-development.</p> <p>OperatorHub. Keycloak Operator</p> <p>EDP Keycloak Operator is now available from OperatorHub both for Upstream (Kubernetes) and OpenShift deployments.</p>"},{"location":"roadmap/#ii-architecture","title":"II. Architecture","text":"<p>Goals:</p> <ul> <li>Improve reusability for EDP components</li> <li>Integrate Kubernetes Native Deployment solutions</li> <li>Introduce abstraction layer for CI/CD components</li> <li>Build processes around the GitOps approach</li> <li>Introduce secrets management</li> </ul>"},{"location":"roadmap/#kubernetes-multitenancy","title":"Kubernetes Multitenancy","text":"<p>Multiple instances of EDP are run in a single Kubernetes cluster. One way to achieve this is to use Multitenancy. Initially, Kiosk was selected as tools that provides this capability. An alternative option that EDP Team took into consideration is Capsule. Another tool which goes far beyond multitenancy is vcluster going a good candidate for e2e testing scenarios where one needs simple lightweight kubernetes cluster in CI pipelines.</p>"},{"location":"roadmap/#microservice-reference-architecture-framework","title":"Microservice Reference Architecture Framework","text":"<p>EDP provides basic Application Templates for a number of technology stacks (Java, .Net, NPM, Python) and Helm is used as a deployment tool. The goal is to extend this library and provide: Application Templates which are built on pre-defined architecture patterns (e.g., Microservice, API Gateway, Circuit Breaker, CQRS, Event Driven) and Deployment Approaches: Canary, Blue/Green. This requires additional tools installation on cluster as well.</p>"},{"location":"roadmap/#policy-enforcement-for-kubernetes","title":"Policy Enforcement for Kubernetes","text":"<p>Running workload in Kubernetes calls for extra effort from Cluster Administrators to ensure those workloads do follow best practices or specific requirements defined on organization level. Those requirements can be formalized in policies and integrated into: CI Pipelines and Kubernetes Cluster (through Admission Controller approach) - to guarantee proper resource management during development and runtime phases. EDP uses Open Policy Agent (from version 2.8.0), since it supports compliance check for more use-cases: Kubernetes Workloads, Terraform and Java code, HTTP APIs and many others. Kyverno is another option being checked in scope of this activity.</p>"},{"location":"roadmap/#secrets-management","title":"Secrets Management","text":"<p>EDP should provide secrets management as a part of platform. There are multiple tools providing secrets management capabilities. The aim is to be aligned with GitOps and Operator Pattern approaches so HashiCorp Vault, Banzaicloud Bank Vaults, Bitnami Sealed Secrets are currently used for internal projects and some of them should be made publicly available - as a part of EDP Deployment.</p> <p>EDP Release 2.12.x</p> <p>External Secret Operator is a recommended secret management tool for the EDP components.</p>"},{"location":"roadmap/#release-management","title":"Release Management","text":"<p>Conventional Commits and Conventional Changelog are two approaches to be used as part of release process. Today EDP provides only capabilities to manage Release Branches. This activity should address this gap by formalizing and implementing Release Process as a part of EDP. Topics to be covered: Versioning, Tagging, Artifacts Promotion.</p>"},{"location":"roadmap/#kubernetes-native-cicd-pipelines","title":"Kubernetes Native CI/CD Pipelines","text":"<p>EDP uses Jenkins as Pipeline Orchestrator. Jenkins runs workload for CI and CD parts. There is also basic support for GitLab CI, but it provides Docker image build functionality only. EDP works on providing an alternative to Jenkins and use Kubernetes Native Approach for pipeline management. There are a number of tools, which provides such capability:</p> <ul> <li>Argo CD</li> <li>Argo Workflows</li> <li>Argo Rollouts</li> <li>Tekton</li> <li>Drone</li> <li>Flux</li> </ul> <p>This list is under investigation and solution is going to be implemented in two steps:</p> <ol> <li>Introduce tool that provide Continues Delivery/Deployment approach. Argo CD is one of the best to go with.</li> <li>Integrate EDP with tool that provides Continues Integration capabilities.</li> </ol> <p>EDP Release 2.12.x</p> <p>Argo CD is suggested as a solution providing the <code>Continuous Delivery</code> capabilities.</p> <p>EDP Release 3.0</p> <p>Tekton is used as a CI/CD pipelines orchestration tool on the platform. Review edp-tekton GitHub repository that keeps all the logic behind this solution on the EDP (Pipelines, Tasks, TriggerTemplates, Interceptors, etc). Get acquainted with the series of publications on our Medium Page.</p>"},{"location":"roadmap/#advanced-edp-role-based-model","title":"Advanced EDP Role-based Model","text":"<p>EDP has a number of base roles which are used across EDP. In some cases it is necessary to provide more granular permissions for specific users. It is possible to do this using Kubernetes Native approach.</p>"},{"location":"roadmap/#notifications-framework","title":"Notifications Framework","text":"<p>EDP has a number of components which need to report their statuses: Build/Code Review/Deploy Pipelines, changes in Environments, updates with artifacts. The goal for this activity is to onboard Kubernetes Native approach which provides Notification capabilities with different sources/channels integration (e.g. Email, Slack, MS Teams). Some of these tools are Argo Events, Botkube.</p>"},{"location":"roadmap/#reconciler-component-retirement","title":"Reconciler Component Retirement","text":"<p>Persistent layer, which is based on edp-db (PostgreSQL) and reconciler component should be retired in favour of Kubernetes Custom Resource (CR). The latest features in EDP are implemented using CR approach.</p> <p>EDP Release 3.0</p> <p>Reconciler component is deprecated and is no longer supported. All the EDP components are migrated to Kubernetes Custom Resources (CR).</p>"},{"location":"roadmap/#iii-building-blocks","title":"III. Building Blocks","text":"<p>Goals:</p> <ul> <li>Introduce best practices from Microservice Reference Architecture deployment and observability using Kubernetes Native Tools</li> <li>Enable integration with the Centralized Test Reporting Frameworks</li> <li>Onboard SAST/DAST tool as a part of CI pipelines and Non-Functional Testing activities</li> </ul> <p>EDP Release 2.12.x</p> <p>SAST is introduced as a mandatory part of the CI Pipelines. The list of currently supported SAST scanners and the instruction on how to add them are also available.</p>"},{"location":"roadmap/#infrastructure-as-code","title":"Infrastructure as Code","text":"<p>EDP Target tool for Infrastructure as Code (IaC) is Terraform. EDP sees two CI/CD scenarios while working with IaC: Module Development and Live Environment Deployment. Today, EDP provides basic capabilities (CI Pipelines) for Terraform Module Development. At the same time, currently EDP doesn't provide Deployment pipelines for Live Environments and the feature is under development. Terragrunt is an option to use in Live Environment deployment. Another Kubernetes Native approach to provision infrastructure components is Crossplane.</p>"},{"location":"roadmap/#database-schema-management","title":"Database Schema Management","text":"<p>One of the challenges for Application running in Kubernetes is to manage database schema. There are a number of tools which provides such capabilities, e.g. Liquibase, Flyway. Both tools provide versioning control for database schemas. There are different approaches on how to run migration scripts in Kubernetes: in init container, as separate Job or as a separate CD stage. Purpose of this activity is to provide database schema management solution in Kubernetes as a part of EDP. EDP Team investigates SchemaHero tool and use-cases which suits Kubernetes native approach for database schema migrations.</p>"},{"location":"roadmap/#open-policy-agent","title":"Open Policy Agent","text":"<p>Open Policy Agent is introduced in version 2.8.0. EDP now supports CI for Rego Language, so you can develop your own policies. The next goal is to provide pipeline steps for running compliance policies check for Terraform, Java, Helm Chart as a part of CI process.</p>"},{"location":"roadmap/#report-portal","title":"Report Portal","text":"<p>EDP uses Allure Framework as a Test Report tool. Another option is to integrate Report Portal into EDP ecosystem.</p> <p>EDP Release 3.0</p> <p>Use ReportPortal to consolidate and analyze your Automation tests results. Consult our pages on how to perform reporting and Keycloak integration.</p>"},{"location":"roadmap/#carrier","title":"Carrier","text":"<p>Carrier provides Non-functional testing capabilities.</p>"},{"location":"roadmap/#java-17","title":"Java 17","text":"<p>EDP supports two LTS versions of Java: 8 and 11. The goal is to provide Java 17 (LTS) support.</p> <p>EDP Release 3.2.1</p> <p>CI Pipelines for Java 17 is available in EDP.</p>"},{"location":"roadmap/#velero","title":"Velero","text":"<p>Velero is used as a cluster backup tool and is deployed as a part of Platform. Currently, Multitenancy/On-premise support for backup capabilities is in process.</p>"},{"location":"roadmap/#istio","title":"Istio","text":"<p>Istio is to be used as a Service Mesh and to address challenges for Microservice or Distributed Architectures.</p>"},{"location":"roadmap/#kong","title":"Kong","text":"<p>Kong is one of tools which is planned to use as an API Gateway solution provider. Another possible candidate for investigation is Ambassador API Gateway</p>"},{"location":"roadmap/#openshift-4x","title":"OpenShift 4.X","text":"<p>EDP supports the OpenShift 4.9 platform.</p> <p>EDP Release 2.12.x</p> <p>EDP Platform runs on the latest OKD versions: 4.9 and 4.10. Creating the IAM Roles for Service Account is a recommended way to work with AWS Resources from the OKD cluster.</p>"},{"location":"roadmap/#iv-admin-console-ui","title":"IV. Admin Console (UI)","text":"<p>Goals:</p> <ul> <li>Improve U\u0425 for different user types to address their concerns in the delivery model</li> <li>Introduce user management capabilities</li> <li>Enrich with traceability metrics for products</li> </ul> <p>EDP Release 2.12.x</p> <p>EDP Team has introduced a new UI component called EDP Headlamp, which will replace the EDP Admin Console in future releases. EDP Headlamp is based on the Kinvolk Headlamp UI Client.</p> <p>EDP Release 3.0</p> <p>EDP Headlamp is used as a Control Plane UI on the platform.</p>"},{"location":"roadmap/#users-management","title":"Users Management","text":"<p>EDP uses Keycloak as an Identity and Access provider. EDP roles/groups are managed inside the Keycloak realm, then these changes are propagated across the EDP Tools. We plan to provide this functionality in EDP Headlamp using the Kubernetes-native approach (Custom Resources).</p>"},{"location":"roadmap/#the-delivery-pipelines-dashboard","title":"The Delivery Pipelines Dashboard","text":"<p>The CD Pipeline section in EDP Headlamp provides basic information, such as environments, artifact versions deployed per each environment, and direct links to the namespaces. One option is to enrich this panel with metrics from the Prometheus, custom resources, or events. Another option is to use the existing dashboards and expose EDP metrics to them, for example, plugin for Lens or OpenShift UI Console.</p>"},{"location":"roadmap/#split-jira-and-commit-validation-sections","title":"Split Jira and Commit Validation Sections","text":"<p>Commit Validate step was initially designed to be aligned with Jira Integration and cannot be used as single feature. Target state is to ensure features CommitMessage Validation and Jira Integration both can be used independently. We also want to add support for Conventional Commits.</p> <p>EDP Release 3.2.0</p> <p>EDP Headlamp has separate sections for Jira Integration and CommitMessage Validation step.</p>"},{"location":"roadmap/#v-documentation-as-code","title":"V. Documentation as Code","text":"<p>Goal:</p> <ul> <li>Transparent documentation and clear development guidelines for EDP customization.</li> </ul> <p>Consolidate documentation in a single repository edp-install, use <code>mkdocs</code> tool to generate docs and GitHub Pages as a hosting solution.</p>"},{"location":"supported-versions/","title":"Supported Versions and Compatibility","text":"<p>EPAM Delivery Platform supports only the three last versions. For a stable performance, the EDP team recommends installing the corresponding Kubernetes and OpenShift versions as indicated in the table below.</p> <p>Get acquainted with the list of the latest releases and component versions on which the platform is tested and verified:</p> EDP Release Version Release Date EKS Version OpenShift Version 3.3 May 25, 2023 1.26 4.12 3.2 Mar 26, 2023 1.23 4.10 3.1 Jan 24, 2023 1.23 4.10 3.0 Dec 19, 2022 1.23 4.10 2.12 Aug 30, 2022 1.23 4.10"},{"location":"developer-guide/","title":"Overview","text":"<p>The EDP Developer guide is intended for developers and provides details on the necessary actions to extend the EDP functionality.</p>"},{"location":"developer-guide/edp-workflow/","title":"EDP Project Rules. Working Process","text":"<p>This page contains the details on the project rules and working process for EDP team and contributors. Explore the main points about working with Gerrit, following the main commit flow, as well as the details about commit types and message below.</p>"},{"location":"developer-guide/edp-workflow/#project-rules","title":"Project Rules","text":"<p>Before starting the development, please check the project rules:</p> <ol> <li> <p>It is highly recommended to become familiar with the Gerrit flow. For details, please refer to the Gerrit official documentation and pay attention to the main points:</p> <p>a. Voting in Gerrit</p> <p>b. Resolution of Merge Conflict</p> <p>c. Comments resolution</p> <p>d. One Jira task should have one Merge Request (MR). If there are many changes within one MR, add the next patch set to the open MR by selecting the Amend commit check box.</p> </li> <li> <p>Only the Assignee is responsible for the MR merge and Jira task status.</p> </li> <li> <p>Every MR should be merged in a timely manner.</p> </li> <li> <p>Log time to Jira ticket.</p> </li> </ol>"},{"location":"developer-guide/edp-workflow/#working-process","title":"Working Process","text":"<p>With EDP, the main workflow is based on the getting a Jira task and creating a Merge Request according to the rules described below.</p> <p>Workflow</p> <p>Get Jira task \u2192 implement, verify by yourself the results \u2192  create Merge Request (MR) \u2192 send for review \u2192 resolve comments/add changes, ask colleagues for the final review \u2192 track the MR merge \u2192 verify by yourself the results \u2192 change the status in the Jira ticket to CODE COMPLETE or RESOLVED \u2192 share necessary links with a QA specialist in the QA Verification channel \u2192 QA specialist closes the Jira task after his verification \u2192 Jira task should be CLOSED.</p> <p>Commit Flow</p> <ol> <li> <p>Get Jira task. Please be aware of the following points:</p> <p>a. Every task has a reporter who can provide more details in case something is not clear.</p> <p>b. The responsible person for the task and code implementation is the assignee who tracks the following:</p> <ul> <li>actual Jira task status</li> </ul> <ul> <li>time logging</li> </ul> <ul> <li>add comments, attach necessary files</li> </ul> <ul> <li>in comments, add link that refers to the merged MR (optional, if not related to many repositories)</li> </ul> <ul> <li>code review and the final merge</li> </ul> <ul> <li>MS Teams chats - ping other colleagues, answer questions, etc.</li> </ul> <ul> <li>verification by a QA specialist</li> </ul> <ul> <li>bug fixing</li> </ul> <p>c. Pay attention to the task Status that differs in different entities, the workflow will help to see the whole task processing:</p> <p> View Jira workflow </p> <p>d. There are several entities that are used on the EDP project: Story, Improvement, Task, Bug.</p> </li> <li> <p>Implement feature, improvement, fix and check the results on your own. If it is impossible to check the results of your work before the merge, verify all later.</p> </li> <li> <p>Create a Merge Request, for details, please refer to the Code Review Process.</p> </li> <li> <p>When committing, use the pattern: [EPMDEDP-JIRA Task Number]: commit type: Commit message.</p> <p>a. [EPMDEDP] - is the default part;</p> <p>b. JIRA Task Number - the number of your Jira task;</p> <p>c. commit type:</p> <p><code>feat</code>: (new feature for the user, not a new feature for build script)</p> <p><code>fix</code>: (bug fix for the user, not a fix to a build script)</p> <p><code>docs</code>: (changes to the documentation)</p> <p><code>style</code>: (formatting, missing semicolons, etc; no production code change)</p> <p><code>refactor</code>: (refactoring production code, eg. renaming a variable)</p> <p><code>test</code>: (adding missing tests, refactoring tests; no production code change)</p> <p><code>chore</code>: (updating grunt tasks etc; no production code change)</p> <p><code>!</code>: (added to other commit types to mark breaking changes) For example:</p> <pre><code>[EPMDEDP-0000]: feat!: Job provisioner is responsible for the formation of Jenkinsfile\n\nBREAKING CHANGE: Job provisioner creates Jenkinsfile and configures it in Jenkins pipeline as a pipeline script.\n</code></pre> <p>d. Commit message:</p> <ul> <li> <p>brief, for example:</p> <p><code>[EPMDEDP-0000]: fix: Fix Gerrit plugin for Jenkins provisioning</code></p> <p>or</p> </li> </ul> <ul> <li>descriptive, for example:<pre><code>[EPMDEDP-0000]: feat: Provide the ability to configure hadolint check\n\n*Add configuration files .hadolint.yaml and .hadolint.yml to stash\n</code></pre> </li> </ul> </li> </ol> <p>Note</p> <p>Make sure there is a descriptive commit message for a breaking change Merge Request. For example:</p> <p>[EPMDEDP-0000]: feat!: Job provisioner is responsible for the formation of Jenkinsfile</p> <p>BREAKING CHANGE: Job provisioner creates Jenkinsfile and configures it in Jenkins pipeline as a pipeline script.</p> <p>Note</p> <p>If a Merge Request contains both new functionality and breaking changes, make sure the functionality description is placed before the breaking changes. For example:</p> <p>[EPMDEDP-0000]: feat!: Update Gerrit to improve access</p> <ul> <li>Implement Developers group creation process</li> <li>Align group permissions</li> </ul> <p>BREAKING CHANGES: Update Gerrit config according to groups</p>"},{"location":"developer-guide/edp-workflow/#related-articles","title":"Related Articles","text":"<ul> <li>Conventional Commits</li> <li>Semantic Commit Messages</li> <li>Karma</li> </ul>"},{"location":"developer-guide/local-development/","title":"Workspace Setup Manual","text":"<p>This page is intended for developers with the aim to share details on how to set up the local environment and start coding in Go language for EPAM Delivery Platform.</p>"},{"location":"developer-guide/local-development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Git is installed;</li> </ul> <ul> <li>One of our repositories where you would like to contribute is cloned locally;</li> </ul> <ul> <li>Docker is installed;</li> </ul> <ul> <li>Kubectl is set up;</li> </ul> <ul> <li>Local Kubernetes cluster (Kind is recommended) is installed;</li> </ul> <ul> <li>Helm is installed;</li> </ul> <ul> <li>Any IDE (GoLand is used here as an example) is installed;</li> </ul> <ul> <li>GoLang stable version is installed.</li> </ul> <p>Note</p> <p>Make sure GOPATH and GOROOT environment variables are added in PATH.</p>"},{"location":"developer-guide/local-development/#environment-setup","title":"Environment Setup","text":"<p>Set up your environment by following the steps below.</p>"},{"location":"developer-guide/local-development/#set-up-your-ide","title":"Set Up Your IDE","text":"<p>We recommend using  GoLand  and enabling the  Kubernetes  plugin. Before installing plugins, make sure to save your work because IDE may require restarting.</p>"},{"location":"developer-guide/local-development/#set-up-your-operator","title":"Set Up Your Operator","text":"<p>To set up the cloned operator, follow the three steps below:</p> <ol> <li> <p>Configure Go Build Option. Open folder in GoLand, click the  button and select the <code>Go Build</code> option:</p> <p> Add configuration </p> </li> <li> <p>Fill in the variables in Configuration tab:</p> <ul> <li>In the <code>Files</code> field, indicate the path to the main.go file;</li> </ul> <ul> <li>In the <code>Working directory</code> field, indicate the path to the operator;</li> </ul> <ul> <li>In the <code>Environment field</code>, specify the namespace to watch by setting <code>WATCH_NAMESPACE</code> variable. It should equal <code>default</code> but it can be any other if required by the cluster specifications.</li> </ul> <ul> <li>In the <code>Environment field</code>, also specify the platform type by setting <code>PLATFORM_TYPE</code>. It should equal either <code>kubernetes</code> or <code>openshift</code>.</li> </ul> <p> Build config </p> </li> <li> <p>Check cluster connectivity and variables. Local development implies working within local Kubernetes clusters. Kind (Kubernetes in Docker) is recommended so set this or another environment first before running code.</p> </li> </ol>"},{"location":"developer-guide/local-development/#pre-commit-activities","title":"Pre-commit Activities","text":"<p>Before making commit and sending pull request, take care of precautionary measures to avoid crashing some other parts of the code.</p>"},{"location":"developer-guide/local-development/#testing-and-linting","title":"Testing and Linting","text":"<p>Testing and linting must be used before every single commit with no exceptions. The instructions for the commands below are written here.</p> <p>It is mandatory to run test and lint to make sure the code passes the tests and meets acceptance criteria. Most operators are covered by tests so just run them by issuing the commands \"make test\" and \"make lint\":</p> <pre><code>  make test\n</code></pre> <p>The command \"make test\" should give the output similar to the following:</p> <p> \"make test\" command </p> <pre><code>  make lint\n</code></pre> <p>The command \"make lint\" should give the output similar to the following:</p> <p> \"make lint\" command </p>"},{"location":"developer-guide/local-development/#observe-auto-generated-docs-api-and-manifests","title":"Observe Auto-Generated Docs, API and Manifests","text":"<p>The commands below are especially essential when making changes to API. The code is unsatisfactory if these commands fail.</p> <ul> <li> <p>Generate documentation in the .MD file format so the developer can read it:</p> <pre><code>make api-docs\n</code></pre> <p>The command \"make api-docs\" should give the output similar to the following:</p> </li> </ul> <p> \"make api-docs\" command with the file contents </p> <ul> <li> <p>There are also manifests within the operator that generate zz_generated.deepcopy.go file in /api/v1 directory. This file is necessary for the platform to work but it's time-consuming to fill it by yourself so there is a mechanism that does it automatically. Update it using the following command and check if it looks properly:</p> <pre><code>make generate\n</code></pre> <p>The command \"make generate\" should give the output similar to the following:</p> </li> </ul> <p> \"make generate\" command </p> <ul> <li> <p>Refresh custom resource definitions for Kubernetes, thus allowing the cluster to know what resources it deals with.</p> <pre><code>make manifests\n</code></pre> <p>The command \"make manifests\" should give the output similar to the following:</p> </li> </ul> <p> \"make manifests\" command </p> <p>At the end of the procedure, you can push your code confidently to your branch and create a pull request.</p> <p>That's it, you're all set! Good luck in coding!</p>"},{"location":"developer-guide/local-development/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Project Rules. Working Process</li> </ul>"},{"location":"developer-guide/mk-docs-development/","title":"Documentation Flow","text":"<p>This section defines necessary steps to start developing the EDP documentation in the MkDocs Framework. The framework presents a static site generator with documentation written in Markdown. All the docs are configured with a YAML configuration file.</p> <p>Note</p> <p>For more details on the framework, please refer to the MkDocs official website.</p> <p>There are two options for working with MkDocs:</p> <ul> <li>Work with MkDocs if Docker is installed</li> <li>Work with MkDocs if Docker is not installed</li> </ul> <p>Please see below the detailed description of each options and choose the one that suits you.</p>"},{"location":"developer-guide/mk-docs-development/#mkdocs-with-docker","title":"MkDocs With Docker","text":"<p>Prerequisites:</p> <ul> <li>Docker is installed.</li> </ul> <ul> <li><code>make</code> utility is installed.</li> </ul> <ul> <li>Git is installed. Please refer to the Git downloads.</li> </ul> <p>To work with MkDocs, take the following steps:</p> <ol> <li> <p>Clone the edp-install repository to your local folder.</p> </li> <li> <p>Run the following command:</p> <p><code>make docs</code></p> </li> <li> <p>Enter the localhost:8000 address in the browser and check that documentation pages are available.</p> </li> <li> <p>Open the file editor, navigate to edp-install-&gt;docs and make necessary changes. Check all the changes at localhost:8000.</p> </li> <li> <p>Create a merge request with changes.</p> </li> </ol>"},{"location":"developer-guide/mk-docs-development/#mkdocs-without-docker","title":"MkDocs Without Docker","text":"<p>Prerequisites:</p> <ul> <li>Git is installed. Please refer to the Git downloads.</li> </ul> <ul> <li>Python 3.9.5 is installed.</li> </ul> <p>To work with MkDocs without Docker, take the following steps:</p> <ol> <li> <p>Clone the edp-install repository to your local folder.</p> </li> <li> <p>Run the following command:</p> <pre><code>pip install -r  hack/mkdocs/requirements.txt\n</code></pre> </li> <li> <p>Run the local development command:</p> <pre><code>mkdocs serve --dev-addr 0.0.0.0:8000\n</code></pre> <p>Note</p> <p>This command may not work on Windows, so a quick solution is: <pre><code>python -m mkdocs serve --dev-addr 0.0.0.0:8000\n</code></pre></p> </li> <li> <p>Enter the localhost:8000 address in the browser and check that documentation pages are available.</p> </li> <li> <p>Open the file editor, navigate to edp-install-&gt;docs and make necessary changes. Check all the changes at localhost:8000.</p> </li> <li> <p>Create a merge request with changes.</p> </li> </ol>"},{"location":"headlamp-user-guide/","title":"Overview","text":"<p>The EDP Headlamp user guide is intended for developers and provides details on working with EDP Headlamp, different codebase types, and EDP CI/CD flow.</p>"},{"location":"headlamp-user-guide/#headlamp","title":"Headlamp","text":"<p>Headlamp is a central management tool in the EDP ecosystem that provides the ability to define pipelines, project resources and new technologies in a simple way. Using Headlamp enables to manage business entities:</p> <ul> <li>Create such codebase types as Applications, Libraries, Autotests and Inrastructures;</li> <li>Create/Update CD Pipelines;</li> <li>Add external Git servers and Clusters.</li> </ul> <p> Overview page </p> <ul> <li>Navigation bar \u2013 consists of the following sections: Overview, Marketplace, Components, CD Pipelines, and Configuration.</li> <li>Top panel bar \u2013 contains documentation link, notifications, Headlamp settings, and cluster settings, such as default and allowed namespaces.</li> <li>Main links \u2013 displays the corresponding links to the major adjusted toolset, to the management tool and to the OpenShift cluster.</li> <li>Filters \u2013 used for searching and filtering the namespaces.</li> </ul> <p>Headlamp is a complete tool allowing to manage and control the codebases (applications, autotests, libraries and infrastructures) added to the environment as well as to create a CD pipeline.</p> <p>Inspect the main features available in Headlamp by following the corresponding link:</p> <ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Add Git Server</li> <li>Add CD Pipeline</li> <li>Add Quality Gate</li> </ul>"},{"location":"headlamp-user-guide/add-application/","title":"Add Application","text":"<p>Headlamp allows to create, clone and import an application and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins/Tekton.</p> <p>To add an application, navigate to the Components section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create new component dialog will appear, then select Application and choose one of the strategies which will be described later in this page. You can create an Application in YAML or via the two-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-application/#create-application-in-yaml","title":"Create Application in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create Application dialog to open the YAML editor and create the Application.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create Application dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-application/#create-application-via-ui","title":"Create Application via UI","text":"<p>The Create Application dialog contains the two steps:</p> <ul> <li>The Codebase Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"headlamp-user-guide/add-application/#codebase-info-menu","title":"Codebase Info Menu","text":"<p>Follow the instructions below to fill in the fields of the Codebase Info menu:</p> <ol> <li> <p>In the Create new component menu, select Application:</p> <p> Application info </p> </li> <li> <p>Select the necessary configuration strategy. There are three configuration strategies:</p> </li> </ol> <ul> <li>Create from template \u2013 creates a project on the pattern in accordance with an application language, a build tool, and a framework. This strategy is recommended for projects that start developing their applications from scratch.</li> </ul> <ul> <li> <p>Import project - allows configuring a replication from the Git server. While importing the existing repository, select the Git server from the drop-down list and define the relative path to the repository, such as /epmd-edp/examples/basic/edp-auto-tests-simple-example.</p> <p>Note</p> <p>In order to use the Import project strategy, make sure to adjust it with the Integrate GitLab/GitHub With Jenkins or Integrate GitLab/GitHub With Tekton page.</p> </li> </ul> <ul> <li> <p>Clone project \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the Repository URL field as well:</p> <p> Clone application </p> <p>In our example, we will use the Create from template strategy:</p> <p> Create application </p> <ol> <li> <p>Select the Git server from the drop-down list and define the relative path to the repository, such as <code>/epmd-edp/examples/basic/edp-auto-tests-simple-example</code>.</p> </li> <li> <p>Type the name of the application in the Component name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> </li> <li> <p>Type the application description.</p> </li> <li> <p>To create an application with an empty repository in Gerrit, select the Empty project check box.</p> </li> <li> <p>Select any of the supported application languages with their providers in the Application Code Language field:</p> <ul> <li>Java \u2013 selecting specific Java version (8,11,17 are available).</li> <li>JavaScript - selecting JavaScript allows using React, Vue, Angular, Express, Next.js and Antora frameworks.</li> <li>Python - selecting Python allows using the Python v.3.8, FastAPI, Flask frameworks.</li> <li>Go - selecting Go allows using the Beego, Gin and Operator SDK frameworks.</li> <li>C# - selecting C# allows using the .Net v.3.1 and .Net v.6.0 frameworks.</li> <li>Helm - selecting Helm allows using the Helm framework.</li> <li>Other - selecting Other allows extending the default code languages when creating a codebase with the clone/import strategy. To add another code language, inspect the Add Other Code Language section.</li> </ul> <p>Note</p> <p>The Create from template strategy does not allow to customize the default code language set.</p> </li> <li> <p>Select necessary Language version/framework depending on the Application code language field.</p> </li> <li> <p>Choose the necessary build tool in the Build Tool field:</p> <ul> <li>Java - selecting Java allows using the Gradle or Maven tool.</li> <li>JavaScript - selecting JavaScript allows using the NPM tool.</li> <li>C# - selecting C# allows using the .Net tool.</li> <li>Python - selecting Python allows using Python tool.</li> <li>Go - selecting Go allows using Go tool.</li> <li>Helm - selecting Helm allows using Helm tool.</li> </ul> <p>Note</p> <p>The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language.</p> <p>Note</p> <p>Tekton pipelines offer built-in support for Java Maven Multi-Module projects. These pipelines are capable of recognizing Java deployable modules based on the information in the pom.xml file and performing relevant deployment actions. It's important to note that although the Dockerfile is typically located in the root directory, Kaniko, the tool used for building container images, uses the targets folder within the deployable module's context. For a clear illustration of a Multi-Module project structure, please refer to this example on GitHub, which showcases a commonly used structure for Java Maven Multi-Module projects.</p> </li> </ol> </li> </ul>"},{"location":"headlamp-user-guide/add-application/#advanced-settings-menu","title":"Advanced Settings Menu","text":"<p>The Advanced Settings menu should look similar to the picture below:</p> <p> Advanced settings </p> <p>Follow the instructions below to fill in the fields of the Advanced Setting menu:</p> <p>a. Specify the name of the Default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted. For the Clone project and Import project strategies: if you want to use the existing branch, enter its name into this field.</p> <p>b. Select the necessary codebase versioning type:</p> <ul> <li>default - using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li> <p>edp - using the edp versioning type, a developer indicates the version number that will be used for all the artifacts stored in artifactory: binaries, pom.xml, metadata, etc. The version stored in repository (e.g. pom.xml) will not be affected or used. Using this versioning overrides any version stored in the repository files without changing actual file.</p> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> Edp versioning </p> </li> </ul> <p>Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> <p>c. Specify the pattern to validate a commit message. Use regular expression to indicate the pattern that is followed on the project to validate a commit message in the code review pipeline. An example of the pattern: <code>^[PROJECT_NAME-d{4}]:.*$</code>.</p> <p> JIRA integration </p> <p>d. Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and setup the Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> <p>e. In the Jira Server field, select the Jira server.</p> <p>f. Specify the pattern to find a Jira ticket number in a commit message. Based on this pattern, the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> <p> Mapping fields </p> <p>g. In the Mapping field name section, specify the names of the Jira fields that should be filled in with attributes from EDP:</p> <ol> <li> <p>Select the name of the field in a Jira ticket from the Mapping field name drop-down menu. The available fields are the following: Fix Version/s, Component/s and Labels.</p> </li> <li> <p>Click the Add button to add the mapping field name.</p> </li> <li> <p>Enter Jira pattern for the field name:</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira.</li> <li>For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator.</li> <li>For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> </li> <li> <p>Click the bin icon to remove the Jira field name.</p> </li> </ol> <p>h. Click the Apply button to add the application to the Applications list.</p> <p>Note</p> <p>After the complete adding of the application, inspect the Application Overview part.</p> <p>Note</p> <p>Since EDP v3.3.0, the CI tool field has been hidden. Now Headlamp automatically defines the CI tool depending on which one is deployed with EDP. If both Jenkins and Tekton are deployed, Headlamp chooses Tekton by default. To define the CI tool manualy, operate with the spec.ciTool parameters.</p>"},{"location":"headlamp-user-guide/add-application/#related-articles","title":"Related Articles","text":"<ul> <li>Manage Applications</li> <li>Add CD Pipeline</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> </ul>"},{"location":"headlamp-user-guide/add-autotest/","title":"Add Autotest","text":"<p>Headlamp enables to clone or import an autotest, add it to the environment with its subsequent deployment in Gerrit (in case the Clone strategy is used) and building of the Code Review pipeline in Jenkins/Tekton, as well as to use it for work with an application under development.  It is also possible to use autotests as quality gates in a newly created CD pipeline.</p> <p>Info</p> <p>Please refer to the Add Application section for the details on how to add an application codebase type. For the details on how to use autotests as quality gates, please refer to the Stages Menu section of the Add CD Pipeline documentation.</p> <p>To add an autotest, navigate to the Components section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create new component dialog will appear, then select Autotest and choose one of the strategies which will be described later in this page. You can create an autotest in YAML or via the two-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-autotest/#create-autotest-in-yaml","title":"Create Autotest in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create Autotest dialog to open the YAML editor and create an autotest:</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create Autotest dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-autotest/#create-autotest-via-ui","title":"Create Autotest via UI","text":"<p>The Create Autotest dialog contains the two steps:</p> <ul> <li>The Codebase Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"headlamp-user-guide/add-autotest/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p>There are two available strategies: clone and import.</p> <ol> <li> <p>The Create new component menu should look like the picture below:</p> <p> Create new component menu </p> </li> <li> <p>In the Repository onboarding strategy field, select the necessary configuration strategy:</p> <ul> <li>Clone project \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the Repository URL field as well.</li> </ul> <ul> <li> <p>Import project - allows configuring a replication from the Git server. While importing the existing repository, select the Git server from the drop-down list and define the relative path to the repository, such as /epmd-edp/examples/basic/edp-auto-tests-simple-example.</p> <p>Note</p> <p>In order to use the Import project strategy, make sure to adjust it with the Integrate GitLab/GitHub With Jenkins or Integrate GitLab/GitHub With Tekton page.</p> <p>In our example, we will use the Clone project strategy:</p> <p> Clone autotest </p> <ol> <li> <p>While cloning the existing repository, it is required to fill in the Repository URL field.</p> </li> <li> <p>Select the Git server from the drop-down list and define the relative path to the repository, such as <code>/epmd-edp/examples/basic/edp-auto-tests-simple-example</code>.</p> </li> <li> <p>Select the Repository credentials check box in case you clone the private repository, and fill in the repository login and password/access token.</p> </li> <li> <p>Fill in the Component name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> </li> <li> <p>Type the necessary description in the Description field.</p> </li> <li> <p>In the Autotest code language field, select the Java code language with its framework (specify Java 8 or Java 11 to be used) and get the default Maven build tool OR add another code language. Selecting Other allows extending the default code languages and get the necessary build tool, for details, inspect the Add Other Code Language section.</p> <p>Note</p> <p>Using the Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>Select the Java framework if Java is selected above.</p> </li> <li> <p>The Build Tool field can dispose of the default Maven tool, Gradle or other built tool in accordance with the selected code language.</p> </li> <li> <p>All the autotest reports will be created in the Allure framework that is available in the Autotest Report Framework field by default.</p> </li> </ol> </li> </ul> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> </ol> <p>The Advanced Settings menu should look like the picture below:</p> <p> Advanced settings </p> <p>a. Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> <p>b. Select the necessary codebase versioning type:</p> <ul> <li>default: Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li> <p>edp: Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml).</p> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> Edp versioning </p> <p>Type the version number from which you want the artifacts to be versioned.</p> </li> </ul> <p>Note</p> <p>The Start Version From field must be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> <p>c. Specify the pattern to validate a commit message. Use regular expression to indicate the pattern that is followed on the project to validate a commit message in the code review pipeline. An example of the pattern: <code>^[PROJECT_NAME-d{4}]:.*$</code></p> <p> Jira integration </p> <p>d. Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> <p>e. As soon as the Jira server is set, select it in the Jira Server field.</p> <p>f. Specify the pattern to find a Jira ticket number in a commit message. Based on this pattern, the value from EDP will be displayed in Jira.</p> <p> Mapping field name </p> <p>g. In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP:</p> <ol> <li> <p>Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> </li> <li> <p>Click the Add button to add the mapping field name.</p> </li> <li> <p>Enter Jira pattern for the field name:</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira.</li> <li>For the Component/s field select the EDP_COMPONENT variable that defines the name of the existing repository. For fexample, nexus-operator.</li> <li>For the Labels field select the EDP_GITTAGvariable that defines a tag assigned to the commit in Git Hub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> </li> <li> <p>Click the bin icon to remove the Jira field name.</p> </li> </ol> <p>h. Click the Apply button to add the library to the Libraries list.</p> <p>Note</p> <p>After the complete adding of the autotest, inspect the Autotest Overview part.</p> <p>Note</p> <p>Since EDP v3.3.0, the CI tool field has been hidden. Now Headlamp automatically defines the CI tool depending on which one is deployed with EDP. If both Jenkins and Tekton are deployed, Headlamp chooses Tekton by default. To define the CI tool manualy, operate with the spec.ciTool parameters.</p>"},{"location":"headlamp-user-guide/add-autotest/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":""},{"location":"headlamp-user-guide/add-autotest/#related-articles","title":"Related Articles","text":"<ul> <li>Manage Autotests</li> <li>Add Application</li> <li>Add CD Pipelines</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> </ul>"},{"location":"headlamp-user-guide/add-cd-pipeline/","title":"Add CD Pipeline","text":"<p>Headlamp provides the ability to deploy an environment on your own and specify the essential components.</p> <p>Navigate to the CD Pipelines section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create CD Pipeline dialog will appear.</p> <p>The creation of the CD pipeline becomes available as soon as an application is created including its provisioning in a branch and the necessary entities for the environment. You can create the CD pipeline in YAML or via the three-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-cd-pipeline/#create-cd-pipeline-in-yaml","title":"Create CD Pipeline in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create CD Pipeline dialog to open the YAML editor and create the CD Pipeline.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create CD Pipeline dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-cd-pipeline/#create-cd-pipeline-in-the-dialog","title":"Create CD Pipeline in the Dialog","text":"<p>The Create CD Pipeline dialog contains the three steps:</p> <ul> <li>The Pipeline Menu</li> <li>The Applications Menu</li> <li>The Stages Menu</li> </ul>"},{"location":"headlamp-user-guide/add-cd-pipeline/#the-pipeline-menu","title":"The Pipeline Menu","text":"<p>The Pipeline tab of the Create CD Pipeline menu should look like the picture below:</p> <p> Create CD pipeline </p> <ol> <li> <p>Type the name of the pipeline in the Pipeline Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> <p>Note</p> <p>The namespace created by the CD pipeline has the following pattern combination: [edp namespace]-[cd pipeline name]-[stage name]. Please be aware that the namespace length should not exceed 63 symbols.</p> </li> <li> <p>Select the deployment type from the drop-down list:</p> <ul> <li>Container - the pipeline will be deployed in a Docker container;</li> <li>Custom - this mode allows to deploy non-container applications and customize the Init stage of CD pipeline.</li> </ul> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#the-applications-menu","title":"The Applications Menu","text":"<p>The Pipeline tab of the Create CD Pipeline menu should look like the picture below:</p> <p> CD pipeline applications </p> <ol> <li>Select the necessary application from the Mapping field name drop-down menu.</li> <li>Select the plus sign icon near the selected application to specify the necessary codebase Docker branch for the application (the output for the branch and other stages from other CD pipelines).</li> <li>Select the application branch from the drop-down menu.</li> <li> <p>Select the Promote in pipeline check box in order to transfer the application from one to another stage   by the specified codebase Docker branch. If the Promote in pipeline check box is not selected,   the same codebase Docker stream will be deployed regardless of the stage, i.e. the codebase Docker stream input,   which was selected for the pipeline, will always be used.</p> <p>Note</p> <p>The newly created CD pipeline has the following pattern combination: [pipeline name]-[branch name]. If there is another deployed CD pipeline stage with the respective codebase Docker stream (= image stream as an OpenShift term), the pattern combination will be as follows: [pipeline name]-[stage name]-[application name]-[verified].</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#the-stages-menu","title":"The Stages Menu","text":"<ol> <li> <p>Click the plus sign icon in the Stages menu and fill in the necessary fields in the Adding Stage window :</p> <p> CD stages </p> <p> Adding stage </p> <p>a. Type the stage name;</p> <p>Note</p> <p>The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name]. Please be aware that the namespace length should not exceed 63 symbols.</p> <p>b. Enter the description for this stage;</p> <p>c. Select the trigger type. The key benefit of the automatic deploy feature is to keep environments up-to-date. The available trigger types are Manual and Auto. When the Auto trigger type is chosen, the CD pipeline will initiate automatically once the image is built. Manual implies that user has to perform deploy manually by clicking the Deploy button in the CD Pipeline menu. Please refer to the Architecture Scheme of CD Pipeline Operator page for additional details.</p> <p>Note</p> <p>In Tekton deploy scenario, automatic deploy will start working only after the first manual deploy.</p> <p>d. Select the job provisioner. In case of working with non-container-based applications, there is an option to use a custom job provisioner. Please refer to the Manage Jenkins CD Job Provision page for details.</p> <p>e. Select the groovy-pipeline library;</p> <p>f. Select the branch;</p> <p>g. Add an unlimited number of quality gates by clicking a corresponding plus sign icon and remove them as well by clicking the recycle bin icon;</p> <p>h. Type the step name, which will be displayed in Jenkins/Tekton, for every quality gate;</p> <p>i. Select the quality gate type:</p> <ul> <li>Manual - means that the promoting process should be confirmed in Jenkins/Tekton manually;</li> <li>Autotests - means that the promoting process should be confirmed by the successful passing of the autotests.</li> </ul> <p>In the additional fields, select the previously created autotest name (j) and specify its branch for the autotest that will be launched on the current stage (k).</p> <p>Note</p> <p>Execution sequence. The image promotion and execution of the pipelines depend on the sequence in which the environments are added.</p> <p>l. Click the Apply button to display the stage in the Stages menu.</p> <p> Continuous delivery menu </p> </li> <li> <p>Edit the stage by clicking its name and applying changes, and remove the added stage by clicking the recycle bin icon    next to its name.</p> </li> <li> <p>Click the Apply button to start the provisioning of the pipeline. After the CD pipeline is added, the new project with the stage name will be created in OpenShift.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#manage-cd-pipeline","title":"Manage CD Pipeline","text":"<p>As soon as the CD pipeline is provisioned and added to the CD Pipelines list, there is an ability to:</p> <p> CD pipeline page </p> <ol> <li> <p>Create another application by clicking the plus sign icon in the lower-right corner of the screen and performing the same steps as described in the Add CD Pipeline section.</p> </li> <li> <p>Open CD pipeline data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the CD pipeline, such as name and deployment type.</li> <li>Applications - displays the CD pipeline applications to promote.</li> <li>Stages - displays the CD pipeline stages and stage metadata (by selecting the information icon near the stage name); allows to add, edit and delete stages, as well as deploy or uninstall image stream versions of the related applications for a stage.</li> <li>Metadata - displays the CD pipeline name, namespace, creation date, finalizers, generation, resource version, and UID. Open this block by selecting the information icon near the options icon next to the CD pipeline name.</li> </ul> </li> <li> <p>Edit the CD pipeline by selecting the options icon next to its name in the CD Pipelines list, and then selecting Edit. For details see the Edit Existing CD Pipeline section.</p> </li> <li> <p>Delete the added CD pipeline by selecting the options icon next to its name in the CD Pipelines list, and then selecting Delete.</p> <p>Info</p> <p>In OpenShift, if the deployment fails with the ImagePullBackOff error, delete the POD.</p> </li> <li> <p>Sort the existing CD pipelines in a table by clicking the sorting icons in the table header. When sorting by name, the CD pipelines will be displayed in alphabetical order. You can also sort the CD pipelines by their status.</p> </li> <li> <p>Search the necessary CD pipeline by the namespace or by entering the corresponding name, language or the build tool into the Filter tool.</p> </li> <li> <p>Select a number of CD pipelines displayed per page (15, 25 or 50 rows) and navigate between pages if the number of CD pipelines exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#edit-existing-cd-pipeline","title":"Edit Existing CD Pipeline","text":"<p>Edit the CD pipeline directly from the CD Pipelines overview page or when viewing the CD Pipeline data:</p> <ol> <li> <p>Select Edit in the options icon menu next to the CD pipeline name:</p> <p> Edit CD pipeline on the CD Pipelines overview page </p> <p> Edit CD pipeline when viewing the CD pipeline data </p> </li> <li> <p>Apply the necessary changes (edit the list of applications for deploy, application branches, and promotion in the pipeline). Add new extra stages by clicking the plus sign icon and filling in the application branch and promotion in the pipeline.</p> <p> Edit CD pipeline dialog </p> </li> <li> <p>Select the Apply button to confirm the changes.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#add-a-new-stage","title":"Add a New Stage","text":"<p>In order to create a new stage for the existing CD pipeline, follow the steps below:</p> <ol> <li> <p>Navigate to the Stages block by clicking the CD pipeline name link in the CD Pipelines list.</p> <p> Add CD pipeline stage </p> </li> <li> <p>Select Create to open the Create stage dialog.</p> </li> <li> <p>Click Edit YAML in the upper-right corner of the Create stage dialog to open the YAML editor and add a stage. Otherwise, fill in the required fields in the dialog. Please see the Stages Menu section for details.</p> </li> <li> <p>Click the Apply button.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#edit-stage","title":"Edit Stage","text":"<p>In order to edit a stage for the existing CD pipeline, follow the steps below:</p> <ol> <li> <p>Navigate to the Stages block by clicking the CD pipeline name link in the CD Pipelines list.</p> <p> Edit CD pipeline stage </p> </li> <li> <p>Select the options icon related to the necessary stage and then select Edit.</p> <p> Edit CD pipeline stage dialog </p> </li> <li> <p>In the Edit Stage dialog, change the stage trigger type. See more about this field in the Stages Menu section.</p> </li> <li> <p>Click the Apply button.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#delete-stage","title":"Delete Stage","text":"<p>Note</p> <p>You cannot remove the last stage, as the CD pipeline does not exist without stages.</p> <p>In order to delete a stage for the existing CD pipeline, follow the steps below:</p> <ol> <li> <p>Navigate to the Stages block by clicking the CD pipeline name link in the CD Pipelines list.</p> <p> Delete CD pipeline stage </p> </li> <li> <p>Select the options icon related to the necessary stage and then select Delete. After the confirmation, the CD stage is deleted with all its components: database record, Jenkins/Tekton pipeline, and cluster namespace.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#view-stage-data","title":"View Stage Data","text":"<p>To view the CD pipeline stage data for the existing CD pipeline, follow the steps below:</p> <ol> <li> <p>Navigate to the Stages block by clicking the CD pipeline name link in the CD Pipelines list.</p> <p> Expand CD pipeline stage </p> </li> <li> <p>Select the expand icon near the stage name. The following blocks will be displayed:</p> <p> CD pipeline stage overview </p> </li> </ol> <ul> <li>Applications - displays the status of the applications related to the stage and allows deploying the applications. Applications health and sync statuses are returned from the Argo CD tool.</li> <li>General Info - displays the stage status, CD pipeline, description, job provisioning, order, trigger type, and source.</li> <li>Quality Gates - displays the stage quality gate type, step name, autotest name, and branch name.</li> </ul>"},{"location":"headlamp-user-guide/add-cd-pipeline/#deploy-application","title":"Deploy Application","text":"<p>Navigate to the Applications block of the stage and select an application. Select the image stream version from the drop-down list and click Deploy. The application will be deployed in the Argo CD tool as well.</p> <p> Deploy the promoted application </p> <p>To update or uninstall the application, select Update or Uninstall.</p> <p> Update or uninstall the application </p> <p>After this, the application will be updated or uninstalled in the Argo CD tool as well.</p> <p>Note</p> <p>In a nutshell, the Update button updates your image version in the Helm chart, whereas the Uninstall button deletes the Helm chart from the namespace where the pipeline is deployed.</p>"},{"location":"headlamp-user-guide/add-cd-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Manage Jenkins CD Pipeline Job Provision</li> </ul>"},{"location":"headlamp-user-guide/add-cluster/","title":"Add Cluster","text":"<p>Adding other clusters allows deploying applications to several clusters when creating a stage of CD pipeline in EDP Headlamp.</p> <p>To add a cluster, follow the steps below:</p> <ol> <li> <p>Navigate to the Configuration section on the navigation bar and select Clusters. The appearance differs depending on the chosen display option:</p> List optionTiled option <p> Configuration menu (List option) </p> <p> Configuration menu (Tiled option) </p> </li> <li> <p>Click the + button to enter the Create new cluster menu:</p> <p> Add Cluster </p> </li> <li> <p>Once clicked, the Create new cluster dialog will appear. You can create a Cluster in YAML or via UI:</p> </li> </ol> Add cluster in YAMLAdd cluster via UI <p>To add cluster in YAML, follow the steps below:</p> <ul> <li>Click the Edit YAML button in the upper-right corner of the Create New Cluster dialog to open the YAML editor and create a Kubernetes secret.</li> </ul> <p> Edit YAML </p> <ul> <li>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create new cluster dialog.</li> </ul> <ul> <li>To save the changes, select the Save &amp; Apply button.</li> </ul> <p>To add cluster in YAML, follow the steps below:</p> <ul> <li> <p>To add a new cluster via the dialog menu, fill in the following fields in the Create New Cluster dialog:</p> <ul> <li>Cluster Name - enter a cluster name;</li> <li>Cluster Host - enter a cluster host;</li> <li>Cluster Token - enter a cluster token;</li> <li>Cluster Certificate - enter a cluster certificate.</li> </ul> </li> </ul> <p> Add Cluster </p> <ul> <li>Click the Apply button to add the cluster to the clusters list.</li> </ul> <p>As a result, the Kubernetes secret will be created for further integration.</p> <p>Currently, the EDP uses the shared Argo CD and the secret needs to be copied to the namespace where the Argo CD is installed.</p>"},{"location":"headlamp-user-guide/add-cluster/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Library</li> <li>Add Autotest</li> <li>Add CD Pipeline</li> </ul>"},{"location":"headlamp-user-guide/add-git-server/","title":"Add Git Server","text":"<p>Important</p> <p>This article describes how to add a Git Server when deploying EDP with Jenkins. When deploying EDP with Tekton, Git Server is created automatically.</p> <p>Add Git servers to use the Import strategy for Jenkins and Tekton when creating an application, autotest or library in EDP Headlamp (Codebase Info step of the Create Application/Autotest/Library dialog). Enabling the Import strategy is a prerequisite to integrate EDP with Gitlab or GitHub.</p> <p>Note</p> <p><code>GitServer</code> Custom Resource can be also created manually. See step 3 for Jenkins import strategy in the Integrate GitHub/GitLab in Jenkins article.</p> <p>To add a Git server, navigate to the Git servers section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create Git server dialog will appear. You can create a Git server in YAML or via the three-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-git-server/#create-git-server-in-yaml","title":"Create Git Server in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create Git server dialog to open the YAML editor and create a Git server.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create Git server dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-git-server/#create-git-server-in-the-dialog","title":"Create Git Server in the Dialog","text":"<p>Fill in the following fields:</p> <p> Create Git server </p> <ul> <li>Git provider - select Gerrit, GitLab or GitHub.</li> <li>Host - enter a Git server endpoint.</li> <li>User - enter a user for Git integration.</li> <li>SSH port - enter a Git SSH port.</li> <li>HTTPS port - enter a Git HTTPS port.</li> <li>Private SSH key - enter a private SSH key for Git integration. To generate this key, follow the instructions of the step 1 for Jenkins in the Integrate GitHub/GitLab in Jenkins article.</li> <li>Access token - enter an access token for Git integration. To generate this token, go to GitLab/GitHub account -&gt; Settings -&gt; SSH and GPG keys -&gt; select New SSH key and add SSH key.</li> </ul> <p>Click the Apply button to add the Git server to the Git servers list. As a result, the Git Server object and the corresponding secret for further integration will be created.</p>"},{"location":"headlamp-user-guide/add-git-server/#related-articles","title":"Related Articles","text":"<ul> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> <li>GitHub Webhook Configuration</li> <li>GitLab Webhook Configuration</li> </ul>"},{"location":"headlamp-user-guide/add-infrastructure/","title":"Add Infrastructure","text":"<p>Headlamp allows to create, clone and import an infrastructure. Its functionality is to create resources in cloud provider.</p> <p>To add an application, navigate to the Components section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create new component dialog will appear, then select Application and choose one of the strategies which will be described later in this page. You can create an Application in YAML or via the two-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-infrastructure/#create-infrastructure-in-yaml","title":"Create Infrastructure in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create Infrastructure dialog to open the YAML editor and create the Infrastructure.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create Infrastructure dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-infrastructure/#create-infrastructure-via-ui","title":"Create Infrastructure via UI","text":"<p>The Create Infrastructure dialog contains the two steps:</p> <ul> <li>The Codebase Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"headlamp-user-guide/add-infrastructure/#codebase-info-menu","title":"Codebase Info Menu","text":"<p>Follow the instructions below to fill in the fields of the Codebase Info menu:</p> <ol> <li> <p>In the Create new component menu, select Infrastructure:</p> <p> Infrastructure info </p> </li> <li> <p>Select the necessary configuration strategy:</p> </li> </ol> <ul> <li>Create from template \u2013 creates a project on the pattern in accordance with an infrastructure language, a build tool, and a framework.</li> </ul> <ul> <li> <p>Import project - allows configuring a replication from the Git server. While importing the existing repository, select the Git server from the drop-down list and define the relative path to the repository, such as /epmd-edp/examples/basic/edp-auto-tests-simple-example.</p> <p>Note</p> <p>In order to use the Import project strategy, make sure to adjust it with the Integrate GitLab/GitHub With Jenkins or Integrate GitLab/GitHub With Tekton page.</p> </li> </ul> <ul> <li> <p>Clone project \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the Repository URL field as well:</p> <p>In our example, we will use the Create from template strategy:</p> <p> Create infrastructure </p> <ol> <li> <p>Select the Git server from the drop-down list and define the Git repo relative path to the repository, such as <code>/epmd-edp/examples/basic/edp-auto-tests-simple-example</code>.</p> </li> <li> <p>Type the name of the infrastructure in the Component name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> </li> <li> <p>Write the description in the Description field.</p> </li> <li> <p>To create an application with an empty repository in Gerrit, select the Empty project check box.</p> </li> <li> <p>Select any of the supported application languages with their providers in the Infrastructure Code Language field. So far, only HCL is supported.</p> <p>Note</p> <p>The Create from template strategy does not allow to customize the default code language set.</p> </li> <li> <p>Select necessary Language version/framework depending on the Infrastructure code language field. So far, only AWS is supported.</p> </li> <li> <p>Choose the necessary build tool in the Build Tool field. So far, only Terraform is supported.\\</p> <p>Note</p> <p>The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language.</p> </li> </ol> </li> </ul> <p>The Advanced Settings menu should look similar to the picture below:</p> <p> Advanced settings </p> <p>Follow the instructions below to fill in the fields of the Advanced Setting menu:</p> <p>a. Specify the name of the Default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted. For the Clone project and Import project strategies: if you want to use the existing branch, enter its name into this field.</p> <p>b. Select the necessary codebase versioning type:</p> <ul> <li>default - using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li> <p>edp - using the edp versioning type, a developer indicates the version number that will be used for all the artifacts stored in artifactory: binaries, pom.xml, metadata, etc. The version stored in repository (e.g. pom.xml) will not be affected or used. Using this versioning overrides any version stored in the repository files without changing actual file.</p> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> Edp versioning </p> </li> </ul> <p>Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> <p>c. Specify the pattern to validate a commit message. Use regular expression to indicate the pattern that is followed on the project to validate a commit message in the code review pipeline. An example of the pattern: <code>^[PROJECT_NAME-d{4}]:.*$</code>.</p> <p> JIRA integration </p> <p>d. Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and setup the Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> <p>e. In the Jira Server field, select the Jira server.</p> <p>f. Specify the pattern to find a Jira ticket number in a commit message. Based on this pattern, the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> <p> Mapping fields </p> <p>g. In the Mapping field name section, specify the names of the Jira fields that should be filled in with attributes from EDP:</p> <ol> <li> <p>Select the name of the field in a Jira ticket from the Mapping field name drop-down menu. The available fields are the following: Fix Version/s, Component/s and Labels.</p> </li> <li> <p>Click the Add button to add the mapping field name.</p> </li> <li> <p>Enter Jira pattern for the field name:</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira.</li> <li>For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator.</li> <li>For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> </li> <li> <p>Click the bin icon to remove the Jira field name.</p> </li> </ol> <p>h. Click the Apply button to add the application to the Applications list.</p> <p>Note</p> <p>After the complete adding of the application, inspect the Application Overview part.</p> <p>Note</p> <p>Since EDP v3.3.0, the CI tool field has been hidden. Now Headlamp automatically defines the CI tool depending on which one is deployed with EDP. If both Jenkins and Tekton are deployed, Headlamp chooses Tekton by default. To define the CI tool manualy, operate with the spec.ciTool parameters.</p>"},{"location":"headlamp-user-guide/add-infrastructure/#advanced-settings-menu","title":"Advanced Settings Menu","text":""},{"location":"headlamp-user-guide/add-infrastructure/#related-articles","title":"Related Articles","text":"<ul> <li>Application Overview</li> <li>Add CD Pipelines</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> </ul>"},{"location":"headlamp-user-guide/add-library/","title":"Add Library","text":"<p>Headlamp helps to create, clone and import a library and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins/Tekton.</p> <p>To add a library, navigate to the Components section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create new component dialog will appear, then select Library and choose one of the strategies which will be described later in this page. You can create a library in YAML or via the two-step menu in the dialog.</p> <p> Create new component menu </p>"},{"location":"headlamp-user-guide/add-library/#create-library-in-yaml","title":"Create Library in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create Library dialog to open the YAML editor and create the Library.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create Application dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-library/#create-library-via-ui","title":"Create Library via UI","text":"<p>The Create Library dialog contains the two steps:</p> <ul> <li>The Codebase Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"headlamp-user-guide/add-library/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<ol> <li> <p>The Create new component menu should look like the following:</p> <p> Create new component menu </p> </li> <li> <p>In the Create new component menu, select the necessary configuration strategy. The choice will define the parameters you will need to specify:</p> <ul> <li>Create from template \u2013 creates a project on the pattern in accordance with a library language, a build tool, and a framework.</li> </ul> <ul> <li> <p>Import project - allows configuring a replication from the Git server. While importing the existing repository, select the Git server from the drop-down list and define the relative path to the repository, such as /epmd-edp/examples/basic/edp-auto-tests-simple-example.</p> <p>Note</p> <p>In order to use the Import project strategy, make sure to adjust it with the Integrate GitLab/GitHub With Jenkins or Integrate GitLab/GitHub With Tekton page.</p> </li> </ul> <ul> <li> <p>Clone project \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the Repository URL field as well:</p> <p> Clone library </p> <p>In our example, we will use the Create from template strategy:</p> <p> Create library </p> <ol> <li>While importing the existing repository, select the Git server from the drop-down list and define the relative path to the repository, such as <code>/epmd-edp/examples/basic/edp-auto-tests-simple-example</code></li> <li>Type the name of the library in the Component name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</li> <li>Type the library description.</li> <li>To create a library with an empty repository in Gerrit, select the Empty project check box. The empty repository option is available only for the Create from template strategy.</li> <li> <p>Select any of the supported code languages with its framework in the Library code language field:</p> <ul> <li>Java \u2013 selecting specific Java version available.</li> <li>JavaScript - selecting JavaScript allows using the NPM tool.</li> <li>Python - selecting Python allows using the Python v.3.8, FastAPI, Flask.</li> <li>Groovy-pipeline - selecting Groovy-pipeline allows having the ability to customize a stages logic. For details,   please refer to the Customize CD Pipeline page.</li> <li>Terraform - selecting Terraform allows using the Terraform different versions via the Terraform version manager (tfenv).   EDP supports all actions available in Terraform, thus providing the ability to modify the virtual infrastructure and launch some checks with the help of linters.   For details, please refer to the Use Terraform Library in EDP page.</li> <li>Rego - this option allows using Rego code language with an Open Policy Agent (OPA) Library. For details, please   refer to the Use Open Policy Agent page.</li> <li>Container - this option allows using the Kaniko tool for building the container images from a Dockerfile. For details, please refer to the CI Pipeline for Container page.</li> <li>Helm - this option allows using the chart testing lint (Pipeline) for Helm charts or using Helm chart as a set of other Helm charts organized according to the example.</li> <li>C# - selecting C# allows using .Net v.3.1 and .Net v.6.0.</li> <li>Other - selecting Other allows extending the default code languages when creating a codebase with the Clone/Import strategy. To add another code language, inspect the Add Other Code Language page.</li> </ul> <p>Note</p> <p>The Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>Select necessary Language version/framework depending on the Library code language field.</p> </li> <li> <p>The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language.</p> </li> </ol> </li> </ul> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-library/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p>The Advanced Settings menu should look like the picture below:</p> <p> Advanced settings </p> <p>a. Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> <p>b. Select the necessary codebase versioning type:</p> <ul> <li>default: Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp: Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml).</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> EDP versioning </p> <p>Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> <p>c. Specify the pattern to validate a commit message. Use regular expression to indicate the pattern that is followed on the project to validate a commit message in the code review pipeline. An example of the pattern: <code>^[PROJECT_NAME-d{4}]:.*$</code></p> <p> Integrate with Jira server </p> <p>d. Select the Integrate with Jira server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> <p>e. As soon as the Jira server is set, select it in the Jira Server field.</p> <p>f. Specify the pattern to find a Jira ticket number in a commit message. Based on this pattern, the value from EDP will be displayed in Jira.</p> <p> Mapping fields </p> <p>g. In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP:</p> <ol> <li> <p>Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> </li> <li> <p>Click the Add button to add the mapping field name.</p> </li> <li> <p>Enter Jira pattern for the field name:</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira.</li> <li>For the Component/s field select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator.</li> <li>For the Labels field select the EDP_GITTAGvariable that defines a tag assigned to the commit in Git Hub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> </li> <li> <p>Click the bin icon to remove the Jira field name.</p> </li> </ol> <p>h. Click the Apply button to add the library to the Libraries list.</p> <p>Note</p> <p>After the complete adding of the library, inspect the Library Overview part.</p> <p>Note</p> <p>Since EDP v3.3.0, the CI tool field has been hidden. Now Headlamp automatically defines the CI tool depending on which one is deployed with EDP. If both Jenkins and Tekton are deployed, Headlamp chooses Tekton by default. To define the CI tool manualy, operate with the spec.ciTool parameters.</p>"},{"location":"headlamp-user-guide/add-library/#related-articles","title":"Related Articles","text":"<ul> <li>Manage Libraries</li> <li>Add CD Pipeline</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> </ul>"},{"location":"headlamp-user-guide/add-marketplace/","title":"Add Component via Marketplace","text":"<p>With the built-in Marketplace, users can easily create a new application by clicking several buttons. This page contains detailed guidelines on how to create a new component with the help of the Marketplace feature.</p>"},{"location":"headlamp-user-guide/add-marketplace/#add-component","title":"Add Component","text":"<p>To create a component from template, follow the instructions below:</p> <ol> <li> <p>Navigate to the Marketplace section on the navigation bar to see the Marketplace overview page.</p> </li> <li> <p>Click the component name to open its details window and click Create from template:</p> <p> Create from template </p> </li> <li> <p>Fill in the required fields and click Apply:</p> <p> Creating from template window </p> </li> <li> <p>As a result, new component will appear in the Components section:</p> <p> Creating from template window </p> </li> </ol>"},{"location":"headlamp-user-guide/add-marketplace/#related-articles","title":"Related Articles","text":"<ul> <li>Marketplace Overview</li> <li>Add Application</li> <li>Add Library</li> <li>Add Infrastructure</li> </ul>"},{"location":"headlamp-user-guide/add-quality-gate/","title":"Add Quality Gate","text":"<p>This section describes how to use quality gate in EDP and how to customize the quality gate for the CD pipeline with the selected build version of the promoted application between stages.</p>"},{"location":"headlamp-user-guide/add-quality-gate/#apply-new-quality-gate-to-pipelines","title":"Apply New Quality Gate to Pipelines","text":"<p>Quality gate pipeline is a usual Tekton pipeline but with a specific label: <code>app.edp.epam.com/pipelinetype: deploy</code>. To add and apply the quality gate to your pipelines, follow the steps below:</p> <p>1. To use the Tekton pipeline as a quality gate pipeline, add this label to the pipelines:     <pre><code>metadata:\n  labels:\n    app.edp.epam.com/pipelinetype: deploy\n</code></pre>   2. Insert the  value that is the quality gate name displayed in the quality gate drop-down list of the CD pipeline menu:     <pre><code>metadata:\n  name: &lt;name-of-quality-gate&gt;\n</code></pre>   3. Ensure the task <code>promote-images</code> contains steps and logic to apply to the project. Also ensure that the last task is <code>promote-images</code> which parameters are mandatory.     <pre><code>spec:\n  params:\n    - default: ''\n      description: Codebases with a tag separated with a space.\n      name: CODEBASE_TAG\n      type: string\n    - default: ''\n      name: CDPIPELINE_CR\n      type: string\n    - default: ''\n      name: CDPIPELINE_STAGE\n      type: string\n  tasks:\n    - name: promote-images\n      params:\n        - name: CODEBASE_TAG\n          value: $(params.CODEBASE_TAG)\n        - name: CDPIPELINE_STAGE\n          value: $(params.CDPIPELINE_STAGE)\n        - name: CDPIPELINE_CR\n          value: $(params.CDPIPELINE_CR)\n      runAfter:\n        - &lt;last-task-name&gt;\n      taskRef:\n        kind: Task\n        name: promote-images\n</code></pre>   4. Create a new pipeline with a unique name or modify your created pipeline with the command below. Please be aware that the \u2039edp-project\u203a value is the name of the EDP tenant:       <pre><code>kubectl apply -f &lt;file&gt;.yaml -namespace \u2039edp-project\u203a\n</code></pre> Example: file.yaml <pre><code> apiVersion: tekton.dev/v1beta1\n kind: Pipeline\n metadata:\n   labels:\n     app.edp.epam.com/pipelinetype: deploy\n   name: &lt;name-of-quality-gate&gt;\n   namespace: &lt;edp-namespace&gt;\n spec:\n   params:\n     - default: &gt;-\n         https://&lt;CI-pipeline-provisioner&gt;-&lt;edp-namespace&gt;.&lt;cluster-name&gt;.aws.main.edp.projects.epam.com/#/namespaces/$(context.pipelineRun.namespace)/pipelineruns/$(context.pipelineRun.name)\n       name: pipelineUrl\n       type: string\n     - default: ''\n       description: Codebases with a tag separated with a space.\n       name: CODEBASE_TAG\n       type: string\n     - default: ''\n       name: CDPIPELINE_CR\n       type: string\n     - default: ''\n       name: CDPIPELINE_STAGE\n       type: string\n   tasks:\n     - name: autotests\n       params:\n         - name: BASE_IMAGE\n           value: bitnami/kubectl:1.25.4\n         - name: EXTRA_COMMANDS\n           value: echo \"Hello World\"\n       taskRef:\n         kind: Task\n         name: run-quality-gate\n     - name: promote-images\n       params:\n         - name: CODEBASE_TAG\n           value: $(params.CODEBASE_TAG)\n         - name: CDPIPELINE_STAGE\n           value: $(params.CDPIPELINE_STAGE)\n         - name: CDPIPELINE_CR\n           value: $(params.CDPIPELINE_CR)\n       runAfter:\n         - autotests\n       taskRef:\n         kind: Task\n         name: promote-images\n</code></pre>"},{"location":"headlamp-user-guide/add-quality-gate/#run-quality-gate","title":"Run Quality Gate","text":"<p>Before running the quality gate, first of all, ensure that the environment has deployed the created CD pipeline and then ensure that the application is successfully deployed and ready to run the quality gate. To run quality gate, please follow the steps below:</p> <ol> <li> <p>Check the CD pipeline status. To do this, open the created CD pipeline, select <code>Image stream version</code>, click <code>DEPLOY</code> button and wait until <code>Applications</code>, <code>Health</code> and <code>Sync</code> statuses become <code>green</code>. This implies that the application is successfully deployed and ready to run the quality gate.</p> <p> CD pipeline stage overview </p> </li> <li> <p>Select the <code>&lt;name-of-quality-gate&gt;</code> of <code>Quality gates</code> from the drop-down list and click the <code>RUN</code> button.The execution process should be started in the <code>Pipelines</code> menu:</p> <p> Quality gate pipeline status </p> </li> </ol>"},{"location":"headlamp-user-guide/add-quality-gate/#add-stage-for-quality-gate","title":"Add Stage for Quality Gate","text":"<p>For a better understanding of this section, please read the documentation about how to add a new stage for quality gate. The scheme below illustrates two approaches of adding quality gates:</p> <p> Types of adding quality gate </p> <ul> <li>The first type of adding a quality gate is about adding the specific quality gate to the specific pipeline stage.</li> </ul> <ul> <li>The second type is rather optional and implies activating the <code>Promote in pipelines</code> option while creating a CD Pipeline to pass the quality gate in a certain sequence.</li> </ul> <p>As a result, after the quality gate is successfully passed, the projected image is promoted to the next stage.</p>"},{"location":"headlamp-user-guide/add-quality-gate/#related-articles","title":"Related Articles","text":"<ul> <li>Add CD Pipeline</li> </ul>"},{"location":"headlamp-user-guide/application/","title":"Manage Applications","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing applications.</p>"},{"location":"headlamp-user-guide/application/#check-and-remove-application","title":"Check and Remove Application","text":"<p>As soon as the application is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins/Tekton for this application. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins/Tekton is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins/Tekton is passed as well.</li> </ul> <p>The added application will be listed in the Applications list allowing you to do the following:</p> <p> Applications menu </p> <ul> <li>Application status - displays the Git Server status. Can be red or green depending on if the Headlamp managed to connect to the Git Server with the specified credentials or not.</li> <li>Application name (clickable) - displays the Git Server name set during the Git Server creation.</li> <li>Open documentation - opens the documentation that leads to this page.</li> <li>Enable filtering - enables filtering by Git Server name and namespace where this custom resource is located in.</li> <li>Create new application - displays the Create new component menu.</li> <li>Edit application - edit the application by selecting the options icon next to its name in the applications list, and then selecting Edit. For details see the Edit Existing Application section.</li> <li> <p>Delete application - remove application by selecting the options icon next to its name in the applications list, and then selecting Delete.</p> <p>Note</p> <p>The application that is used in a CD pipeline cannot be removed.</p> </li> </ul> <p>There are also options to sort the applications:</p> <ul> <li>Sort the existing applications in a table by clicking the sorting icons in the table header. Sort the applications alphabetically by their name, language, build tool, framework, and CI tool. You can also sort the applications by their status: Created, Failed, or In progress.</li> </ul> <ul> <li> <p>Select a number of applications displayed per page (15, 25 or 50 rows) and navigate between pages if the number of applications exceeds the capacity of a single page:</p> <p> Applications pages </p> </li> </ul>"},{"location":"headlamp-user-guide/application/#edit-existing-application","title":"Edit Existing Application","text":"<p>EDP Headlamp provides the ability to enable, disable or edit the Jira Integration functionality for applications.R</p> <ol> <li> <p>To edit an application directly from the Applications overview page or when viewing the application data:</p> <ul> <li>Select Edit in the options icon menu:</li> </ul> <p> Edit application on the Applications overview page </p> <p> Edit application when viewing the application data </p> <ul> <li>The Edit Application dialog opens.</li> </ul> </li> <li> <p>To enable Jira integration, in the Edit Application dialog do the following:</p> <p> Edit application </p> <p>a. Mark the Integrate with Jira server check box and fill in the necessary fields. Please see steps d-h of the Add Application page.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. (Optional) Enable commit validation mechanism by navigating to Jenkins/Tekton and adding the commit-validate stage in the Code Review pipeline to have your commits reviewed.</p> </li> <li> <p>To disable Jira integration, in the Edit Application dialog do the following:</p> <p>a. Unmark the Integrate with Jira server check box.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. (Optional) Disable commit validation mechanism by navigating to Jenkins/Tekton and removing the commit-validate stage in the Code Review pipeline to have your commits reviewed.</p> </li> <li> <p>To create, edit and delete application branches, please refer to the Manage Branches page.</p> </li> </ol>"},{"location":"headlamp-user-guide/application/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Manage Branches</li> </ul>"},{"location":"headlamp-user-guide/autotest/","title":"Manage Autotests","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing autotests.</p>"},{"location":"headlamp-user-guide/autotest/#check-and-remove-autotest","title":"Check and Remove Autotest","text":"<p>As soon as the autotest is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins/Tekton for this autotest. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins/Tekton is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins/Tekton is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins/Tekton, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added autotest will be listed in the Autotests list allowing you to do the following:</p> <p> Autotests page </p> <ul> <li>Autotest status - displays the Git Server status. Can be red or green depending on if the Headlamp managed to connect to the Git Server with the specified credentials or not.</li> </ul> <ul> <li>Autotest name (clickable) - displays the Git Server name set during the Git Server creation.</li> </ul> <ul> <li>Open documentation - opens the documentation that leads to this page.</li> </ul> <ul> <li>Enable filtering - enables filtering by Git Server name and namespace where this custom resource is located in.</li> </ul> <ul> <li>Create new autotest - displays the Create new component menu.</li> </ul> <ul> <li>Edit autotest - edit the autotest by selecting the options icon next to its name in the autotests list, and then selecting Edit. For details see the Edit Existing Autotest section.</li> </ul> <ul> <li> <p>Delete autotest - remove autotest with the corresponding database and Jenkins/Tekton pipelines by selecting the options icon next to its name in the Autotests list, and then selecting Delete:</p> <p>Note</p> <p>The autotest that is used in a CD pipeline cannot be removed.</p> </li> </ul> <p>There are also options to sort the applications:</p> <ul> <li>Sort the existing autotests in a table by clicking the sorting icons in the table header. Sort the autotests alphabetically by their name, language, build tool, framework, and CI tool. You can also sort the autotests by their status: Created, Failed, or In progress.</li> </ul> <ul> <li>Select a number of autotests displayed per page (15, 25 or 50 rows)  and navigate between pages if the number of autotests exceeds the capacity of a single page.</li> </ul>"},{"location":"headlamp-user-guide/autotest/#edit-existing-autotest","title":"Edit Existing Autotest","text":"<p>EDP Headlamp provides the ability to enable, disable or edit the Jira Integration functionality for autotests.</p> <ol> <li> <p>To edit an autotest directly from the Autotests overview page or when viewing the autotest data:</p> <ul> <li> <p>Select Edit in the options icon menu:</p> <p> Edit autotest on the autotests overview page </p> <p> Edit autotest when viewing the autotest data </p> </li> </ul> <ul> <li>The Edit Autotest dialog opens.</li> </ul> </li> <li> <p>To enable Jira integration, on the Edit Autotest page do the following:</p> <p> Edit library </p> <p>a. Mark the Integrate with Jira server check box and fill in the necessary fields. Please see steps d-h on the Add Autotests page.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</p> <p>Note</p> <p>Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration and Adjust VCS Integration With Jira pages.</p> </li> <li> <p>To disable Jira integration, in the Edit Autotest dialog do the following:</p> <p>a. Unmark the Integrate with Jira server check box.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</p> <p>As a result, the necessary changes will be applied.</p> </li> <li> <p>To create, edit and delete application branches, please refer to the Manage Branches page.</p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#add-autotest-as-a-quality-gate","title":"Add Autotest as a Quality Gate","text":"<p>In order to add an autotest as a quality gate to a newly added CD pipeline, do the following:</p> <ol> <li> <p>Create a CD pipeline with the necessary parameters. Please refer to the Add CD Pipeline section for the details.</p> </li> <li> <p>In the Stages menu, select the Autotest quality gate type. It means the promoting process should be confirmed by the successful passing of the autotests.</p> </li> <li> <p>In the additional fields, select the previously created autotest name and specify its branch.</p> </li> <li> <p>After filling in all the necessary fields, click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new namespace containing the stage name will be created in Kubernetes (in OpenShift, a new project will be created) with the following name pattern: [cluster name]-[cd pipeline name]-[stage name].</p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#configure-autotest-launch-at-specific-stage","title":"Configure Autotest Launch at Specific Stage","text":"<p>In order to configure the added autotest launch at the specific stage with necessary parameters, do the following:</p> <ol> <li> <p>Add the necessary stage to the CD pipeline. Please refer to the Add CD Pipeline documentation for the details.</p> </li> <li> <p>Navigate to the run.json file and add the stage name and the specific parameters.</p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#launch-autotest-locally","title":"Launch Autotest Locally","text":"<p>There is an ability to run the autotests locally using the IDEA (Integrated Development Environment Application, such as IntelliJ, NetBeans etc.). To launch the autotest project for the local verification, perform the following steps:</p> <ol> <li> <p>Clone the project to the local machine.</p> </li> <li> <p>Open the project in IDEA and find the run.json file to copy out the necessary command value.</p> </li> <li> <p>Paste the copied command value into the Command line field and run it with the necessary values and namespace.</p> </li> <li> <p>As a result, all the launched tests will be executed.</p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotests</li> <li>Add CD Pipeline</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Manage Branches</li> </ul>"},{"location":"headlamp-user-guide/cluster/","title":"Manage Clusters","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing clusters.</p> <p>In a nutshell, cluster in Headlamp is a Kubernetes secret that stores credentials and enpoint to connect to the another cluster. Adding new clusters allows users to deploy applications in several clusters, thus improving flexibilty of your infrastructure.</p> <p>The added cluster will be listed in the clusters list allowing you to do the following:</p> <p> Clusters list </p>"},{"location":"headlamp-user-guide/cluster/#view-authentication-data","title":"View Authentication Data","text":"<p>To view authentication data that is used to log in to the cluster, run the <code>kubectl describe</code> command:</p> <pre><code>kubectl describe secret cluster_name -n &lt;edp-project&gt;\n</code></pre>"},{"location":"headlamp-user-guide/cluster/#delete-cluster","title":"Delete Cluster","text":"<p>To delete cluster, use the <code>kubectl delete</code> command as follows:</p> <pre><code>kubectl delete secret cluster_name -n &lt;edp-project&gt;\n</code></pre>"},{"location":"headlamp-user-guide/cluster/#related-articles","title":"Related Articles","text":"<ul> <li>Add Cluster</li> <li>Add Application</li> </ul>"},{"location":"headlamp-user-guide/git-server-overview/","title":"Manage Git Servers","text":"<p>Git Server is a custom resource that is required for using the import strategy when creating a new component, whether it is an application, library, autotest or infrastructure.</p> <p>Under the hood, Git server in Headlamp is a Kubernetes secret that stores credentials to the remote Git server.</p> <p>The added application will be listed in the Applications list allowing you to do the following:</p> <p> Git Server menu </p> <ul> <li>Git Server status - displays the Git Server status. Can be red or green depending on if the Headlamp managed to connect to the Git Server with the specified credentials or not.</li> </ul> <ul> <li>Git Server name - displays the Git Server name set during the Git Server creation.</li> </ul> <ul> <li>Open documentation - opens the documentation that leads to this page.</li> </ul> <ul> <li>Enable filtering - enables filtering by Git Server name and namespace where this custom resource is located in.</li> </ul> <ul> <li>Create new Git Server - displays the Create Git Server menu.</li> </ul> <p>Note</p> <p>Git Server can't be deleted via the Headlamp UI. Use the <code>kubectl delete GitServer &lt;Git_server_name&gt; -n &lt;edp-project&gt;</code> command to delete the GitServer custom resource.</p>"},{"location":"headlamp-user-guide/git-server-overview/#view-authentication-data","title":"View Authentication Data","text":"<p>To view authentication data that is used to connect to the Git server, use <code>kubectl describe</code> command as follows:</p> <pre><code>kubectl describe GitServer git_server_name -n &lt;edp-project&gt;\n</code></pre>"},{"location":"headlamp-user-guide/git-server-overview/#delete-git-server","title":"Delete Git Server","text":"<p>To remove a Git Server from the Git Servers list, utilize the <code>kubectl delete</code> command as follows:</p> <pre><code>kubectl delete GitServer git_server_name -n &lt;edp-project&gt;\n</code></pre>"},{"location":"headlamp-user-guide/git-server-overview/#related-articles","title":"Related Articles","text":"<ul> <li>Add Git Server</li> </ul>"},{"location":"headlamp-user-guide/infrastructure/","title":"Manage Infrastructures","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing infrastructures.</p>"},{"location":"headlamp-user-guide/infrastructure/#check-and-remove-application","title":"Check and Remove Application","text":"<p>As soon as the infrastructure is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins/Tekton for this application. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins/Tekton is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins/Tekton is passed as well.</li> </ul> <p>The added application will be listed in the Applications list allowing you to do the following:</p> <p> Applications menu </p> <ul> <li>Infrastructure status - displays the Git Server status. Can be red or green depending on if the Headlamp managed to connect to the Git Server with the specified credentials or not.</li> <li>Infrastructure name (clickable) - displays the infrastructure name set during the Git Server creation.</li> <li>Open documentation - opens the documentation that leads to this page.</li> <li>Enable filtering - enables filtering by Git Server name and namespace where this custom resource is located in.</li> <li>Create new infrastructure - displays the Create new component menu.</li> <li>Edit infrastructure - edit the infrastructure by selecting the options icon next to its name in the infrastructures list, and then selecting Edit. For details see the Edit Existing Application section.</li> <li>Delete infrastructure - remove infrastructure by selecting the options icon next to its name in the infrastructures list, and then selecting Delete.</li> </ul> <p>There are also options to sort the infrastructures:</p> <ul> <li>Sort the existing infrastructures in a table by clicking the sorting icons in the table header. Sort the infrastructures alphabetically by their name, language, build tool, framework, and CI tool. You can also sort the infrastructures by their status: Created, Failed, or In progress.</li> </ul> <ul> <li>Select a number of infrastructures displayed per page (15, 25 or 50 rows)  and navigate between pages if the number of applications exceeds the capacity of a single page.</li> </ul>"},{"location":"headlamp-user-guide/infrastructure/#edit-existing-infrastructure","title":"Edit Existing Infrastructure","text":"<p>EDP Headlamp provides the ability to enable, disable or edit the Jira Integration functionality for infrastructures.</p> <ol> <li> <p>To edit an infrastructure directly from the infrastructures overview page or when viewing the infrastructure data:</p> <ul> <li>Select Edit in the options icon menu:</li> </ul> <p> Edit infrastructure on the Infrastructures overview page </p> <p> Edit infrastructure when viewing the infrastructure data </p> <ul> <li>The Edit Infrastructure dialog opens.</li> </ul> </li> <li> <p>To enable Jira integration, in the Edit Infrastructure dialog do the following:</p> <p> Edit infrastructure </p> <p>a. Mark the Integrate with Jira server check box and fill in the necessary fields. Please see steps d-h on the Add Infrastructure page.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</p> </li> <li> <p>To disable Jira integration, in the Edit Infrastructure dialog do the following:</p> <p>a. Unmark the Integrate with Jira server check box.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</p> </li> <li> <p>To create, edit and delete infrastructure branches, please refer to the Manage Branches page.</p> </li> </ol>"},{"location":"headlamp-user-guide/infrastructure/#related-articles","title":"Related Articles","text":"<ul> <li>Add Infrastructure</li> <li>Manage Branches</li> </ul>"},{"location":"headlamp-user-guide/library/","title":"Manage Libraries","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing libraries.</p>"},{"location":"headlamp-user-guide/library/#check-and-remove-library","title":"Check and Remove Library","text":"<p>As soon as the library is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins/Tekton for this library. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins/Tekton is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins/Tekton is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins/Tekton, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added library will be listed in the Libraries list allowing to do the following:</p> <p> Library menu </p> <ol> <li> <p>Create another library by clicking the plus sign icon in the lower-right corner of the screen and performing the same steps as described on the Add Library page.</p> </li> <li> <p>Open library data by clicking its link name. Once clicked, the following blocks will be displayed:</p> </li> </ol> <ul> <li>Library status - displays the Git Server status. Can be red or green depending on if the Headlamp managed to connect to the Git Server with the specified credentials or not.</li> <li>Library name (clickable) - displays the Git Server name set during the Git Server creation.</li> <li>Open documentation - opens the documentation that leads to this page.</li> <li>Enable filtering - enables filtering by Git Server name and namespace where this custom resource is located in.</li> <li>Create new library - displays the Create new component menu.</li> <li>Edit library - edit the library by selecting the options icon next to its name in the libraries list, and then selecting Edit. For details see the Edit Existing Library section.</li> <li> <p>Delete Library - remove library with the corresponding database and Jenkins/Tekton pipelines by selecting the options icon next to its name in the libraries list, and then selecting Delete.</p> <p>Note</p> <p>The library that is used in a CD pipeline cannot be removed.</p> </li> </ul> <p>There are also options to sort the libraries:</p> <ul> <li>Sort the existing libraries in a table by clicking the sorting icons in the table header. Sort the libraries alphabetically by their name, language, build tool, framework, and CI tool. You can also sort the libraries by their status: Created, Failed, or In progress.</li> <li>Select a number of libraries displayed per page (15, 25 or 50 rows) and navigate between pages if the number of libraries exceeds the capacity of a single page.</li> </ul>"},{"location":"headlamp-user-guide/library/#edit-existing-library","title":"Edit Existing Library","text":"<p>EDP Headlamp provides the ability to enable, disable or edit the Jira Integration functionality for libraries.</p> <ol> <li> <p>To edit a library directly from the Libraries overview page or when viewing the library data:</p> <ul> <li> <p>Select Edit in the options icon menu:</p> <p> Edit library on the libraries overview page </p> <p> Edit library when viewing the library data </p> </li> </ul> <ul> <li>The Edit Library dialog opens.</li> </ul> </li> <li> <p>To enable Jira integration, in the Edit Library dialog do the following:</p> <p> Edit library </p> <p>a. Mark the Integrate with Jira server check box and fill in the necessary fields. Please see steps d-h on the Add Library page.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</p> </li> <li> <p>To disable Jira integration, in the Edit Library dialog do the following:</p> <p>a. Unmark the Integrate with Jira server check box.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</p> <p>As a result, the necessary changes will be applied.</p> </li> <li> <p>To create, edit and delete library branches, please refer to the Manage Branches page.</p> </li> </ol>"},{"location":"headlamp-user-guide/library/#related-articles","title":"Related Articles","text":"<ul> <li>Add Library</li> <li>Manage Branches</li> </ul>"},{"location":"headlamp-user-guide/manage-branches/","title":"Manage Branches","text":"<p>This page describes how to manage branches in the created component, whether it is an application, library, autotest or infrastructure.</p>"},{"location":"headlamp-user-guide/manage-branches/#add-new-branch","title":"Add New Branch","text":"<p>Note</p> <p>When working with libraries, pay attention when specifying the branch name: the branch name is involved in the formation of the library version, so it must comply with the versioning semantic rules for the library.</p> <p>When adding a component, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li> <p>Navigate to the Branches block by clicking the component name link in the Components list.</p> </li> <li> <p>Select the options icon related to the necessary branch and then select Create:</p> <p> Add branch </p> </li> <li> <p>Click Edit YAML in the upper-right corner of the dialog to open the YAML editor and add a branch. Otherwise, fill in the required fields in the dialog:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch.</p> <p>b. Branch name - type the branch name. Pay attention that this field remains static if you create a release branch. For the Clone and Import strategies: if you want to use the existing branch, enter its name into this field.</p> <p>c. From Commit Hash - paste the commit hash from which the branch will be created. For the Clone and Import strategies: Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Default branch version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number.</p> <p>f. Click the Apply button and wait until the new branch will be added to the list.</p> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type.</p> </li> </ol> <p>The default component repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"headlamp-user-guide/manage-branches/#build-branch","title":"Build Branch","text":"<p>In order to build branch from the latest commit, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the library name link in the Libraries list.</li> <li> <p>Select the options icon related to the necessary branch and then select Build:</p> <p> Build branch </p> </li> </ol> <p>The pipeline run status is displayed near the branch name in the Branches block:</p> <p> Pipeline run status in Headlamp </p> <p>The corresponding item appears on the Tekton Dashboard in the PipelineRuns section:</p> <p> Pipeline run status in Tekton </p>"},{"location":"headlamp-user-guide/manage-branches/#delete-branch","title":"Delete Branch","text":"<p>Note</p> <p>The default master branch cannot be removed.</p> <p>In order to delete the added branch with the corresponding record in the Headlamp database, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the component name link in the compoents list.</li> <li> <p>Select the options icon related to the necessary branch and then select Delete:</p> <p> Delete branch </p> </li> </ol>"},{"location":"headlamp-user-guide/manage-branches/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Library</li> <li>Add Autotest</li> </ul>"},{"location":"headlamp-user-guide/marketplace/","title":"Marketplace Overview","text":"<p>The EDP Marketplace offers a range of Templates, predefined tools and settings for creating software. These Templates speed up development, minimize errors, and ensure consistency. A key EDP Marketplace feature is customization. Organizations can create and share their own Templates, finely tuned to their needs. Each Template serves as a tailored blueprint of tools and settings.</p> <p>These tailored Templates include preset CI/CD pipelines, automating your development workflows. From initial integration to final deployment, these processes are efficiently managed. Whether for new applications or existing ones, these templates enhance processes, save time, and ensure consistency.</p> <p>To see the Marketplace section, navigate to the Main menu -&gt; EDP -&gt; Marketplace. General look of the Marketplace section is described below:</p> <p> Marketplace section (listed view) </p> <ul> <li>Marketplace templates - all the components marketplace can offer;</li> <li>Template properties - the item summary that shows the type, category, language, framework, build tool and maturity;</li> <li>Enable/disable filters - enables users to enable/disable searching by the item name or namespace it is available in;</li> <li>Change view - allows switching from the listed view to the tiled one and vice versa. See the screenshot below for details.</li> </ul> <p>There is also a possibility to switch into the tiled view instead of the listed one:</p> <p> Marketplace section (tiled view) </p> <p>To view the details of a marketplace item, simply click on its name:</p> <p> Item details </p> <p>The details window shows suplemental information, such as item's author, keywords, release version and the link to the repository it is located in. The window also contains the Create from template button that allows users to create the component by the chosen template. The procedure of creating new components is described in the Add Component via Marketplace page.</p>"},{"location":"headlamp-user-guide/marketplace/#related-articles","title":"Related Articles","text":"<ul> <li>Add Component via Marketplace</li> <li>Add Application</li> <li>Add Library</li> <li>Add Infrastructure</li> </ul>"},{"location":"operator-guide/","title":"Overview","text":"<p>The EDP Operator guide is intended for DevOps and provides information on EDP installation, configuration and customization, as well as the platform support. Inspect the documentation to adjust the EPAM Delivery Platform according to your business needs:</p> <ul> <li>The Installation section provides the prerequisites for EDP installation, including Kubernetes or OpenShift cluster setup, Keycloak, DefectDojo, Kiosk, and Ingress-nginx setup as well as the subsequent deployment of EPAM Delivery Platform.</li> </ul> <ul> <li>The Configuration section indicates the options to set the project with adding a code language, backup, integrate VCS with Jenkins or Tekton, managing Jenkins pipelines, and logging.</li> </ul> <ul> <li>The Integration section comprises the AWS, GitHub, GitLab, Jira, and Logsight integration options.</li> </ul> <ul> <li>The Tutorials section provides information on working with various aspects, for example, using cert-manager in OpenShift, deploying AWS EKS cluster, deploying OKD 4.9 cluster, deploying OKD 4.10 cluster, managing Jenkins agent, and upgrading Keycloak v.17.0.x-legacy to v.19.0.x on Kubernetes.</li> </ul>"},{"location":"operator-guide/add-jenkins-agent/","title":"Manage Jenkins Agent","text":"<p>Inspect the main steps to add and update Jenkins agent.</p>"},{"location":"operator-guide/add-jenkins-agent/#createupdate-jenkins-agent","title":"Create/Update Jenkins Agent","text":"<p>Every Jenkins agent is based on epamedp/edp-jenkins-base-agent. Check DockerHub for the latest version. Use it to create a new agent (or update an old one). See the example with Dockerfile of gradle-java11-agent below:</p> View: Dockerfile <pre><code>    # Copyright 2021 EPAM Systems.\n    # Licensed under the Apache License, Version 2.0 (the \"License\");\n    # you may not use this file except in compliance with the License.\n    # You may obtain a copy of the License at\n    # http://www.apache.org/licenses/LICENSE-2.0\n    # Unless required by applicable law or agreed to in writing, software\n    # distributed under the License is distributed on an \"AS IS\" BASIS,\n    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    # See the License for the specific language governing permissions and\n    # limitations under the License.\n\n    FROM epamedp/edp-jenkins-base-agent:1.0.1\n    SHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"]\n    ENV GRADLE_VERSION=7.1 \\\n        PATH=$PATH:/opt/gradle/bin\n\n    # Install Gradle\n    RUN curl -skL -o /tmp/gradle-bin.zip https://services.gradle.org/distributions/gradle-$GRADLE_VERSION-bin.zip &amp;&amp; \\\n        mkdir -p /opt/gradle &amp;&amp; \\\n        unzip -q /tmp/gradle-bin.zip -d /opt/gradle &amp;&amp; \\\n        ln -sf /opt/gradle/gradle-$GRADLE_VERSION/bin/gradle /usr/local/bin/gradle\n\n    RUN yum install java-11-openjdk-devel.x86_64 -y &amp;&amp; \\\n        rpm -V java-11-openjdk-devel.x86_64 &amp;&amp; \\\n        yum clean all -y\n\n    WORKDIR $HOME/.gradle\n\n    RUN chown -R \"1001:0\" \"$HOME\" &amp;&amp; \\\n        chmod -R \"g+rw\" \"$HOME\"\n\n    USER 1001\n</code></pre> <p>After the Docker agent update/creation, build and load the image into the project registry (e.g. DockerHub, AWS ECR, etc.).</p>"},{"location":"operator-guide/add-jenkins-agent/#add-jenkins-agent-configuration","title":"Add Jenkins Agent Configuration","text":"<p>To add a new Jenkins agent, take the steps below:</p> <ol> <li> <p>Run the following command. Please be aware that \u2039edp-project\u203a is the name of the EDP tenant.</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-project&gt;\n</code></pre> <p>Note</p> <p>On an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> <p>Add new agent template.      View: ConfigMap jenkins-slaves <pre><code>  data:\n    docker-template: |-\n     &lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;docker&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;docker&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;IMAGE_NAME:IMAGE_TAG&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n</code></pre> <p>Note</p> <p>The name and label properties should be unique(docker in the example above). Insert image name and tag instead of IMAGE_NAME:IMAGE_TAG.</p> <li> <p>Open Jenkins to ensure that everything is added correctly. Click the Manage Jenkins option, navigate to the Manage Nodes and Clouds-&gt;Configure Clouds-&gt;Kubernetes-&gt;Pod Templates..., and scroll down to find new Jenkins agent Pod Template details...:</p> <p> Jenkins pod template </p> <p>As a result, the newly added Jenkins agent will be available in the Advanced Settings block of the Admin Console tool during the codebase creation:</p> <p> Advanced settings </p> </li>"},{"location":"operator-guide/add-jenkins-agent/#modify-existing-agent-configuration","title":"Modify Existing Agent Configuration","text":"<p>If your application is integrated with EDP, take the steps below to change an existing agent configuration:</p> <ol> <li> <p>Run the following command. Please be aware that \u2039edp-project\u203a is the name of the EDP tenant.</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-project&gt;\n</code></pre> <p>Note</p> <p>On an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> </li> <li> <p>Find the agent template in use and change and change the parameters.</p> </li> <li> <p>Open Jenkins and check the correct addition. Click the Manage Jenkins option, navigate to the Manage Nodes and Clouds-&gt;Configure Clouds-&gt;Kubernetes-&gt;Pod Templates..., and scroll down to Pod Template details... with the necessary data.</p> </li> </ol>"},{"location":"operator-guide/add-other-code-language/","title":"Add Other Code Language","text":"<p>There is an ability to extend the default code languages when creating a codebase with the Clone or Import strategy.</p> <p> Other code language </p> <p>Warning</p> <p>The Create strategy does not allow to customize the default code language set.</p> <p>To customize the Build Tool list, perform the following:</p> <ul> <li> <p>Edit the edp-admin-console deployment by adding the necessary code language into the BUILD TOOLS field:</p> <pre><code> kubectl edit deployment edp-admin-console -n &lt;edp-project&gt;\n</code></pre> <p>Note</p> <p>Using an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> <p>Info</p> <p>\u2039edp-project\u203a is the name of the EDP tenant here and in all the following steps.</p> View: edp-admin-console deployment <pre><code>...\nspec:\ncontainers:\n- env:\n...\n- name: BUILD_TOOLS\nvalue: docker # List of custom build tools in Admin Console, e.g. 'docker,helm';\n...\n...\n</code></pre> </li> </ul> <ul> <li>Add the Jenkins agent by following the instruction.</li> </ul> <ul> <li>Add the Custom CI pipeline provisioner by following the instruction.</li> </ul> <ul> <li> <p>As a result, the newly added Jenkins agent will be available in the Select Jenkins Slave dropdown list of the Advanced Settings block during the codebase creation:</p> <p> Advanced settings </p> </li> </ul> <p>If it is necessary to create Code Review and Build pipelines, add corresponding entries (e.g. stages[Build-application-docker], [Code-review-application-docker]). See the example below:</p> <pre><code>...\nstages['Code-review-application-docker'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"sonar\"}]'\nstages['Build-application-docker'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build-image-kaniko\"}' + ',{\"name\": \"git-tag\"}]'\n...\n</code></pre> <p> Jenkins job provisioner </p> <p>Note</p> <p>Application is one of the available options. Another option might be to add a library. Please refer to the Add Library page for details.</p>"},{"location":"operator-guide/add-other-code-language/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Library</li> <li>Manage Jenkins Agent</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> </ul>"},{"location":"operator-guide/add-security-scanner/","title":"Add Security Scanner","text":"<p>In order to add a new security scanner, perform the steps below:</p> <ol> <li> <p>Select a pipeline customization option from the Customize CI Pipeline article. Follow the steps described in this article, to create a new repository.</p> <p>Note</p> <p>This tutorial will focus on adding a new stage using shared library via the custom global pipeline libraries.</p> </li> <li> <p>Open the new repository and create a directory with the <code>/src/com/epam/edp/customStages/impl/ci/impl/stageName/</code> name in the library repository, for example: <code>/src/com/epam/edp/customStages/impl/ci/impl/security/</code>. After that, add a Groovy file with another name to the same stages catalog, for example: <code>CustomSAST.groovy</code>.</p> </li> <li> <p>Copy the logic from <code>SASTMavenGradleGoApplication.groovy</code> stage into the new <code>CustomSAST.groovy</code> stage.</p> </li> <li> <p>Add a new <code>runGoSecScanner</code> function to the stage:</p> <pre><code>@Stage(name = \"sast-custom\", buildTool = [\"maven\",\"gradle\",\"go\"], type = [ProjectType.APPLICATION])\nclass CustomSAST {\n...\ndef runGoSecScanner(context) {\ndef edpName = context.platform.getJsonPathValue(\"cm\", \"edp-config\", \".data.edp_name\")\ndef reportData = [:]\nreportData.active = \"true\"\nreportData.verified = \"false\"\nreportData.path = \"sast-gosec-report.json\"\nreportData.type = \"Gosec Scanner\"\nreportData.productTypeName = \"Tenant\"\nreportData.productName = \"${edpName}\"\nreportData.engagementName = \"${context.codebase.name}-${context.git.branch}\"\nreportData.autoCreateContext = \"true\"\nreportData.closeOldFindings = \"true\"\nreportData.pushToJira = \"false\"\nreportData.environment = \"Development\"\nreportData.testTitle = \"SAST\"\nscript.sh(script: \"\"\"\n                set -ex\n                gosec -fmt=json -out=${reportData.path} ./...\n        \"\"\")\nreturn reportData\n}\n...\n}\n</code></pre> </li> <li> <p>Add function calls for the <code>runGoSecScanner</code> and <code>publishReport</code> functions:</p> <pre><code>...\nscript.node(\"sast\") {\nscript.dir(\"${testDir}\") {\nscript.unstash 'all-repo'\n...\ndef dataFromGoSecScanner = runGoSecScanner(context)\npublishReport(defectDojoCredentials, dataFromGoSecScanner)\n}\n}\n...\n</code></pre> </li> <li> <p>Gosec scanner will be installed on the Jenkins SAST agent. It is based on the <code>epamedp/edp-jenkins-base-agent</code>. Please check DockerHub for its latest version.</p> <p>See below an example of the <code>edp-jenkins-sast-agent</code> Dockerfile:</p> View: Default Dockerfile <pre><code> # Copyright 2022 EPAM Systems.\n\n # Licensed under the Apache License, Version 2.0 (the \"License\");\n # you may not use this file except in compliance with the License.\n # You may obtain a copy of the License at\n # http://www.apache.org/licenses/LICENSE-2.0\n\n # Unless required by applicable law or agreed to in writing, software\n # distributed under the License is distributed on an \"AS IS\" BASIS,\n # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n # See the License for the specific language governing permissions and\n # limitations under the License.\n\n FROM epamedp/edp-jenkins-base-agent:1.0.31\n\n SHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"]\n\n USER root\n\n ENV SEMGREP_SCANNER_VERSION=0.106.0 \\\n     GOSEC_SCANNER_VERSION=2.12.0\n\n RUN apk --no-cache add \\\n     curl=7.79.1-r2 \\\n     build-base=0.5-r3 \\\n     python3-dev=3.9.5-r2 \\\n     py3-pip=20.3.4-r1 \\\n     go=1.16.15-r0\n\n # hadolint ignore=DL3059\n RUN pip3 install --no-cache-dir --upgrade --ignore-installed \\\n     pip==22.2.1 \\\n     ruamel.yaml==0.17.21 \\\n     semgrep==${SEMGREP_SCANNER_VERSION}\n\n # Install GOSEC\n RUN curl -Lo /tmp/gosec.tar.gz https://github.com/securego/gosec/releases/download/v${GOSEC_SCANNER_VERSION}/gosec_${GOSEC_SCANNER_VERSION}_linux_amd64.tar.gz &amp;&amp; \\\n     tar xf /tmp/gosec.tar.gz &amp;&amp; \\\n     rm -f /tmp/gosec.tar.gz &amp;&amp; \\\n     mv gosec /bin/gosec\n\n RUN chown -R \"1001:0\" \"$HOME\" &amp;&amp; \\\n     chmod -R \"g+rw\" \"$HOME\"\n\n USER 1001\n</code></pre> </li> </ol>"},{"location":"operator-guide/add-security-scanner/#related-articles","title":"Related Articles","text":"<ul> <li>Customize CI Pipeline</li> <li>Static Application Security Testing Overview</li> <li>Semgrep</li> </ul>"},{"location":"operator-guide/argocd-integration/","title":"Argo CD Integration","text":"<p>EDP uses Jenkins Pipeline as a part of the Continues Delivery/Continues Deployment implementation. Another approach is to use Argo CD tool as an alternative to Jenkins. Argo CD follows the best GitOps practices, uses Kubernetes native approach for the Deployment Management, has rich UI and required RBAC capabilities.</p>"},{"location":"operator-guide/argocd-integration/#argo-cd-deployment-approach-in-edp","title":"Argo CD Deployment Approach in EDP","text":"<p>Argo CD can be installed using two different approaches:</p> <ul> <li>Cluster-wide scope with the cluster-admin access</li> <li>Namespaced scope with the single namespace access</li> </ul> <p>Both approaches can be deployed with High Availability (HA) or Non High Availability (non HA) installation manifests.</p> <p>EDP uses the HA deployment with the cluster-admin permissions, to minimize cluster resources consumption by sharing single Argo CD instance across multiple EDP Tenants. Please follow the installation instructions to deploy Argo CD.</p>"},{"location":"operator-guide/argocd-integration/#edp-argo-cd-integration","title":"EDP Argo CD Integration","text":"<p>See a diagram below for the details:</p> <p> Argo CD Diagram </p> <ul> <li>Argo CD is deployed in a separate <code>argocd</code> namespace.</li> <li>Argo CD uses a <code>cluster-admin</code> role for managing cluster-scope resources.</li> <li>The <code>control-plane</code> application is created using the App of Apps approach, and its code is managed by the <code>control-plane</code> members.</li> <li>The <code>control-plane</code> is used to onboard new Argo CD Tenants (Argo CD Projects - AppProject).</li> <li>The <code>EDP Tenant Member</code> manages <code>Argo CD Applications</code> using <code>kind: Application</code> in the <code>edpTenant</code> namespace.</li> </ul> <p>The App Of Apps approach is used to manage the <code>EDP Tenants</code>. Inspect the edp-grub repository structure that is used to provide the EDP Tenants for the Argo CD Projects:</p> <pre><code>edp-grub\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 apps                      ### All Argo CD Applications are stored here\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 grub-argocd.yaml      # Application that provisions Argo CD Resources - Argo Projects (EDP Tenants)\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 grub-keycloak.yaml    # Application that provisions Keycloak Resources - Argo CD Groups (EDP Tenants)\n\u251c\u2500\u2500 apps-configs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 grub\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 argocd            ### Argo CD resources definition\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 team-bar.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 team-foo.yaml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 keycloak          ### Keycloak resources definition\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 team-bar.yaml\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 team-foo.yaml\n\u251c\u2500\u2500 bootstrap\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 root.yaml             ### Root application in App of Apps, which provision Applications from /apps\n\u2514\u2500\u2500 examples                  ### Examples\n\u2514\u2500\u2500 tenant\n        \u2514\u2500\u2500 foo-petclinic.yaml\n</code></pre> <p>The Root Application must be created under the <code>control-plane</code> scope.</p>"},{"location":"operator-guide/argocd-integration/#configuration","title":"Configuration","text":"<p>Note</p> <p>Make sure that both EDP and Argo CD are installed, and that SSO is enabled.</p> <p>To start using Argo CD with EDP, perform the following steps:</p>"},{"location":"operator-guide/argocd-integration/#keycloak","title":"Keycloak","text":"<ol> <li> <p>Create a Keycloak Group.</p> <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakRealmGroup\nmetadata:\nname: argocd-team-foo-users\nspec:\nname: ArgoCD-team-foo-users\nrealm: main\n</code></pre> </li> <li> <p>In Keycloak, add users to the <code>ArgoCD-team-foo-users</code> Keycloak Group.</p> </li> </ol>"},{"location":"operator-guide/argocd-integration/#argo-cd","title":"Argo CD","text":"<ol> <li> <p>Add a credential template for Gerrit, GitHub, GitLab integrations. The credential template must be created for each Git server.</p> GerritGitHub/GitLab <p>Copy existing SSH private key for Gerrit to Argo CD namespace</p> <pre><code>EDP_NAMESPACE=&lt;EPD_NAMESPACE&gt;\nGERRIT_PORT=$(kubectl get gerrit gerrit -n ${EDP_NAMESPACE} -o jsonpath='{.spec.sshPort}')\nGERRIT_ARGOCD_SSH_KEY_NAME=\"gerrit-argocd-sshkey\"\nGERRIT_URL=$(echo \"ssh://argocd@gerrit.${EDP_NAMESPACE}:${GERRIT_PORT}\" | base64)\nkubectl get secret ${GERRIT_ARGOCD_SSH_KEY_NAME} -n ${EDP_NAMESPACE} -o json | jq 'del(.data.username,.metadata.annotations,.metadata.creationTimestamp,.metadata.labels,.metadata.resourceVersion,.metadata.uid,.metadata.ownerReferences)' | jq '.metadata.namespace = \"argocd\"' | jq --arg name \"${EDP_NAMESPACE}\" '.metadata.name = $name' | jq --arg url \"${GERRIT_URL}\" '.data.url = $url' | jq '.data.sshPrivateKey = .data.id_rsa' | jq 'del(.data.id_rsa,.data.\"id_rsa.pub\")' | kubectl apply -f -\nkubectl label --overwrite secret ${EDP_NAMESPACE} -n argocd \"argocd.argoproj.io/secret-type=repo-creds\"\n</code></pre> <p>Generate an SSH key pair and add a public key to GitLab or GitHub account.</p> <p>Warning</p> <p>Use an additional GitHub/GitLab User to access a repository. For example: - GitHub, add a User to a repository with a \"Read\" role. - GitLab, add a User to a repository with a \"Guest\" role.</p> <pre><code>ssh-keygen -t ed25519 -C \"email@example.com\" -f argocd\n</code></pre> <p>Copy SSH private key to Argo CD namespace</p> <pre><code>EDP_NAMESPACE=&lt;EDP_NAMESPACE&gt;\nVCS_HOST=\"&lt;github.com_or_gitlab.com&gt;\"\nACCOUNT_NAME=\"&lt;ACCOUNT_NAME&gt;\"\nURL=\"ssh://git@${VCS_HOST}:22/${ACCOUNT_NAME}\"\n\nkubectl create secret generic ${EDP_NAMESPACE} -n argocd \\\n--from-file=sshPrivateKey=argocd \\\n--from-literal=url=\"${URL}\"\nkubectl label --overwrite secret ${EDP_NAMESPACE} -n argocd \"argocd.argoproj.io/secret-type=repo-creds\"\n</code></pre> <p>Add public SSH key to GitHub/GitLab account.</p> </li> <li> <p>Add SSH Known hosts    for Gerrit, GitHub, GitLab integration.</p> GerritGitHub/GitLab <p>Add Gerrit host to Argo CD config map with known hosts</p> <pre><code>EDP_NAMESPACE=&lt;EDP_NAMESPACE&gt;\nKNOWN_HOSTS_FILE=\"/tmp/ssh_known_hosts\"\nARGOCD_KNOWN_HOSTS_NAME=\"argocd-ssh-known-hosts-cm\"\nGERRIT_PORT=$(kubectl get gerrit gerrit -n ${EDP_NAMESPACE} -o jsonpath='{.spec.sshPort}')\n\nrm -f ${KNOWN_HOSTS_FILE}\nkubectl get cm ${ARGOCD_KNOWN_HOSTS_NAME} -n argocd -o jsonpath='{.data.ssh_known_hosts}' &gt; ${KNOWN_HOSTS_FILE}\nkubectl exec -it deployment/gerrit -n ${EDP_NAMESPACE} -- ssh-keyscan -p ${GERRIT_PORT} gerrit.${EDP_NAMESPACE} &gt;&gt; ${KNOWN_HOSTS_FILE}\nkubectl create configmap ${ARGOCD_KNOWN_HOSTS_NAME} -n argocd --from-file ${KNOWN_HOSTS_FILE} -o yaml --dry-run=client | kubectl apply -f -\n</code></pre> <p>Add GitHub/GitLab host to Argo CD config map with known hosts</p> <pre><code>EDP_NAMESPACE=&lt;EPD_NAMESPACE&gt;\nVCS_HOST=\"&lt;VCS_HOST&gt;\"\nKNOWN_HOSTS_FILE=\"/tmp/ssh_known_hosts\"\nARGOCD_KNOWN_HOSTS_NAME=\"argocd-ssh-known-hosts-cm\"\n\nrm -f ${KNOWN_HOSTS_FILE}\nkubectl get cm ${ARGOCD_KNOWN_HOSTS_NAME} -n argocd -o jsonpath='{.data.ssh_known_hosts}' &gt; ${KNOWN_HOSTS_FILE}\nssh-keyscan ${VCS_HOST} &gt;&gt; ${KNOWN_HOSTS_FILE}\nkubectl create configmap ${ARGOCD_KNOWN_HOSTS_NAME} -n argocd --from-file ${KNOWN_HOSTS_FILE} -o yaml --dry-run=client | kubectl apply -f -\n</code></pre> </li> <li> <p>Create an Argo CD Project (EDP Tenant), for example, with the <code>team-foo</code> name:</p> AppProject<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\nname: team-foo\nnamespace: argocd\n# Finalizer that ensures that project is not deleted until it is not referenced by any application\nfinalizers:\n- resources-finalizer.argocd.argoproj.io\nspec:\ndescription: CD pipelines for team-foo\nroles:\n- name: developer\ndescription: Users for team-foo tenant\npolicies:\n- p, proj:team-foo:developer, applications, create, team-foo/*, allow\n- p, proj:team-foo:developer, applications, delete, team-foo/*, allow\n- p, proj:team-foo:developer, applications, get, team-foo/*, allow\n- p, proj:team-foo:developer, applications, override, team-foo/*, allow\n- p, proj:team-foo:developer, applications, sync, team-foo/*, allow\n- p, proj:team-foo:developer, applications, update, team-foo/*, allow\n- p, proj:team-foo:developer, repositories, create, team-foo/*, allow\n- p, proj:team-foo:developer, repositories, delete, team-foo/*, allow\n- p, proj:team-foo:developer, repositories, update, team-foo/*, allow\n- p, proj:team-foo:developer, repositories, get, team-foo/*, allow\ngroups:\n# Keycloak Group name\n- ArgoCD-team-foo-users\ndestinations:\n# ensure we can deploy to ns with tenant prefix\n- namespace: 'team-foo-*'\n# allow to deploy to specific server (local in our case)\nserver: https://kubernetes.default.svc\n# Deny all cluster-scoped resources from being created, except for Namespace\nclusterResourceWhitelist:\n- group: ''\nkind: Namespace\n# Allow all namespaced-scoped resources to be created, except for ResourceQuota, LimitRange, NetworkPolicy\nnamespaceResourceBlacklist:\n- group: ''\nkind: ResourceQuota\n- group: ''\nkind: LimitRange\n- group: ''\nkind: NetworkPolicy\n# we are ok to create any resources inside namespace\nnamespaceResourceWhitelist:\n- group: '*'\nkind: '*'\n# enable access only for specific git server. The example below 'team-foo' - it is namespace where EDP deployed\nsourceRepos:\n- ssh://argocd@gerrit.team-foo:30007/*\n# enable capability to deploy objects from namespaces\nsourceNamespaces:\n- team-foo\n</code></pre> </li> <li> <p>Optional: if the Argo CD controller has not been enabled to manage the Application resources in the specific namespaces    (<code>team-foo</code>, in our case) in the Install Argo CD, modify the <code>argocd-cmd-params-cm</code>    ConfigMap in the Argo CD namespace and add the <code>application.namespaces</code> parameter to the subsection data:</p> argocd-cmd-params-cm<pre><code>...\ndata:\napplication.namespaces: team-foo\n...\n</code></pre> values.yaml file<pre><code>...\nconfigs:\nparams:\napplication.namespaces: team-foo\n...\n</code></pre> </li> <li> <p>Check that your new Repository, Known Hosts, and AppProject are added to the Argo CD UI.</p> </li> </ol> <p>Once Argo CD is successfully integrated, EDP user can utilize Argo CD to deploy CD pipelines.</p>"},{"location":"operator-guide/argocd-integration/#check-argo-cd-integration-optional","title":"Check Argo CD Integration (Optional)","text":"<p>This section provides the information on how to test the integration with Argo CD and is not mandatory to be followed.</p> <ol> <li> <p>Follow the Add Application instruction to deploy a test EDP application with the <code>demo</code> name, which should be stored in a Gerrit private repository:</p> Example: Argo CD Application  <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\nname: demo\nspec:\nproject: team-foo\ndestination:\nnamespace: team-foo-demo\nserver: https://kubernetes.default.svc\nsource:\nhelm:\nparameters:\n- name: image.tag\nvalue: master-0.1.0-1\n- name: image.repository\nvalue: image-repo\npath: deploy-templates\nrepoURL: ssh://argocd@gerrit.team-foo:30007/demo.git\ntargetRevision: master\nsyncPolicy:\nsyncOptions:\n- CreateNamespace=true\nautomated:\nselfHeal: true\nprune: true\n</code></pre> </li> <li> <p>Check that your new Application is added to the Argo CD UI under the <code>team-foo</code> Project scope.</p> </li> </ol>"},{"location":"operator-guide/argocd-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Install Argo CD</li> </ul>"},{"location":"operator-guide/configure-keycloak-oidc-eks/","title":"EKS OIDC With Keycloak","text":"<p>This article provides the instruction of configuring Keycloak as OIDC Identity Provider for EKS. The example is written on Terraform (HCL).</p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#prerequisites","title":"Prerequisites","text":"<p>To follow the instruction, check the following prerequisites:</p> <ol> <li>terraform 0.14.10</li> <li>hashicorp/aws = 4.8.0</li> <li>mrparkers/keycloak &gt;= 3.0.0</li> <li>hashicorp/kubernetes ~&gt; 2.9.0</li> <li>kubectl = 1.22</li> <li>kubelogin  &gt;= v1.25.1</li> <li>Ensure that Keycloak has network availability for AWS (not in a private network).</li> </ol> <p>Note</p> <p>To connect OIDC with a cluster, install and configure the kubelogin plugin. For Windows, it is recommended to download the kubelogin as a binary and add it to your PATH.</p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#solution-overview","title":"Solution Overview","text":"<p>The solution includes three types of the resources - AWS (EKS), Keycloak, Kubernetes. The left part of Keycloak resources remain unchanged after creation, thus allowing us to associate a claim for a user group membership. Other resources can be created, deleted or changed if needed. The most crucial from Kubernetes permissions are Kubernetes RoleBindings and ClusterRoles/Roles. Roles present a set of permissions, in turn RoleBindings map Kubernetes Role to representative Keycloak groups, so a group member can have just appropriate permissions.</p> <p> EKS Keycloak OIDC </p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#keycloak-configuration","title":"Keycloak Configuration","text":"<p>To configure Keycloak, follow the steps described below.</p> <ul> <li>Create a client:</li> </ul> <pre><code>resource \"keycloak_openid_client\" \"openid_client\" {\nrealm_id                                  = \"openshift\"\nclient_id                                 = \"kubernetes\"\naccess_type                               = \"CONFIDENTIAL\"\nstandard_flow_enabled                     = true\nimplicit_flow_enabled                     = false\ndirect_access_grants_enabled              = true\nservice_accounts_enabled                  = true\noauth2_device_authorization_grant_enabled = true\nbackchannel_logout_session_required       = true\n\nroot_url    = \"http://localhost:8000/\"\nbase_url    = \"http://localhost:8000/\"\nadmin_url   = \"http://localhost:8000/\"\nweb_origins = [\"*\"]\n\nvalid_redirect_uris = [\n\"http://localhost:8000/*\"\n]\n}\n</code></pre> <ul> <li>Create the client scope:</li> </ul> <pre><code>resource \"keycloak_openid_client_scope\" \"openid_client_scope\" {\nrealm_id               = &lt;realm_id&gt;\nname                   = \"groups\"\ndescription            = \"When requested, this scope will map a user's group memberships to a claim\"\ninclude_in_token_scope = true\nconsent_screen_text    = false\n}\n</code></pre> <ul> <li>Add scope to the client by selecting all default client scope:</li> </ul> <pre><code>resource \"keycloak_openid_client_default_scopes\" \"client_default_scopes\" {\nrealm_id  = &lt;realm_id&gt;\nclient_id = keycloak_openid_client.openid_client.id\n\ndefault_scopes = [\n\"profile\",\n\"email\",\n\"roles\",\n\"web-origins\",\nkeycloak_openid_client_scope.openid_client_scope.name,\n]\n}\n</code></pre> <ul> <li>Add the following mapper to the client scope:</li> </ul> <pre><code>resource \"keycloak_openid_group_membership_protocol_mapper\" \"group_membership_mapper\" {\nrealm_id            = &lt;realm_id&gt;\nclient_scope_id     = keycloak_openid_client_scope.openid_client_scope.id\nname                = \"group-membership-mapper\"\nadd_to_id_token     = true\nadd_to_access_token = true\nadd_to_userinfo     = true\nfull_path           = false\n\nclaim_name = \"groups\"\n}\n</code></pre> <ul> <li>In the authorization token, get groups membership field with the list of group membership in the realm: <pre><code>...\n\"email_verified\": false,\n\"name\": \"An User\",\n\"groups\": [\n\"&lt;env_prefix_name&gt;-oidc-viewers\",\n\"&lt;env_prefix_name&gt;-oidc-cluster-admins\"\n],\n\"preferred_username\": \"an_user@example.com\",\n\"given_name\": \"An\",\n\"family_name\": \"User\",\n\"email\": \"an_user@example.com\"\n...\n</code></pre></li> </ul> <ul> <li>Create group/groups, e.g. admin group:</li> </ul> <pre><code>resource \"keycloak_group\" \"oidc_tenant_admin\" {\nrealm_id = &lt;realm_id&gt;\nname     = \"kubernetes-oidc-admins\"\n}\n</code></pre>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#eks-configuration","title":"EKS Configuration","text":"<p>To configure EKS, follow the steps described below. In AWS Console, open EKS home page -&gt; Choose a cluster -&gt; Configuration tab -&gt; Authentication tab.</p> <p>The Terraform code for association with Keycloak:</p> <ul> <li>terraform.tfvars <pre><code>...\ncluster_identity_providers = {\nkeycloak = {\nclient_id                     = &lt;keycloak_client_id&gt;\nidentity_provider_config_name = \"Keycloak\"\nissuer_url                    = \"https://&lt;keycloak_url&gt;/auth/realms/&lt;realm_name&gt;\"\ngroups_claim                  = \"groups\"\n}\n...\n</code></pre></li> <li>the resource code <pre><code>resource \"aws_eks_identity_provider_config\" \"keycloak\" {\nfor_each = { for k, v in var.cluster_identity_providers : k =&gt; v if true }\n\ncluster_name = var.platform_name\n\noidc {\nclient_id                     = each.value.client_id\ngroups_claim                  = lookup(each.value, \"groups_claim\", null)\ngroups_prefix                 = lookup(each.value, \"groups_prefix\", null)\nidentity_provider_config_name = try(each.value.identity_provider_config_name, each.key)\nissuer_url                    = each.value.issuer_url\nrequired_claims               = lookup(each.value, \"required_claims\", null)\nusername_claim                = lookup(each.value, \"username_claim\", null)\nusername_prefix               = lookup(each.value, \"username_prefix\", null)\n}\n\ntags = var.tags\n}\n</code></pre></li> </ul> <p>Note</p> <p>The resource creation takes around 20-30 minutes. The resource doesn't support updating, so each change will lead to deletion of the old instance and creation of a new instance instead.</p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#kubernetes-configuration","title":"Kubernetes Configuration","text":"<p>To connect the created Keycloak resources with permissions, it is necessary to create Kubernetes Roles and RoleBindings:</p> <ul> <li>ClusterRole <pre><code>resource \"kubernetes_cluster_role_v1\" \"oidc_tenant_admin\" {\nmetadata {\nname = \"oidc-admin\"\n}\nrule {\napi_groups = [\"*\"]\nresources  = [\"*\"]\nverbs      = [\"*\"]\n}\n}\n</code></pre></li> <li>ClusterRoleBinding <pre><code>resource \"kubernetes_cluster_role_binding_v1\" \"oidc_cluster_rb\" {\nmetadata {\nname = \"oidc-cluster-admin\"\n}\nrole_ref {\napi_group = \"rbac.authorization.k8s.io\"\nkind      = \"ClusterRole\"\nname      = kubernetes_cluster_role_v1.oidc_tenant_admin.metadata[0].name\n}\nsubject {\nkind      = \"Group\"\nname      = keycloak_group.oidc_tenant_admin.name\napi_group = \"rbac.authorization.k8s.io\"\n    # work-around due https://github.com/hashicorp/terraform-provider-kubernetes/issues/710\nnamespace = \"\"\n}\n}\n</code></pre></li> </ul> <p>Note</p> <p>When creating the Keycloak group, ClusterRole, and ClusterRoleBinding, a user receives cluster admin permissions. There is also an option to provide admin permissions just to a particular namespace or another resources set in another namespace. For details, please refer to the Mixing Kubernetes Roles page.</p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#kubeconfig","title":"Kubeconfig","text":"<p>Template for kubeconfig:</p> <p><pre><code>apiVersion: v1\npreferences: {}\nkind: Config\n\nclusters:\n- cluster:\nserver: https://&lt;eks_url&gt;.eks.amazonaws.com\ncertificate-authority-data: &lt;certificate_authtority_data&gt;\nname: &lt;cluster_name&gt;\n\ncontexts:\n- context:\ncluster: &lt;cluster_name&gt;\nuser: &lt;keycloak_user_email&gt;\nname: &lt;cluster_name&gt;\n\ncurrent-context: &lt;cluster_name&gt;\n\nusers:\n- name: &lt;keycloak_user_email&gt;\nuser:\nexec:\napiVersion: client.authentication.k8s.io/v1beta1\ncommand: kubectl\nargs:\n- oidc-login\n- get-token\n- -v1\n- --oidc-issuer-url=https://&lt;keycloak_url&gt;/auth/realms/&lt;realm&gt;\n- --oidc-client-id=&lt;keycloak_client_id&gt;\n- --oidc-client-secret=&lt;keycloak_client_secret&gt;\n</code></pre> Flag -v1 can be used for debug, in a common case it's not needed and can be deleted.</p> <p>To find the client secret:</p> <ol> <li>Open Keycloak</li> <li>Choose realm</li> <li>Find keycloak_client_id that was previously created</li> <li>Open Credentials tab</li> <li>Copy Secret</li> </ol>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#testing","title":"Testing","text":"<p>Before testing, ensure that a user is a member of the correct Keycloak group. To add a user to a Keycloak group:</p> <ol> <li>Open Keycloak</li> <li>Choose realm</li> <li>Open user screen with search field</li> <li>Find a user and open the configuration</li> <li>Open Groups tab</li> <li>In Available Groups, choose an appropriate group</li> <li>Click the Join button</li> <li>The group should appear in the Group Membership list</li> </ol> <p>Follow the steps below to test the configuration:</p> <ul> <li>Run kubectl command, it is important to specify the correct kubeconfig: <pre><code>KUBECONFIG=&lt;path_to_oidc_kubeconfig&gt; kubectl get ingresses -n &lt;namespace_name&gt;\n</code></pre></li> <li>After the first run and redirection to the Keycloak login page, log in using credentials (login:password) or using SSO Provider. In case of the successful login, you will receive the following notification that can be closed:</li> </ul> <p> OIDC Successful Login </p> <ul> <li>As the result, a respective response from the Kubernetes will appear in the console in case a user is configured correctly and is a member of the correct group and Roles/RoleBindings.</li> </ul> <ul> <li>If something is not set up correctly, the following output error will be displayed: <pre><code>Error from server (Forbidden): ingresses.networking.k8s.io is forbidden:\nUser \"https://&lt;keycloak_url&gt;/auth/realms/&lt;realm&gt;#&lt;keycloak_user_id&gt;\"\ncannot list resource \"ingresses\" in API group \"networking.k8s.io\" in the namespace \"&lt;namespace_name&gt;\"\n</code></pre></li> </ul>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#session-update","title":"Session Update","text":"<p>To update the session, clear cache. The default location for the login cache:</p> <pre><code>rm -rf ~/.kube/cache\n</code></pre>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#access-cluster-via-lens","title":"Access Cluster via Lens","text":"<p>To access the Kubernetes cluster via Lens, follow the steps below to configure it:</p> <ul> <li>Add a new kubeconfig to the location where Lens has access. The default location of the kubeconfig is ~/.kube/config but it can be changed by navigating to File -&gt; Preferences -&gt; Kubernetes -&gt; Kubeconfig Syncs;</li> <li>(Optional) Using Windows, it is recommended to reboot the system after adding a new kubeconfig.</li> <li>Authenticate on the Keycloak login page to be able to access the cluster;</li> </ul> <p>Note</p> <p>Lens does not add namespaces of the project automatically, so it is necessary to add them manually, simply go to Settings -&gt; Namespaces and add the namespaces of a project.</p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#related-articles","title":"Related Articles","text":"<ul> <li>Headlamp OIDC Configuration</li> </ul>"},{"location":"operator-guide/container-registry-harbor-integration-tekton-ci/","title":"Integrate Harbor With EDP Pipelines","text":"<p>Harbor serves as a tool for storing images and artifacts. This documentation contains instructions on how to create a project in Harbor and set up a robot account for interacting with the registry from CI pipelines.</p>"},{"location":"operator-guide/container-registry-harbor-integration-tekton-ci/#overview","title":"Overview","text":"<p>Harbor integration with Tekton enables the centralized storage of container images within the cluster, eliminating the need for external services. By leveraging Harbor as the container registry, users can manage and store their automation results and reports in one place.</p>"},{"location":"operator-guide/container-registry-harbor-integration-tekton-ci/#integration-procedure","title":"Integration Procedure","text":"<p>The integration procedure consists of two steps:</p> <ul> <li>Creating a project where the application images will be stored;</li> <li>Creating an account that will be used to put images into the project.</li> </ul>"},{"location":"operator-guide/container-registry-harbor-integration-tekton-ci/#create-new-project","title":"Create New Project","text":"<p>The process of creating new projects is the following:</p> <ol> <li>Log in to the Harbor console using your credentials.</li> <li> <p>Navigate to the Projects menu, click the New Project button:</p> <p> Projects menu </p> </li> <li> <p>On the New Project menu, enter a project name that matches your EDP namespace in the Project Name field. Keep other fields as default and click OK to continue:</p> <p> New Project menu </p> </li> </ol>"},{"location":"operator-guide/container-registry-harbor-integration-tekton-ci/#set-up-robot-account","title":"Set Up Robot Account","text":"<p>To make EDP and Harbor project interact with each other, set up a robot account:</p> <ol> <li> <p>Navigate to your newly created project, select Robot Accounts menu and choose New Robot Account:</p> <p> Create Robot Account menu </p> </li> <li> <p>In the pop-up window, fill in the fields as follows:</p> <ul> <li>Name - type the name of a robot account;</li> <li>Expiration time - select Never;</li> <li>Description - add description;</li> <li>Permissions - keep the Pull Repository and Push Repository permissions.</li> </ul> <p>To proceed, click the ADD button:</p> <p> Robot Accounts menu </p> </li> <li> <p>In the appeared window, copy the robot account credentials or click the Export to file button to save all locally:</p> <p> New credentials for Robot Account </p> </li> <li> <p>Create the kaniko-docker-config Kubernetes secret using the template below. Fill in the fields with your own values:</p> ManuallyExternal Secret Operator <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: kaniko-docker-config\nnamespace: platform\ntype: kubernetes.io/dockerconfigjson\nstringData:\n.dockerconfigjson: |\n{\n\"auths\" : {\n\"harbor-registry.com\": { \"auth\": \"&lt;base64 encoded \"user:secret\" string&gt;\" }\n}\n}\n</code></pre> <p>By default, EDP allows to get a value from the SecretStore, in which the value of <code>kaniko-docker-config</code>:</p> /edp/deploy-secrets<pre><code>{\n\"kaniko-docker-config\":  {\"auths\" : {\"harbor-registry.com\": { \"auth\": \"&lt;base64 encoded \"user:secret\" string&gt;\" }}}\n}\n</code></pre> <p>Example</p> <p>The <code>auth</code> string can be generated by this command: <pre><code>echo -n \"robot\\$edp-project+edp:secret\" | base64\n</code></pre></p> </li> <li> <p>In the values.yaml file for the edp-install helm chart, set the following values for the specified fields:</p> <ul> <li> <p>If <code>kaniko-docker-config</code> secret has been created manually.</p> values.yaml<pre><code>...\nkaniko:\nexistingDockerConfig: \"kaniko-docker-config\"\nglobal:\ndockerRegistry:\nurl: harbor-registry.com\ntype: \"harbor\"\n...\n</code></pre> </li> </ul> <ul> <li> <p>If <code>kaniko-docker-config</code> secret has been created via External Secrets Operator</p> values.yaml<pre><code>...\nkaniko:\nexistingDockerConfig: \"kaniko-docker-config\"\nexternalSecrets:\nenabled: true\nglobal:\ndockerRegistry:\nurl: harbor-registry.com\ntype: \"harbor\"\n...\n</code></pre> </li> </ul> </li> <li> <p>(Optional) Update the EDP Helm chart if it has already been deployed:</p> <pre><code>helm update --install edp epamedp/edp-install \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> </li> <li> <p>After completing the steps above, you can get back and continue installing EDP.   As a result, application images built in Headlamp UI will be stored in your Harbor project.</p> </li> </ol>"},{"location":"operator-guide/container-registry-harbor-integration-tekton-ci/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Install Harbor</li> <li>Adjust Jira Integration</li> <li>Custom SonarQube Integration</li> </ul>"},{"location":"operator-guide/delete-edp/","title":"Uninstall EDP","text":"<p>This tutorial provides detailed instructions on the optimal method to uninstall the EPAM Delivery Platform.</p>"},{"location":"operator-guide/delete-edp/#deletion-procedure","title":"Deletion Procedure","text":"<p>To uninstall EDP, perform the following steps:</p> <ol> <li> <p>It is highly recommended to delete all the resources created via Headlamp UI first. It can be:</p> <ul> <li>Applications;</li> <li>Libraries;</li> <li>Autotests;</li> <li>Infrastructures;</li> <li>CD Pipelines.</li> </ul> <p>We recommend deleting them via Headlamp UI respectively, although it is also possible to delete all the Headlamp resources using the <code>kubectl delete</code> command.</p> </li> <li> <p>Delete application namespaces. They should be called according to the <code>&lt;edp-project&gt;-&lt;cd-pipeline&gt;-&lt;stage-name&gt;</code> pattern.</p> </li> <li> <p>Uninstall EDP the same way it was installed.</p> </li> <li> <p>Run the script that deletes the rest of the custom resources:</p> View: CleanEDP.sh <pre><code>#!/bin/sh\n\n###################################################################\n# A POSIX script to remove EDP Kubernetes Custom Resources        #\n#                                                                 #\n# PREREQUISITES                                                   #\n#     kubectl&gt;=1.23.x, awscli (for EKS authentication)            #\n#                                                                 #\n# TESTED                                                          #\n#     OS: Ubuntu, FreeBSD, Windows (GitBash)                      #\n#     Shells: zsh, bash, dash                                     #\n###################################################################\n\n[ -n \"${DEBUG}\" ] &amp;&amp; set -x\n\nset -e\n\nexit_err() {\nprintf '%s\\n' \"$1\" &gt;&amp;2\nexit 1\n}\n\ncheck_kubectl() {\nif ! hash kubectl; then\nexit_err \"Error: kubectl is not installed\"\nfi\n}\n\nget_script_help() {\nself_name=\"$(basename \"$0\")\"\necho \"\\\n${self_name} deletes EDP Kubernetes Custom Resources\n\nUsage: ${self_name}\n\nOptions:\n${self_name} [OPTION] [FILE]\n\n-h, --help          Print Help\n-k, --kubeconfig    Pass Kubeconfig file\n\nDebug:\nDEBUG=true ${self_name}\n\nExamples:\n${self_name} --kubeconfig ~/.kube/custom_config\"\n}\n\nyellow_fg() {\ntput setaf 3 || true\n}\n\nno_color_out() {\ntput sgr0 || true\n}\n\nget_current_context() {\nkubectl config current-context\n}\n\nget_context_ns() {\nkubectl config view \\\n--minify --output jsonpath='{..namespace}' 2&gt; /dev/null\n}\n\nget_ns() {\nkubectl get ns \"${edp_ns}\" --output name --request-timeout='5s'\n}\n\ndelete_ns() {\nkubectl delete ns \"${edp_ns}\" --timeout='30s'\n}\n\nget_edp_crds() {\nkubectl get crds --no-headers=true | awk '/edp.epam.com/ {print $1}'\n}\n\nget_all_edp_crs_manif() {\nkubectl get \"${edp_crds_comma_list}\" -n \"${edp_ns}\" \\\n--output yaml --ignore-not-found --request-timeout='15s'\n}\n\ndel_all_edp_crs() {\nkubectl delete --all \"${edp_crds_comma_list}\" -n \"${edp_ns}\" \\\n--ignore-not-found --timeout='15s'\n}\n\niterate_edp_crs() {\nedp_crds_comma_list=\"$(printf '%s' \"${edp_crds}\" | tr -s '\\n' ',')\"\nget_all_edp_crs_manif \\\n| sed '/finalizers:/,/.*:/{//!d;}' \\\n| kubectl replace -f - || true\ndel_all_edp_crs || true\n}\n\niterate_edp_crds() {\nn=0\nwhile [ \"$n\" -lt 2 ]; do\nn=$((n + 1))\n\nif [ \"$n\" -eq 2 ]; then\n# Delete remaining resources\nedp_crds=\"keycloakclients,codebasebranches,jenkinsfolders\"\niterate_edp_crs\necho \"EDP Custom Resources in NS ${color_ns} have been deleted.\"\nbreak\nfi\n\necho \"Replacing EDP CR Manifests. Wait for output (may take 2min)...\"\nedp_crds=\"$(get_edp_crds)\"\niterate_edp_crs\ndone\n}\n\nselect_ns() {\nis_context=\"$(get_current_context)\" || exit 1\nprintf '%s' \"Current cluster: \"\nprintf '%s\\n' \"$(yellow_fg)${is_context}$(no_color_out)\"\n\ncurrent_ns=\"$(get_context_ns)\" || true\n\nprintf '%s\\n' \"Enter EDP namespace\"\nprintf '%s' \"Skip to use [$(yellow_fg)${current_ns}$(no_color_out)]: \"\nread -r edp_ns\n\nif [ -z \"${edp_ns}\" ]; then\nedp_ns=\"${current_ns}\"\necho \"${edp_ns}\"\nif [ -z \"${edp_ns}\" ]; then\nexit_err \"Error: namespace is not specified\"\nfi\nelse\nget_ns || exit 1\nfi\n\ncolor_ns=\"$(yellow_fg)${edp_ns}$(no_color_out)\"\n}\n\nchoose_delete_ns() {\nprintf '%s\\n' \"Do you want to delete namespace ${color_ns} as well? (y/n)?\"\nprintf '%s' \"Skip or enter [N/n] to keep the namespace: \"\nread -r answer\nif [ \"${answer}\" != \"${answer#[Yy]}\" ]; then\ndelete_edp_ns=true\necho \"Namespace ${color_ns} is marked for deletion.\"\nelse\necho \"Skipped. Deleting EDP Custom Resources only.\"\nfi\n}\n\ndelete_ns_if_true() {\nif [ \"${delete_edp_ns}\" = true ]; then\necho \"Deleting ${color_ns} namespace...\"\ndelete_ns || exit 1\nfi\n}\n\ninvalid_option() {\nexit_err \"Invalid option '$1'. Use -h, --help for details\"\n}\n\nmain_func() {\ncheck_kubectl\nselect_ns\nchoose_delete_ns\niterate_edp_crds\ndelete_ns_if_true\n}\n\nwhile [ \"$#\" -gt 0 ]; do\ncase \"$1\" in\n-h | --help)\nget_script_help\nexit 0\n;;\n-k | --kubeconfig)\nshift\n[ $# = 0 ] &amp;&amp; exit_err \"No Kubeconfig file specified\"\nexport KUBECONFIG=\"$1\"\n;;\n--)\nbreak\n;;\n-k* | --k*)\necho \"Did you mean '--kubeconfig'?\"\ninvalid_option \"$1\"\n;;\n-* | *)\ninvalid_option \"$1\"\n;;\nesac\nshift\ndone\n\nmain_func\n</code></pre> <p>The script will prompt user to specify the namespace where EDP was deployed in and choose if the namespace is going to be deleted. This script will delete EDP custom resources in the namespace specified by user.</p> </li> <li> <p>In Keycloak, delete the <code>&lt;edp-project&gt;-main</code> realm, also delete client which is supposed to be called by the <code>&lt;edp-project&gt;-main</code> pattern in the openshift realm.</p> </li> </ol>"},{"location":"operator-guide/delete-edp/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Install EDP via Helmfile</li> <li>Keycloak Integration</li> </ul>"},{"location":"operator-guide/delete-jenkins-job-provision/","title":"Delete Jenkins Job Provision","text":"<p>To delete the job provisioner, take the following steps:</p> <ol> <li> <p>Delete the job provisioner from Jenkins. Navigate to Admin Console-&gt;Jenkins-&gt;jobs-&gt;job-provisions folder, select the necessary provisioner and click the drop-down right to the provisioner name. Select Delete project.</p> <p> Delete job provisioner </p> </li> </ol>"},{"location":"operator-guide/deploy-aws-eks/","title":"Deploy AWS EKS Cluster","text":"<p>This instruction provides detailed information on the Amazon Elastic Kubernetes Service cluster deployment and contains the additional setup necessary for the managed infrastructure.</p>"},{"location":"operator-guide/deploy-aws-eks/#prerequisites","title":"Prerequisites","text":"<p>Before the EKS cluster deployment and configuration, make sure to check the prerequisites.</p>"},{"location":"operator-guide/deploy-aws-eks/#required-tools","title":"Required Tools","text":"<p>Install the required tools listed below:</p> <ul> <li>Git</li> </ul> <ul> <li>tfenv</li> </ul> <ul> <li>AWS CLI</li> </ul> <ul> <li>kubectl</li> </ul> <ul> <li>helm</li> </ul> <ul> <li>lens (optional)</li> </ul> <p>To check the correct tools installation, run the following commands:</p> <pre><code>$ git --version\n$ tfenv --version\n$ aws --version\n$ kubectl version\n$ helm version\n</code></pre>"},{"location":"operator-guide/deploy-aws-eks/#aws-account-and-iam-roles","title":"AWS Account and IAM Roles","text":"<ul> <li>Make sure the AWS account is active.</li> </ul> <ul> <li> <p>Create the AWS IAM role: EKSDeployerRole to deploy EKS cluster on the project side. The provided resources will allow to use cross-account deployment by assuming the created EKSDeployerRole from the root AWS account. Take the following steps:</p> <ol> <li> <p>Clone git repo with the edp-terraform-aws-platform.git ism-deployer project, and rename it according to the project name.</p> <p>  clone project <pre><code>$ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git\n$ mv edp-terraform-aws-platform edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;\n$ cd edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;/iam-deployer\n</code></pre> <p>where:</p> <ul> <li>\u2039PROJECT_NAME\u203a - is a project name or a unique platform identifier, for example, <code>shared</code> or <code>test-eks</code>.</li> </ul> <li> <p>Fill in the input variables for Terraform run in the \u2039iam-deployer/terraform.tfvars\u203a file. Use the iam-deployer/template.tfvars as an example. Please find the detailed description of the variables in the iam-deployer/variables.tf file.</p> <p> terraform.tfvars file example <pre><code>aws_profile = \"aws_user\"\n\nregion = \"eu-central-1\"\n\ntags = {\n\"SysName\"      = \"EKS\"\n\"SysOwner\"     = \"owner@example.com\"\n\"Environment\"  = \"EKS-TEST-CLUSTER\"\n\"CostCenter\"   = \"0000\"\n\"BusinessUnit\" = \"BU\"\n\"Department\"   = \"DEPARTMENT\"\n}\n</code></pre> <li> <p>Run the <code>terraform apply</code> command. Then initialize the backend and apply the changes.</p> <p> apply the changes <pre><code>$ terraform init\n$ terraform apply\n...\nDo you want to perform these actions?\nTerraform will perform the actions described above.\nOnly 'yes' will be accepted to approve.\n\nEnter a value: yes\n\naws_iam_role.deployer: Creating...\naws_iam_role.deployer: Creation complete after 4s [id=EKSDeployerRole]\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.\n\nOutputs:\n\ndeployer_iam_role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\"\ndeployer_iam_role_id = \"EKSDeployerRole\"\ndeployer_iam_role_name = \"EKSDeployerRole\"\n</code></pre> <li> <p>Commit the local state. At this run, Terraform will use the local backend to store the state on the local filesystem. Terraform locks that state using system APIs and performs operations locally. It is not mandatory to store the resulted state file in Git, but this option can be used since the file data is not sensitive. Optionally, commit the state of the s3-backend project.</p> <pre><code>$ git add iam-deployer/terraform.tfstate iam-deployer/terraform.tfvars\n$ git commit -m \"Terraform state for IAM deployer role\"\n</code></pre> </li> <ul> <li> <p>Create the AWS IAM role: ServiceRoleForEKSWorkerNode to connect to the EKS cluster. Take the following steps: <ol> <li> <p>Use the local state file or the AWS S3 bucket for saving the state file. The AWS S3 bucket creation is described in the Terraform Backend section.</p> </li> <li> <p>Go to the folder with the <code>iam-workernode</code> role edp-terraform-aws-platform.git, and rename it according to the project name.</p> <p>  go to the iam-workernode folder <pre><code>$ cd edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;/iam-workernode\n</code></pre> <p>where:</p> <ul> <li>\u2039PROJECT_NAME\u203a - is a project name or a unique platform identifier, for example, <code>shared</code> or <code>test-eks</code>.</li> </ul> <li> <p>Fill in the input variables for Terraform run in the \u2039iam-workernode/terraform.tfvars\u203a file, use the iam-workernode/template.tfvars as an example. Please find the detailed description of the variables in the iam-workernode/variables.tf file.</p> <p> terraform.tfvars file example <pre><code>role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\"\n\nplatform_name = \"&lt;PROJECT_NAME&gt;\"\n\niam_permissions_boundary_policy_arn = \"arn:aws:iam::012345678910:policy/some_role_boundary\"\n\nregion = \"eu-central-1\"\n\ntags = {\n\"SysName\"      = \"EKS\"\n\"SysOwner\"     = \"owner@example.com\"\n\"Environment\"  = \"EKS-TEST-CLUSTER\"\n\"CostCenter\"   = \"0000\"\n\"BusinessUnit\" = \"BU\"\n\"Department\"   = \"DEPARTMENT\"\n}\n</code></pre> <li> <p>Run the <code>terraform apply</code> command. Then initialize the backend and apply the changes.</p> <p> apply the changes <pre><code>$ terraform init\n$ terraform apply\n...\nDo you want to perform these actions?\nTerraform will perform the actions described above.\nOnly 'yes' will be accepted to approve.\n\nEnter a value: yes\n</code></pre> <ul> <li> <p>Create the AWS IAM role: ServiceRoleForEKSShared for the EKS cluster. Take the following steps:</p> <ol> <li> <p>Create the AWS IAM role: ServiceRoleForEKSShared</p> </li> <li> <p>Attach the following policies: \"AmazonEKSClusterPolicy\" and \"AmazonEKSServicePolicy\"</p> </li> </ol> </li> </ul> <ul> <li>Configure AWS profile for deployment from the local node. Please, refer to the AWS documentation for detailed guide to configure profiles.</li> </ul> <ul> <li>Create AWS Key pair for EKS cluster nodes access. Please refer to the AWS documentation for detailed guide to create a Key pair.</li> </ul> <ul> <li>Create a public Hosted Zone if there is no any to provide for EKS cluster deployment. Please, refer to the AWS documentation for detailed guide to create a Hosted zone.</li> </ul>"},{"location":"operator-guide/deploy-aws-eks/#terraform-backend","title":"Terraform Backend","text":"<p>The Terraform configuration for EKS cluster deployment has a backend block, which defines where and how the operations are performed, and where the state snapshots are stored. Currently, the best practice is to store the state as a given key in a given bucket on Amazon S3.</p> <p>This backend also supports state locking and consistency checking via Dynamo DB, which can be enabled by setting the <code>dynamodb_table</code> field to an existing DynamoDB table name.</p> <p>In the following configuration a single DynamoDB table can be used to lock multiple remote state files. Terraform generates key names that include the values of the bucket and key variables.</p> <p>In the edp-terraform-aws-platform.git repo an optional project is provided to create initial resources to start using Terraform from the scratch.</p> <p>The provided resources will allow to use the following Terraform options:</p> <ul> <li>to store Terraform states remotely in the Amazon S3 bucket;</li> </ul> <ul> <li>to manage remote state access with S3 bucket policy;</li> </ul> <ul> <li>to support state locking and consistency checking via DynamoDB.</li> </ul> <p>After Terraform run the following AWS resources will be created:</p> <ul> <li>S3 bucket: terraform-states-\u2039AWS_ACCOUNT_ID\u203a</li> </ul> <ul> <li>S3 bucket policy: terraform-states-\u2039AWS_ACCOUNT_ID\u203a</li> </ul> <ul> <li>DynamoDB lock table: terraform_locks</li> </ul> <p>Please, skip this section if you already have the listed resources for further Terraform remote backend usage.</p> <p>To create the required resources, do the following:</p> <ol> <li> <p>Clone git repo with s3-backend project edp-terraform-aws-platform.git, rename it in the correspondence with project name.</p> <p> clone project <pre><code>  $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git\n\n  $ mv edp-terraform-aws-platform tedp-terraform-aws-platform-&lt;PROJECT_NAME&gt;\n\n  $ cd edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;/s3-backend\n</code></pre> <p>where:</p> <p>\u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc.</p> <li> <p>Fill the input variables for Terraform run in the \u2039s3-backend/terraform.tfvars\u203a file, refer to the s3-backend/template.tfvars as an example.</p> <p> terraform.tfvars file example <pre><code>  region = \"eu-central-1\"\n\ns3_states_bucket_name = \"terraform-states\"\n\ntable_name = \"terraform_locks\"\n\ntags = {\n\"SysName\"      = \"EKS\"\n\"SysOwner\"     = \"owner@example.com\"\n\"Environment\"  = \"EKS-TEST-CLUSTER\"\n\"CostCenter\"   = \"0000\"\n\"BusinessUnit\" = \"BU\"\n\"Department\"   = \"DEPARTMENT\"\n}\n</code></pre> <p>Find the detailed description of the variables in the s3-backend/variables.tf file.</p> <li> <p>Run Terraform apply. Initialize the backend and apply the changes.</p> <p> apply the changes <pre><code>  $ terraform init\n$ terraform apply\n...\n  Do you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_dynamodb_table.terraform_lock_table: Creating...\n  aws_s3_bucket.terraform_states: Creating...\n  aws_dynamodb_table.terraform_lock_table: Creation complete after 27s [id=terraform-locks-test]\n  aws_s3_bucket.terraform_states: Creation complete after 1m10s [id=terraform-states-test-012345678910]\n  aws_s3_bucket_policy.terraform_states: Creating...\n  aws_s3_bucket_policy.terraform_states: Creation complete after 1s [id=terraform-states-test-012345678910]\n\n  Apply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\n  Outputs:\n\n  terraform_lock_table_dynamodb_id = \"terraform_locks\"\nterraform_states_s3_bucket_name = \"terraform-states-012345678910\"\n</code></pre> <li> <p>Commit the local state. At this run Terraform will use the local backend to store state on the local filesystem, locks that state using system APIs, and performs operations locally. There is no strong requirements to store the resulted state file in the git, but it's possible at will since there is no sensitive data. On your choice, commit the state of the s3-backend project or not.</p> <pre><code>  $ git add s3-backend/terraform.tfstate\n\n$ git commit -m \"Terraform state for s3-backend\"\n</code></pre> <p>As a result, the projects that run Terraform can use the following definition for remote state configuration:</p> providers.tf - terraform backend configuration block <pre><code>terraform {\n  backend \"s3\" {\n    bucket         = \"terraform-states-&lt;AWS_ACCOUNT_ID&gt;\"\n    key            = \"&lt;PROJECT_NAME&gt;/&lt;REGION&gt;/terraform/terraform.tfstate\"\n    region         = \"&lt;REGION&gt;\"\n    acl            = \"bucket-owner-full-control\"\n    dynamodb_table = \"terraform_locks\"\n    encrypt        = true\n  }\n}\n</code></pre> <p>where:</p> <ul> <li>AWS_ACCOUNT_ID - is AWS account id, e.g. 012345678910,</li> <li>REGION - is AWS region, e.g. eu-central-1,</li> <li>PROJECT_NAME - is a project name, a unique platform identifier, e.g. shared, test-eks etc.</li> </ul> View: providers.tf - terraform backend configuration example <pre><code>terraform {\n  backend \"s3\" {\n    bucket         = \"terraform-states-012345678910\"\n    key            = \"test-eks/eu-central-1/terraform/terraform.tfstate\"\n    region         = \"eu-central-1\"\n    acl            = \"bucket-owner-full-control\"\n    dynamodb_table = \"terraform_locks\"\n    encrypt        = true\n  }\n}\n</code></pre> </li> <p>Note</p> <p>At the moment, it is recommended to use common s3 bucket and Dynamo DB in the root EDP account both for Shared and Standalone clusters deployment.</p>"},{"location":"operator-guide/deploy-aws-eks/#deploy-eks-cluster","title":"Deploy EKS Cluster","text":"<p>To deploy the EKS cluster, make sure that all the above-mentioned Prerequisites are ready to be used.</p>"},{"location":"operator-guide/deploy-aws-eks/#eks-cluster-deployment-with-terraform","title":"EKS Cluster Deployment with Terraform","text":"<ol> <li> <p>Clone git repo with the Terraform project for EKS infrastructure edp-terraform-aws-platform.git and rename it in the correspondence with project name if not yet.</p> <p> clone project <pre><code>  $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git\n  $ mv edp-terraform-aws-platform edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;\n  $ cd edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;\n</code></pre> <p>where:</p> <ul> <li>\u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc.</li> </ul> <li> <p>Configure Terraform backend according to your project needs or use instructions from the Configure Terraform backend section.</p> </li> <li> <p>Fill the input variables for Terraform run in the \u2039terraform.tfvars\u203a file, refer to the template.tfvars file and apply the changes. See details below. Be sure to put the correct values of the variables created in the Prerequisites section. Find the detailed description of the variables in the variables.tf file.</p> <p>Warning</p> <p>Please, do not use upper case in the input variables. It can lead to unexpected issues.</p> template.tfvars file template <pre><code># Check out all the inputs based on the comments below and fill the gaps instead &lt;...&gt;\n  # More details on each variable can be found in the variables.tf file\n\n  create_elb = true # set to true if you'd like to create ELB for Gerrit usage\n\n  region   = \"&lt;REGION&gt;\"\n  role_arn = \"&lt;ROLE_ARN&gt;\"\n\n  platform_name        = \"&lt;PLATFORM_NAME&gt;\"        # the name of the cluster and AWS resources\n  platform_domain_name = \"&lt;PLATFORM_DOMAIN_NAME&gt;\" # must be created as a prerequisite\n\n  # The following will be created or used existing depending on the create_vpc value\n  subnet_azs    = [\"&lt;SUBNET_AZS1&gt;\", \"&lt;SUBNET_AZS2&gt;\"]\n  platform_cidr = \"&lt;PLATFORM_CIDR&gt;\"\n  private_cidrs = [\"&lt;PRIVATE_CIDRS1&gt;\", \"&lt;PRIVATE_CIDRS2&gt;\"]\n  public_cidrs  = [\"&lt;PUBLIC_CIDRS1&gt;\", \"&lt;PUBLIC_CIDRS2&gt;\"]\n\n  infrastructure_public_security_group_ids = [\n    \"&lt;INFRASTRUCTURE_PUBLIC_SECURITY_GROUP_IDS1&gt;\",\n    \"&lt;INFRASTRUCTURE_PUBLIC_SECURITY_GROUP_IDS2&gt;\",\n  ]\n\n  ssl_policy = \"&lt;SSL_POLICY&gt;\"\n\n  # EKS cluster configuration\n  cluster_version = \"1.22\"\n  key_name        = \"&lt;AWS_KEY_PAIR_NAME&gt;\" # must be created as a prerequisite\n  enable_irsa     = true\n\n  cluster_iam_role_name            = \"&lt;SERVICE_ROLE_FOR_EKS&gt;\"\n  worker_iam_instance_profile_name = \"&lt;SERVICE_ROLE_FOR_EKS_WORKER_NODE\"\n\n  add_userdata = &lt;&lt;EOF\n  export TOKEN=$(aws ssm get-parameter --name &lt;PARAMETER_NAME&gt; --query 'Parameter.Value' --region &lt;REGION&gt; --output text)\n  cat &lt;&lt;DATA &gt; /var/lib/kubelet/config.json\n  {\n    \"auths\":{\n      \"https://index.docker.io/v1/\":{\n        \"auth\":\"$TOKEN\"\n      }\n    }\n  }\n  DATA\n  EOF\n\n  map_users = [\n    {\n      \"userarn\" : \"&lt;IAM_USER_ARN1&gt;\",\n      \"username\" : \"&lt;IAM_USER_NAME1&gt;\",\n      \"groups\" : [\"system:masters\"]\n    },\n    {\n      \"userarn\" : \"&lt;IAM_USER_ARN2&gt;\",\n      \"username\" : \"&lt;IAM_USER_NAME2&gt;\",\n      \"groups\" : [\"system:masters\"]\n    }\n  ]\n\n  map_roles = [\n    {\n      \"rolearn\" : \"&lt;IAM_ROLE_ARN1&gt;\",\n      \"username\" : \"&lt;IAM_ROLE_NAME1&gt;\",\n      \"groups\" : [\"system:masters\"]\n    },\n  ]\n\n  tags = {\n    \"SysName\"      = \"&lt;SYS_NAME&gt;\"\n    \"SysOwner\"     = \"&lt;SYSTEM_OWNER&gt;\"\n    \"Environment\"  = \"&lt;ENVIRONMENT&gt;\"\n    \"CostCenter\"   = \"&lt;COST_CENTER&gt;\"\n    \"BusinessUnit\" = \"&lt;BUSINESS_UNIT&gt;\"\n    \"Department\"   = \"&lt;DEPARTMENT&gt;\"\n    \"user:tag\"     = \"&lt;PLATFORM_NAME&gt;\"\n  }\n\n  # Variables for demand pool\n  demand_instance_types      = [\"r5.large\"]\n  demand_max_nodes_count     = 0\n  demand_min_nodes_count     = 0\n  demand_desired_nodes_count = 0\n\n  // Variables for spot pool\n  spot_instance_types      = [\"r5.xlarge\", \"r5.large\", \"r4.large\"] # need to ensure we use nodes with more memory\n  spot_max_nodes_count     = 2\n  spot_desired_nodes_count = 2\n  spot_min_nodes_count     = 2\n</code></pre> <p>Note</p> <p>The file above is an example. Please find the latest version in the project repo in the terraform.tfvars file.</p> <p>There are the following possible scenarios to deploy the EKS cluster:</p> Case 1: Create new VPC and deploy the EKS cluster, terraform.tfvars file example <pre><code>create_elb     = true # set to true if you'd like to create ELB for Gerrit usage\n\nregion   = \"eu-central-1\"\nrole_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\"\n\nplatform_name        = \"test-eks\"\nplatform_domain_name = \"example.com\" # must be created as a prerequisite\n\n# The following will be created or used existing depending on the create_vpc value\nsubnet_azs    = [\"eu-central-1a\", \"eu-central-1b\"]\nplatform_cidr = \"172.31.0.0/16\"\nprivate_cidrs = [\"172.31.0.0/20\", \"172.31.16.0/20\"]\npublic_cidrs  = [\"172.31.32.0/20\", \"172.31.48.0/20\"]\n\n# Use this parameter the second time you apply the code to specify new AWS Security Groups\ninfrastructure_public_security_group_ids = [\n  #  \"sg-00000000000000000\",\n  #  \"sg-00000000000000000\",\n]\n\n# EKS cluster configuration\ncluster_version = \"1.22\"\nkey_name        = \"test-kn\" # must be created as a prerequisite\nenable_irsa     = true\n\n# Define if IAM roles should be created during the deployment or used existing ones\ncluster_iam_role_name            = \"ServiceRoleForEKSShared\"\nworker_iam_instance_profile_name = \"ServiceRoleForEksSharedWorkerNode0000000000000000000000\"\n\nadd_userdata = &lt;&lt;EOF\nexport TOKEN=$(aws ssm get-parameter --name edprobot --query 'Parameter.Value' --region eu-central-1 --output text)\ncat &lt;&lt;DATA &gt; /var/lib/kubelet/config.json\n{\n  \"auths\":{\n    \"https://index.docker.io/v1/\":{\n      \"auth\":\"$TOKEN\"\n    }\n  }\n}\nDATA\nEOF\n\nmap_users = [\n  {\n    \"userarn\" : \"arn:aws:iam::012345678910:user/user_name1@example.com\",\n    \"username\" : \"user_name1@example.com\",\n    \"groups\" : [\"system:masters\"]\n  },\n  {\n    \"userarn\" : \"arn:aws:iam::012345678910:user/user_name2@example.com\",\n    \"username\" : \"user_name2@example.com\",\n    \"groups\" : [\"system:masters\"]\n  }\n]\n\nmap_roles = [\n  {\n    \"rolearn\" : \"arn:aws:iam::012345678910:role/EKSClusterAdminRole\",\n    \"username\" : \"eksadminrole\",\n    \"groups\" : [\"system:masters\"]\n  },\n]\n\ntags = {\n  \"SysName\"      = \"EKS\"\n  \"SysOwner\"     = \"owner@example.com\"\n  \"Environment\"  = \"EKS-TEST-CLUSTER\"\n  \"CostCenter\"   = \"2020\"\n  \"BusinessUnit\" = \"BU\"\n  \"Department\"   = \"DEPARTMENT\"\n  \"user:tag\"     = \"test-eks\"\n}\n\n# Variables for spot pool\nspot_instance_types      = [\"r5.large\", \"r4.large\"] # need to ensure we use nodes with more memory\nspot_max_nodes_count     = 1\nspot_desired_nodes_count = 1\nspot_min_nodes_count     = 1\n</code></pre> </li> <li> <p>Run Terraform apply. Initialize the backend and apply the changes.</p> apply the changes <pre><code>   $ terraform init\n   $ terraform apply\n   ...\n\n   Do you want to perform these actions?\n   Terraform will perform the actions described above.\n   Only 'yes' will be accepted to approve.\n   Enter a value: yes\n   ...\n</code></pre> </li>"},{"location":"operator-guide/deploy-aws-eks/#check-eks-cluster-deployment","title":"Check EKS cluster deployment","text":"<p>As a result, the \u2039PLATFORM_NAME\u203a EKS cluster is deployed to the specified AWS account.</p> <p>Make sure you have all required tools listed in the Install required tools section.</p> <p>To connect to the cluster find the kubeconfig_ file in the project folder which is output of the last Terraform apply run. Move it to the ~/.kube/ folder. <pre><code>    $ mv kubeconfig_&lt;PLATFORM_NAME&gt; ~/.kube/\n</code></pre> <p>Run the following commands to ensure the EKS cluster is up and has required nodes count:</p> <pre><code>    $ kubectl config get-contexts\n    $ kubectl get nodes\n</code></pre> <p>Note</p> <p>If the there are any authorisation issues, make sure the users section in the kubeconfig_ file has all required parameters based on you AWS CLI version. Find more details in the create kubeconfig AWS user guide. And pay attention on the kubeconfig_aws_authenticator terraform input variables. <p>Optionally, a Lens tool can be installed and used for further work with Kubernetes cluster. Refer to the original documentation to add and process the cluster.</p>"},{"location":"operator-guide/deploy-okd-4.10/","title":"Deploy OKD 4.10 Cluster","text":"<p>This instruction provides detailed information on the OKD 4.10 cluster deployment in the AWS Cloud and contains the additional setup necessary for the managed infrastructure.</p> <p>A full description of the cluster deployment can be found in the official documentation.</p>"},{"location":"operator-guide/deploy-okd-4.10/#prerequisites","title":"Prerequisites","text":"<p>Before the OKD cluster deployment and configuration, make sure to check the prerequisites.</p>"},{"location":"operator-guide/deploy-okd-4.10/#required-tools","title":"Required Tools","text":"<ol> <li> <p>Install the following tools listed below:</p> <ul> <li>AWS CLI</li> <li>OpenShift CLI</li> <li>Lens (optional)</li> </ul> </li> <li> <p>Create the AWS IAM user with the required permissions. Make sure the AWS account is active, and the user doesn't have a permission boundary. Remove any Service Control Policy (SCP) restrictions from the AWS account.</p> </li> <li> <p>Generate a key pair for cluster node SSH access. Please perform the steps below:</p> <ul> <li>Generate the SSH key. Specify the path and file name, such as ~/.ssh/id_ed25519, of the new SSH key. If there is an existing key pair, ensure that the public key is in the ~/.ssh directory.<pre><code>ssh-keygen -t ed25519 -N '' -f &lt;path&gt;/&lt;file_name&gt;\n</code></pre> </li> </ul> <ul> <li>Add the SSH private key identity to the SSH agent for a local user if it has not already been added.<pre><code>eval \"$(ssh-agent -s)\"\n</code></pre> </li> </ul> <ul> <li>Add the SSH private key to the ssh-agent:<pre><code>ssh-add &lt;path&gt;/&lt;file_name&gt;\n</code></pre> </li> </ul> </li> <li> <p>Build the <code>ccoctl</code> tool:</p> <ul> <li>Clone the <code>cloud-credential-operator</code> repository.<pre><code>git clone https://github.com/openshift/cloud-credential-operator.git\n</code></pre> </li> </ul> <ul> <li>Move to the <code>cloud-credential-operator</code> folder and build the <code>ccoctl</code> tool.<pre><code>cd cloud-credential-operator &amp;&amp; git checkout release-4.10\nGO_PACKAGE='github.com/openshift/cloud-credential-operator'\ngo build -ldflags \"-X $GO_PACKAGE/pkg/version.versionFromGit=$(git describe --long --tags --abbrev=7 --match 'v[0-9]*')\" ./cmd/ccoctl\n</code></pre> </li> </ul> </li> </ol>"},{"location":"operator-guide/deploy-okd-4.10/#prepare-for-the-deployment-process","title":"Prepare for the Deployment Process","text":"<p>Before deploying the OKD cluster, please perform the steps below:</p>"},{"location":"operator-guide/deploy-okd-4.10/#create-aws-resources","title":"Create AWS Resources","text":"<p>Create the AWS resources with the Cloud Credential Operator utility (the <code>ccoctl</code> tool):</p> <ol> <li> <p>Generate the public and private RSA key files that are used to set up the OpenID Connect identity provider for the cluster:</p> <pre><code>./ccoctl aws create-key-pair\n</code></pre> </li> <li> <p>Create an OpenID Connect identity provider and an S3 bucket on AWS:</p> <pre><code>./ccoctl aws create-identity-provider \\\n--name=&lt;NAME&gt; \\\n--region=&lt;AWS_REGION&gt; \\\n--public-key-file=./serviceaccount-signer.public\n</code></pre> <p>where:</p> <ul> <li>NAME - is the name used to tag any cloud resources created for tracking,</li> <li>AWS_REGION - is the AWS region in which cloud resources will be created.</li> </ul> </li> <li> <p>Create the IAM roles for each component in the cluster:</p> <ul> <li> <p>Extract the list of the <code>CredentialsRequest</code> objects from the OpenShift Container Platform release image:</p> <pre><code>oc adm release extract \\\n--credentials-requests \\\n--cloud=aws \\\n--to=./credrequests \\\n--quay.io/openshift-release-dev/ocp-release:4.10.25-x86_64\n</code></pre> <p>Note</p> <p>A version of the openshift-release-dev docker image can be found in the Quay registry.</p> </li> </ul> <ul> <li>Use the <code>ccoctl</code> tool to process all <code>CredentialsRequest</code> objects in the <code>credrequests</code> directory:<pre><code>ccoctl aws create-iam-roles \\\n--name=&lt;NAME&gt; \\\n--region=&lt;AWS_REGION&gt; \\\n--credentials-requests-dir=./credrequests\n--identity-provider-arn=arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;NAME&gt;-oidc.s3.&lt;AWS_REGION&gt;.amazonaws.com\n</code></pre> </li> </ul> </li> </ol>"},{"location":"operator-guide/deploy-okd-4.10/#create-okd-manifests","title":"Create OKD Manifests","text":"<p>Before deploying the OKD cluster, please perform the steps below:</p> <ol> <li> <p>Download the OKD installer.</p> </li> <li> <p>Extract the installation program:</p> <pre><code>tar -xvf openshift-install-linux.tar.gz\n</code></pre> </li> <li> <p>Download the installation pull secret for any private registry. This pull secret allows to authenticate with the services that are provided by the authorities, including Quay.io, serving the container images for OKD components. For example, here is a pull secret for Docker Hub:</p> The pull secret for the private registry <pre><code>{\n\"auths\":{\n\"https://index.docker.io/v1/\":{\n\"auth\":\"$TOKEN\"\n}\n}\n}\n</code></pre> </li> <li> <p>Create a deployment directory and the install-config.yaml file:</p> <pre><code>mkdir okd-deployment\ntouch okd-deployment/install-config.yaml\n</code></pre> <p>To specify more details about the OKD cluster platform or to modify the values of the required parameters, customize the install-config.yaml file for the AWS. Please see below an example of the customized file:</p> install-config.yaml - OKD cluster\u2019s platform installation configuration file <pre><code>apiVersion: v1\nbaseDomain: &lt;YOUR_DOMAIN&gt;\ncredentialsMode: Manual\ncompute:\n- architecture: amd64\nhyperthreading: Enabled\nname: worker\nplatform:\naws:\nrootVolume:\nsize: 30\nzones:\n- eu-central-1a\ntype: r5.large\nreplicas: 3\ncontrolPlane:\narchitecture: amd64\nhyperthreading: Enabled\nname: master\nplatform:\naws:\nrootVolume:\nsize: 50\nzones:\n- eu-central-1a\ntype: m5.xlarge\nreplicas: 3\nmetadata:\ncreationTimestamp: null\nname: 4-10-okd-sandbox\nnetworking:\nclusterNetwork:\n- cidr: 10.128.0.0/14\nhostPrefix: 23\nmachineNetwork:\n- cidr: 10.0.0.0/16\nnetworkType: OVNKubernetes\nserviceNetwork:\n- 172.30.0.0/16\nplatform:\naws:\nregion: eu-central-1\nuserTags:\nuser:tag: 4-10-okd-sandbox\npublish: External\npullSecret: &lt;PULL_SECRET&gt;\nsshKey: |\n&lt;SSH_KEY&gt;\n</code></pre> <p>where:</p> <ul> <li>YOUR_DOMAIN - is a base domain,</li> <li>PULL_SECRET - is a created pull secret for a private registry,</li> <li>SSH_KEY - is a created SSH key.</li> </ul> </li> <li> <p>Create the required OpenShift Container Platform installation manifests:</p> <pre><code>./openshift-install create manifests --dir okd-deployment\n</code></pre> </li> <li> <p>Copy the manifests generated by the <code>ccoctl</code> tool to the <code>manifests</code> directory created by the installation program:</p> <pre><code>cp ./manifests/* ./okd-deployment/manifests/\n</code></pre> </li> <li> <p>Copy the private key generated in the <code>tls</code> directory by the <code>ccoctl</code> tool to the installation directory:</p> <pre><code>cp -a ./tls ./okd-deployment\n</code></pre> </li> </ol>"},{"location":"operator-guide/deploy-okd-4.10/#deploy-the-cluster","title":"Deploy the Cluster","text":"<p>To initialize the cluster deployment, run the following command:</p> <pre><code>./openshift-install create cluster --dir okd-deployment --log-level=info\n</code></pre> <p>Note</p> <p>If the cloud provider account configured on the host does not have sufficient permissions to deploy the cluster, the installation process stops, and the missing permissions are displayed.</p> <p>When the cluster deployment is completed, directions for accessing the cluster are displayed in the terminal, including a link to the web console and credentials for the kubeadmin user. The <code>kubeconfig</code> for the cluster will be located in okd-deployment/auth/kubeconfig.</p> Example output <pre><code>...\nINFO Install complete!\nINFO To access the cluster as the system:admin user when using 'oc', run 'export KUBECONFIG=/home/myuser/install_dir/auth/kubeconfig'\nINFO Access the OpenShift web-console here: https://console-openshift-console.apps.mycluster.example.com\nINFO Login to the console with the user: \"kubeadmin\", and password: \"4vYBz-Ee6gm-ymBZj-Wt5AL\"\nINFO Time elapsed: 36m22s:\n</code></pre> <p>Warning</p> <p>The Ignition config files contain certificates that expire after 24 hours, which are then renewed at that time. Do not turn off the cluster for this time, or you will have to update the certificates manually. See OpenShift Container Platform documentation for more information.</p>"},{"location":"operator-guide/deploy-okd-4.10/#log-into-the-cluster","title":"Log Into the Cluster","text":"<p>To log into the cluster, export the <code>kubeconfig</code>:</p> <pre><code>  export KUBECONFIG=&lt;installation_directory&gt;/auth/kubeconfig\n</code></pre> <p>Optionally, use the Lens tool for further work with the Kubernetes cluster.</p> <p>Note</p> <p>To install and manage the cluster, refer to Lens documentation.</p>"},{"location":"operator-guide/deploy-okd-4.10/#manage-okd-cluster-without-the-inbound-rules","title":"Manage OKD Cluster Without the Inbound Rules","text":"<p>In order to manage the OKD cluster without the <code>0.0.0.0/0</code> inbound rules, please perform the steps below:</p> <ol> <li> <p>Create a Security Group with a list of your external IPs:</p> <pre><code>aws ec2 create-security-group --group-name &lt;SECURITY_GROUP_NAME&gt; --description \"&lt;DESCRIPTION_OF_SECURITY_GROUP&gt;\" --vpc-id &lt;VPC_ID&gt;\naws ec2 authorize-security-group-ingress \\\n--group-id '&lt;SECURITY_GROUP_ID&gt;' \\\n--ip-permissions 'IpProtocol=all,PrefixListIds=[{PrefixListId=&lt;PREFIX_LIST_ID&gt;}]'\n</code></pre> </li> <li> <p>Manually attach this new Security Group to all master nodes of the cluster.</p> </li> <li> <p>Create another Security Group with an Elastic IP of the Cluster VPC:</p> <pre><code>aws ec2 create-security-group --group-name custom-okd-4-10 --description \"Cluster Ip to 80, 443\" --vpc-id &lt;VPC_ID&gt;\naws ec2 authorize-security-group-ingress \\\n--group-id '&lt;SECURITY_GROUP_ID&gt;' \\\n--protocol all \\\n--port 80 \\\n--cidr &lt;ELASTIC_IP_OF_CLUSTER_VPC&gt;\naws ec2 authorize-security-group-ingress \\\n--group-id '&lt;SECURITY_GROUP_ID&gt;' \\\n--protocol all \\\n--port 443 \\\n--cidr &lt;ELASTIC_IP_OF_CLUSTER_VPC&gt;\n</code></pre> </li> <li> <p>Modify the cluster load balancer via the <code>router-default</code> svc in the <code>openshift-ingress</code> namespace, paste two Security Groups created on previous steps:</p> The pull secret for the private registry <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: router-default\n  namespace: openshift-ingress\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: \"tag_name=some_value\"\n    service.beta.kubernetes.io/aws-load-balancer-security-groups: \"&lt;SECURITY_GROUP_IDs&gt;\"\n    ...\n</code></pre> </li> </ol>"},{"location":"operator-guide/deploy-okd-4.10/#optimize-spot-instances-usage","title":"Optimize Spot Instances Usage","text":"<p>In order to optimize the usage of Spot Instances on the AWS, add the following line under the <code>providerSpec</code> field in the MachineSet of Worker Nodes:</p> <pre><code>providerSpec:\nvalue:\nspotMarketOptions: {}\n</code></pre>"},{"location":"operator-guide/deploy-okd-4.10/#related-articles","title":"Related Articles","text":"<ul> <li>Deploy AWS EKS Cluster</li> <li>Manage Jenkins Agent</li> <li>Associate IAM Roles With Service Accounts</li> <li>Deploy OKD 4.9 Cluster</li> </ul>"},{"location":"operator-guide/deploy-okd/","title":"Deploy OKD 4.9 Cluster","text":"<p>This instruction provides detailed information on the OKD 4.9 cluster deployment in the AWS Cloud and contains the additional setup necessary for the managed infrastructure.</p> <p>A full description of the cluster deployment can be found in the official documentation.</p>"},{"location":"operator-guide/deploy-okd/#prerequisites","title":"Prerequisites","text":"<p>Before the OKD cluster deployment and configuration, make sure to check the prerequisites.</p>"},{"location":"operator-guide/deploy-okd/#required-tools","title":"Required Tools","text":"<ol> <li> <p>Install the following tools listed below:</p> <ul> <li>AWS CLI</li> <li>OpenShift CLI</li> <li>Lens (optional)</li> </ul> </li> <li> <p>Create the AWS IAM user with the required permissions. Make sure the AWS account is active, and the user doesn't have a permission boundary. Remove any Service Control Policy (SCP) restrictions from the AWS account.</p> </li> <li> <p>Generate a key pair for cluster node SSH access. Please perform the steps below:</p> <ul> <li>Generate the SSH key. Specify the path and file name, such as ~/.ssh/id_ed25519, of the new SSH key. If there is an existing key pair, ensure that the public key is in the ~/.ssh directory.<pre><code> ssh-keygen -t ed25519 -N '' -f &lt;path&gt;/&lt;file_name&gt;\n</code></pre> </li> </ul> <ul> <li>Add the SSH private key identity to the SSH agent for a local user if it has not already been added.<pre><code> eval \"$(ssh-agent -s)\"\n</code></pre> </li> </ul> <ul> <li>Add the SSH private key to the ssh-agent:<pre><code> ssh-add &lt;path&gt;/&lt;file_name&gt;\n</code></pre> </li> </ul> </li> </ol>"},{"location":"operator-guide/deploy-okd/#prepare-for-the-deployment-process","title":"Prepare for the Deployment Process","text":"<p>Before deploying the OKD cluster, please perform the steps below:</p> <ol> <li> <p>Download the OKD installer.</p> </li> <li> <p>Extract the installation program:</p> <pre><code>tar -xvf openshift-install-linux.tar.gz\n</code></pre> </li> <li> <p>Download the installation pull secret for any private registry.</p> <p>This pull secret allows to authenticate with the services that are provided by the included authorities, including Quay.io serving container images for OKD components. For example, here is a pull secret for Docker Hub:</p> The pull secret for the private registry <pre><code>{\n  \"auths\":{\n    \"https://index.docker.io/v1/\":{\n      \"auth\":\"$TOKEN\"\n    }\n  }\n}\n</code></pre> </li> <li> <p>Create the deployment directory and the install-config.yaml file:</p> <pre><code>mkdir okd-deployment\ntouch okd-deployment/install-config.yaml\n</code></pre> <p>To specify more details about the OKD cluster platform or to modify the values of the required parameters, customize the install-config.yaml file for AWS. Please see an example of the customized file below:</p> install-config.yaml - OKD cluster\u2019s platform installation configuration file <pre><code>apiVersion: v1\nbaseDomain: &lt;YOUR_DOMAIN&gt;\ncompute:\n- architecture: amd64\n  hyperthreading: Enabled\n  name: worker\n  platform:\n    aws:\n      zones:\n        - eu-central-1a\n      rootVolume:\n        size: 50\n      type: r5.large\n  replicas: 3\ncontrolPlane:\n  architecture: amd64\n  hyperthreading: Enabled\n  name: master\n  platform:\n    aws:\n      rootVolume:\n        size: 50\n      zones:\n        - eu-central-1a\n      type: m5.xlarge\n  replicas: 3\nmetadata:\n  creationTimestamp: null\n  name: 4-9-okd-sandbox\nplatform:\n  aws:\n    region: eu-central-1\n    userTags:\n      user:tag: 4-9-okd-sandbox\npublish: External\npullSecret: &lt;PULL_SECRET&gt;\nsshKey: |\n  &lt;SSH_KEY&gt;\n</code></pre> <p>where:</p> <ul> <li>YOUR_DOMAIN - is a base domain,</li> <li>PULL_SECRET - is a created pull secret for a private registry,</li> <li>SSH_KEY - is a created SSH key.</li> </ul> </li> </ol>"},{"location":"operator-guide/deploy-okd/#deploy-the-cluster","title":"Deploy the Cluster","text":"<p>To initialize the cluster deployment, run the following command:</p> <pre><code>./openshift-install create cluster --dir &lt;installation_directory&gt; --log-level=info\n</code></pre> <p>Note</p> <p>If the cloud provider account configured on the host does not have sufficient permissions to deploy the cluster, the installation process stops, and the missing permissions are displayed.</p> <p>When the cluster deployment is completed, directions for accessing the cluster are displayed in the terminal, including a link to the web console and credentials for the kubeadmin user. The <code>kubeconfig</code> for the cluster will be located in okd-deployment/auth/kubeconfig.</p> Example output <pre><code>...\nINFO Install complete!\nINFO To access the cluster as the system:admin user when using 'oc', run 'export KUBECONFIG=/home/myuser/install_dir/auth/kubeconfig'\nINFO Access the OpenShift web-console here: https://console-openshift-console.apps.mycluster.example.com\nINFO Login to the console with the user: \"kubeadmin\", and password: \"4vYBz-Ee6gm-ymBZj-Wt5AL\"\nINFO Time elapsed: 36m22s:\n</code></pre> <p>Warning</p> <p>The Ignition config files contain certificates that expire after 24 hours, which are then renewed at that time. Do not turn off the cluster for this time, or you will have to update the certificates manually. See OpenShift Container Platform documentation for more information.</p>"},{"location":"operator-guide/deploy-okd/#log-into-the-cluster","title":"Log Into the Cluster","text":"<p>To log into the cluster, export the <code>kubeconfig</code>:</p> <pre><code>  export KUBECONFIG=&lt;installation_directory&gt;/auth/kubeconfig\n</code></pre> <p>Optionally, use the Lens tool for further work with the Kubernetes cluster.</p> <p>Note</p> <p>To install and manage the cluster, refer to Lens documentation.</p>"},{"location":"operator-guide/deploy-okd/#related-articles","title":"Related Articles","text":"<ul> <li>Deploy AWS EKS Cluster</li> <li>Manage Jenkins Agent</li> <li>Deploy OKD 4.10 Cluster</li> </ul>"},{"location":"operator-guide/ebs-csi-driver/","title":"Install Amazon EBS CSI Driver","text":"<p>The Amazon Elastic Block Store (Amazon EBS) Container Storage Interface (CSI) driver allows Amazon Elastic Kubernetes Service (Amazon EKS) clusters to manage the lifecycle of Amazon EBS volumes for Kubernetes Persistent Volumes.</p>"},{"location":"operator-guide/ebs-csi-driver/#prerequisites","title":"Prerequisites","text":"<p>An existing AWS Identity and Access Management (IAM) OpenID Connect (OIDC) provider for your cluster. To determine whether you already have an OIDC provider or to create a new one, see Creating an IAM OIDC provider for your cluster.</p> <p>To add an Amazon EBS CSI add-on, please follow the steps below:</p> <ol> <li> <p>Check your cluster details (the random value in the cluster name will be required in the next step):</p> <pre><code>kubectl cluster-info\n</code></pre> </li> <li> <p>Create Kubernetes IAM Trust Policy for Amazon EBS CSI Driver. Replace <code>AWS_ACCOUNT_ID</code> with your account ID, <code>AWS_REGION</code> with your AWS Region, and <code>EXAMPLED539D4633E53DE1B71EXAMPLE</code> with the value that was returned in the previous step. Save this Trust Policy into a file <code>aws-ebs-csi-driver-trust-policy.json</code>.</p> aws-ebs-csi-driver-trust-policy.json <pre><code>  {\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Principal\": {\n\"Federated\": \"arn:aws:iam::AWS_ACCOUNT_ID:oidc-provider/oidc.eks.AWS_REGION.amazonaws.com/id/EXAMPLED539D4633E53DE1B71EXAMPLE\"\n},\n\"Action\": \"sts:AssumeRoleWithWebIdentity\",\n\"Condition\": {\n\"StringEquals\": {\n\"oidc.eks.AWS_REGION.amazonaws.com/id/EXAMPLED539D4633E53DE1B71EXAMPLE:aud\": \"sts.amazonaws.com\",\n\"oidc.eks.AWS_REGION.amazonaws.com/id/EXAMPLED539D4633E53DE1B71EXAMPLE:sub\": \"system:serviceaccount:kube-system:ebs-csi-controller-sa\"\n}\n}\n}\n]\n}\n</code></pre> <p>To get the notion of the IAM Role creation, please refer to the official documentation.</p> </li> <li> <p>Create the IAM role, for example:</p> <pre><code>aws iam create-role \\\n--role-name AmazonEKS_EBS_CSI_DriverRole \\\n--assume-role-policy-document file://\"aws-ebs-csi-driver-trust-policy.json\"\n</code></pre> </li> <li> <p>Attach the required AWS Managed Policy <code>AmazonEBSCSIDriverPolicy</code> to the role with the following command:</p> <pre><code>aws iam attach-role-policy \\\n--policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy \\\n--role-name AmazonEKS_EBS_CSI_DriverRole\n</code></pre> </li> <li> <p>Add the Amazon EBS CSI add-on using the AWS CLI. Replace <code>my-cluster</code> with the name of your cluster, <code>AWS_ACCOUNT_ID</code> with your account ID, and <code>AmazonEKS_EBS_CSI_DriverRole</code> with the name of the role that was created earlier:</p> <pre><code>aws eks create-addon --cluster-name my-cluster --addon-name aws-ebs-csi-driver \\\n--service-account-role-arn arn:aws:iam::AWS_ACCOUNT_ID:role/AmazonEKS_EBS_CSI_DriverRole\n</code></pre> <p>Note</p> <p>When the plugin is deployed, it creates the <code>ebs-csi-controller-sa</code> service account. The service account is bound to a Kubernetes <code>ClusterRole</code> with the required Kubernetes permissions. The <code>ebs-csi-controller-sa</code> service account should already be annotated with <code>arn:aws:iam::AWS_ACCOUNT_ID:role/AmazonEKS_EBS_CSI_DriverRole</code>. To check the annotation, please run:</p> <pre><code>kubectl get sa ebs-csi-controller-sa -n kube-system -o=jsonpath='{.metadata.annotations}'\n</code></pre> <p>In case pods have errors, restart the <code>ebs-csi-controller</code> deployment:</p> <pre><code>kubectl rollout restart deployment ebs-csi-controller -n kube-system\n</code></pre> </li> </ol>"},{"location":"operator-guide/ebs-csi-driver/#related-articles","title":"Related Articles","text":"<ul> <li>Creating an IAM OIDC provider for your cluster</li> <li>Creating the Amazon EBS CSI driver IAM role for service accounts</li> <li>Managing the Amazon EBS CSI driver as an Amazon EKS add-on</li> </ul>"},{"location":"operator-guide/edp-access-model/","title":"EDP Access Model","text":"<p>EDP uses two different methods to regulate access to resources, each tailored to specific scenarios:</p> <ul> <li>The initial method involves <code>roles</code> and <code>groups</code> in Keycloak and is used for SonarQube, Jenkins and partly for Nexus.</li> </ul> <ul> <li>The second method of resource access control in EDP involves <code>EDP custom resources</code>. This approach requires modifying custom resources that outline the required access privileges for every user or group and is used to govern access to Gerrit, Nexus, Headlamp, EKS Cluster and Argo CD.</li> </ul> <p>Info</p> <p>These two approaches are not interchangeable, as each has its unique capabilities.</p>"},{"location":"operator-guide/edp-access-model/#keycloak","title":"Keycloak","text":"<p>This section explains what realm roles and realm groups are and how they function within Keycloak.</p>"},{"location":"operator-guide/edp-access-model/#realm-roles","title":"Realm Roles","text":"<p>The Keycloak realm of <code>&lt;edp-project&gt;</code> has two realm roles with a composite types named <code>administrator</code> and <code>developer</code>:</p> <ul> <li>The <code>administrator</code> realm role is designed for users who need administrative access to the tools used in the project. This realm role contains two roles: <code>jenkins-administrators</code> and <code>sonar-administrators</code>. Users who are assigned the <code>administrator</code> realm role will be granted these two roles automatically.</li> </ul> <ul> <li>The <code>developer</code> realm role, on the other hand, is designed for users who need access to the development tools used in the project. This realm role also contains two roles: <code>jenkins-users</code> and <code>sonar-developers</code>. Users who are assigned the <code>developer</code> realm role will be granted these two roles automatically.</li> </ul> <p>These realm roles have been defined to make it easier to assign groups of rights to users.</p> <p>The table below shows the realm roles and the composite types they relate to.</p> Realm Role Name Regular Role Composite role administrator developer jenkins-administrators jenkins-users sonar-administrators sonar-developers"},{"location":"operator-guide/edp-access-model/#realm-groups","title":"Realm Groups","text":"<p>EDP uses two different realms for group management, <code>&lt;edp-project&gt;</code> and <code>openshift</code>:</p> <ul> <li>The <code>&lt;edp-project&gt;</code> realm contains two groups that are specifically used for controlling access to Argo CD. These groups are named <code>ArgoCDAdmins</code> and <code>ArgoCD-&lt;edp-project&gt;-users</code>.</li> </ul> <ul> <li>The <code>openshift</code> realm contains five groups that are used for access control in both the Headlamp and EKS cluster. These groups are named <code>&lt;edp-project&gt;-oidc-admins</code>, <code>&lt;edp-project&gt;-oidc-builders</code>, <code>&lt;edp-project&gt;-oidc-deployers</code>,<code>&lt;edp-project&gt;-oidc-developers</code> and <code>&lt;edp-project&gt;-oidc-viewers</code>.</li> </ul> Realm Group Name Realm Name ArgoCDAdmins <code>&lt;edp-project&gt;</code> <code>ArgoCD-&lt;edp-project&gt;-users</code> <code>&lt;edp-project&gt;</code> <code>&lt;edp-project&gt;-oidc-admins</code> openshift <code>&lt;edp-project&gt;-oidc-builders</code> openshift <code>&lt;edp-project&gt;-oidc-deployers</code> openshift <code>&lt;edp-project&gt;-oidc-developers</code> openshift <code>&lt;edp-project&gt;-oidc-viewers</code> openshift"},{"location":"operator-guide/edp-access-model/#sonarqube","title":"SonarQube","text":"<p>In the case of SonarQube, there are two ways to manage access: via Keycloak and via EDP approach. This sections describes both of the approaches.</p>"},{"location":"operator-guide/edp-access-model/#manage-access-via-keycloak","title":"Manage Access via Keycloak","text":"<p>SonarQube access is managed using Keycloak roles in the <code>&lt;edp-project&gt;</code> realm. The <code>sonar-developers</code> and <code>sonar-administrators</code> realm roles are the two available roles that determine user access levels. To grant access, the corresponding role must be added to the user in Keycloak.</p> <p>For example, a user who needs developer access to SonarQube should be assigned the <code>sonar-developers</code> or <code>developer</code> composite role in Keycloak.</p>"},{"location":"operator-guide/edp-access-model/#edp-approach-for-managing-access","title":"EDP Approach for Managing Access","text":"<p>EDP provides its own SonarQube Permission Template, which is used to manage user access and permissions for SonarQube projects.</p> <p>The template is stored in the custom SonarQube resource of the operator, an example of a custom resource can be found below.</p> <p>SonarPermissionTemplate</p> <pre><code>apiVersion: v2.edp.epam.com/v1\nkind: SonarPermissionTemplate\nmetadata:\nname: edp-default\nspec:\ndescription: EDP permission templates (DO NOT REMOVE)\ngroupPermissions:\n- groupName: non-interactive-users\npermissions:\n- user\n- groupName: sonar-administrators\npermissions:\n- admin\n- user\n- groupName: sonar-developers\npermissions:\n- codeviewer\n- issueadmin\n- securityhotspotadmin\n- user\nname: edp-default\nprojectKeyPattern: .+\nsonarOwner: sonar\n</code></pre> <p>The SonarQube Permission Template contains three groups: <code>non-interactive-users</code>, <code>sonar-administrators</code> and <code>sonar-developers</code>:</p> <ul> <li><code>non-interactive-users</code> are users who do not require direct access to the SonarQube project but need to be informed about the project's status and progress. This group has read-only access to the project, which means that they can view the project's data and metrics but cannot modify or interact with it in any way.</li> </ul> <ul> <li><code>sonar-administrators</code> are users who have full control over the SonarQube project. They have the ability to create, modify, and delete projects, as well as manage user access and permissions. This group also has the ability to configure SonarQube settings and perform other administrative tasks.</li> </ul> <ul> <li><code>sonar-developers</code> are users who are actively working on the SonarQube project. They have read and write access to the project, which means that they can modify the project's data and metrics. This group also has the ability to configure project-specific settings and perform other development tasks.</li> </ul> <p>These groups are designed to provide different levels of access to the SonarQube project, depending on the user's role and responsibilities.</p> <p>Info</p> <p>If a user has no group, it will have the <code>sonar-users</code> group by default. This group does not have any permissions in the <code>edp-default</code> Permission Template.</p> <p>The permissions that are attached to each of the groups are described below in the table:</p> Group Name Permissions <code>non-interactive-users</code> user <code>sonar-administrators</code> admin, user <code>sonar-developers</code> codeviewer, issueadmin, securityhotspotadmin, user <code>sonar-users</code> -"},{"location":"operator-guide/edp-access-model/#nexus","title":"Nexus","text":"<p>Users authenticate to Nexus using their Keycloak credentials.</p> <p>During the authentication process, the OAuth2-Proxy receives the user's role from Keycloak.</p> <p>Info</p> <p>Only users with either the <code>administrator</code> or <code>developer</code> role in Keycloak can access Nexus.</p> <p>Nexus has four distinct roles available, including <code>edp-admin</code>, <code>edp-viewer</code>, <code>nx-admin</code> and <code>nx-anonymous</code>. To grant the user access to one or more of these roles, an entry must be added to the custom Nexus resource.</p> <p>For instance, in the context of the custom Nexus resource, the user \"user_1@example.com\" has been assigned the \"nx-admin\" role. An example can be found below:</p> <p>Nexus</p> <pre><code>apiVersion: v2.edp.epam.com/v1\nkind: Nexus\nmetadata:\nname: nexus\nspec:\nbasePath: /\nedpSpec:\ndnsWildcard: example.com\nkeycloakSpec:\nenabled: false\nroles:\n- developer\n- administrator\nusers:\n- roles:\n- nx-admin\nusername: user_1@example.com\n</code></pre>"},{"location":"operator-guide/edp-access-model/#gerrit","title":"Gerrit","text":"<p>The user should use their credentials from Keycloak when authenticating to Gerrit.</p> <p>After logging into Gerrit, the user is not automatically attached to any groups. To add a user to a group, the <code>GerritGroupMember</code> custom resource must be created. This custom resource specifies the user's email address and the name of the group to which they should be added.</p> <p>The ConfigMap below is an example of the <code>GerritGroupMember</code> resource:</p> <p>GerritGroupMember</p> <pre><code>apiVersion: v2.edp.epam.com/v1\nkind: GerritGroupMember\nmetadata:\nname: user-admins\nspec:\naccountId: user@user.com\ngroupId: Administrators\n</code></pre> <p>After the <code>GerritGroupMember</code> resource is created, the user will have the permissions and access levels associated with that group.</p>"},{"location":"operator-guide/edp-access-model/#headlamp-and-eks-cluster","title":"Headlamp and EKS Cluster","text":"<p>Both Headlamp and EKS Cluster use Keycloak groups for controlling access. Users need to be added to the required group in Keycloak to get access. The groups that are used for access control are in the <code>openshift</code> realm.</p> <p>Note</p> <p>The <code>openshift</code> realm is used because a Keycloak client for OIDC is in this realm.</p>"},{"location":"operator-guide/edp-access-model/#keycloak-groups","title":"Keycloak Groups","text":"<p>There are two types of groups provided for users:</p> <ul> <li>Independent group: provides the minimum required permission set.</li> <li>Extension group: extends the rights of an independent group.</li> </ul> <p>For example, the <code>&lt;edp-project&gt;-oidc-viewers</code> group can be extended with rights from the <code>&lt;edp-project&gt;-oidc-builders</code> group.</p> Group Name Independent Group Extension Group <code>&lt;edp-project&gt;-oidc-admins</code> <code>&lt;edp-project&gt;-oidc-developers</code> <code>&lt;edp-project&gt;-oidc-viewers</code> <code>&lt;edp-project&gt;-oidc-builders</code> <code>&lt;edp-project&gt;-oidc-deployers</code> Name Action List View Getting of all namespaced resources Build Starting a PipelineRun from Headlamp UI Deploy Deploying a new version of application via Argo CD Application Group Name View Build Deploy Full Namespace Access <code>&lt;edp-project&gt;-oidc-admins</code> <code>&lt;edp-project&gt;-oidc-developers</code> <code>&lt;edp-project&gt;-oidc-viewers</code> <code>&lt;edp-project&gt;-oidc-builders</code> <code>&lt;edp-project&gt;-oidc-deployers</code>"},{"location":"operator-guide/edp-access-model/#cluster-rbac-resources","title":"Cluster RBAC Resources","text":"<p>The <code>&lt;edp-project&gt;</code> namespace has five role bindings that provide the necessary permissions for the Keycloak groups described above.</p> Role Binding Name Role Name Groups tenant-admin cluster-admin <code>&lt;edp-project&gt;-oidc-admins</code> tenant-builder tenant-builder <code>&lt;edp-project&gt;-oidc-builders</code> tenant-deployer tenant-deployer <code>&lt;edp-project&gt;-oidc-deployers</code> tenant-developer tenant-developer <code>&lt;edp-project&gt;-oidc-developers</code> tenant-viewer view <code>&lt;edp-project&gt;-oidc-viewers</code> , <code>&lt;edp-project&gt;-oidc-developers</code> <p>Note</p> <p>EDP provides an aggregate ClusterRole with permissions to view custom EDP resources. ClusterRole is named <code>edp-aggregate-view-&lt;edp-project&gt;</code></p> <p>Info</p> <p>The <code>tenant-admin</code> RoleBinding will be created in a created namespace by <code>cd-pipeline-operator</code>. <code>tenant-admin</code> RoleBinding assign the <code>admin</code> role to <code>&lt;edp-project&gt;-oidc-admins</code> and <code>&lt;edp-project&gt;-oidc-developers</code> groups.</p>"},{"location":"operator-guide/edp-access-model/#grant-user-access-to-the-created-namespaces","title":"Grant User Access to the Created Namespaces","text":"<p>To provide users with admin or developer privileges for project namespaces, they need to be added to the <code>&lt;edp-project&gt;-oidc-admins</code> and <code>&lt;edp-project&gt;-oidc-developers</code> groups in Keycloak.</p>"},{"location":"operator-guide/edp-access-model/#argo-cd","title":"Argo CD","text":"<p>In Argo CD, groups are specified when creating an AppProject to restrict access to deployed applications. To gain access to deployed applications within a project, the user must be added to their corresponding Argo CD group in Keycloak. This ensures that only authorized users can access and modify applications within the project.</p> <p>Info</p> <p>By default, only the <code>ArgoCDAdmins</code> group is automatically created in Keycloak.</p>"},{"location":"operator-guide/edp-access-model/#related-articles","title":"Related Articles","text":"<ul> <li>Headlamp Overview</li> <li>EKS OIDC With Keycloak</li> <li>Argo CD Integration</li> </ul>"},{"location":"operator-guide/edp-kiosk-usage/","title":"EDP Kiosk Usage","text":"<p>Explore the way Kiosk, a multi-tenancy extension for Kubernetes, is used in EDP.</p>"},{"location":"operator-guide/edp-kiosk-usage/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed Kiosk 0.2.11.</li> </ul>"},{"location":"operator-guide/edp-kiosk-usage/#diagram-of-using-kiosk-by-edp","title":"Diagram of using Kiosk by EDP","text":"<p> Kiosk usage </p> <p>Agenda</p> <ul> <li>blue - created by Helm chart;</li> <li>grey - created manually</li> </ul>"},{"location":"operator-guide/edp-kiosk-usage/#usage","title":"Usage","text":"<ul> <li>EDP installation area on a diagram is described by following link;</li> </ul> <ul> <li>Once the above step is executed, edp-cd-pipeline-operator service account will be linked to kiosk-edit ClusterRole   to get an ability for leveraging Kiosk specific resources (e.g. Space);</li> </ul> <ul> <li>Newly created stage in \u2039edp-project\u203a installation of EDP generates new Kiosk Space resource that is linked to  Kiosk Account; <ul> <li>According to Kiosk doc the Space resource creates namespace with RoleBinding that contains relation between service account   which is linked to Kiosk Account and kiosk-space-admin ClusterRole.   As cd-pipeline-operator ServiceAccount is linked to Account, it has admin permissions in all generated by him namespaces.</li> </ul>"},{"location":"operator-guide/edp-kiosk-usage/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Set Up Kiosk</li> </ul>"},{"location":"operator-guide/eks-oidc-integration/","title":"EKS OIDC Integration","text":"<p>This page is a detailed guide on integrating Keycloak with the edp-keycloak-operator to serve as an identity provider for AWS Elastic Kubernetes Service (EKS). It provides step-by-step instructions for creating necessary realms, users, roles, and client configurations for a seamless Keycloak-EKS collaboration. Additionally, it includes guidelines on installing the edp-keycloak-operator using Helm charts.</p>"},{"location":"operator-guide/eks-oidc-integration/#prerequisites","title":"Prerequisites","text":"<ul> <li>EKS Configuration is performed;</li> <li>Helm v3.10.0 is installed;</li> <li>Keycloak is installed.</li> </ul>"},{"location":"operator-guide/eks-oidc-integration/#configure-keycloak","title":"Configure Keycloak","text":"<p>To prepare Keycloak for integration with the edp-keycloak-operator, follow the steps below:</p> <ol> <li> <p>Ensure that the openshift realm is created.</p> </li> <li> <p>Create the orchestrator user and set the password in the Master realm.</p> </li> <li> <p>In the Role Mapping tab, assign the proper roles to the user:</p> <ul> <li> <p>Realm Roles:</p> <ul> <li>create-realm;</li> </ul> <ul> <li>offline_access;</li> </ul> <ul> <li>uma_authorization.</li> </ul> </li> </ul> <ul> <li> <p>Client Roles <code>openshift-realm</code>:</p> <ul> <li>impersonation;</li> </ul> <ul> <li>manage-authorization;</li> </ul> <ul> <li>manage-clients;</li> </ul> <ul> <li>manage-users.</li> </ul> </li> </ul> </li> </ol> <p> Role mappings </p>"},{"location":"operator-guide/eks-oidc-integration/#install-keycloak-operator","title":"Install Keycloak Operator","text":"<p>To install the Keycloak operator, follow the steps below:</p> <ol> <li> <p>Add the <code>epamedp</code> Helm chart to a local client:</p> <pre><code>helm repo add epamedp https://epam.github.io/edp-helm-charts/stable\nhelm repo update\n</code></pre> </li> <li> <p>Install the Keycloak operator:</p> <pre><code>helm install keycloak-operator epamedp/keycloak-operator --namespace security --set name=keycloak-operator\n</code></pre> </li> </ol>"},{"location":"operator-guide/eks-oidc-integration/#connect-keycloak-operator-to-keycloak","title":"Connect Keycloak Operator to Keycloak","text":"<p>The next stage after installing Keycloak is to integrate it with the Keycloak operator. It can be implemented with the following steps:</p> <ol> <li> <p>Create the keycloak secret that will contain username and password to perform the integration. Set your own password. The username must be orchestrator:</p> <pre><code>kubectl -n security create secret generic keycloak \\\n--from-literal=username=orchestrator \\\n--from-literal=password=&lt;password&gt;\n</code></pre> </li> <li> <p>Create the Keycloak Custom Resource with the Keycloak instance URL and the secret created in the previous step:</p> <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: Keycloak\nmetadata:\nname: main\nnamespace: security\nspec:\nsecret: keycloak                   # Secret name\nurl: https://keycloak.example.com  # Keycloak URL\n</code></pre> </li> <li> <p>Create the KeycloakRealm Custom Resource:</p> <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakRealm\nmetadata:\nname: control-plane\nnamespace: security\nspec:\nrealmName: control-plane\nkeycloakOwner: main\n</code></pre> </li> <li> <p>Create the KeycloakRealmGroup Custom Resource for both administrators and developers:</p> administratorsdevelopers <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakRealmGroup\nmetadata:\nname: administrators\nnamespace: security\nspec:\nrealm: control-plane\nname: eks-oidc-administrator\n</code></pre> <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakRealmGroup\nmetadata:\nname: developers\nnamespace: security\nspec:\nrealm: control-plane\nname: eks-oidc-developers\n</code></pre> </li> <li> <p>Create the KeycloakClientScope Custom Resource:</p> <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakClientScope\nmetadata:\nname: groups-keycloak-eks\nnamespace: security\nspec:\nname: groups\nrealm: control-plane\ndescription: \"Group Membership\"\nprotocol: openid-connect\nprotocolMappers:\n- name: groups\nprotocol: openid-connect\nprotocolMapper: \"oidc-group-membership-mapper\"\nconfig:\n\"access.token.claim\": \"true\"\n\"claim.name\": \"groups\"\n\"full.path\": \"false\"\n\"id.token.claim\": \"true\"\n\"userinfo.token.claim\": \"true\"\n</code></pre> </li> <li> <p>Create the KeycloakClient Custom Resource:</p> <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakClient\nmetadata:\nname: eks\nnamespace: security\nspec:\nadvancedProtocolMappers: true\nclientId: eks\ndirectAccess: true\npublic: false\ndefaultClientScopes:\n- groups\ntargetRealm: control-plane\nwebUrl: \"http://localhost:8000\"\n</code></pre> </li> <li> <p>Create the KeycloakRealmUser Custom Resource for both administrator and developer roles:</p> administrator roledeveloper role <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakRealmUser\nmetadata:\nname: keycloakrealmuser-sample\nnamespace: security\nspec:\nrealm: control-plane\nusername: \"administrator\"\nfirstName: \"John\"\nlastName: \"Snow\"\nemail: \"administrator@example.com\"\nenabled: true\nemailVerified: true\npassword: \"12345678\"\nkeepResource: true\nrequiredUserActions:\n- UPDATE_PASSWORD\ngroups:\n- eks-oidc-administrator\n</code></pre> <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakRealmUser\nmetadata:\nname: keycloakrealmuser-sample\nnamespace: security\nspec:\nrealm: control-plane\nusername: \"developers\"\nfirstName: \"John\"\nlastName: \"Snow\"\nemail: \"developers@example.com\"\nenabled: true\nemailVerified: true\npassword: \"12345678\"\nkeepResource: true\nrequiredUserActions:\n- UPDATE_PASSWORD\ngroups:\n- eks-oidc-developers\n</code></pre> </li> <li> <p>As a result, Keycloak is integrated with the AWS Elastic Kubernetes Service. This integration enables users to log in to the EKS cluster effortlessly using their kubeconfig files while managing permissions through Keycloak.</p> </li> </ol>"},{"location":"operator-guide/eks-oidc-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Keycloak Installation</li> <li>EKS OIDC With Keycloak</li> </ul>"},{"location":"operator-guide/enable-irsa/","title":"Associate IAM Roles With Service Accounts","text":"<p>This page contains accurate information on how to associate an IAM role with the service account (IRSA) in EPAM Delivery Platform.</p> <p>Get acquainted with the AWS Official Documentation on the subject before proceeding.</p>"},{"location":"operator-guide/enable-irsa/#common-configuration-of-iam-roles-with-service-accounts","title":"Common Configuration of IAM Roles With Service Accounts","text":"<p>To successfully associate the IAM role with the service account, follow the steps below:</p> <ol> <li> <p>Create an IAM role that will further be associated with the service account. This role must have the following trust policy:</p> <p>IAM Role</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;OIDC_PROVIDER&gt;\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"&lt;OIDC_PROVIDER&gt;:sub\": \"system:serviceaccount:&lt;SERVICE_ACCOUNT_NAMESPACE&gt;:&lt;SERVICE_ACCOUNT_NAME&gt;\"\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>View cluster's \u2039OIDC_PROVIDER\u203a URL.</p> <pre><code>  aws eks describe-cluster --name &lt;CLUSTER_NAME&gt; --query \"cluster.identity.oidc.issuer\" --output text\n</code></pre> <p>Example output:</p> <pre><code>  https://oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E\n</code></pre> <p>\u2039OIDC_PROVIDER\u203a in this example will be:</p> <pre><code>  oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E\n</code></pre> </li> <li> <p>Deploy the amazon-eks-pod-identity-webhook v0.2.0.</p> <p>Note</p> <p>The amazon-eks-pod-identity-webhook functionality is provided out of the box in EKS v1.21 and higher. This does not apply if the cluster has been upgraded from older versions. Therefore, skip step 2 and continue from step 3 in this documentation.</p> <p>2.1. Provide the stable(ed8c41f) version of the Docker image in the deploy/deployment-base.yaml file.</p> <p>2.2. Provide ${CA_BUNDLE}_in the_deploy/mutatingwebhook.yaml file:</p> <pre><code>  secret_name=$(kubectl -n default get sa default -o jsonpath='{.secrets[0].name}') \\\n  CA_BUNDLE=$(kubectl -n default get secret/$secret_name -o jsonpath='{.data.ca\\.crt}' | tr -d '\\n')\n</code></pre> <p>2.3. Deploy the Webhook:</p> <pre><code>  kubectl apply -f deploy/\n</code></pre> <p>2.4. Approve the csr:</p> <pre><code>  csr_name=$(kubectl get csr -o jsonpath='{.items[?(@.spec.username==\"system:serviceaccount:default:pod-identity-webhook\")].metadata.name}')\n  kubectl certificate approve $csr_name\n</code></pre> </li> <li> <p>Annotate the created service account with the IAM role:</p> <p>Service Account</p> <pre><code>  apiVersion: v1\n  kind: ServiceAccount\n  metadata:\n    name: &lt;SERVICE_ACCOUNT_NAME&gt;\n    namespace: &lt;NAMESPACE&gt;\n    annotations:\n      eks.amazonaws.com/role-arn: \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/&lt;IAM_ROLE_NAME&gt;\"\n</code></pre> </li> <li> <p>All newly launched pods with this service account will be modified and then use the associated IAM role. Find below the pod specification template:</p> <p>Pod Template</p> <pre><code>  apiVersion: v1\n  kind: Pod\n  metadata:\n    name: irsa-test\n    namespace: &lt;POD_NAMESPACE&gt;\n  spec:\n    serviceAccountName: &lt;SERVICE_ACCOUNT_NAME&gt;\n    securityContext:\n      fsGroup: 65534\n    containers:\n    - name: terraform\n      image: epamedp/edp-jenkins-terraform-agent:2.0.4\n      command: ['sh', '-c', 'aws sts \"get-caller-identity\" &amp;&amp; sleep 3600']\n</code></pre> </li> <li> <p>Check the logs of the created pod from the template above.</p> <p>Example output:</p> <pre><code>  {\n  \"UserId\": \"XXXXXXXXXXXXXXXXXXXXX:botocore-session-XXXXXXXXXX\",\n  \"Account\": \"XXXXXXXXXXXX\",\n  \"Arn\": \"arn:aws:sts::XXXXXXXXXXXX:assumed-role/AWSIRSATestRole/botocore-session-XXXXXXXXXX\"\n  }\n</code></pre> <p>As a result, it is possible to perform actions in AWS under the AWSIRSATestRole role.</p> </li> </ol>"},{"location":"operator-guide/enable-irsa/#related-articles","title":"Related Articles","text":"<ul> <li>Use Terraform Library in EDP</li> </ul>"},{"location":"operator-guide/external-secrets-operator-integration/","title":"External Secrets Operator Integration","text":"<p>External Secrets Operator (ESO) can be integrated with EDP.</p> <p>There are multiple Secrets Providers that can be used within ESO. EDP is integrated with two major providers:</p> <ul> <li>Kubernetes Secrets</li> <li>AWS Systems Manager Parameter Store</li> </ul> <p>EDP uses various secrets to integrate various applications. Below is a list of secrets that are used in the EDP platform and their description.</p> Secret Name Field Description keycloak username Admin username for keycloak, used by keycloak operator keycloak password Admin password for keycloak, used by keycloak operator defectdojo-ciuser-token token Defectdojo token with admin permissions defectdojo-ciuser-token url Defectdojo url kaniko-docker-config registry.com Change to registry url kaniko-docker-config username Registry username kaniko-docker-config password Registry password kaniko-docker-config auth Base64 encoded 'user:secret' string regcred registry.com Change to registry url regcred username Registry username regcred password Registry password regcred auth Base64 encoded 'user:secret' string github-config id_rsa Private key from github repo in base64 github-config token Api token github-config secretString Random string gitlab-config id_rsa Private key from gitlab repo in base64 gitlab-config token Api token gitlab-config secretString Random string jira-user username Jira username in base64 jira-user password Jira password in base64 sonar-ciuser-token username Sonar service account username sonar-ciuser-token secret Sonar service account secret nexus-ci-user username Nexus service account username nexus-ci-user password Nexus service accountpassword oauth2-proxy-cookie-secret cookie-secret Secret key for keycloak client in base64 nexus-proxy-cookie-secret cookie-secret Secret key for keycloak client in base64 keycloak-client-headlamp-secret Secret key for keycloak client in base64 keycloak-client-argo-secret Secret key for keycloak client in base64"},{"location":"operator-guide/external-secrets-operator-integration/#kubernetes-provider","title":"Kubernetes Provider","text":"<p>All secrets are stored in Kubernetes in pre-defined namespaces. EDP suggests using the following approach for secrets management:</p> <ul> <li><code>EDP_NAMESPACE-vault</code>, where EDP_NAMESPACE is a name of the namespace where EDP is deployed, such as <code>edp-vault</code>. This namespace is used by EDP platform. Access to secrets in the <code>edp-vault</code> is permitted only for <code>EDP Administrators</code>.</li> </ul> <ul> <li><code>EDP_NAMESPACE-cicd-vault</code>, where EDP_NAMESPACE is a name of the namespace where EDP is deployed, such as <code>edp-cicd-vault</code>. Development team uses access to secrets in the <code>edp-cicd-vault</code>for microservices development.</li> </ul> <p>See a diagram below for more details:</p> <p></p> <p>In order to install EDP, a list of passwords must be created. Secrets are provided automatically when using ESO.</p> <ol> <li> <p>Create a common namespace for secrets and EDP:</p> <pre><code>kubectl create namespace edp-vault\nkubectl create namespace edp\n</code></pre> </li> <li> <p>Create secrets in the <code>edp-vault</code> namespace:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: keycloak\nnamespace: edp-vault\ndata:\npassword: cGFzcw==  # pass in base64\nusername: dXNlcg==  # user in base64\ntype: Opaque\n</code></pre> </li> <li> <p>In the <code>edp-vault</code> namespace, create a Role with a permission to read secrets:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nnamespace: edp-vault\nname: external-secret-store\nrules:\n- apiGroups: [\"\"]\nresources:\n- secrets\nverbs:\n- get\n- list\n- watch\n- apiGroups:\n- authorization.k8s.io\nresources:\n- selfsubjectrulesreviews\nverbs:\n- create\n</code></pre> </li> <li> <p>In the <code>edp-vault</code> namespace, create a ServiceAccount used by <code>SecretStore</code>:</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: secret-manager\nnamespace: edp\n</code></pre> </li> <li> <p>Connect the Role from the <code>edp-vault</code> namespace with the ServiceAccount in the <code>edp</code> namespace:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: eso-from-edp\nnamespace: edp-vault\nsubjects:\n- kind: ServiceAccount\nname: secret-manager\nnamespace: edp\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: Role\nname: external-secret-store\n</code></pre> </li> <li> <p>Create a SecretStore in the <code>edp</code> namespace, and use ServiceAccount for authentication:</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\nname: edp-vault\nnamespace: edp\nspec:\nprovider:\nkubernetes:\nremoteNamespace: edp-vault  # namespace with secrets\nauth:\nserviceAccount:\nname: secret-manager\nserver:\ncaProvider:\ntype: ConfigMap\nname: kube-root-ca.crt\nkey: ca.crt\n</code></pre> </li> <li> <p>Each secret must be defined by the <code>ExternalSecret</code> object. A code example below creates the <code>keycloak</code> secret in the <code>edp</code> namespace based on a secret with the same name in the <code>edp-vault</code> namespace:</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\nname: keycloak\nnamespace: edp\nspec:\nrefreshInterval: 1h\nsecretStoreRef:\nkind: SecretStore\nname: edp-vault\n# target:\n#   name: secret-to-be-created  # name of the k8s Secret to be created. metadata.name used if not defined\ndata:\n- secretKey: username       # key to be created\nremoteRef:\nkey: keycloak           # remote secret name\nproperty: username      # value will be fetched from this field\n- secretKey: password       # key to be created\nremoteRef:\nkey: keycloak           # remote secret name\nproperty: password      # value will be fetched from this field\n</code></pre> </li> </ol> <p>Apply the same approach for enabling secrets management in the namespaces used for microservices development, such as <code>sit</code> and <code>qa</code> on the diagram above.</p>"},{"location":"operator-guide/external-secrets-operator-integration/#aws-systems-manager-parameter-store","title":"AWS Systems Manager Parameter Store","text":"<p>AWS SSM Parameter Store can be used as a Secret Provider for ESO. For EDP, it is recommended to use the IAM Roles For Service Accounts approach (see a diagram below).</p> <p></p>"},{"location":"operator-guide/external-secrets-operator-integration/#aws-parameter-store-in-edp-scenario","title":"AWS Parameter Store in EDP Scenario","text":"<p>In order to install EDP, a list of passwords must be created. Follow the steps below, to get secrets from the SSM:</p> <ol> <li> <p>In the AWS, create an AWS IAM policy and an IAM role used by <code>ServiceAccount</code> in <code>SecretStore</code>. The IAM role must have permissions to get values from the SSM Parameter Store.</p> <p>a. Create an IAM policy that allows to get values from the Parameter Store with the <code>edp/</code> path. Use your <code>AWS Region</code> and <code>AWS Account Id</code>:</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Sid\": \"VisualEditor0\",\n\"Effect\": \"Allow\",\n\"Action\": \"ssm:GetParameter*\",\n\"Resource\": \"arn:aws:ssm:eu-central-1:012345678910:parameter/edp/*\"\n}\n]\n}\n</code></pre> <p>b. Create an AWS IAM role with trust relationships (defined below) and attach the IAM policy. Put your string for <code>Federated</code> value (see more on IRSA enablement for EKS Cluster) and AWS region.</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Principal\": {\n\"Federated\": \"arn:aws:iam::012345678910:oidc-provider/oidc.eks.eu-central-1.amazonaws.com/id/XXXXXXXXXXXXXXXXXX\"\n},\n\"Action\": \"sts:AssumeRoleWithWebIdentity\",\n\"Condition\": {\n\"StringLike\": {\n\"oidc.eks.eu-central-1.amazonaws.com/id/XXXXXXXXXXXXXXXXXX:sub\": \"system:serviceaccount:edp:*\"\n}\n}\n}\n]\n}\n</code></pre> </li> <li> <p>Create a secret in the AWS Parameter Store with the name <code>/edp/my-json-secret</code>. This secret is represented as a parameter of type string within the AWS Parameter Store:</p> View: Parameter Store JSON <pre><code>{\n\"keycloak\":\n{\n\"username\": \"keycloak-username\",\n\"password\": \"keycloak-password\"\n},\n\"defectdojo-ciuser-token\":\n{\n\"token\": \"XXXXXXXXXXXX\",\n\"url\": \"https://defectdojo.example.com\"\n},\n\"kaniko-docker-config\":\n{\n\"auths\" :\n{\n\"registry.com\":\n{\n\"username\":\"registry-username\",\n\"password\":\"registry-password\",\n\"auth\": \"&lt;base64 encoded 'user:secret' string&gt;\"\n}\n}},\n\"regcred\":\n{\n\"auths\":\n{\n\"registry.com\":\n{\n\"username\":\"registry-username\",\n\"password\":\"registry-password\",\n\"auth\":\"&lt;base64 encoded 'user:secret' string&gt;\"\n}\n}},\n\"github-config\":\n{\n\"id_rsa\": \"id-rsa-key\",\n\"token\": \"github-token\",\n\"secretString\": \"XXXXXXXXXXXX\"\n},\n\"gitlab-config\":\n{\n\"id_rsa\": \"id-rsa-key\",\n\"token\": \"gitlab-token\",\n\"secretString\": \"XXXXXXXXXXXX\"\n},\n\"jira-user\":\n{\n\"username\": \"jira-username\",\n\"password\": \"jira-password\"\n},\n\"sonar-ciuser-token\": { \"username\": \"&lt;ci-user&gt;\",  \"secret\": \"&lt;secret&gt;\" },\n\"nexus-ci-user\": { \"username\": \"&lt;ci.user&gt;\",  \"password\": \"&lt;secret&gt;\" },\n\"oauth2-proxy-cookie-secret\": { \"cookie-secret\": \"XXXXXXXXXXXX\" },\n\"nexus-proxy-cookie-secret\": { \"cookie-secret\": \"XXXXXXXXXXXX\" },\n\"keycloak-client-headlamp-secret\":  \"XXXXXXXXXXXX\",\n\"keycloak-client-argo-secret\":  \"XXXXXXXXXXXX\"\n}\n</code></pre> </li> <li> <p>Set External Secret operator enabled by updating the values.yaml file:</p> EDP install values.yaml<pre><code>externalSecrets:\nenabled: true\n</code></pre> </li> <li> <p>Install/upgrade edp-install:</p> <pre><code>helm upgrade --install edp epamedp/edp-install --wait --timeout=900s \\\n--version &lt;edp_version&gt; \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt; \\\n--atomic\n</code></pre> </li> </ol>"},{"location":"operator-guide/external-secrets-operator-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Install External Secrets Operator</li> </ul>"},{"location":"operator-guide/github-debug-webhooks/","title":"Debug GitHub Webhooks in Jenkins","text":"<p>A webhook enables third-party services like GitHub to send real-time updates to an application. Updates are triggered by an event or an action by the webhook provider (for example, a push to a repository, a Pull Request creation), and pushed to the application via HTTP requests, namely, Jenkins. The GitHub Jenkins job provisioner creates a webhook in the GitHub repository during the Create release pipeline once the Integrate GitHub/GitLab in Jenkins is enabled and the GitHub Webhook Configuration is completed.</p> <p>The Jenkins setup in EDP uses the following plugins responsible for listening on GitHub webhooks:</p> <ul> <li>GitHub plugin is configured to listen on Push events.</li> </ul> <ul> <li>GitHub Pull Request Builder is configured to listen on Pull Request events.</li> </ul> <p>In case of any issues with webhooks, try the following solutions:</p> <ol> <li> <p>Check that the firewalls are configured to accept the incoming traffic from the IP address range that is described in the GitHub documentation.</p> </li> <li> <p>Check that GitHub Personal Access Token is correct and has sufficient scope permissions.</p> </li> <li> <p>Check that the job has run at least once before using the hook (once an application is created in EDP, the build job should be run automatically in Jenkins).</p> </li> <li> <p>Check that both Push and issue comment and Pull Request webhooks are created on the GitHub side (unlike GitLab, GitHub does not need separate webhooks for each branch):</p> <ul> <li>Go to the GitHub repository -&gt; Settings -&gt; Webhooks.</li> </ul> <p> Webhooks settings </p> </li> <li> <p>Click each webhook and check if the event delivery is successful:</p> <ul> <li>The URL payload must be <code>https://jenkins-the-host.com/github-webhook/</code> for the GitHub plugin and <code>https://jenkins-the-host.com/ghprbhook/</code> for the GitHub Pull Request Builder.</li> <li>The content type must be application/json for Push events and application/x-www-form-urlencoded for Pull Request events.</li> <li>The html_url in the Payload request must match the repository URL and be without .git at the end of the URL.</li> </ul> </li> <li> <p>Check that the X-Hub-Signature secret is verified. It is provided by the Jenkins GitHub plugin for Push events and by the GitHub Pull Request Builder plugin for Pull Request events. The Secret field is optional. Nevertheless, if incorrect, it can prevent webhook events.</p> <p>For the GitHub plugin (Push events):</p> <ul> <li>Go to Jenkins -&gt; Manage Jenkins -&gt; Configure System, and find the GitHub plugin section.</li> <li>Select Advanced -&gt; Shared secrets to add the secret via the Jenkins Credentials Provider.</li> </ul> <p>For the GitHub Pull Request Builder (Pull Request events):</p> <ul> <li>Go to Jenkins -&gt; Manage Jenkins -&gt; Configure System, and find the GitHub Pull Request Builder plugin section.</li> <li>Check Shared secret that can be added manually.</li> </ul> </li> <li> <p>Redeliver events by clicking the Redeliver button and check the Response body.</p> <p> Manage webhook </p> <p>Note</p> <p>Use Postman to debug webhooks. Add all headers to Postman from the webhook Request -&gt; Headers field and send the payload (Request body) using the appropriate content type.</p> <p>Examples for Push and Pull Request events:</p> <p> Postman push event payload headers GitHub plugin push events </p> <p>The response in the Jenkins log:</p> <pre><code>Jan 17, 2022 8:51:14 AM INFO org.jenkinsci.plugins.github.webhook.subscriber.PingGHEventSubscriber onEvent\nPING webhook received from repo &lt;https://github.com/user-profile/user-repo&gt;!\n</code></pre> <p> Postman pull request event payload headers GitHub pull request builder </p> <p>The response in the Jenkins log:</p> <pre><code>Jan 17, 2022 8:17:53 AM FINE org.jenkinsci.plugins.ghprb.GhprbRootAction\nGot payload event: ping\n</code></pre> </li> <li> <p>Check that the repo pushing to Jenkins, the GitHub project URL in the project configuration, and the repos in the pipeline Job must be lined up.</p> </li> <li> <p>Enable the GitHub hook trigger for GITScm polling for the Build job.</p> <p> GitHub hook trigger </p> </li> <li> <p>Enable the GitHub Pull Request Builder for the Code Review job.</p> <p> GitHub pull request builder </p> </li> <li> <p>Filter through Jenkins log by using Jenkins custom log recorder:</p> <ul> <li>Go to Manage Jenkins -&gt; System log -&gt; Add new log recorder.</li> <li> <p>The Push events for the GitHub:</p> Logger Log Level org.jenkinsci.plugins.github.webhook.subscriber.DefaultPushGHEventSubscriber ALL com.cloudbees.jenkins.GitHubPushTrigger ALL com.cloudbees.jenkins.GitHubWebHook ALL org.jenkinsci.plugins.github.webhook.WebhookManager ALL org.jenkinsci.plugins.github.webhook.subscriber.PingGHEventSubscriber ALL </li> </ul> <ul> <li> <p>The Pull Request events for the GitHub Pull Request Builder:</p> Logger Log Level org.jenkinsci.plugins.ghprb.GhprbRootAction ALL org.jenkinsci.plugins.ghprb.GhprbTrigger ALL org.jenkinsci.plugins.ghprb.GhprbPullRequest ALL org.jenkinsci.plugins.ghprb.GhprbRepository ALL </li> </ul> <p>Note</p> <p>Below is an example of using the Pipeline script with webhooks for the GitHub plugin implemented in the EDP pipelines:</p> <pre><code>properties([pipelineTriggers([githubPush()])])\n\nnode {\n    git credentialsId: 'github-sshkey', url: 'https://github.com/someone/something.git', branch: 'master'\n}\n</code></pre> <p>Push events may not work correctly with the Job Pipeline script from SCM option in the current version of the GitHub plugin 1.34.1.</p> </li> </ol>"},{"location":"operator-guide/github-debug-webhooks/#related-articles","title":"Related Articles","text":"<ul> <li>GitHub Webhooks</li> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> <li>GitHub Webhook Configuration</li> <li>Manage Jenkins CI Pipeline Job Provision</li> <li>GitHub Plugin</li> <li>GitHub Pull Request Builder</li> </ul>"},{"location":"operator-guide/github-integration/","title":"GitHub Webhook Configuration","text":"<p>Follow the steps below to automatically integrate Jenkins with GitHub webhooks.</p> <p>Note</p> <p>Before applying the GitHub integration, make sure you have already visited the Integrate GitHub/GitLab in Jenkins page.</p> <ol> <li> <p>Ensure the new job provisioner is created, as well as Secret with SSH key and GitServer custom resources.</p> </li> <li> <p>Ensure the access token for GitHub is created.</p> </li> <li> <p>Navigate to Dashboard -&gt; Manage Jenkins -&gt; Manage Credentials -&gt; Global -&gt; Add Credentials, and create new credentials with the Secret text kind. In the Secret field, provide the GitHub API token, fill in the ID field with the <code>github-access-token</code> value:</p> <p> Jenkins github credentials </p> </li> <li> <p>Navigate to Jenkins -&gt; Manage Jenkins -&gt; Configure system -&gt; GitHub, and configure the GitHub server:</p> <p> GitHub plugin config GitHub plugin Shared secrets config </p> <p>Note</p> <p>Keep the Manage hooks checkbox clear since the Job Provisioner automatically creates webhooks in the repository regardless of the checkbox selection. Select Advanced to see the shared secrets that can be used in a webhook Secret field to authenticate payloads from GitHub to Jenkins. The Secret field is optional.</p> </li> <li> <p>Configure the GitHub Pull Request Builder plugin. This plugin is responsible for listening on Pull Request webhook events and triggering Code Review jobs:</p> <p>Note</p> <p>The Secret field is optional and is used in a webhook Secret field to authenticate payloads from GitHub to Jenkins. For details, please refer to the official GitHub pull request builder plugin documentation.</p> <p> GitHub pull plugin config </p> </li> </ol>"},{"location":"operator-guide/github-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> <li>Adjust Jira Integration</li> <li>Manage Jenkins CI Pipeline Job Provision</li> </ul>"},{"location":"operator-guide/gitlab-debug-webhooks/","title":"Debug GitLab Webhooks in Jenkins","text":"<p>A webhook enables third-party services like GitLab to send real-time updates to the application. Updates are triggered by an event or action by the webhook provider (for example, a push to a repository, a Merge Request creation), and pushed to the application via the HTTP requests, namely, Jenkins. The GitLab Jenkins job provisioner creates a webhook in the GitLab repository during the Create release pipeline once the Integrate GitHub/GitLab in Jenkins is enabled and the GitLab Integration is completed.</p> <p>The Jenkins setup in EDP uses the GitLab plugin responsible for listening on GitLab webhook Push and Merge Request events.</p> <p>In case of any issues with webhooks, try the following solutions:</p> <ol> <li> <p>Check that the firewalls are configured to accept incoming traffic from the IP address range that is described in the GitLab documentation.</p> </li> <li> <p>Check that GitLab Personal Access Token is correct and has the api scope. If you have used the Project Access Token, make sure that the role is Owner or Maintainer, and it has the api scope.</p> </li> <li> <p>Check that the job has run at least once before using the hook (once an application is created in EDP, the build job should be run automatically in Jenkins).</p> </li> <li> <p>Check that both Push Events, Note Events and Merge Requests Events, Note Events webhooks are created on the GitLab side for each branch (unlike GitHub, GitLab must have separate webhooks for each branch).</p> <ul> <li>Go to the GitLab repository -&gt; Settings -&gt; Webhooks:</li> </ul> <p> Webhooks list </p> </li> <li> <p>Click Edit next to each webhook and check if the event delivery is successful. If the webhook is sent, the Recent Deliveries list becomes available. Click View details.</p> <p> Webhooks settings </p> <ul> <li>The URL payload must be similar to the job URL on Jenkins. For example: <code>https://jenkins-server.com/project/project-name/MAIN-Build-job</code> is for the Push events. <code>https://jenkins-server.com/project/project-name/MAIN-Code-review-job</code> is for the Merge Request events.</li> <li>The content type must be application/json for both events.</li> <li>The \"web_url\" in the Request body must match the repository URL.</li> <li>Project \"web_url\", \"path_with_namespace\", \"homepage\" links must be without .git at the end of the URL.</li> </ul> </li> <li> <p>Verify the Secret token (X-Gitlab-Token). This token comes from the Jenkins job due to the Jenkins GitLab Plugin and is created by our Job Provisioner:</p> <ul> <li>Go to the Jenkins job and select Configure.</li> <li>Select Advanced under the Build Triggers and check the Secret token.</li> </ul> <p>Secret token is optional and can be empty. Nevertheless, if incorrect, it can prevent webhook events.</p> </li> <li> <p>Redeliver events by clicking the Resend Request button and check the Response body.</p> <p>Note</p> <p>Use Postman to debug webhooks. Add all headers to Postman from the webhook Request Headers field and send the payload (Request body) using the appropriate content type.</p> <p>Examples for Push and Merge Request events:</p> <p> Postman push request payload headers Push request build pipeline </p> <p>The response in the Jenkins log:</p> <pre><code>Jan 17, 2022 11:26:34 AM INFO com.dabsquared.gitlabjenkins.webhook.GitLabWebHook getDynamic\nWebHook call ed with url: /project/project-name/MAIN-Build-job\nJan 17, 2022 11:26:34 AM INFO com.dabsquared.gitlabjenkins.trigger.handler.AbstractWebHookTriggerHandler handle\nproject-name/MAIN-Build-job triggered for push.\n</code></pre> <p> Postman merge request payload headers Merge request code review pipeline </p> <p>The response in the Jenkins log:</p> <pre><code>Jan 17, 2022 11:14:58 AM INFO com.dabsquared.gitlabjenkins.webhook.GitLabWebHook getDynamic\nWebHook called with url: /project/project-name/MAIN-Code-review-job\n</code></pre> </li> <li> <p>Check that the repository pushing to Jenkins and the repository(ies) in the pipeline Job are lined up. GitLab Connection must be defined in the job settings.</p> </li> <li> <p>Check that the settings in the Build Triggers for the Build job are as follows:</p> <p> Build triggers build pipeline </p> </li> <li> <p>Check that the settings in the Build Triggers for the Code Review job are as follows:</p> <p> Build triggers code review pipeline </p> </li> <li> <p>Filter through Jenkins log by using Jenkins custom log recorder:</p> <ul> <li>Go to Manage Jenkins -&gt; System Log -&gt; Add new log recorder.</li> <li> <p>The Push and Merge Request events for the GitLab:</p> Logger Log Level com.dabsquared.gitlabjenkins.webhook.GitLabWebHook ALL com.dabsquared.gitlabjenkins.trigger.handler.AbstractWebHookTriggerHandler ALL com.dabsquared.gitlabjenkins.trigger.handler.merge.MergeRequestHookTriggerHandlerImpl ALL com.dabsquared.gitlabjenkins.util.CommitStatusUpdater ALL </li> </ul> </li> </ol>"},{"location":"operator-guide/gitlab-debug-webhooks/#related-articles","title":"Related Articles","text":"<ul> <li>GitLab Webhooks</li> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> <li>Jenkins Integration With GitLab</li> <li>GitLab Integration</li> <li>Manage Jenkins CI Pipeline Job Provision</li> <li>GitLab Plugin</li> </ul>"},{"location":"operator-guide/gitlab-integration/","title":"GitLab Webhook Configuration","text":"<p>Follow the steps below to automatically create and integrate Jenkins GitLab webhooks.</p> <p>Note</p> <p>Before applying the GitLab integration, make sure to enable Integrate GitHub/GitLab in Jenkins. For details, please refer to the Integrate GitHub/GitLab in Jenkins page.</p> <ol> <li> <p>Ensure the new job provisioner is created, as well as Secret with SSH key and GitServer custom resources.</p> </li> <li> <p>Ensure the access token for GitLab is created.</p> </li> <li> <p>Create the Jenkins Credential ID by navigating to Dashboard -&gt; Manage Jenkins -&gt; Manage Credentials -&gt; Global -&gt; Add Credentials:</p> <ul> <li>Select the Secret text kind.</li> <li>Select the Global scope.</li> <li>Secret is the access token that was created earlier.</li> <li>ID is the gitlab-access-token ID.</li> <li>Use the description of the current Credential ID.</li> </ul> <p> Jenkins credential </p> <p>Warning</p> <p>When using the GitLab integration, a webhook is automatically created. After the removal of the application, the webhook stops working but is not deleted. If necessary, it must be deleted manually.</p> <p>Note</p> <p>The next step is necessary if it is needed to see the status of Jenkins Merge Requests builds in the GitLab CI/CD Pipelines section.</p> </li> <li> <p>In order to see the status of Jenkins Merge Requests builds in the GitLab CI/CD Pipelines section, configure the    GitLab plugin by navigating to Manage Jenkins -&gt; Configure System and filling in the GitLab plugin settings:</p> <ul> <li>Connection name is gitlab.</li> <li>GitLab host URL is a host URL to GitLab.</li> <li>Use the gitlab-access-token credentials.</li> </ul> <p> GitLab plugin configuration </p> <p>Find below an example of the Merge Requests build statuses in the GitLab CI/CD Pipelines section:</p> <p> GitLab pipelines statuses </p> </li> </ol>"},{"location":"operator-guide/gitlab-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Adjust Jira Integration</li> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> <li>Grant Jenkins Access to the Gitlab Project</li> <li>Manage Jenkins CI Pipeline Job Provision</li> </ul>"},{"location":"operator-guide/gitlabci-integration/","title":"Adjust GitLab CI Tool","text":"<p>EDP allows selecting one of two available CI (Continuous Integration) tools, namely: Jenkins or GitLab. The Jenkins tool is available by default. To use the GitLab CI tool, it is required to make it available first.</p> <p>Follow the steps below to adjust the GitLab CI tool:</p> <ol> <li> <p>In GitLab, add the environment variables to the project.</p> <ul> <li> <p>To add variables, navigate to Settings -&gt; CI/CD -&gt; Expand Variables -&gt; Add Variable:</p> <p> Gitlab ci environment variables </p> </li> </ul> <ul> <li> <p>Apply the necessary variables as they differ in accordance with the cluster OpenShift / Kubernetes, see below:</p> OpenShift Environment Variables Description DOCKER_REGISTRY_URL URL to OpenShift docker registry DOCKER_REGISTRY_PASSWORD Service Account token that has an access to registry DOCKER_REGISTRY_USER user name OPENSHIFT_SA_TOKEN token that can be used to log in to OpenShift <p>Info</p> <p>In order to get access to the Docker registry and OpenShift, use the gitlab-ci ServiceAccount; pay attention that SA description contains the credentials and secrets:</p> <p> Service account </p> Kubernetes Environment Variables Description DOCKER_REGISTRY_URL URL to Amazon ECR AWS_ACCESS_KEY_ID auto IAM user access key AWS_SECRET_ACCESS_KEY auto IAM user secret access key K8S_SA_TOKEN token that can be used to log in to Kubernetes <p>Note</p> <p>To get the access to ECR, it is required to have an auto IAM user that has rights to push/create a repository.</p> </li> </ul> </li> <li> <p>In Admin Console, select the CI tool in the Advanced Settings menu during the codebase creation:</p> <p> Advanced settings </p> <p>Note</p> <p>The selection of the CI tool is available only with the Import strategy.</p> </li> <li> <p>As soon as the codebase is provisioned, the .gitlab-ci.yml file will be created in the repository that describes the pipeline's stages and logic:</p> <p> .gitlab-ci.yml file presented in repository </p> </li> </ol>"},{"location":"operator-guide/harbor-oidc/","title":"Harbor OIDC Configuration","text":"<p>This page provides instructions for configuring OIDC authorization for Harbor. This enables the use of Single Sign-On (SSO) for authorization in Harbor and allows centralized control over user access and rights through a single configuration point.</p>"},{"location":"operator-guide/harbor-oidc/#prerequisites","title":"Prerequisites","text":"<p>Before the beginning, ensure your cluster meets the following requirements:</p> <ul> <li>Keycloak is installed;</li> <li>EPAM Delivery Platform is installed.</li> </ul>"},{"location":"operator-guide/harbor-oidc/#configure-keycloak","title":"Configure Keycloak","text":"<p>To start from, configure Keycloak by creating two Kubernetes resources. Follow the steps below to succeed:</p> <ol> <li> <p>Generate the keycloak-client-harbor-secret for Keycloak using either the commands below or using the External Secrets Operator:</p> <pre><code>keycloak_client_harbor_secret=$(openssl rand -base64 32 | head -c 32)\n</code></pre> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic keycloak-client-harbor-secret \\\n--from-literal=cookie-secret=${keycloak_client_harbor_secret}\n</code></pre> </li> <li> <p>Create the KeycloakClient custom resource by applying the HarborKeycloakClient.yaml file in the  namespace. This custom resource will use the <code>keycloak-client-harbor-secret</code> to include the harbor client. After the download, you will receive the created harbor client, and the password that is actually the value of the Kubernetes secret from the step 1: View: HarborKeycloakClient.yaml <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakClient\nmetadata:\nname: harbor\nspec:\nadvancedProtocolMappers: true\nclientId: harbor\ndirectAccess: true\npublic: false\nsecret: keycloak-client-harbor-secret\ndefaultClientScopes:\n- profile\n- email\n- roles\ntargetRealm: control-plane\nwebUrl: &lt;harbor_endpoint&gt;\nprotocolMappers:\n- name: roles\nprotocol: openid-connect\nprotocolMapper: oidc-usermodel-realm-role-mapper\nconfig:\naccess.token.claim: true\nclaim.name: roles\nid.token.claim: true\nuserinfo.token.claim: true\nmultivalued: true\n</code></pre>"},{"location":"operator-guide/harbor-oidc/#configure-harbor","title":"Configure Harbor","text":"<p>The next stage is to configure Harbor. Proceed with following the steps below:</p> <ol> <li> <p>Log in to Harbor UI with an account that has Harbor system administrator privileges. To get the administrator password, execute the command below:</p> <pre><code>kubectl get secret harbor -n harbor -o jsonpath='{.data.HARBOR_ADMIN_PASSWORD}' | base64 --decode\n</code></pre> </li> <li> <p>Navigate to Administration -&gt; Configuration -&gt; Authentication. Configure OIDC using the parameters below:</p> <pre><code>auth_mode: oidc_auth\noidc_name: keycloak\noidc_endpoint: &lt;keycloak_endpoint&gt;/auth/realms/control-plane\noidc_client_id: harbor\noidc_client_secret: &lt;keycloak-client-harbor-secret&gt;\noidc_groups_claim: roles\noidc_admin_group: administrator\noidc_scope: openid,email,profile,roles\nverify_certificate: true\noidc_auto_onboard: true\noidc_user_claim: preferred_username\n</code></pre> <p> Harbor Authentication Configuration </p> </li> </ol> <p>As a result, users will be prompted to authenticate themselves when logging in to Harbor UI.</p>"},{"location":"operator-guide/harbor-oidc/#related-articles","title":"Related Articles","text":"<ul> <li>Configure Access Token Lifetime</li> <li>EKS OIDC With Keycloak</li> <li>External Secrets Operator Integration</li> <li>Integrate Harbor With EDP Pipelines</li> </ul>"},{"location":"operator-guide/headlamp-oidc/","title":"Headlamp OIDC Configuration","text":"<p>This page provides the instructions of configuring the OIDC authorization for EDP Headlamp UI, thus allowing using SSO for authorization in Headlamp and controlling user access and rights from one configuration point.</p>"},{"location":"operator-guide/headlamp-oidc/#prerequisites","title":"Prerequisites","text":"<p>Ensure the following values are set first before starting the Headlamp OIDC configuration:</p> <ol> <li> <p><code>realm_id</code>  = openshift</p> </li> <li> <p><code>client_id</code> = kubernetes</p> </li> <li> <p><code>keycloak_client_key</code>= keycloak_client_secret_key (received from: <code>Openshift realm</code> -&gt; <code>clients</code> -&gt; <code>kubernetes</code> -&gt; <code>Credentials</code> -&gt; <code>Client secret</code>)</p> </li> <li> <p><code>group</code> = <code>&lt;edp-project&gt;-oidc-admins</code>, <code>&lt;edp-project&gt;-oidc-builders</code>, <code>&lt;edp-project&gt;-oidc-deployers</code>,  <code>&lt;edp-project&gt;-oidc-developers</code>, <code>&lt;edp-project&gt;-oidc-viewers</code> (Should be created manually in the realm from point 1)</p> </li> </ol> <p>Note</p> <p>The values indicated above are the result of the Keycloak configuration as an OIDC identity provider. To receive them, follow the instructions on the Keycloak OIDC EKS Configuration page.</p>"},{"location":"operator-guide/headlamp-oidc/#configure-keycloak","title":"Configure Keycloak","text":"<p>To proceed with the Keycloak configuration, perform the following:</p> <ol> <li> <p>Add the URL of the Headlamp to the <code>valid_redirect_uris</code> variable in Keycloak:</p> View: keycloak_openid_client <pre><code>  valid_redirect_uris = [\n\"https://edp-headlamp-&lt;edp_namespace&gt;.&lt;dns_wildcard&gt;/*\"\n\"http://localhost:8000/*\"\n]\n</code></pre> <p>Make sure to define the following Keycloak client values as indicated:</p> <p> Keycloak client configuration </p> </li> <li> <p>Configure the Keycloak client key in Kubernetes using the Kubernetes secrets or the External Secrets Operator:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: keycloak-client-headlamp-secret\nnamespace: &lt;edp-project&gt;\ntype: Opaque\nstringData:\nclientSecret: &lt;keycloak_client_secret_key&gt;\n</code></pre> </li> <li> <p>Assign user to one or more groups in Keycloak.</p> </li> </ol>"},{"location":"operator-guide/headlamp-oidc/#integrate-headlamp-with-kubernetes","title":"Integrate Headlamp With Kubernetes","text":"<p>Headlamp can be integrated in Kubernetes in three steps:</p> <ol> <li> <p>Update the values.yaml file by enabling OIDC:</p> View: values.yaml <pre><code>edp-headlamp:\nconfig:\noidc:\nenabled: true\n</code></pre> </li> <li> <p>Navigate to Headlamp and log in by clicking the <code>Sign In</code> button:</p> <p> Headlamp login page </p> </li> <li> <p>Go to <code>EDP</code> section -&gt; <code>Account</code> -&gt; <code>Settings</code>, and set up a namespace:</p> <p> Headlamp namespace settings </p> </li> </ol> <p>As a result, it is possible to control access and rights from the Keycloak endpoint.</p>"},{"location":"operator-guide/headlamp-oidc/#related-articles","title":"Related Articles","text":"<ul> <li>Configure Access Token Lifetime</li> <li>EKS OIDC With Keycloak</li> <li>External Secrets Operator</li> </ul>"},{"location":"operator-guide/import-strategy-jenkins/","title":"Integrate GitHub/GitLab in Jenkins","text":"<p>This page describes how to integrate EDP with GitLab or GitHub in case of following the Jenkins deploy scenario.</p>"},{"location":"operator-guide/import-strategy-jenkins/#integration-procedure","title":"Integration Procedure","text":"<p>To start from, it is required to add both Secret with SSH key and GitServer custom resources by taking the steps below:</p> <ol> <li> <p>Generate an SSH key pair and add a public key to GitLab    or GitHub    account.</p> <pre><code>ssh-keygen -t ed25519 -C \"email@example.com\"\n</code></pre> </li> <li> <p>Generate access token for GitLab    or GitHub    account with read/write access to the API. Both personal and project access tokens are applicable.</p> GitHubGitLab <p>To create access token in GitHub, follow the steps below:</p> <ul> <li>Log in to GitHub.</li> <li>Click the profile account and navigate to Settings -&gt; Developer Settings.</li> <li>Select Personal access tokens (classic) and generate a new token with the following parameters:</li> </ul> <p> Repo permission </p> <p>Note</p> <p>The access below is required for the GitHub Pull Request Builder plugin to get Pull Request commits, their status, and author info.</p> <p> Admin permission User permission </p> <p>Warning</p> <p>Make sure to save a new personal access token because it won`t be displayed later.</p> <p>To create access token in GitLab, follow the steps below:</p> <ul> <li>Log in to GitLab.</li> <li>In the top-right corner, click the avatar and select Settings.</li> <li>On the User Settings menu, select Access Tokens.</li> <li>Choose a name and an optional expiry date for the token.</li> <li>In the Scopes block, select the api scope for the token.</li> </ul> <p> Personal access tokens </p> <ul> <li>Click the Create personal access token button.</li> </ul> <p>Note</p> <p>Make sure to save the access token as there will not be any ability to access it once again.</p> <p>In case you want to create a project access token instead of a personal one, the GitLab Jenkins plugin will be able to accept payloads from webhooks for the project only:</p> <ul> <li>Log in to GitLab and navigate to the project.</li> <li>On the User Settings menu, select Access Tokens.</li> <li>Choose a name and an optional expiry date for the token.</li> <li>Choose a role: Owner or Maintainer.</li> <li>In the Scopes block, select the api scope for the token.</li> </ul> <p> Project access tokens </p> <ul> <li>Click the Create project access token button.</li> </ul> </li> <li> <p>Create secret in the <code>&lt;edp-project&gt;</code> namespace for the Git account with the id_rsa, username, and token fields. We recommend using Headlamp to implement this:</p> <ul> <li> <p>Open Headlamp URL. Use the Sign-In option:</p> <p> Logging screen </p> </li> </ul> <ul> <li> <p>In the top right corner, enter the <code>Cluster settings</code> and set the <code>Default namespace</code>. The <code>Allowed namespaces</code> field is optional. All the resources created via Headlamp are created in the <code>Default namespace</code> whereas <code>Allowed namespaces</code> means the namespaces you are allowed to access in this cluster:</p> <p> Cluster settings </p> </li> </ul> <ul> <li> <p>Log into Headlamp UI, select <code>EDP</code> -&gt; <code>Git Servers</code> -&gt; <code>+</code> to see the <code>Create Git Server</code> menu:</p> <p> Git Servers overview </p> </li> </ul> <ul> <li> <p>Choose your Git provider, insert Host, Access token, Private SSH key. Adjust SSH port, User and HTTPS port if needed and click <code>Apply</code>:</p> <p>Note</p> <p>Do not forget to press enter at the very end of the private key to have the last row empty.</p> <p> Create Git Servers menu </p> </li> </ul> <ul> <li> <p>After performing the steps above, two Kubernetes custom resources will be created in the default namespace: secret and GitServer. Headlamp appends random symbols to both the secret and the GitServer to provide names with uniqueness. Also, the attempt to connect to your actual Git server will be performed. If the connection with the server is established, the Git server status should be green:</p> <p> Git server status </p> <p>Note</p> <p>The value of the nameSshKeySecret property is the name of the Secret that is indicated in the first step above.</p> </li> </ul> </li> <li> <p>Create the <code>JenkinsServiceAccount</code> custom resource with the credentials field that corresponds to the nameSshKeySecret property above:</p> <pre><code>apiVersion: v2.edp.epam.com/v1\nkind: JenkinsServiceAccount\nmetadata:\nname: gitlab # It can also be github.\nnamespace: &lt;edp-project&gt;\nspec:\ncredentials: &lt;nameSshKeySecret&gt;\nownerName: ''\ntype: ssh\n</code></pre> </li> <li> <p>Double-check that the new SSH credentials called <code>gitlab</code>/<code>github</code> are created in Jenkins using the SSH key. Navigate to <code>Jenkins</code> -&gt; <code>Manage Jenkins</code> -&gt; <code>Manage Credentials</code> -&gt; <code>(global)</code>:</p> <p> Jenkins credentials </p> </li> <li> <p>Create a new job provisioner by following the instructions for GitHub or GitLab. The job provisioner will create a job suite for an application added to EDP. The job provisioner will also create webhooks for the project in GitLab using a GitLab token.</p> </li> <li> <p>Configure GitHub or GitLab plugins in Jenkins.</p> </li> </ol>"},{"location":"operator-guide/import-strategy-jenkins/#related-articles","title":"Related Articles","text":"<ul> <li>Add Git Server</li> <li>Add Application</li> <li>GitHub Webhook Configuration</li> <li>GitLab Webhook Configuration</li> </ul>"},{"location":"operator-guide/import-strategy-tekton/","title":"Integrate GitHub/GitLab in Tekton","text":"<p>This page describes how to integrate EDP with GitLab or GitHub in case of following the Tekton deploy scenario.</p>"},{"location":"operator-guide/import-strategy-tekton/#integration-procedure","title":"Integration Procedure","text":"<p>To start from, it is required to add both Secret with SSH key and GitServer custom resources by taking the steps below.</p> <ol> <li> <p>Generate an SSH key pair and add a public key to GitLab    or GitHub    account.</p> <pre><code>ssh-keygen -t ed25519 -C \"email@example.com\"\n</code></pre> </li> <li> <p>Generate access token for GitLab    or GitHub    account with read/write access to the API. Both personal and project access tokens are applicable.</p> GitHubGitLab <p>To create access token in GitHub, follow the steps below:</p> <ul> <li>Log in to GitHub.</li> <li>Click the profile account and navigate to Settings -&gt; Developer Settings.</li> <li>Select Personal access tokens (classic) and generate a new token with the following parameters:</li> </ul> <p> Repo permission </p> <p>Note</p> <p>The access below is required for the GitHub Pull Request Builder plugin to get Pull Request commits, their status, and author info.</p> <p> Admin permission User permission </p> <p>Warning</p> <p>Make sure to save a new personal access token because it won`t be displayed later.</p> <p>To create access token in GitLab, follow the steps below:</p> <ul> <li>Log in to GitLab.</li> <li>In the top-right corner, click the avatar and select Settings.</li> <li>On the User Settings menu, select Access Tokens.</li> <li>Choose a name and an optional expiry date for the token.</li> <li>In the Scopes block, select the api scope for the token.</li> </ul> <p> Personal access tokens </p> <ul> <li>Click the Create personal access token button.</li> </ul> <p>Note</p> <p>Make sure to save the access token as there will not be any ability to access it once again.</p> <p>In case you want to create a project access token instead of a personal one, the GitLab Jenkins plugin will be able to accept payloads from webhooks for the project only:</p> <ul> <li>Log in to GitLab and navigate to the project.</li> <li>On the User Settings menu, select Access Tokens.</li> <li>Choose a name and an optional expiry date for the token.</li> <li>Choose a role: Owner or Maintainer.</li> <li>In the Scopes block, select the api scope for the token.</li> </ul> <p> Project access tokens </p> <ul> <li>Click the Create project access token button.</li> </ul> </li> <li> <p>Create a secret in the <code>edp-project</code> namespace for the Git account with the id_rsa, username, and token fields. Take the following template as an example (use github instead of gitlab for GitHub):</p> <pre><code>kubectl create secret generic gitlab -n &lt;edp-project&gt; \\\n--from-file=id_rsa=id_rsa \\\n--from-literal=username=git \\\n--from-literal=token=your_gitlab_access_token\n</code></pre> </li> </ol>"},{"location":"operator-guide/import-strategy-tekton/#related-articles","title":"Related Articles","text":"<ul> <li>Add Git Server</li> <li>Add Application</li> <li>GitHub WebHook Configuration</li> <li>GitLab WebHook Configuration</li> </ul>"},{"location":"operator-guide/import-strategy/","title":"Enable VCS Import Strategy","text":"<p>Enabling the VCS Import strategy is a prerequisite to integrate EDP with GitLab or GitHub.</p>"},{"location":"operator-guide/import-strategy/#general-steps","title":"General Steps","text":"<p>In order to use the Import strategy, it is required to add both Secret with SSH key and GitServer custom resources by taking the steps below.</p> <ol> <li> <p>Generate an SSH key pair and add a public key to GitLab    or GitHub    account.</p> <pre><code>ssh-keygen -t ed25519 -C \"email@example.com\"\n</code></pre> </li> <li> <p>Generate access token for GitLab    or GitHub    account with read/write access to the API. Both personal and project access tokens are applicable.</p> </li> </ol> GitHubGitLab <p>To create access token in GitHub, follow the steps below:</p> <ul> <li>Log in to GitHub.</li> <li>Click the profile account and navigate to Settings -&gt; Developer Settings.</li> <li>Select Personal access tokens (classic) and generate a new token with the following parameters:</li> </ul> <p> Repo permission </p> <p>Note</p> <p>The access below is required for the GitHub Pull Request Builder plugin to get Pull Request commits, their status, and author info.</p> <p> Admin permission User permission </p> <p>Warning</p> <p>Make sure to save a new personal access token because it won`t be displayed later.</p> <p>To create access token in GitLab, follow the steps below:</p> <ul> <li>Log in to GitLab.</li> <li>In the top-right corner, click the avatar and select Settings.</li> <li>On the User Settings menu, select Access Tokens.</li> <li>Choose a name and an optional expiry date for the token.</li> <li>In the Scopes block, select the api scope for the token.</li> </ul> <p> Personal access tokens </p> <ul> <li>Click the Create personal access token button.</li> </ul> <p>Note</p> <p>Make sure to save the access token as there will not be any ability to access it once again.</p> <p>In case you want to create a project access token instead of a personal one, the GitLab Jenkins plugin will be able to accept payloads from webhooks for the project only:</p> <ul> <li>Log in to GitLab and navigate to the project.</li> <li>On the User Settings menu, select Access Tokens.</li> <li>Choose a name and an optional expiry date for the token.</li> <li>Choose a role: Owner or Maintainer.</li> <li>In the Scopes block, select the api scope for the token.</li> </ul> <p> Project access tokens </p> <ul> <li>Click the Create project access token button.</li> </ul>"},{"location":"operator-guide/import-strategy/#ci-tool-specific-steps","title":"CI Tool Specific Steps","text":"<p>The further steps depend on the CI tool used.</p> Tekton CI toolJenkins CI tool <ol> <li> <p>Create a secret in the <code>edp-project</code> namespace for the Git account with the id_rsa, username, and token fields.   Take the following template as an example (use github instead of gitlab for GitHub):</p> <pre><code>kubectl create secret generic gitlab -n &lt;edp-project&gt; \\\n--from-file=id_rsa=id_rsa \\\n--from-literal=username=git \\\n--from-literal=token=your_gitlab_access_token\n</code></pre> </li> <li> <p>After completing the steps above, you can get back and continue installing EDP.</p> </li> </ol> <ol> <li> <p>Create secret in the <code>&lt;edp-project&gt;</code> namespace for the Git account with the id_rsa, username, and token fields. We recommend using Headlamp to implement this:</p> <p>Open Headlamp URL. Use the Sign-In option:</p> <p> Logging screen </p> <p>In the top right corner, enter the <code>Cluster settings</code> and set the <code>Default namespace</code>. The <code>Allowed namespaces</code> field is optional. All the resources created via Headlamp are created in the <code>Default namespace</code> whereas <code>Allowed namespaces</code> means the namespaces you are allowed to access in this cluster:</p> <p> Cluster settings </p> <p>Log into Headlamp UI, select <code>EDP</code> -&gt; <code>Git Servers</code> -&gt; <code>+</code> to see the <code>Create Git Server</code> menu:</p> <p> Git Servers overview </p> <p>Choose your Git provider, insert Host, Access token, Private SSH key. Adjust SSH port, User and HTTPS port if needed and click <code>Apply</code>:</p> <p>Note</p> <p>Do not forget to press enter at the very end of the private key to have the last row empty.</p> <p> Create Git Servers menu </p> <p>When everything is done, two custom resources will be created in the default namespace: secret and Git server. Headlamp appends random symbols to both the secret and the server to provide names with uniqueness. Also, the attempt to connect to your Git server will be performed. If everything is correct, the Git server status should be green:</p> <p> Git server status </p> <p>Note</p> <p>The value of the nameSshKeySecret property is the name of the Secret that is indicated in the first step above.</p> </li> <li> <p>Create the <code>JenkinsServiceAccount</code> custom resource with the credentials field that corresponds to the nameSshKeySecret property above:</p> <pre><code>apiVersion: v2.edp.epam.com/v1\nkind: JenkinsServiceAccount\nmetadata:\nname: gitlab # It can also be github.\nnamespace: &lt;edp-project&gt;\nspec:\ncredentials: &lt;nameSshKeySecret&gt;\nownerName: ''\ntype: ssh\n</code></pre> </li> <li> <p>Double-check that the new SSH credentials called <code>gitlab</code>/<code>github</code> are created in Jenkins using the SSH key. Navigate to <code>Jenkins</code> -&gt; <code>Manage Jenkins</code> -&gt; <code>Manage Credentials</code> -&gt; <code>(global)</code>:</p> <p> Jenkins credentials </p> </li> <li> <p>The next step is to create a new job provisioner by following the instructions for GitHub or GitLab. The job provisioner will create a job suite for an application added to EDP. It will also create webhooks for the project in GitLab using a GitLab token.</p> </li> <li> <p>The next step is to integrate Jenkins with GitHub or GitLab by setting their plugins.</p> </li> </ol>"},{"location":"operator-guide/import-strategy/#related-articles","title":"Related Articles","text":"<ul> <li>Add Git Server</li> <li>Add Application</li> <li>GitHub Webhook Configuration</li> <li>GitLab Webhook Configuration</li> </ul>"},{"location":"operator-guide/install-argocd/","title":"Install Argo CD","text":"<p>Inspect the prerequisites and the main steps to perform for enabling Argo CD in EDP.</p>"},{"location":"operator-guide/install-argocd/#prerequisites","title":"Prerequisites","text":"<p>The following tools must be installed:</p> <ul> <li>Keycloak</li> <li>EDP</li> <li>Kubectl version 1.23.0</li> <li>Helm version 3.10.0</li> </ul>"},{"location":"operator-guide/install-argocd/#installation","title":"Installation","text":"<p>Argo CD enablement for EDP consists of two major steps:</p> <ul> <li>Argo CD integration with EDP (SSO enablement, codebase onboarding, etc.)</li> <li>Argo CD installation</li> </ul> <p>Info</p> <p>It is also possible to install Argo CD using the Helmfile. For details, please refer to the Install via Helmfile page.</p>"},{"location":"operator-guide/install-argocd/#integrate-with-edp","title":"Integrate With EDP","text":"<p>To enable Argo CD integration, ensure that the <code>argocd.enabled</code> flag values.yaml is set to <code>true</code></p>"},{"location":"operator-guide/install-argocd/#install-with-helm","title":"Install With Helm","text":"<p>Argo CD can be installed in several ways, please follow the official documentation for more details.</p> <p>Follow the steps below to install Argo CD using Helm:</p> <p>For the OpenShift users:</p> <p>When using the OpenShift platform, apply the <code>SecurityContextConstraints</code> resource. Change the namespace in the <code>users</code> section if required.</p> <p> View: argocd-scc.yaml <p><pre><code>allowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\napiVersion: security.openshift.io/v1\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 99\nmax: 65543\ngroups: []\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: argo-redis-ha\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nseccompProfiles:\n- '*'\nusers:\n- system:serviceaccount:argocd:argo-redis-ha\n- system:serviceaccount:argocd:argo-redis-ha-haproxy\n- system:serviceaccount:argocd:argocd-notifications-controller\n- system:serviceaccount:argocd:argo-argocd-repo-server\n- system:serviceaccount:argocd:argocd-server\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </p> <ol> <li> <p>Check out the values.yaml file sample of the Argo CD customization, which is based on the <code>HA mode without autoscaling</code>:</p> View: kubernetes-values.yaml <pre><code>redis-ha:\nenabled: true\n\ncontroller:\nenableStatefulSet: true\n\nserver:\nreplicas: 2\nextraArgs:\n- \"--insecure\"\nenv:\n- name: ARGOCD_API_SERVER_REPLICAS\nvalue: '2'\ningress:\nenabled: true\nhosts:\n- \"argocd.&lt;Values.global.dnsWildCard&gt;\"\nconfig:\n# required when SSO is enabled\nurl: \"https://argocd.&lt;.Values.global.dnsWildCard&gt;\"\napplication.instanceLabelKey: argocd.argoproj.io/instance-edp\noidc.config: |\nname: Keycloak\nissuer: https://&lt;.Values.global.keycloakEndpoint&gt;/auth/realms/&lt;.Values.global.edpName&gt;-main\nclientID: argocd\nclientSecret: $oidc.keycloak.clientSecret\nrequestedScopes:\n- openid\n- profile\n- email\n- groups\nrbacConfig:\n# users may be still be able to login,\n# but will see no apps, projects, etc...\npolicy.default: ''\nscopes: '[groups]'\npolicy.csv: |\n# default global admins\ng, ArgoCDAdmins, role:admin\n\nconfigs:\nparams:\napplication.namespaces: &lt;.Values.global.edpName&gt;\n\nrepoServer:\nreplicas: 2\n\n# we use Keycloak so no DEX is required\ndex:\nenabled: false\n\n# Disabled for multitenancy env with single instance deployment\napplicationSet:\nenabled: false\n</code></pre> View: openshift-values.yaml <pre><code>redis-ha:\nenabled: true\n\ncontroller:\nenableStatefulSet: true\n\nserver:\nreplicas: 2\nextraArgs:\n- \"--insecure\"\nenv:\n- name: ARGOCD_API_SERVER_REPLICAS\nvalue: '2'\nroute:\nenabled: true\nhostname: \"argocd.&lt;.Values.global.dnsWildCard&gt;\"\ntermination_type: edge\ntermination_policy: Redirect\nconfig:\n# required when SSO is enabled\nurl: \"https://argocd.&lt;.Values.global.dnsWildCard&gt;\"\napplication.instanceLabelKey: argocd.argoproj.io/instance-edp\noidc.config: |\nname: Keycloak\nissuer: https://&lt;.Values.global.keycloakEndpoint&gt;/auth/realms/&lt;.Values.global.edpName&gt;-main\nclientID: argocd\nclientSecret: $oidc.keycloak.clientSecret\nrequestedScopes:\n- openid\n- profile\n- email\n- groups\nrbacConfig:\n# users may be still be able to login,\n# but will see no apps, projects, etc...\npolicy.default: ''\nscopes: '[groups]'\npolicy.csv: |\n# default global admins\ng, ArgoCDAdmins, role:admin\n\nconfigs:\nparams:\napplication.namespaces: &lt;.Values.global.edpName&gt;\n\nrepoServer:\nreplicas: 2\n\n# we use Keycloak so no DEX is required\ndex:\nenabled: false\n\n# Disabled for multitenancy env with single instance deployment\napplicationSet:\nenabled: false\n</code></pre> <p>Populate Argo CD values with the values from the EDP values.yaml:</p> <ul> <li>&lt;.Values.global.dnsWildCard&gt; is the EDP DNS WildCard.</li> <li>&lt;.Values.global.keycloakEndpoint&gt; is the Keycloak Hostname.</li> <li>&lt;.Values.global.edpName&gt; is the EDP name.</li> </ul> </li> <li> <p>Run the installation:</p> <pre><code>kubectl create ns argocd\nhelm repo add argo https://argoproj.github.io/argo-helm\nhelm install argo --version 5.33.1 argo/argo-cd -f values.yaml -n argocd\n</code></pre> </li> <li> <p>Update the <code>argocd-secret</code> secret in the <code>argocd</code> namespace by providing the correct Keycloak client secret (<code>oidc.keycloak.clientSecret</code>)    with the value from the <code>keycloak-client-argocd-secret</code> secret in the EDP namespace. Then restart the deployment:</p> <pre><code>ARGOCD_CLIENT=$(kubectl -n &lt;EDP_NAMESPACE&gt; get secret keycloak-client-argocd-secret  -o jsonpath='{.data.clientSecret}')\nkubectl -n argocd patch secret argocd-secret -p=\"{\\\"data\\\":{\\\"oidc.keycloak.clientSecret\\\": \\\"${ARGOCD_CLIENT}\\\"}}\" -v=1\nkubectl -n argocd rollout restart deployment argo-argocd-server\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-argocd/#related-articles","title":"Related Articles","text":"<ul> <li>Argo CD Integration</li> <li>Install via Helmfile</li> </ul>"},{"location":"operator-guide/install-defectdojo/","title":"Install DefectDojo","text":"<p>Inspect the main steps to perform for installing DefectDojo via Helm Chart.</p> <p>Info</p> <p>It is also possible to install DefectDojo using the EDP addons approach. For details, please refer to the EDP addons approach.</p>"},{"location":"operator-guide/install-defectdojo/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.26.0 is installed.</li> <li>Helm version 3.12.0+ is installed.</li> </ul>"},{"location":"operator-guide/install-defectdojo/#installation","title":"Installation","text":"<p>Info</p> <p>Please refer to the DefectDojo Helm Chart and Deploy DefectDojo into the Kubernetes cluster sections for details.</p> <p>To install DefectDojo, follow the steps below:</p> <ol> <li> <p>Check that a security namespace is created. If not, run the following command to create it:</p> <pre><code>kubectl create namespace defectdojo\n</code></pre> <p>For the OpenShift users:</p> <p>When using the OpenShift platform, install the <code>SecurityContextConstraints</code> resource. In case of using a custom namespace for <code>defectdojo</code>, change the namespace in the <code>users</code> section.</p> <p> View: defectdojo-scc.yaml <p><pre><code>allowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\napiVersion: security.openshift.io/v1\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 999\nmax: 65543\ngroups: []\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: defectdojo\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:defectdojo:defectdojo\n- system:serviceaccount:defectdojo:defectdojo-rabbitmq\n- system:serviceaccount:defectdojo:default\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </p> <li> <p>Add a chart repository:</p> <pre><code>helm repo add defectdojo 'https://raw.githubusercontent.com/DefectDojo/django-DefectDojo/helm-charts'\nhelm repo update\n</code></pre> </li> <li> <p>Create PostgreSQL admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo-postgresql-specific \\\n--from-literal=postgresql-password=&lt;postgresql_password&gt; \\\n--from-literal=postgresql-postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> <p>Note</p> <p>The <code>postgresql_password</code> and <code>postgresql_postgres_password</code> passwords must be 16 characters long.</p> </li> <li> <p>Create Rabbitmq admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo-rabbitmq-specific \\\n--from-literal=rabbitmq-password=&lt;rabbitmq_password&gt; \\\n--from-literal=rabbitmq-erlang-cookie=&lt;rabbitmq_erlang_cookie&gt;\n</code></pre> <p>Note</p> <p>The <code>rabbitmq_password</code> password must be 10 characters long.</p> <p>The <code>rabbitmq_erlang_cookie</code> password must be 32 characters long.</p> </li> <li> <p>Create DefectDojo admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo \\\n--from-literal=DD_ADMIN_PASSWORD=&lt;dd_admin_password&gt; \\\n--from-literal=DD_SECRET_KEY=&lt;dd_secret_key&gt; \\\n--from-literal=DD_CREDENTIAL_AES_256_KEY=&lt;dd_credential_aes_256_key&gt; \\\n--from-literal=METRICS_HTTP_AUTH_PASSWORD=&lt;metric_http_auth_password&gt;\n</code></pre> <p>Note</p> <p>The <code>dd_admin_password</code> password must be 22 characters long.</p> <p>The <code>dd_secret_key</code> password must be 128 characters long.</p> <p>The <code>dd_credential_aes_256_key</code> password must be 128 characters long.</p> <p>The <code>metric_http_auth_password</code> password must be 32 characters long.</p> </li> <li> <p>Install DefectDojo v.2.22.4 using defectdojo/defectdojo Helm chart v.1.6.69:</p> <pre><code>helm upgrade --install \\\ndefectdojo \\\n--version 1.6.69 \\\ndefectdojo/defectdojo \\\n--namespace defectdojo \\\n--values values.yaml\n</code></pre> <p>Check out the values.yaml file sample of the DefectDojo customization:</p> View: values.yaml <pre><code>tag: 2.22.4\nfullnameOverride: defectdojo\nhost: defectdojo.&lt;ROOT_DOMAIN&gt;\nsite_url: https://defectdojo.&lt;ROOT_DOMAIN&gt;\nalternativeHosts:\n- defectdojo-django.defectdojo\n\ninitializer:\n# should be false after initial installation was performed\nrun: true\ndjango:\ningress:\nenabled: true # change to 'false' for OpenShift\nactivateTLS: false\nuwsgi:\nlivenessProbe:\n# Enable liveness checks on uwsgi container. Those values are use on nginx readiness checks as well.\n# default value is 120, so in our case 20 is just fine\ninitialDelaySeconds: 20\n</code></pre> </li> <li> <p>For the OpenShift platform, install a Route:</p> View: defectdojo-route.yaml <pre><code>kind: Route\napiVersion: route.openshift.io/v1\nmetadata:\nname: defectdojo\nnamespace: defectdojo\nspec:\nhost: defectdojo.&lt;ROOT_DOMAIN&gt;\npath: /\ntls:\ninsecureEdgeTerminationPolicy: Redirect\ntermination: edge\nto:\nkind: Service\nname: defectdojo-django\nport:\ntargetPort: http\nwildcardPolicy: None\n</code></pre> </li>"},{"location":"operator-guide/install-defectdojo/#configuration","title":"Configuration","text":"<p>To prepare DefectDojo for integration with EDP, follow the steps below:</p> <ol> <li> <p>Get credentials of the DefectDojo admin:</p> <pre><code>echo \"DefectDojo admin password: $(kubectl \\\nget secret defectdojo \\\n--namespace=defectdojo \\\n--output jsonpath='{.data.DD_ADMIN_PASSWORD}' \\\n| base64 --decode)\"\n</code></pre> </li> <li> <p>Get a token of the DefectDojo user:</p> <ul> <li>Login to the DefectDojo UI using the credentials.</li> </ul> <ul> <li>Go to the API v2 key (token).</li> </ul> <ul> <li>Copy the API key.</li> </ul> </li> <li> <p>Provision secrets using kubectl, EDP Portal UI or with the <code>externalSecrets</code> operator:</p> </li> </ol> kubectlEDP Portal UIExternal Secrets Operator <pre><code>kubectl -n &lt;edp_namespace&gt; create secret generic defectdojo-ciuser-token \\\n--from-literal=token=&lt;dd_token_of_dd_user&gt; \\\n--from-literal=url=\"&lt;defectdojo_url&gt;\"\n</code></pre> <p>Go to the <code>EDP Portal UI</code> open <code>EDP</code> -&gt; <code>Configuration</code> -&gt; <code>DefectDojo</code> change <code>URL</code> and <code>Token</code> and click <code>save</code> button.</p> <p> DefectDojo update manual secret </p> <p>Store defectdojo URL and Token in AWS Parameter Store with following format: <pre><code>\"defectdojo-ciuser-token\":\n{\n\"token\": \"XXXXXXXXXXXX\",\n  \"url\": \"https://defectdojo.example.com\"\n},\n</code></pre></p> <p>More detail of External Secrets Operator Integration can found on the following page</p> <p>After following the instructions provided, you should be able to integrate your DefectDojo with the EPAM Delivery Platform using one of the few available scenarios.</p>"},{"location":"operator-guide/install-defectdojo/#related-articles","title":"Related Articles","text":"<ul> <li>Install External Secrets Operator</li> <li>External Secrets Operator Integration</li> <li>Install Harbor</li> </ul>"},{"location":"operator-guide/install-edp/","title":"Install EDP","text":"<p>Inspect the main steps to install EPAM Delivery Platform. Please check the Prerequisites Overview page before starting the installation. There are several recommended ways to deploy EPAM Delivery Platform:</p> <ul> <li>Using Helm (see below);</li> <li>Using Helmfile.</li> </ul> <p>Note</p> <p>The installation process below is given for a Kubernetes cluster. The steps that differ for an OpenShift cluster are indicated in the notes.</p> <p>Note</p> <p>\u2039edp-project\u203a is the name of the EDP tenant in all the following steps.</p> <ol> <li> <p>Create an \u2039edp-project\u203a namespace or a Kiosk space depending on whether Kiosk is used or not.</p> <ul> <li> <p>Without Kiosk, create a namespace:</p> <pre><code>kubectl create namespace &lt;edp-project&gt;\n</code></pre> <p>Note</p> <p>For an OpenShift cluster, run the <code>oc</code> command instead of the <code>kubectl</code> one.</p> </li> </ul> <ul> <li> <p>With Kiosk, create a relevant space:</p> <pre><code>apiVersion: tenancy.kiosk.sh/v1alpha1\nkind: Space\nmetadata:\nname: &lt;edp-project&gt;\nspec:\naccount: &lt;edp-project&gt;-admin\n</code></pre> </li> </ul> <p>Note</p> <p>Kiosk is mandatory for EDP v.2.8.x. It is not implemented for the previous versions, and is optional for EDP since v.2.9.x.</p> </li> <li> <p>For EDP, it is required to have Keycloak access to perform the integration. Create a secret with user and password provisioned in the step 2 of the Keycloak Configuration section.</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic keycloak \\\n--from-literal=username=&lt;username&gt; \\\n--from-literal=password=&lt;password&gt;\n</code></pre> </li> <li> <p>Generate a cookie-secret for proxy with the following command:</p> <p><pre><code>nexus_proxy_cookie_secret=$(openssl rand -base64 32 | head -c 32)\n</code></pre> Create <code>nexus-proxy-cookie-secret</code> in the  namespace: <pre><code>kubectl -n &lt;edp-project&gt; create secret generic nexus-proxy-cookie-secret \\\n--from-literal=cookie-secret=${nexus_proxy_cookie_secret}\n</code></pre> <li> <p>Add the Helm EPAMEDP Charts for local client.</p> <pre><code>helm repo add epamedp https://epam.github.io/edp-helm-charts/stable\n</code></pre> </li> <li> <p>Choose the required Helm chart version:</p> <pre><code>helm search repo epamedp/edp-install\nNAME                    CHART VERSION   APP VERSION     DESCRIPTION\nepamedp/edp-install     3.3.0           3.3.0           A Helm chart for EDP Install\n</code></pre> <p>Note</p> <p>It is highly recommended to use the latest released version.</p> </li> <li> <p>By default, EDP uses Tekton as a CI tool (see more in the Prerequisites Overview page). To use Jenkins instead of Tekton, redefine the following parameters in the values.yaml file:</p> View: values.yaml <pre><code>...\nedp-tekton:\nenabled: false\n...\njenkins-operator:\nenabled: true\n...\nadmin-console-operator:\nenabled: true\n...\n</code></pre> </li> <li> <p>EDP can be integrated with the following version control systems:</p> <ul> <li>Gerrit (by default)</li> <li>GitHub</li> <li>GitLab</li> </ul> <p>This integration implies in what system the development of the application will be or is already being carried out. The <code>global.gitProvider</code> flag in the edp-install controls this integration:</p> Gerrit (by default)GitHubGitLab values.yaml<pre><code>...\nglobal:\ngitProvider: gerrit\n...\n</code></pre> values.yaml<pre><code>...\nglobal:\ngitProvider: github\n...\n</code></pre> values.yaml<pre><code>...\nglobal:\ngitProvider: gitlab\n...\n</code></pre> <p>By default, the internal Gerrit server is deployed as a result of EDP deployment. For more details on how to integrate EDP with GitLab or GitHub instead of Gerrit, please refer to the Integrate GitHub/GitLab in Jenkins or Integrate GitHub/GitLab in Tekton article.</p> </li> <li> <p>Check the parameters in the EDP installation chart. For details, please refer to the values.yaml file.</p> </li> <li> <p>Install EDP in the \u2039edp-project\u203a namespace with the Helm tool.</p> <pre><code>helm install edp epamedp/edp-install --wait --timeout=900s \\\n--version &lt;edp_version&gt; \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>See the details on the parameters below:</p> Tekton CI toolJenkins CI tool Example values.yaml file<pre><code>global:\n# -- namespace or a project name (in case of OpenShift)\nedpName: &lt;edp-project&gt;\n# -- platform type that can be \"kubernetes\" or \"openshift\"\nplatform: \"kubernetes\"\n# DNS wildcard for routing in the Kubernetes cluster; \ndnsWildCard: \"example.com\"\n# -- Administrators of your tenant\nadmins:\n- \"stub_user_one@example.com\"\n# -- Developers of your tenant\ndevelopers:\n- \"stub_user_one@example.com\"\n- \"stub_user_two@example.com\"\n# -- Cluster URL, e.g. https://xxxxxxxxxxxxxxxxxxxx.sk1.eu-central-1.eks.amazonaws.com can get from kubeconfig.clusters.cluster.server;\nwebConsole:\nurl: &lt;kubeconfig.clusters.cluster.server&gt;\n# -- Can be gerrit, github or gitlab. By default: gerrit\ngitProvider: gerrit\n# -- Gerrit SSH node port\ngerritSSHPort: \"22\"\n# Keycloak address with which the platform will be integrated\nkeycloakUrl: \"https://keycloak.example.com\"\ndockerRegistry:\n# -- Docker Registry endpoint\nurl: \"&lt;AWS_ACCOUNT_ID&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com\"\n\n# AWS Region, e.g. \"eu-central-1\"\nawsRegion:\n\nargocd:\n# -- Enable ArgoCD integration\nenabled: true\n# -- ArgoCD URL in format schema://URI\n# -- By default, https://argocd.{{ .Values.global.dnsWildCard }}\nurl: \"\"\n\n# Kaniko configuration section\nkaniko:\n# -- AWS IAM role to be used for kaniko pod service account (IRSA). Format: arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/&lt;AWS_IAM_ROLE_NAME&gt;\nroleArn:\n\nedp-tekton:\n# Tekton Kaniko configuration section\nkaniko:\n# -- AWS IAM role to be used for kaniko pod service account (IRSA). Format: arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/&lt;AWS_IAM_ROLE_NAME&gt;\nroleArn:\n# Change to true to pass ctLint config\nctLint:\nvalidateMaintainers: false\n\nedp-headlamp:\nconfig:\noidc:\nenabled: false\n</code></pre> Example values.yaml file<pre><code>global:\n# -- namespace or a project name (in case of OpenShift)\nedpName: &lt;edp-project&gt;\n# -- platform type that can be \"kubernetes\" or \"openshift\"\nplatform: \"kubernetes\"\n# DNS wildcard for routing in the Kubernetes cluster;\ndnsWildCard: &lt;DNS_wildcard&gt;\n# -- Administrators of your tenant\nadmins:\n- \"stub_user_one@example.com\"\n# -- Developers of your tenant\ndevelopers:\n- \"stub_user_one@example.com\"\n- \"stub_user_two@example.com\"\n# -- Cluster URL, e.g. https://xxxxxxxxxxxxxxxxxxxx.sk1.eu-central-1.eks.amazonaws.com can get from kubeconfig.clusters.cluster.server;\nwebConsole:\nurl: &lt;kubeconfig.clusters.cluster.server&gt;\n# -- Can be gerrit, github or gitlab. By default: gerrit\ngitProvider: gerrit\n# -- Gerrit SSH node port\ngerritSSHPort: \"22\"\n# Keycloak address with which the platform will be integrated\nkeycloakUrl: \"https://keycloak.example.com\"\ndockerRegistry:\n# -- Define Image Registry that will to be used in Pipelines. Can be ecr (default), harbor\ntype: \"ecr\"\n# -- Docker Registry endpoint\nurl: \"&lt;AWS_ACCOUNT_ID&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com\"\n\n# AWS Region, e.g. \"eu-central-1\"\nawsRegion:\n\nargocd:\n# -- Enable ArgoCD integration\nenabled: false\n\n# Kaniko configuration section\nkaniko:\n# -- AWS IAM role to be used for kaniko pod service account (IRSA). Format: arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWS_IAM_ROLE_NAME&gt;\nroleArn:\n\njenkins-operator:\nenabled: true\n\n# Critical operator used by Jenkins\nadmin-console-operator:\nenabled: true\n\nedp-tekton:\nenabled: false\n\nedp-headlamp:\nconfig:\noidc:\nenabled: false\n</code></pre> <p>Note</p> <p>Set <code>global.platform=openshift</code> while deploying EDP in OpenShift.</p> <p>Info</p> <p>The full installation with integration between tools will take at least 10 minutes.</p> </li> <li> <p>To check if the installation is successful, run the command below:</p> <p><pre><code>helm status &lt;edp-release&gt; -n &lt;edp-project&gt;\n</code></pre>   You can also check ingress endpoints to get Headlamp endpoint to enter Headlamp UI:   <pre><code>kubectl describe ingress -n &lt;edp-project&gt;\n</code></pre></p> </li> <li> <p>Once EDP is successfully installed, you can navigate to our Use Cases to try out EDP functionality.</p> </li>"},{"location":"operator-guide/install-edp/#related-articles","title":"Related Articles","text":"<ul> <li>Quick Start</li> <li>Install EDP via Helmfile</li> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> <li>GitHub Webhook Configuration</li> <li>GitLab Webhook Configuration</li> <li>Set Up Kubernetes</li> <li>Set Up OpenShift</li> <li>EDP Installation Prerequisites Overview</li> <li>Headlamp OIDC Integration</li> </ul>"},{"location":"operator-guide/install-external-secrets-operator/","title":"Install External Secrets Operator","text":"<p>Inspect the prerequisites and the main steps to perform for enabling External Secrets Operator in EDP.</p>"},{"location":"operator-guide/install-external-secrets-operator/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.23.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.10.0+ is installed. Please refer to the Helm page on GitHub for details.</li> </ul>"},{"location":"operator-guide/install-external-secrets-operator/#installation","title":"Installation","text":"<p>To install External Secrets Operator with Helm, run the following commands:</p> <pre><code>helm repo add external-secrets https://charts.external-secrets.io\n\nhelm install external-secrets \\\nexternal-secrets/external-secrets \\\n--version 0.8.3 \\\n-n external-secrets \\\n--create-namespace\n</code></pre> <p>Info</p> <p>It is also possible to install External Secrets Operator using the Helmfile or Operator Lifecycle Manager (OLM).</p>"},{"location":"operator-guide/install-external-secrets-operator/#related-articles","title":"Related Articles","text":"<ul> <li>External Secrets Operator Integration</li> <li>Install Harbor</li> </ul>"},{"location":"operator-guide/install-harbor/","title":"Install Harbor","text":"<p>EPAM Delivery Platform uses Harbor as a storage for application images that are created when building applications.</p> <p>Inspect the prerequisites and the main steps to perform for enabling Harbor in EDP.</p>"},{"location":"operator-guide/install-harbor/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.26.0 is installed.</li> <li>Helm version 3.12.0+ is installed.</li> </ul>"},{"location":"operator-guide/install-harbor/#installation","title":"Installation","text":"<p>To install Harbor with Helm, follow the steps below:</p> <ol> <li> <p>Create a namespace for Harbor:</p> <pre><code>kubectl create namespace harbor\n</code></pre> </li> <li> <p>Create a secret for administrator user and registry:</p> ManuallyExternal Secret Operator <pre><code>kubectl create secret generic harbor \\\n--from-literal=HARBOR_ADMIN_PASSWORD=&lt;secret&gt; \\\n--from-literal=REGISTRY_HTPASSWD=&lt;secret&gt; \\\n--from-literal=REGISTRY_PASSWD=&lt;secret&gt; \\\n--from-literal=secretKey=&lt;secret&gt; \\\n--namespace harbor\n</code></pre> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\nname: harbor\nnamespace: harbor\nspec:\nrefreshInterval: 1h\nsecretStoreRef:\nkind: SecretStore\nname: aws-parameterstore\ndata:\n- secretKey: HARBOR_ADMIN_PASSWORD\nremoteRef:\nconversionStrategy: Default\ndecodingStrategy: None\nkey: /control-plane/deploy-secrets\nproperty: harbor.HARBOR_ADMIN_PASSWORD\n- secretKey: secretKey\nremoteRef:\nconversionStrategy: Default\ndecodingStrategy: None\nkey: /control-plane/deploy-secrets\nproperty: harbor.secretKey\n- secretKey: REGISTRY_HTPASSWD\nremoteRef:\nconversionStrategy: Default\ndecodingStrategy: None\nkey: /control-plane/deploy-secrets\nproperty: harbor.REGISTRY_HTPASSWD\n- secretKey: REGISTRY_PASSWD\nremoteRef:\nconversionStrategy: Default\ndecodingStrategy: None\nkey: /control-plane/deploy-secrets\nproperty: harbor.REGISTRY_PASSWD\n</code></pre> <p>Note</p> <p>The <code>HARBOR_ADMIN_PASSWORD</code> is the initial password of Harbor admin. The <code>secretKey</code> is the secret key that is used for encryption. Must be 16 characters long. The <code>REGISTRY_PASSWD</code> is Harbor registry password. The <code>REGISTRY_HTPASSWD</code> is login and password in htpasswd string format. This value is the string in the password file generated by the <code>htpasswd</code> command where the username is <code>harbor_registry_user</code> and the encryption type is <code>bcrypt</code>. See the example below: <pre><code>htpasswd -bBc passwordfile harbor_registry_user harbor_registry_password\n</code></pre> The username must be <code>harbor_registry_user</code>. The password must be the value from <code>REGISTRY_PASSWD</code>.</p> </li> <li> <p>Add the Helm Harbor Charts for the local client.</p> <pre><code>helm repo add harbor https://helm.goharbor.io\n</code></pre> </li> <li> <p>Check the parameters in the Harbor installation chart. For details, please refer to    the values.yaml file.</p> </li> <li> <p>Install Harbor in the \u2039harbor\u203a namespace with the Helm tool.</p> <pre><code>helm install harbor harbor/harbor\n    --version 1.12.2 \\\n--namespace harbor \\\n--values values.yaml\n</code></pre> <p>See the details on the parameters below:</p> <p>Example values.yaml file</p> <pre><code># we use Harbor secret to consolidate all the Harbor secrets\nexistingSecretAdminPassword: harbor\nexistingSecretAdminPasswordKey: HARBOR_ADMIN_PASSWORD\nexistingSecretSecretKey: harbor\n\ncore:\n# The XSRF key. Will be generated automatically if it isn't specified\nxsrfKey: \"\"\njobservice:\n# Secret is used when job service communicates with other components.\n# If a secret key is not specified, Helm will generate one.\n# Must be a string of 16 chars.\nsecret: \"\"\nregistry:\n# Secret is used to secure the upload state from client\n# and registry storage backend.\n# If a secret key is not specified, Helm will generate one.\n# Must be a string of 16 chars.\nsecret: \"\"\ncredentials:\nusername: harbor_registry_user\nexistingSecret: harbor\nfullnameOverride: harbor\n# If Harbor is deployed behind the proxy, set it as the URL of proxy\nexternalURL: https://core.harbor.domain\nipFamily:\nipv6:\nenabled: false\nexpose:\ntls:\nenabled: false\ningress:\nhosts:\ncore: core.harbor.domain\nnotary: notary.harbor.domain\nupdateStrategy:\ntype: Recreate\npersistence:\npersistentVolumeClaim:\nregistry:\nsize: 30Gi\njobservice:\njobLog:\nsize: 1Gi\ndatabase:\nsize: 2Gi\nredis:\nsize: 1Gi\ntrivy:\nsize: 5Gi\ndatabase:\ninternal:\n# The initial superuser password for internal database\npassword: \"changeit\"\n</code></pre> </li> <li> <p>To check if the installation is successful, run the command below:</p> <p><pre><code>helm status &lt;harbor-release&gt; -n harbor\n</code></pre>   You can also check ingress endpoints to get Harbor endpoint to enter Harbor UI:   <pre><code>kubectl describe ingress &lt;harbor_ingress&gt; -n harbor\n</code></pre></p> </li> </ol>"},{"location":"operator-guide/install-harbor/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Integrate Harbor With EDP Pipelines</li> </ul>"},{"location":"operator-guide/install-ingress-nginx/","title":"Install NGINX Ingress Controller","text":"<p>Inspect the prerequisites and the main steps to perform for installing Install NGINX Ingress Controller on Kubernetes.</p>"},{"location":"operator-guide/install-ingress-nginx/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.23.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.10.2 is installed. Please refer to the Helm page on GitHub for details.</li> </ul>"},{"location":"operator-guide/install-ingress-nginx/#installation","title":"Installation","text":"<p>Info</p> <p>It is also possible to install NGINX Ingress Controller using the Helmfile. For details, please refer to the Install via Helmfile page.</p> <p>To install the ingress-nginx chart, follow the steps below:</p> <ol> <li> <p>Create an ingress-nginx namespace:</p> <pre><code>kubectl create namespace ingress-nginx\n</code></pre> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo update\n</code></pre> </li> <li> <p>Install the ingress-nginx chart:</p> <pre><code>helm install ingress ingress-nginx/ingress-nginx \\\n--version 4.7.0 \\\n--values values.yaml \\\n--namespace ingress-nginx\n</code></pre> <p>Check out the values.yaml file sample of the ingress-nginx chart customization:</p> </li> </ol> View: values.yaml <pre><code>controller:\naddHeaders:\nX-Content-Type-Options: nosniff\nX-Frame-Options: SAMEORIGIN\nresources:\nlimits:\nmemory: \"256Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"128M\"\nconfig:\nssl-redirect: 'true'\nclient-header-buffer-size: '64k'\nhttp2-max-field-size: '64k'\nhttp2-max-header-size: '64k'\nlarge-client-header-buffers: '4 64k'\nupstream-keepalive-timeout: '120'\nkeep-alive: '10'\nuse-forwarded-headers: 'true'\nproxy-real-ip-cidr: '172.32.0.0/16'\nproxy-buffer-size: '8k'\n\n# To watch Ingress objects without the ingressClassName field set parameter value to true.\n# https://kubernetes.github.io/ingress-nginx/#i-have-only-one-ingress-controller-in-my-cluster-what-should-i-do\nwatchIngressWithoutClass: true\n\nservice:\ntype: NodePort\nnodePorts:\nhttp: 32080\nhttps: 32443\nupdateStrategy:\nrollingUpdate:\nmaxUnavailable: 1\ntype: RollingUpdate\nmetrics:\nenabled: true\ndefaultBackend:\nenabled: true\nserviceAccount:\ncreate: true\nname: nginx-ingress-service-account\n</code></pre> <p>Warning</p> <p>Align value controller.config.proxy-real-ip-cidr with AWS VPC CIDR.</p>"},{"location":"operator-guide/install-keycloak/","title":"Install Keycloak","text":"<p>Inspect the prerequisites and the main steps to perform for installing Keycloak.</p> <p>Info</p> <p>The installation process below is given for a Kubernetes cluster. The steps that differ for an OpenShift cluster are indicated in the warnings blocks.</p>"},{"location":"operator-guide/install-keycloak/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.23.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.10.0+ is installed. Please refer to the Helm page on GitHub for details.</li> </ul> <p>Info</p> <p>EDP team is using a Keycloakx helm chart from the codecentric repository, but other repositories can be used as well (e.g. Bitnami). Before installing Keycloak, it is necessary to install a PostgreSQL database.</p> <p>Info</p> <p>It is also possible to install Keycloak using the Helmfile. For details, please refer to the Install via Helmfile page.</p>"},{"location":"operator-guide/install-keycloak/#postgresql-installation","title":"PostgreSQL Installation","text":"<p>To install PostgreSQL, follow the steps below:</p> <ol> <li> <p>Check that a security namespace is created. If not, run the following command to create it:</p> <pre><code>kubectl create namespace security\n</code></pre> <p>Warning</p> <p>On the OpenShift platform, apply the <code>SecurityContextConstraints</code> resource. Change the namespace in the <code>users</code> section if required.</p> View: keycloak-scc.yaml <pre><code>allowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\napiVersion: security.openshift.io/v1\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 999\nmax: 65543\ngroups: []\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: keycloak\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:security:keycloakx\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> View: postgresql-keycloak-scc.yaml <pre><code>allowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\napiVersion: security.openshift.io/v1\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 999\nmax: 65543\ngroups: []\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: postgresql-keycloak\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:security:default\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </li> <li> <p>Create PostgreSQL admin secret:</p> <pre><code>kubectl -n security create secret generic keycloak-postgresql \\\n--from-literal=password=&lt;postgresql_password&gt; \\\n--from-literal=postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> </li> <li> <p>Add a helm chart repository:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Install PostgreSQL v15.2.0 using bitnami/postgresql Helm chart v12.1.15:</p> <p>Info</p> <p>The PostgreSQL can be deployed in production ready mode. For example, it may include multiple replicas, persistent storage, autoscaling, and monitoring. For details, please refer to the official Chart documentation.</p> <pre><code>helm install postgresql bitnami/postgresql \\\n--version 12.1.15 \\\n--values values.yaml \\\n--namespace security\n</code></pre> <p>Check out the values.yaml file sample of the PostgreSQL customization:</p> View: values.yaml <pre><code># PostgreSQL read only replica parameters\nreadReplicas:\n# Number of PostgreSQL read only replicas\nreplicaCount: 1\n\nimage:\ntag: 15.2.0-debian-11-r0\n\nglobal:\npostgresql:\nauth:\nusername: admin\nexistingSecret: keycloak-postgresql\ndatabase: keycloak\n\nprimary:\npersistence:\nenabled: true\nsize: 3Gi\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-keycloak/#keycloak-installation","title":"Keycloak Installation","text":"<p>To install Keycloak, follow the steps below:</p> <ol> <li> <p>Use <code>security</code> namespace from the PostgreSQL installation.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add codecentric https://codecentric.github.io/helm-charts\nhelm repo update\n</code></pre> </li> <li> <p>Create Keycloak admin secret:</p> <pre><code>kubectl -n security create secret generic keycloak-admin-creds \\\n--from-literal=username=&lt;keycloak_admin_username&gt; \\\n--from-literal=password=&lt;keycloak_admin_password&gt;\n</code></pre> </li> <li> <p>Install Keycloak 20.0.3 using codecentric/keycloakx Helm chart:</p> <p>Info</p> <p>Keycloak can be deployed in production ready mode. For example, it may include multiple replicas, persistent storage, autoscaling, and monitoring. For details, please refer to the official Chart documentation.</p> <pre><code>helm install keycloakx codecentric/keycloakx \\\n--version 2.2.1 \\\n--values values.yaml \\\n--namespace security\n</code></pre> <p>Check out the values.yaml file sample of the Keycloak customization:</p> View: values.yaml <pre><code>replicas: 1\n\n# Deploy the latest version\nimage:\ntag: \"20.0.3\"\n\n# start: create OpenShift realm which is required by EDP\nextraInitContainers: |\n- name: realm-provider\nimage: busybox\nimagePullPolicy: IfNotPresent\ncommand:\n- sh\nargs:\n- -c\n- |\necho '{\"realm\": \"openshift\",\"enabled\": true}' &gt; /opt/keycloak/data/import/openshift.json\nvolumeMounts:\n- name: realm\nmountPath: /opt/keycloak/data/import\n\n# The following parameter is unrecommended to expose. Exposed health checks lead to an unnecessary attack vector.\nhealth:\nenabled: false\n# The following parameter is unrecommended to expose. Exposed metrics lead to an unnecessary attack vector.\nmetrics:\nenabled: false\n\nextraVolumeMounts: |\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumes: |\n- name: realm\nemptyDir: {}\n\ncommand:\n- \"/opt/keycloak/bin/kc.sh\"\n- \"--verbose\"\n- \"start\"\n- \"--auto-build\"\n- \"--http-enabled=true\"\n- \"--http-port=8080\"\n- \"--hostname-strict=false\"\n- \"--hostname-strict-https=false\"\n- \"--spi-events-listener-jboss-logging-success-level=info\"\n- \"--spi-events-listener-jboss-logging-error-level=warn\"\n- \"--import-realm\"\n\nextraEnv: |\n- name: KC_PROXY\nvalue: \"passthrough\"\n- name: KEYCLOAK_ADMIN\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: username\n- name: KEYCLOAK_ADMIN_PASSWORD\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: password\n- name: JAVA_OPTS_APPEND\nvalue: &gt;-\n-XX:+UseContainerSupport\n-XX:MaxRAMPercentage=50.0\n-Djava.awt.headless=true\n-Djgroups.dns.query={{ include \"keycloak.fullname\" . }}-headless\n\n# This block should be uncommented if you install Keycloak on Kubernetes\ningress:\nenabled: true\nannotations:\nkubernetes.io/ingress.class: nginx\ningress.kubernetes.io/affinity: cookie\n# The following parameter is unrecommended to expose. Admin paths lead to an unnecessary attack vector.\nconsole:\nenabled: false\nrules:\n- host: keycloak.&lt;ROOT_DOMAIN&gt;\npaths:\n- path: '{{ tpl .Values.http.relativePath $ | trimSuffix \"/\" }}/'\npathType: Prefix\n\n# This block should be uncommented if you set Keycloak to OpenShift and change the host field\n# route:\n#   enabled: false\n#   # Path for the Route\n#   path: '/'\n#   # Host name for the Route\n#   host: \"keycloak.&lt;ROOT_DOMAIN&gt;\"\n#   # TLS configuration\n#   tls:\n#     enabled: true\n\nresources:\nlimits:\nmemory: \"2048Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"512Mi\"\n\n# Check database readiness at startup\ndbchecker:\nenabled: true\n\ndatabase:\nvendor: postgres\nexistingSecret: keycloak-postgresql\nhostname: postgresql\nport: 5432\nusername: admin\ndatabase: keycloak\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-keycloak/#configuration","title":"Configuration","text":"<p>To prepare Keycloak for integration with EDP, follow the steps below:</p> <ol> <li> <p>Ensure that the <code>openshift</code> realm is created.</p> </li> <li> <p>Create the <code>edp_&lt;EDP_PROJECT&gt;</code> user and set the password in the <code>Master</code> realm.</p> <p>Note</p> <p>This user should be used by EDP to access Keycloak. Please refer to the Install EDP and Install EDP via Helmfile sections for details.</p> </li> <li> <p>In the <code>Role Mapping</code> tab, assign the proper roles to the user:</p> <ul> <li> <p>Realm Roles:</p> <ul> <li>create-realm,</li> </ul> <ul> <li>offline_access,</li> </ul> <ul> <li>uma_authorization</li> </ul> </li> </ul> <ul> <li> <p>Client Roles <code>openshift-realm</code>:</p> <ul> <li>impersonation,</li> </ul> <ul> <li>manage-authorization,</li> </ul> <ul> <li>manage-clients,</li> </ul> <ul> <li>manage-users</li> </ul> </li> </ul> <p> Role mappings </p> </li> </ol>"},{"location":"operator-guide/install-keycloak/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Install via Helmfile</li> <li>Install Harbor</li> </ul>"},{"location":"operator-guide/install-kiosk/","title":"Set Up Kiosk","text":"<p>Kiosk is a multi-tenancy extension for managing tenants and namespaces in a shared Kubernetes cluster. Within EDP, Kiosk is used to separate resources and enables the following options (see more details):</p> <ul> <li>Access to the EDP tenants in a Kubernetes cluster;</li> </ul> <ul> <li>Multi-tenancy access at the service account level for application deploy.</li> </ul> <p>Inspect the main steps to set up Kiosk for the proceeding EDP installation.</p> <p>Note</p> <p>Kiosk deploy is mandatory for EDP v.2.8.. In earlier versions, Kiosk is not implemented. Since EDP v.2.9.0, integration with Kiosk is an optional feature. You may not want to use it, so just skip those steps and disable in Helm parameters during EDP deploy.</p> <pre><code># global.kioskEnabled: &lt;true/false&gt;\n</code></pre>"},{"location":"operator-guide/install-kiosk/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.18.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.6.0 is installed. Please refer to the Helm page on GitHub for details.</li> </ul>"},{"location":"operator-guide/install-kiosk/#installation","title":"Installation","text":"<ul> <li>Deploy Kiosk version 0.2.11 in the cluster. To install it, run the following command:<pre><code>  # Install kiosk with helm v3\n\n  helm repo add kiosk https://charts.devspace.sh/\n  kubectl create namespace kiosk\n  helm install kiosk --version 0.2.11 kiosk/kiosk -n kiosk --atomic\n</code></pre> </li> </ul> <p>For more details, please refer to the Kiosk page on the GitHub.</p>"},{"location":"operator-guide/install-kiosk/#configuration","title":"Configuration","text":"<p>To provide access to the EDP tenant, follow the steps below.</p> <ul> <li>Check that a security namespace is created. If not, run the following command to create it:<pre><code>  kubectl create namespace security\n</code></pre> </li> </ul> <p>Note</p> <p>On an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> <ul> <li>Add a service account to the security namespace.<pre><code>  kubectl -n security create sa &lt;edp-project&gt;\n</code></pre> </li> </ul> <p>Info</p> <p>\u2039edp-project\u203a is the name of the EDP tenant here and in all the following steps.</p> <ul> <li>Apply the Account template to the cluster. Please check the sample below: <pre><code>apiVersion: tenancy.kiosk.sh/v1alpha1\nkind: Account\nmetadata:\nname: &lt;edp-project&gt;-admin\nspec:\nspace:\nclusterRole: kiosk-space-admin\nsubjects:\n- kind: ServiceAccount\nname: &lt;edp-project&gt;\nnamespace: security\n</code></pre></li> </ul> <ul> <li>Apply the ClusterRoleBinding to the 'kiosk-edit' cluster role (current role is added during installation of Kiosk). Please check the sample below: <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: &lt;edp-project&gt;-kiosk-edit\nsubjects:\n- kind: ServiceAccount\nname: &lt;edp-project&gt;\nnamespace: security\nroleRef:\nkind: ClusterRole\nname: kiosk-edit\napiGroup: rbac.authorization.k8s.io\n</code></pre></li> <li>To provide access to the EDP tenant, generate kubeconfig with Service Account \u2039edp-project\u203a permission. The \u2039edp-project\u203a account created earlier is located in the security namespace.</li> </ul>"},{"location":"operator-guide/install-loki/","title":"Install Grafana Loki","text":"<p>EDP configures the logging with the help of Grafana Loki aggregation system.</p>"},{"location":"operator-guide/install-loki/#installation","title":"Installation","text":"<p>To install Loki, follow the steps below:</p> <ol> <li> <p>Create logging namespace:</p> <pre><code>  kubectl create namespace logging\n</code></pre> <p>Note</p> <p>On the OpenShift cluster, run the <code>oc</code> command instead of the <code>kubectl</code> command.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>  helm repo add grafana https://grafana.github.io/helm-charts\n  helm repo update\n</code></pre> <p>Note</p> <p>It is possible to use Amazon Simple Storage Service Amazon S3 as an object storage for Loki. To configure access, please refer to the IRSA for Loki documentation.</p> </li> <li> <p>Install Loki v.2.6.0:</p> <pre><code>  helm install loki grafana/loki \\\n  --version 2.6.0 \\\n  --values values.yaml \\\n  --namespace logging\n</code></pre> <p>Check out the values.yaml file sample of the Loki customization:</p> View: values.yaml <pre><code>image:\nrepository: grafana/loki\ntag: 2.3.0\nconfig:\nauth_enabled: false\nschema_config:\nconfigs:\n- from: 2021-06-01\nstore: boltdb-shipper\nobject_store: s3\nschema: v11\nindex:\nprefix: loki_index_\nperiod: 24h\nstorage_config:\naws:\ns3: s3://&lt;AWS_REGION&gt;/loki-&lt;CLUSTER_NAME&gt;\nboltdb_shipper:\nactive_index_directory: /data/loki/index\ncache_location: /data/loki/boltdb-cache\nshared_store: s3\nchunk_store_config:\nmax_look_back_period: 24h\nresources:\nlimits:\nmemory: \"128Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"128Mi\"\nserviceAccount:\ncreate: true\nname: edp-loki\nannotations:\neks.amazonaws.com/role-arn: \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\npersistence:\nenabled: false\n</code></pre> <p>Note</p> <p>In case of using cluster scheduling and amazon-eks-pod-identity-webhook, it is necessary to restart the Loki pod after the cluster is up and running. Please refer to the Schedule Pods Restart documentation.</p> </li> <li> <p>Configure custom bucket policy to delete the old data.</p> </li> </ol>"},{"location":"operator-guide/install-reportportal/","title":"Install ReportPortal","text":"<p>Inspect the prerequisites and the main steps to perform for installing ReportPortal.</p> <p>Info</p> <p>It is also possible to install ReportPortal using the Helmfile. For details, please refer to the Install via Helmfile page.</p>"},{"location":"operator-guide/install-reportportal/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.23.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.10.2 is installed. Please refer to the Helm page on GitHub for details.</li> </ul> <p>Info</p> <p>Please refer to the ReportPortal Helm Chart section for details.</p>"},{"location":"operator-guide/install-reportportal/#minio-installation","title":"MinIO Installation","text":"<p>To install MinIO, follow the steps below:</p> <ol> <li> <p>Check that <code>&lt;edp-project&gt;</code> namespace is created. If not, run the following command to create it:</p> <pre><code>kubectl create namespace &lt;edp-project&gt;\n</code></pre> <p>For the OpenShift users:</p> <p>When using the OpenShift platform, install the <code>SecurityContextConstraints</code> resources. In case of using a custom namespace for the <code>reportportal</code>, change the namespace in the <code>users</code> section.</p> View: report-portal-third-party-resources-scc.yaml <pre><code>apiVersion: security.openshift.io/v1\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: report-portal-minio-rabbitmq-postgresql\nallowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 999\nmax: 65543\ngroups: []\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:report-portal:minio\n- system:serviceaccount:report-portal:rabbitmq\n- system:serviceaccount:report-portal:postgresql\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> View: report-portal-elasticsearch-scc.yaml <pre><code>apiVersion: security.openshift.io/v1\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: report-portal-elasticsearch\nallowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegedContainer: true\nallowedCapabilities: []\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- max: 1000\nmin: 1000\ngroups: []\npriority: 0\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities: []\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMax: 1000\nuidRangeMin: 0\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:report-portal:elasticsearch-master\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Create MinIO admin secret:</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic reportportal-minio-creds \\\n--from-literal=root-password=&lt;root_password&gt; \\\n--from-literal=root-user=&lt;root_user&gt;\n</code></pre> </li> <li> <p>Install MinIO v.11.10.3 using bitnami/minio Helm chart v.11.10.3:</p> <pre><code>helm install minio bitnami/minio \\\n--version 11.10.3 \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the MinIO customization:</p> View: values.yaml <pre><code>auth:\nexistingSecret: reportportal-minio-creds\npersistence:\nsize: 1Gi\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-reportportal/#rabbitmq-installation","title":"RabbitMQ Installation","text":"<p>To install RabbitMQ, follow the steps below:</p> <ol> <li> <p>Use <code>&lt;edp-project&gt;</code> namespace from the MinIO installation.</p> </li> <li> <p>Use <code>bitnami</code> chart repository from the MinIO installation.</p> </li> <li> <p>Create RabbitMQ admin secret:</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic reportportal-rabbitmq-creds \\\n--from-literal=rabbitmq-password=&lt;rabbitmq_password&gt; \\\n--from-literal=rabbitmq-erlang-cookie=&lt;rabbitmq_erlang_cookie&gt;\n</code></pre> <p>Warning</p> <p>The <code>rabbitmq_password</code> password must be 10 characters long. The <code>rabbitmq_erlang_cookie</code> password must be 32 characters long.</p> </li> <li> <p>Install RabbitMQ v.10.3.8 using bitnami/rabbitmq Helm chart v.10.3.8:</p> <pre><code>helm install rabbitmq bitnami/rabbitmq \\\n--version 10.3.8 \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the RabbitMQ customization:</p> View: values.yaml <pre><code>auth:\nexistingPasswordSecret: reportportal-rabbitmq-creds\nexistingErlangSecret: reportportal-rabbitmq-creds\npersistence:\nsize: 1Gi\n</code></pre> </li> <li> <p>After the rabbitmq pod gets the status Running, you need to configure the RabbitMQ memory threshold</p> <pre><code>kubectl -n &lt;edp-project&gt; exec -it rabbitmq-0 -- rabbitmqctl set_vm_memory_high_watermark 0.8\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-reportportal/#elasticsearch-installation","title":"Elasticsearch Installation","text":"<p>To install Elasticsearch, follow the steps below:</p> <ol> <li> <p>Use <code>&lt;edp-project&gt;</code> namespace from the MinIO installation.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add elastic https://helm.elastic.co\nhelm repo update\n</code></pre> </li> <li> <p>Install Elasticsearch v.7.17.3 using elastic/elasticsearch Helm chart v.7.17.3:</p> <pre><code>helm install elasticsearch elastic/elasticsearch \\\n--version 7.17.3 \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the Elasticsearch customization:</p> View: values.yaml <pre><code>replicas: 1\n\nextraEnvs:\n- name: discovery.type\nvalue: single-node\n- name: cluster.initial_master_nodes\nvalue: \"\"\n\nrbac:\ncreate: true\n\nresources:\nrequests:\ncpu: \"100m\"\nmemory: \"2Gi\"\n\nvolumeClaimTemplate:\nresources:\nrequests:\nstorage: 3Gi\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-reportportal/#postgresql-installation","title":"PostgreSQL Installation","text":"<p>To install PostgreSQL, follow the steps below:</p> <ol> <li> <p>Use <code>&lt;edp-project&gt;</code> namespace from the MinIO installation.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add bitnami-archive https://raw.githubusercontent.com/bitnami/charts/archive-full-index/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Create PostgreSQL admin secret:</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic reportportal-postgresql-creds \\\n--from-literal=postgresql-password=&lt;postgresql_password&gt; \\\n--from-literal=postgresql-postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> <p>Warning</p> <p>The <code>postgresql_password</code> and <code>postgresql_postgres_password</code> passwords must be 16 characters long.</p> </li> <li> <p>Install PostgreSQL v.10.9.4 using Helm chart v.10.9.4:</p> <pre><code>helm install postgresql bitnami-archive/postgresql \\\n--version 10.9.4 \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the PostgreSQL customization:</p> View: values.yaml <pre><code>persistence:\nsize: 1Gi\nresources:\nrequests:\ncpu: \"100m\"\nserviceAccount:\nenabled: true\npostgresqlUsername: \"rpuser\"\npostgresqlDatabase: \"reportportal\"\nexistingSecret: \"reportportal-postgresql-creds\"\ninitdbScripts:\ninit_postgres.sh: |\n#!/bin/sh\n/opt/bitnami/postgresql/bin/psql -U postgres -d ${POSTGRES_DB} -c 'CREATE EXTENSION IF NOT EXISTS ltree; CREATE EXTENSION IF NOT EXISTS pgcrypto; CREATE EXTENSION IF NOT EXISTS pg_trgm;'\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-reportportal/#reportportal-installation","title":"ReportPortal Installation","text":"<p>To install ReportPortal, follow the steps below:</p> <ol> <li> <p>Use <code>&lt;edp-project&gt;</code> namespace from the MinIO installation.</p> <p>For the OpenShift users:</p> <p>When using the OpenShift platform, install the <code>SecurityContextConstraints</code> resource. In case of using a custom namespace for the <code>reportportal</code>, change the namespace in the <code>users</code> section.</p> View: report-portal-reportportal-scc.yaml <pre><code>apiVersion: security.openshift.io/v1\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: report-portal\nallowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegedContainer: true\nallowedCapabilities: []\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- max: 1000\nmin: 1000\ngroups: []\npriority: 0\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities: []\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMax: 1000\nuidRangeMin: 0\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:report-portal:reportportal\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add report-portal \"https://reportportal.github.io/kubernetes\"\nhelm repo update\n</code></pre> </li> <li> <p>Install ReportPortal v.5.8.0 using Helm chart v.5.8.0:</p> <pre><code>helm install report-portal report-portal/reportportal \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the ReportPortal customization:</p> View: values.yaml <pre><code>serviceindex:\nresources:\nrequests:\ncpu: 50m\nuat:\nresources:\nrequests:\ncpu: 50m\nserviceui:\nresources:\nrequests:\ncpu: 50m\nserviceAccountName: \"reportportal\"\nsecurityContext:\nrunAsUser: 0\nserviceapi:\nresources:\nrequests:\ncpu: 50m\nserviceanalyzer:\nresources:\nrequests:\ncpu: 50m\nserviceanalyzertrain:\nresources:\nrequests:\ncpu: 50m\n\nrabbitmq:\nSecretName: \"reportportal-rabbitmq-creds\"\nendpoint:\naddress: rabbitmq.&lt;EDP_PROJECT&gt;.svc.cluster.local\nuser: user\napiuser: user\n\npostgresql:\nSecretName: \"reportportal-postgresql-creds\"\nendpoint:\naddress: postgresql.&lt;EDP_PROJECT&gt;.svc.cluster.local\n\nelasticsearch:\nendpoint: http://elasticsearch-master.&lt;EDP_PROJECT&gt;.svc.cluster.local:9200\n\nminio:\nsecretName: \"reportportal-minio-creds\"\nendpoint: http://minio.&lt;EDP_PROJECT&gt;.svc.cluster.local:9000\nendpointshort: minio.&lt;EDP_PROJECT&gt;.svc.cluster.local:9000\naccesskeyName: \"root-user\"\nsecretkeyName: \"root-password\"\n\ningress:\n# IF YOU HAVE SOME DOMAIN NAME SET INGRESS.USEDOMAINNAME to true\nusedomainname: true\nhosts:\n- report-portal-&lt;EDP_PROJECT&gt;.&lt;ROOT_DOMAIN&gt;\n</code></pre> </li> <li> <p>For the OpenShift platform, install a Gateway with Route:</p> View: gateway-config-cm.yaml <pre><code>kind: ConfigMap\nmetadata:\nname: gateway-config\nnamespace: report-portal\napiVersion: v1\ndata:\ntraefik-dynamic-config.yml: |\nhttp:\nmiddlewares:\nstrip-ui:\nstripPrefix:\nprefixes:\n- \"/ui\"\nforceSlash: false\nstrip-api:\nstripPrefix:\nprefixes:\n- \"/api\"\nforceSlash: false\nstrip-uat:\nstripPrefix:\nprefixes:\n- \"/uat\"\nforceSlash: false\n\nrouters:\nindex-router:\nrule: \"Path(`/`)\"\nservice: \"index\"\nui-router:\nrule: \"PathPrefix(`/ui`)\"\nmiddlewares:\n- strip-ui\nservice: \"ui\"\nuat-router:\nrule: \"PathPrefix(`/uat`)\"\nmiddlewares:\n- strip-uat\nservice: \"uat\"\napi-router:\nrule: \"PathPrefix(`/api`)\"\nmiddlewares:\n- strip-api\nservice: \"api\"\n\nservices:\nuat:\nloadBalancer:\nservers:\n- url: \"http://report-portal-reportportal-uat:9999/\"\n\nindex:\nloadBalancer:\nservers:\n- url: \"http://report-portal-reportportal-index:8080/\"\n\napi:\nloadBalancer:\nservers:\n- url: \"http://report-portal-reportportal-api:8585/\"\n\nui:\nloadBalancer:\nservers:\n- url: \"http://report-portal-reportportal-ui:8080/\"\ntraefik.yml: |\nentryPoints:\nhttp:\naddress: \":8081\"\nmetrics:\naddress: \":8082\"\n\nmetrics:\nprometheus:\nentryPoint: metrics\naddEntryPointsLabels: true\naddServicesLabels: true\nbuckets:\n- 0.1\n- 0.3\n- 1.2\n- 5.0\n\nproviders:\nfile:\nfilename: /etc/traefik/traefik-dynamic-config.yml\n</code></pre> View: gateway-deployment.yaml <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\nlabels:\napp: reportportal\nname: gateway\nnamespace: report-portal\nspec:\nreplicas: 1\nselector:\nmatchLabels:\ncomponent: gateway\ntemplate:\nmetadata:\nlabels:\ncomponent: gateway\nspec:\ncontainers:\n- image: quay.io/waynesun09/traefik:2.3.6\nname: traefik\nports:\n- containerPort: 8080\nprotocol: TCP\nresources: {}\nvolumeMounts:\n- mountPath: /etc/traefik/\nname: config\nreadOnly: true\nvolumes:\n- name: config\nconfigMap:\ndefaultMode: 420\nname: gateway-config\n</code></pre> View: gateway-route.yaml <pre><code>kind: Route\napiVersion: route.openshift.io/v1\nmetadata:\nlabels:\napp: reportportal\nname: reportportal\nnamespace: report-portal\nspec:\nhost: report-portal.&lt;CLUSTER_DOMAIN&gt;\nport:\ntargetPort: http\ntls:\ninsecureEdgeTerminationPolicy: Redirect\ntermination: edge\nto:\nkind: Service\nname: gateway\nweight: 100\nwildcardPolicy: None\n</code></pre> View: gateway-service.yaml <pre><code>apiVersion: v1\nkind: Service\nmetadata:\nlabels:\napp: reportportal\ncomponent: gateway\nname: gateway\nnamespace: report-portal\nspec:\nports:\n# use 8081 to allow for usage of the dashboard which is on port 8080\n- name: http\nport: 8081\nprotocol: TCP\ntargetPort: 8081\nselector:\ncomponent:  gateway\nsessionAffinity: None\ntype: ClusterIP\n</code></pre> </li> </ol> <p>Note</p> <p>For user access: default/1q2w3e For admin access: superadmin/erebus Please refer to the ReportPortal.io page for details.</p>"},{"location":"operator-guide/install-reportportal/#related-articles","title":"Related Articles","text":"<ul> <li>Install via Helmfile</li> </ul>"},{"location":"operator-guide/install-tekton/","title":"Install Tekton","text":"<p>EPAM Delivery Platform uses Tekton resources, such as Tasks, Pipelines, Triggers, and Interceptors, for running the CI/CD pipelines.</p> <p>Inspect the main steps to perform for installing the Tekton resources via the Tekton release files.</p>"},{"location":"operator-guide/install-tekton/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.24.0 or higher is installed. Please refer to the Kubernetes official website for details.</li> <li>For Openshift/OKD, the latest version of the <code>oc</code> utility is required. Please refer to the OKD page on GitHub for details.</li> <li>Created AWS ECR repository for Kaniko cache. By default, the Kaniko cache repository name is <code>kaniko-cache</code> and this parameter is located in our Tekton <code>common-library</code>.</li> </ul>"},{"location":"operator-guide/install-tekton/#installation-on-kubernetes-cluster","title":"Installation on Kubernetes Cluster","text":"<p>To install Tekton resources, follow the steps below:</p> <p>Info</p> <p>Please refer to the Install Tekton Pipelines and Install and set up Tekton Triggers sections for details.</p> <ol> <li> <p>Install Tekton pipelines v0.45.0 using the release file:</p> <p>Note</p> <p>Tekton Pipeline resources are used for managing and running EDP Tekton Pipelines and Tasks. Please refer to the EDP Tekton Pipelines and EDP Tekton Tasks pages for details.</p> <pre><code>kubectl apply -f https://storage.googleapis.com/tekton-releases/pipeline/previous/v0.45.0/release.yaml\n</code></pre> </li> <li> <p>Install Tekton Triggers v0.23.0 using the release file:</p> <p>Note</p> <p>Tekton Trigger resources are used for managing and running EDP Tekton EventListeners, Triggers, TriggerBindings and TriggerTemplates. Please refer to the EDP Tekton Triggers page for details.</p> <pre><code>kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/previous/v0.23.0/release.yaml\n</code></pre> </li> <li> <p>Install Tekton Interceptors v0.23.0 using the release file:</p> <p>Note</p> <p>EPAM Delivery Platform uses GitLab and GitHub ClusterInterceptors for managing requests from webhooks.</p> <pre><code>kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/previous/v0.23.0/interceptors.yaml\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-tekton/#installation-on-okd-cluster","title":"Installation on OKD cluster","text":"<p>To install Tekton resources, follow the steps below:</p> <p>Info</p> <p>Please refer to the Install Tekton Operator documentation for details.</p> <p>Note</p> <p>Tekton Operator also deploys Pipelines as Code CI that requires OpenShift v4.11 (based on Kubernetes v1.24) or higher. This feature is optional and its deployments can be scaled to zero replicas.</p> <p>Install Tekton Operator v0.65.1 using the release file:</p> <pre><code>kubectl apply -f https://github.com/tektoncd/operator/releases/download/v0.65.1/openshift-release.yaml\n</code></pre> <p>After the installation, the Tekton Operator will install the following components: Pipeline, Trigger, and Addons.</p> <p>Note</p> <p>If there is the following error in the <code>openshift-operators</code> namespace for <code>openshift-pipelines-operator</code> and <code>tekton-operator-webhook</code> deployments:</p> <pre><code>Error: container has runAsNonRoot and image will run as root\n</code></pre> <p>Patch the deployments with the following commands:</p> <pre><code>kubectl -n openshift-operators patch deployment openshift-pipelines-operator -p '{\"spec\": {\"template\": {\"spec\": {\"securityContext\": {\"runAsUser\": 1000}}}}}'\nkubectl -n openshift-operators patch deployment tekton-operator-webhook -p '{\"spec\": {\"template\": {\"spec\": {\"securityContext\": {\"runAsUser\": 1000}}}}}'\n</code></pre> <p>Grant access for Tekton Service Accounts in the <code>openshift-pipelines</code> namespace to the Privileged SCC:</p> <pre><code>oc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-operators-proxy-webhook\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-pipelines-controller\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-pipelines-resolvers\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-pipelines-webhook\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-triggers-controller\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-triggers-core-interceptors\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-triggers-webhook\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:pipelines-as-code-controller\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:pipelines-as-code-watcher\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:pipelines-as-code-webhook\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:default\n</code></pre>"},{"location":"operator-guide/install-tekton/#related-articles","title":"Related Articles","text":"<ul> <li>Install via Helmfile</li> </ul>"},{"location":"operator-guide/install-velero/","title":"Install Velero","text":"<p>Velero is an open source tool to safely back up, recover, and migrate Kubernetes clusters and persistent volumes. It works both on premises and in a public cloud. Velero consists of a server process running as a deployment in your Kubernetes cluster and a command-line interface (CLI) with which DevOps teams and platform operators configure scheduled backups, trigger ad-hoc backups, perform restores, and more.</p>"},{"location":"operator-guide/install-velero/#installation","title":"Installation","text":"<p>To install Velero, follow the steps below:</p> <ol> <li> <p>Create velero namespace:</p> <pre><code>  kubectl create namespace velero\n</code></pre> <p>Note</p> <p>On an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>  helm repo add vmware-tanzu https://vmware-tanzu.github.io/helm-charts\n  helm repo update\n</code></pre> <p>Note</p> <p>Velero AWS Plugin requires access to AWS resources.  To configure access, please refer to the IRSA for Velero documentation.</p> </li> <li> <p>Install Velero v.2.14.13:</p> <pre><code>  helm install velero vmware-tanzu/velero \\\n  --version 2.14.13 \\\n  --values values.yaml \\\n  --namespace velero\n</code></pre> <p>Check out the values.yaml file sample of the Velero customization:</p> View: values.yaml <pre><code>image:\nrepository: velero/velero\ntag: v1.5.3\nsecurityContext:\nfsGroup: 65534\nrestic:\nsecurityContext:\nfsGroup: 65534\nserviceAccount:\nserver:\ncreate: true\nname: edp-velero\nannotations:\neks.amazonaws.com/role-arn: \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\"\ncredentials:\nuseSecret: false\nconfiguration:\nprovider: aws\nbackupStorageLocation:\nname: default\nbucket: velero-&lt;CLUSTER_NAME&gt;\nconfig:\nregion: eu-central-1\nvolumeSnapshotLocation:\nname: default\nconfig:\nregion: &lt;AWS_REGION&gt;\ninitContainers:\n- name: velero-plugin-for-aws\nimage: velero/velero-plugin-for-aws:v1.1.0\nvolumeMounts:\n- mountPath: /target\nname: plugins\n</code></pre> <p>Note</p> <p>In case of using cluster scheduling and amazon-eks-pod-identity-webhook, it is necessary to restart the Velero pod after the cluster is up and running. Please refer to the Schedule Pods Restart documentation.</p> </li> <li> <p>Install the client side (velero cli) according to the official documentation.</p> </li> </ol>"},{"location":"operator-guide/install-velero/#configuration","title":"Configuration","text":"<ol> <li> <p>Create backup for all components in the namespace:</p> <pre><code>  velero backup create &lt;BACKUP_NAME&gt; --include-namespaces &lt;NAMESPACE&gt;\n</code></pre> </li> <li> <p>Create a daily backup of the namespace:</p> <pre><code>  velero schedule create &lt;BACKUP_NAME&gt;  --schedule \"0 10 * * MON-FRI\" --include-namespaces &lt;NAMESPACE&gt; --ttl 120h0m0s\n</code></pre> </li> <li> <p>To restore from backup, use the following command:</p> <pre><code>  velero restore create &lt;RESTORE_NAME&gt; --from-backup &lt;BACKUP_NAME&gt;\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/","title":"Install via Helmfile","text":"<p>This article provides the instruction on how to deploy EDP and components in Kubernetes using Helmfile that is intended for deploying Helm charts. Helmfile templates are available in GitHub repository.</p>"},{"location":"operator-guide/install-via-helmfile/#prerequisites","title":"Prerequisites","text":"<p>The following tools and plugins must be installed:</p> <ul> <li>Kubectl version 1.23.0</li> <li>Helm version 3.10.0+</li> <li>Helmfile version 0.144.0</li> <li>Helm diff plugin version 3.6.0</li> </ul>"},{"location":"operator-guide/install-via-helmfile/#helmfile-structure","title":"Helmfile Structure","text":"<ul> <li>The <code>envs/common.yaml</code> file contains the specification for environments pattern, list of helm repositories from which it is necessary to fetch the helm charts and additional Helm parameters.</li> <li>The <code>envs/platform.yaml</code> file contains global parameters that are used in various Helmfiles.</li> <li>The <code>releases/envs/</code> contains symbol links to environments files.</li> <li>The <code>releases/*.yaml</code> file contains description of parameters that is used when deploying a Helm chart.</li> <li>The <code>helmfile.yaml</code> file defines components to be installed by defining a path to Helm releases files.</li> <li>The <code>envs/ci.yaml</code> file contains stub parameters for CI linter.</li> <li>The <code>test/lint-ci.sh</code> script for running CI linter with debug loglevel and stub parameters.</li> <li>The <code>resources/*.yaml</code> file contains additional resources for the OpenShift platform.</li> </ul>"},{"location":"operator-guide/install-via-helmfile/#operate-helmfile","title":"Operate Helmfile","text":"<p>Before applying the Helmfile, please fill in the global parameters in the <code>envs/platform.yaml</code> (check the examples in the <code>envs/ci.yaml</code>) and <code>releases/*.yaml</code> files for every Helm deploy.</p> <p>Pay attention to the following recommendations while working with the Helmfile:</p> <ul> <li>To launch Lint, run the <code>test/lint-ci.sh</code> script.</li> </ul> <ul> <li>Display the difference between the deployed and environment state (<code>helm diff</code>):<pre><code>helmfile --environment platform -f helmfile.yaml diff\n</code></pre> </li> </ul> <ul> <li>Apply the deployment:<pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ul> <ul> <li>Modify the deployment and apply the changes:<pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml sync\n</code></pre> </li> </ul> <ul> <li>To deploy the components according to the label, use the selector to target a subset of releases when running the Helmfile. It can be useful for large Helmfiles with the releases that are logically grouped together. For example, to display the difference only for the <code>nginx-ingress</code> file, use the following command:<pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml diff\n</code></pre> </li> </ul> <ul> <li>To destroy the release, run the following command:<pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml destroy\n</code></pre> </li> </ul>"},{"location":"operator-guide/install-via-helmfile/#deploy-components","title":"Deploy Components","text":"<p>Using the Helmfile, the following components can be installed:</p> <ul> <li>NGINX Ingress Controller</li> <li>Keycloak</li> <li>EPAM Delivery Platform</li> <li>Argo CD</li> <li>External Secrets Operator</li> <li>DefectDojo</li> <li>Moon</li> <li>ReportPortal</li> <li>Kiosk</li> <li>Monitoring stack, included Prometheus, Alertmanager, Grafana, PrometheusOperator</li> </ul> <ul> <li>Logging ELK stack, included Elasticsearch, Fluent-bit, Kibana</li> <li>Logging Grafana/Loki stack, included Grafana, Loki, Promtail, Logging Operator, Logging Operator Logging</li> </ul>"},{"location":"operator-guide/install-via-helmfile/#deploy-nginx-ingress-controller","title":"Deploy NGINX Ingress Controller","text":"<p>Info</p> <p>Skip this step for the OpenShift platform, because it has its own Ingress Controller.</p> <p>To install NGINX Ingress controller, follow the steps below:</p> <ol> <li> <p>In the <code>releases/nginx-ingress.yaml</code> file, set the <code>proxy-real-ip-cidr</code> parameter according to the value with AWS VPC IPv4 CIDR.</p> </li> <li> <p>Install NGINX Ingress controller:</p> <pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-keycloak","title":"Deploy Keycloak","text":"<p>Keycloak requires a database deployment, so it has two charts: <code>releases/keycloak.yaml</code> and <code>releases/postgresql-keycloak.yaml</code>.</p> <p>To install Keycloak, follow the steps below:</p> <ol> <li> <p>Create a <code>security</code> namespace:</p> <p>Note</p> <p>For the OpenShift users: This namespace is also indicated as <code>users</code> in the following custom <code>SecurityContextConstraints</code> resources: <code>resources/keycloak-scc.yaml</code> and <code>resources/postgresql-keycloak-scc.yaml</code>. Change the namespace name when using a custom namespace.</p> <pre><code>kubectl create namespace security\n</code></pre> </li> <li> <p>Create PostgreSQL admin secret:</p> <pre><code>kubectl -n security create secret generic keycloak-postgresql \\\n--from-literal=password=&lt;postgresql_password&gt; \\\n--from-literal=postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> </li> <li> <p>In the <code>envs/platform.yaml</code> file, set the <code>dnsWildCard</code> parameter.</p> </li> <li> <p>Create Keycloak admin secret:</p> <pre><code>kubectl -n security create secret generic keycloak-admin-creds \\\n--from-literal=username=&lt;keycloak_admin_username&gt; \\\n--from-literal=password=&lt;keycloak_admin_password&gt;\n</code></pre> </li> <li> <p>Install Keycloak:</p> <pre><code>helmfile  --selector component=sso --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-external-secrets-operator","title":"Deploy External Secrets Operator","text":"<p>To install External Secrets Operator, follow the steps below:</p> <pre><code>helmfile --selector component=secrets --environment platform -f helmfile.yaml apply\n</code></pre>"},{"location":"operator-guide/install-via-helmfile/#deploy-kiosk","title":"Deploy Kiosk","text":"<p>To install Kiosk, follow the steps below:</p> <pre><code>helmfile --selector component=kiosk --environment platform -f helmfile.yaml apply\n</code></pre>"},{"location":"operator-guide/install-via-helmfile/#deploy-epam-delivery-platform","title":"Deploy EPAM Delivery Platform","text":"<p>To install EDP, follow the steps below:</p> <ol> <li> <p>Create a <code>platform</code> namespace:</p> <pre><code>kubectl create namespace platform\n</code></pre> </li> <li> <p>For EDP, it is required to have Keycloak access to perform the integration. Create a secret with the user and password provisioned in the step 2 of the Keycloak Configuration section.</p> <pre><code>kubectl -n platform create secret generic keycloak \\\n  --from-literal=username=&lt;username&gt; \\\n  --from-literal=password=&lt;password&gt;\n</code></pre> </li> <li> <p>In the <code>envs/platform.yaml</code> file, set the <code>edpName</code> and <code>keycloakEndpoint</code> parameters.</p> </li> <li> <p>In the <code>releases/edp-install.yaml</code> file, check and fill in all values.</p> </li> <li> <p>Install EDP:</p> <pre><code>helmfile  --selector component=edp --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-argo-cd","title":"Deploy Argo CD","text":"<p>Before Argo CD deployment, install the following tools:</p> <ul> <li>Keycloak</li> <li>EDP</li> </ul> <p>To install Argo CD, follow the steps below:</p> <ol> <li> <p>Install Argo CD:</p> <p>For the OpenShift users:<p>When using a custom namespace for Argo CD, the <code>argocd</code> namespace is also indicated as <code>users</code> in the <code>resources/argocd-scc.yaml</code> custom <code>SecurityContextConstraints</code> resource. Change it there as well.</p> </p> <pre><code>helmfile --selector component=argocd --environment platform -f helmfile.yaml apply\n</code></pre> </li> <li> <p>Update the <code>argocd-secret</code> secret in the Argo CD namespace by providing the correct Keycloak client secret (<code>oidc.keycloak.clientSecret</code>) with the value from the <code>keycloak-client-argocd-secret</code> secret in EDP namespace. Then restart the deployment:</p> <pre><code>ARGOCD_CLIENT=$(kubectl -n platform get secret keycloak-client-argocd-secret  -o jsonpath='{.data.clientSecret}')\nkubectl -n argocd patch secret argocd-secret -p=\"{\\\"data\\\":{\\\"oidc.keycloak.clientSecret\\\": \\\"${ARGOCD_CLIENT}\\\"}}\" -v=1\nkubectl -n argocd rollout restart deployment argo-argocd-server\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-defectdojo","title":"Deploy DefectDojo","text":"<p>Prerequisites</p> <ol> <li>Before DefectDojo deployment,first make sure to have the Keycloak configuration.</li> </ol> <p>Info</p> <p>It is also possible to install DefectDojo via Helm Chart. For details, please refer to the Install DefectDojo page.</p> <p>To install DefectDojo via Helmfile, follow the steps below:</p> <ol> <li> <p>Create a DefectDojo namespace:</p> <p>For the OpenShift users:</p> <p>This namespace is also indicated as <code>users</code> in the <code>resources/defectdojo-scc.yaml</code> custom <code>SecurityContextConstraints</code> resource. Change it when using a custom namespace. Also, change the namespace in the <code>resources/defectdojo-route.yaml</code> file.</p> <pre><code>kubectl create namespace defectdojo\n</code></pre> </li> <li> <p>Modify the <code>host</code> in <code>resources/defectdojo-route.yaml</code> (only for OpenShift).</p> </li> <li> <p>Create a PostgreSQL admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo-postgresql-specific \\\n--from-literal=postgresql-password=&lt;postgresql_password&gt; \\\n--from-literal=postgresql-postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> <p>Note</p> <p>The <code>postgresql_password</code> and <code>postgresql_postgres_password</code> passwords must be 16 characters long.</p> </li> <li> <p>Create a RabbitMQ admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo-rabbitmq-specific \\\n--from-literal=rabbitmq-password=&lt;rabbitmq_password&gt; \\\n--from-literal=rabbitmq-erlang-cookie=&lt;rabbitmq_erlang_cookie&gt;\n</code></pre> <p>Note</p> <p>The <code>rabbitmq_password</code> password must be 10 characters long.</p> <p>The <code>rabbitmq_erlang_cookie</code> password must be 32 characters long.</p> </li> <li> <p>Create a DefectDojo admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo \\\n--from-literal=DD_ADMIN_PASSWORD=&lt;dd_admin_password&gt; \\\n--from-literal=DD_SECRET_KEY=&lt;dd_secret_key&gt; \\\n--from-literal=DD_CREDENTIAL_AES_256_KEY=&lt;dd_credential_aes_256_key&gt; \\\n--from-literal=METRICS_HTTP_AUTH_PASSWORD=&lt;metric_http_auth_password&gt;\n</code></pre> <p>Note</p> <p>The <code>dd_admin_password</code> password must be 22 characters long.</p> <p>The <code>dd_secret_key</code> password must be 128 characters long.</p> <p>The <code>dd_credential_aes_256_key</code> password must be 128 characters long.</p> <p>The <code>metric_http_auth_password</code> password must be 32 characters long.</p> </li> <li> <p>Create a Keycloak client secret for DefectDojo:</p> <p>Note</p> <p>The <code>keycloak_client_secret</code> value received from: <code>edpName</code>-main realm -&gt; clients -&gt; defectdojo -&gt; Credentials -&gt; Client secret</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo-extrasecrets \\\n--from-literal=DD_SOCIAL_AUTH_KEYCLOAK_SECRET=&lt;keycloak_client_secret&gt;\n</code></pre> </li> <li> <p>In the <code>envs/platform.yaml</code> file, set the <code>dnsWildCard</code> parameter.</p> </li> <li> <p>In the releases/defectdojo.yaml file, check and fill in all values.</p> </li> <li> <p>Install DefectDojo:</p> <pre><code>helmfile  --selector component=defectdojo --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-reportportal","title":"Deploy ReportPortal","text":"<p>Info</p> <p>It is also possible to install ReportPortal via Helm Chart. For details, please refer to the Install ReportPortal page.</p> <p>ReportPortal requires third-party deployments: RabbitMQ, ElasticSearch, PostgreSQL, MinIO.</p> <p>To install third-party resources, follow the steps below:</p> <ol> <li> <p>Create a RabbitMQ admin secret:</p> <pre><code>kubectl -n report-portal create secret generic reportportal-rabbitmq-creds \\\n--from-literal=rabbitmq-password=&lt;rabbitmq_password&gt; \\\n--from-literal=rabbitmq-erlang-cookie=&lt;rabbitmq_erlang_cookie&gt;\n</code></pre> <p>Warning</p> <p>The <code>rabbitmq_password</code> password must be 10 characters long.</p> <p>The <code>rabbitmq_erlang_cookie</code> password must be 32 characters long.</p> </li> <li> <p>Create a PostgreSQL admin secret:</p> <pre><code>kubectl -n report-portal create secret generic reportportal-postgresql-creds \\\n--from-literal=postgresql-password=&lt;postgresql_password&gt; \\\n--from-literal=postgresql-postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> <p>Warning</p> <p>The <code>postgresql_password</code> and <code>postgresql_postgres_password</code> passwords must be 16 characters long.</p> </li> <li> <p>Create a MinIO admin secret:</p> <pre><code>kubectl -n report-portal create secret generic reportportal-minio-creds \\\n--from-literal=root-password=&lt;root_password&gt; \\\n--from-literal=root-user=&lt;root_user&gt;\n</code></pre> </li> <li> <p>In the <code>envs/platform.yaml</code> file, set the <code>dnsWildCard</code> and <code>edpName</code> parameters.</p> <p>For the OpenShift users:</p> <p>The namespace is also indicated as <code>users</code> in the following custom <code>SecurityContextConstraints</code> resources: <code>resources/report-portal-elasticsearch-scc.yaml</code> and <code>resources/report-portal-third-party-resources-scc.yaml</code>. Change the namespace name when using a custom namespace.</p> </li> <li> <p>Install third-party resources:</p> <pre><code>helmfile --selector component=report-portal-third-party-resources --environment platform -f helmfile.yaml apply\n</code></pre> </li> <li> <p>After the rabbitmq pod gets the status Running, you need to configure the RabbitMQ memory threshold</p> <pre><code>kubectl -n report-portal exec -it rabbitmq-0 -- rabbitmqctl set_vm_memory_high_watermark 0.8\n</code></pre> </li> </ol> <p>To install ReportPortal via Helmfile, follow the steps below:</p> <p>For the OpenShift users:</p> <ol> <li>The namespace is also indicated as <code>users</code> in the <code>resources/report-portal-reportportal-scc.yaml</code> custom <code>SecurityContextConstraints</code> resource. Change it when using a custom namespace.</li> <li>Change the namespace in the following files: <code>resources/report-portal-gateway/gateway-config-cm</code>, <code>resources/report-portal-gateway/gateway-deployment</code>, <code>resources/report-portal-gateway/gateway-route</code>, and <code>resources/report-portal-gateway/gateway-service</code>.</li> <li>Modify the <code>host</code> in <code>resources/report-portal-gateway/gateway-route</code></li> </ol> <pre><code>helmfile --selector component=report-portal --environment platform -f helmfile.yaml apply\n</code></pre> <p>Note</p> <p>For user access: default/1q2w3e For admin access: superadmin/erebus Please refer to the ReportPortal.io page for details.</p>"},{"location":"operator-guide/install-via-helmfile/#deploy-moon","title":"Deploy Moon","text":"<p>Moon is a browser automation solution compatible with Selenium, Cypress, Playwright, and Puppeteer using Kubernetes or Openshift to launch browsers.</p> <p>Note</p> <p>Aerokube/Moon does not require third-party deployments.</p> <p>Follow the steps below to deploy Moon:</p> <ol> <li> <p>Use the following command to install Moon:</p> <pre><code>helmfile --selector component=moon --environment platform -f helmfile.yaml apply\n</code></pre> </li> <li> <p>After the installation, open the Ingress Dashboard and check that <code>SELENOID</code> and <code>SSE</code> have the <code>CONNECTED</code> status.</p> <p> Main board </p> </li> <li> <p>In Moon, use the following command with the Ingress rule, for example, <code>wd/hub</code>:</p> <pre><code>    curl -X POST 'http://&lt;INGRESS_LINK&gt;/wd/hub/session' -d '{\n                \"desiredCapabilities\":{\n                    \"browserName\":\"firefox\",\n                    \"version\": \"79.0\",\n                    \"platform\":\"ANY\",\n                    \"enableVNC\": true,\n                    \"name\": \"edp\",\n                    \"sessionTimeout\": \"480s\"\n                }\n            }'\n</code></pre> <p>See below the list of Moon Dashboard Ingress rules:</p> <p> Moon Dashboard Ingress rules </p> <p>After using the command above, the container will start, and the VNC viewer will be displayed on the Moon Dashboard:</p> <p> VNC viewer with the container starting </p> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-monitoring","title":"Deploy Monitoring","text":"<p>The monitoring stack includes Grafana, Prometheus, Alertmanager, and Karma-dashboard. To deploy it follow the steps:</p> <ol> <li> <p>Generate a token for Keycloak client:</p> <p>Note</p> <p>The token must be 32-character and include alphabetic and numeric symbols. For example, use the following command:</p> <pre><code>keycloak_client_secret=$(date +%s | sha256sum | base64 | head -c 32 ; echo)\n</code></pre> </li> <li> <p>Create a secret for the Keycloak client:</p> <pre><code>kubectl -n platform create secret generic keycloak-client-grafana \\\n--from-literal=clientSecret=&lt;keycloak_client_secret&gt;\n</code></pre> </li> <li> <p>Create a secret for the Grafana:</p> <pre><code>kubectl -n monitoring create secret generic keycloak-client-grafana \\\n--from-literal=GF_AUTH_GENERIC_OAUTH_CLIENT_SECRET=&lt;keycloak_client_secret&gt; \\\n</code></pre> </li> <li> <p>Create a custom resource for the Keycloak client:</p> View: keycloak_client <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakClient\nmetadata:\nname: grafana\nnamespace: platform\nspec:\nclientId: grafana\ndirectAccess: true\nserviceAccount:\nenabled: true\ntargetRealm: platform-main\nwebUrl: https://grafana-monitoring.&lt;dnsWildCard&gt;\nsecret: keycloak-client.grafana\n</code></pre> </li> <li> <p>Run command:</p> <pre><code>helmfile --selector component=monitoring --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-logging","title":"Deploy Logging","text":"ELK stackGrafana, Loki, Promtail stack <p>To install Elasticsearch, Kibana and Fluentbit, run command:</p> <pre><code>helmfile --selector component=logging-elastic --environment platform -f helmfile.yaml apply\n</code></pre> <p>To install Grafana, Loki, Promtail, follow the steps below:</p> <ol> <li> <p>Make sure that appropriate resources are created:</p> <ul> <li>Secret for the Keycloak client</li> </ul> <ul> <li>Secret for the Grafana</li> </ul> </li> <li> <p>Create a custom resource for the Keycloak client:</p> View: keycloak_client <pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakClient\nmetadata:\nname: grafana\nnamespace: platform\nspec:\nclientId: grafana-logging\ndirectAccess: true\nserviceAccount:\nenabled: true\ntargetRealm: platform-main\nwebUrl: https://grafana-logging.&lt;dnsWildCard&gt;\nsecret: keycloak-client.grafana\n</code></pre> </li> <li> <p>Run command:</p> <pre><code>helmfile --selector component=logging --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Install NGINX Ingress Controller</li> <li>Install Keycloak</li> <li>Install DefectDojo</li> <li>Install ReportPortal</li> <li>Install Argo CD</li> </ul>"},{"location":"operator-guide/jira-gerrit-integration/","title":"Adjust VCS Integration With Jira","text":"<p>In order to adjust the Version Control System integration with Jira Server, first make sure you have the following prerequisites:</p> <ul> <li>VCS Server</li> <li>Jira</li> <li>Crucible</li> </ul> <p>When checked the prerequisites, follow the steps below to proceed with the integration:</p> <ol> <li> <p>Integrate every project in VCS Server with every project in Crucible by creating a corresponding request in EPAM Support Portal. Add the repositories links and fill in the Keep Informed field as this request must be approved.</p> <p> Request example </p> </li> <li> <p>Provide additional details to the support team. If the VCS is Gerrit, inspect the sample below of its integration:</p> <p>2.1 Create a new \"crucible-\" user in Gerrit with SSH key and add a new user to the \"Non-Interactive Users\" Gerrit group; <p>2.2 Create a new group in Gerrit \"crucible-watcher-group\" and add the \"crucible-\" user; <p>2.3 Provide access to All-Projects for the \"crucible-watcher-group\" group:</p> <p> Gerrit All-Projects configuration </p> <p> Gerrit All-Projects configuration </p> <li> <p>To link commits with Jira ticket, being in Gerrit, enter a Jira ticket ID in a commit message using the specific format:</p> <p>[PROJECT-CODE-1234]: commit message</p> <p>where PROJECT-CODE is a specific code of a project, 1234 is an ID number, and a commit message.</p> </li> <li> <p>As a result, all Gerrit commits will be displayed on Crucible:</p> <p> Crucible project </p> </li>"},{"location":"operator-guide/jira-gerrit-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Adjust Jira Integration</li> </ul>"},{"location":"operator-guide/jira-integration/","title":"Adjust Jira Integration","text":"<p>This documentation guide provides step-by-step instructions for enabling the Jira integration option in the Headlamp UI for EPAM Delivery Platform. Jira integration allows including useful metadata in Jira tickets.</p>"},{"location":"operator-guide/jira-integration/#overview","title":"Overview","text":"<p>Integrating Jira can provide a number of benefits, such as increased visibility and traceability, automatic linking code changes to relevant Jira issues, streamlining the management and tracking of development progress.</p> <p>By linking CI pipelines to Jira issues, teams can get a better understanding of the status of their work and how it relates to the overall development process. This can help to improve communication and collaboration, and ultimately lead to faster and more efficient delivery of software.</p> <p>Enabling Jira integration allows for the automatic population of three fields in Jira tickets: Fix Versions, Components, and Labels. Each of these fields provides distinct benefits:</p> <ul> <li>Fix Versions: helps track progress against release schedules;</li> <li>Components: allows grouping related issues together;</li> <li>Labels: enables identification of specific types of work.</li> </ul> <p>Teams can utilize these fields to enhance their work prioritization, identify dependencies, improve collaboration, and ultimately achieve faster software delivery.</p>"},{"location":"operator-guide/jira-integration/#integration-procedure","title":"Integration Procedure","text":"<p>In order to adjust the Jira server integration, first add JiraServer CR by performing the following:</p> <ol> <li> <p>Create the secret in the  namespace for Jira Server account. Fill in the username and password fields with your own values: External Secret OperatorManually <p>By default, EDP allows to get a value from the SecretStore, in which the value of <code>jira-user</code>:</p> /edp/deploy-secrets<pre><code>{\n\"jira-user\": { \"username\": \"usernameInBase64\", \"password\": \"passwordInBase64\" }\n}\n</code></pre> <pre><code>apiVersion: v1\ndata:\npassword: passwordInBase64\nusername: usernameInBase64\nkind: Secret\nmetadata:\nname: jira-user\ntype: kubernetes.io/basic-auth\n</code></pre> <li> <p>Create JiraServer CR in the OpenShift/Kubernetes namespace with the apiUrl, credentialName and rootUrl fields:</p> <pre><code>apiVersion: v2.edp.epam.com/v1\nkind: JiraServer\nmetadata:\nname: jira-server\nspec:\napiUrl: 'https://jira-api.example.com'\ncredentialName: jira-user\nrootUrl: 'https://jira.example.com'\n</code></pre> <p>Note</p> <p>The value of the credentialName property is the name of the Secret, which is indicated in the first point above.</p> </li> <li> <p>In the Headlamp UI, navigate to the Advanced Settings menu to check that the Integrate with Jira server check box appeared:</p> <p> Advanced settings </p> <p>Note</p> <p>There are four predefined variables with the respective values that can be specified singly or as a combination:</p> <p>EDP_COMPONENT \u2013 returns application-name EDP_VERSION \u2013 returns 0.0.0-SNAPSHOT or 0.0.0-RC EDP_SEM_VERSION \u2013 returns 0.0.0 EDP_GITTAG \u2013 returns build/0.0.0-SNAPSHOT.2 or build/0.0.0-RC.2</p> <p>There are no character restrictions when combining the variables, combination samples: EDP_SEM_VERSION-EDP_COMPONENT or EDP_COMPONENT-hello-world/EDP_VERSION, etc.</p> <p>As a result of successful Jira integration, the additional information will be added to tickets.</p> </li>"},{"location":"operator-guide/jira-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Adjust VCS Integration With Jira</li> <li>Add Application</li> </ul>"},{"location":"operator-guide/kaniko-irsa/","title":"IAM Roles for Kaniko Service Accounts","text":"<p>Note</p> <p>The information below is relevant in case ECR is used as Docker container registry. Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation.</p> <p>The \"build-image-kaniko\" stage manages ECR through IRSA that should be available on the cluster. Follow the steps below to create a required role:</p> <ol> <li> <p>Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko_policy\":</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n        \"Effect\": \"Allow\",\n        \"Action\": [\n            \"ecr:*\",\n            \"cloudtrail:LookupEvents\"\n        ],\n        \"Resource\": \"arn:aws:ecr:&lt;AWS_REGION&gt;:&lt;AWS_ACCOUNT_ID&gt;:repository/&lt;EDP_NAMESPACE&gt;/*\"\n    },\n    {\n        \"Effect\": \"Allow\",\n        \"Action\": \"ecr:GetAuthorizationToken\",\n        \"Resource\": \"*\"\n    },\n    {\n        \"Effect\": \"Allow\",\n        \"Action\": [\n            \"ecr:DescribeRepositories\",\n            \"ecr:CreateRepository\"\n        ],\n        \"Resource\": \"arn:aws:ecr:&lt;AWS_REGION&gt;:&lt;AWS_ACCOUNT_ID&gt;:repository/*\"\n    }\n  ]\n}\n</code></pre> </li> <li> <p>Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\" with trust relationships:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;OIDC_PROVIDER&gt;\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"&lt;OIDC_PROVIDER&gt;:sub\": \"system:serviceaccount:&lt;EDP_NAMESPACE&gt;:edp-kaniko\"\n        }\n      }\n    }\n  ]\n}\n</code></pre> </li> <li> <p>Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\" role.</p> </li> <li> <p>Define the resulted arn role value into the kaniko.roleArn parameter in values.yaml during the EDP installation.</p> </li> </ol>"},{"location":"operator-guide/kaniko-irsa/#related-articles","title":"Related Articles","text":"<ul> <li>Associate IAM Roles With Service Accounts</li> <li>Install EDP</li> </ul>"},{"location":"operator-guide/kibana-ilm-rollover/","title":"Aggregate Application Logs Using EFK Stack","text":"<p>This documentation describes the advantages of EFK stack over the traditional ELK stack, explains the value that this stack brings to EDP and instructs how to set up the EFK stack to integrate the advanced logging system with your application.</p>"},{"location":"operator-guide/kibana-ilm-rollover/#elk-stack-overview","title":"ELK Stack Overview","text":"<p>The ELK (Elasticsearch, Logstash and Kibana) stack gives the ability to aggregate logs from all the managed systems and applications, analyze these logs and create visualizations for application and infrastructure monitoring, faster troubleshooting, security analytics and more.</p> <p>Here is a brief description of the ELK stack default components:</p> <ul> <li>Beats family - The logs shipping tool that conveys logs from the source locations, such as Filebeat, Metricbeat, Packetbeat, etc. Beats can work instead of Logstash or along with it.</li> <li>Logstash - The log processing framework for log collecting, processing, storing and searching activities.</li> <li>Elasticsearch - The distributed search and analytics engine based on Lucene Java library.</li> <li>Kibana - The visualization engine that queries the data from Elasticsearch.</li> </ul> <p> ELK Stack </p>"},{"location":"operator-guide/kibana-ilm-rollover/#efk-stack-overview","title":"EFK Stack Overview","text":"<p>We use FEK (also called EFK) (Fluent Bit, Elasticsearch, Kibana) stack in Kubernetes instead of ELK because this stack provides us with the support for Logsight for Stage Verification and Incident Detection. In addition to it, Fluent Bit has a smaller memory fingerprint than Logstash. Fluent Bit has the Inputs, Parsers, Filters and Outputs plugins similarly to Logstash.</p> <p> FEK Stack </p>"},{"location":"operator-guide/kibana-ilm-rollover/#automate-elasticsearch-index-rollover-with-ilm","title":"Automate Elasticsearch Index Rollover With ILM","text":"<p>In this guide, index rollover with the Index Lifecycle Management ILM is automated in the FEK stack.</p> <p>The resources can be created via API using curl, Postman, Kibana Dev Tools console or via GUI. They are going to be created them using Kibana Dev Tools.</p> <ol> <li> <p>Go to <code>Management</code> \u2192 <code>Dev Tools</code> in the Kibana dashboard:</p> <p> Dev Tools </p> </li> <li> <p>Create index lifecycle policy with the index rollover:</p> <p>Note</p> <p>This policy can also be created in GUI in <code>Management</code> \u2192 <code>Stack Management</code> \u2192 <code>Index Lifecycle Policies</code>.</p> <p>Index Lifecycle has several phases: Hot, Warm, Cold, Frozen, Delete. Indices also have different priorities in each phase. The warmer the phase, the higher the priority is supposed to be, e.g., 100 for the hot phase, 50 for the warm phase, and 0 for the cold phase. </p> <p>In this Use Case, only the Hot and Delete phases are configured. So an index will be created, rolled over to a new index when 1gb in size or 1day in time and deleted in 7 days. The rollover may not happen exactly at 1GB because it depends on how often Kibana checks the index size. Kibana usually checks the index size every 10 minutes but this can be changed by setting the indices.lifecycle.poll_interval monitoring timer.</p> <p>The index lifecycle policy example:</p> Index Lifecycle Policy <pre><code>PUT _ilm/policy/fluent-bit-policy\n{\n\"policy\": {\n\"phases\": {\n\"hot\": {\n\"min_age\": \"0ms\",\n\"actions\": {\n\"set_priority\": {\n\"priority\": 100\n},\n\"rollover\": {\n\"max_size\": \"1gb\",\n\"max_primary_shard_size\": \"1gb\",\n\"max_age\": \"1d\"\n}\n}\n},\n\"delete\": {\n\"min_age\": \"7d\",\n\"actions\": {\n\"delete\": {\n\"delete_searchable_snapshot\": true\n}\n}\n}\n}\n}\n}\n</code></pre> <p>Insert the code above into the <code>Dev Tools</code> and click the arrow to send the <code>PUT</code> request.</p> </li> <li> <p>Create an index template so that a new index is created according to this template after the rollover:</p> <p>Note</p> <p>This policy can also be created in GUI in <code>Management</code> \u2192 <code>Stack Management</code> \u2192 <code>Index Management</code> \u2192 <code>Index Templates</code>.</p> <p>Expand the menu below to see the index template example:</p> Index Template <pre><code>PUT /_index_template/fluent-bit\n{\n\"index_patterns\": [\"fluent-bit-kube-*\"],\n\"template\": {\n\"settings\": {\n\"index\": {\n\"lifecycle\": {\n\"name\": \"fluent-bit-policy\",\n\"rollover_alias\": \"fluent-bit-kube\"\n},\n\"number_of_shards\": \"1\",\n\"number_of_replicas\": \"0\"\n}\n}\n}\n}\n</code></pre> <p>Note</p> <ul> <li><code>index.lifecycle.rollover_alias</code> is required when using a policy containing the rollover action and specifies which alias to rollover on behalf of this index. The intention here is that the rollover alias is also defined on the index.</li> </ul> <ul> <li><code>number_of_shards</code> is the quantity of the primary shards. Elasticsearch index is really just a logical grouping of one or more physical shards, where each shard is actually a self-contained index. By distributing the documents in an index across multiple shards and distributing those shards across multiple nodes, Elasticsearch can ensure redundancy, which both protects against hardware failures and increases query capacity as nodes are added to a cluster. As the cluster grows (or shrinks), Elasticsearch automatically migrates shards to re-balance the cluster. Please refer to the official documentation here.</li> </ul> <ul> <li> <p><code>number_of_replicas</code> is the number of replica shards. A replica shard is a copy of a primary shard. Elasticsearch will never assign a replica to the same node as the primary shard, so make sure you have more than one node in your Elasticsearch cluster if you need to use replica shards. The Elasticsearch cluster details and the quantity of nodes can be checked with:</p> <pre><code>GET _cluster/health\n</code></pre> </li> </ul> <p>Since we use one node, the number_of_shards  is 1 and number_of_replicas is 0. If you put more replicas within one node, your index will get yellow status in Kibana, yet still be working.</p> </li> <li> <p>Create an empty index with write permissions:</p> <p>Note</p> <p>This index can also be created in GUI in <code>Management</code> \u2192 <code>Stack Management</code> \u2192 <code>Index Management</code> \u2192 <code>Indices</code>.</p> <p>Index example with the date math format:</p> Index <pre><code># URI encoded /&lt;fluent-bit-kube-{now/d}-000001&gt;\nPUT /%3Cfluent-bit-kube-%7Bnow%2Fd%7D-000001%3E\n{\n\"aliases\": {\n\"fluent-bit-kube\": {\n\"is_write_index\": true\n}\n}\n}\n</code></pre> <p>The code above will create an index in the<code>{index_name}-{current_date}-{rollover_index_increment}</code> format. For example: <code>fluent-bit-kube-2023.03.17-000001</code>.</p> <p>Please refer to the official documentation on the index rollover with Date Math here.</p> <p>Note</p> <p>It is also possible to use index pattern below if the date math format does not seem applicable:</p> <p> Index <pre><code>PUT fluent-bit-kube-000001\n{\n\"aliases\": {\n\"fluent-bit-kube\": {\n\"is_write_index\": true\n}\n}\n}\n</code></pre> </p> <p>Check the status of the created index:</p> <pre><code>GET fluent-bit-kube*-000001/_ilm/explain\n</code></pre> </li> <li> <p>Configure Fluent Bit. Play attention to the Elasticsearch Output plugin configuration.</p> <p>The important fields in the <code>[OUTPUT]</code> section are <code>Index fluent-bit-kube</code> since we should use the index with the same name as Rollover Alias in Kibana and <code>Logstash_Format Off</code> as we use the Rollover index pattern in Kibana that increments by 1.</p> <p>ConfigMap example with Configuration Variables for <code>HTTP_User</code> and <code>HTTP_Passwd</code>:</p> ConfigMap fluent-bit <pre><code>data:\nfluent-bit.conf: |\n[SERVICE]\nDaemon Off\nFlush 10\nLog_Level info\nParsers_File parsers.conf\nParsers_File custom_parsers.conf\nHTTP_Server On\nHTTP_Listen 0.0.0.0\nHTTP_Port 2020\nHealth_Check On\n\n[INPUT]\nName tail\nTag kube.*\nPath /var/log/containers/*.log\nParser docker\nMem_Buf_Limit 5MB\nSkip_Long_Lines Off\nRefresh_Interval 10\n[INPUT]\nName systemd\nTag host.*\nSystemd_Filter _SYSTEMD_UNIT=kubelet.service\nRead_From_Tail On\nStrip_Underscores On\n\n[FILTER]\nName                kubernetes\nMatch               kube.*\nKube_Tag_Prefix     kube.var.log.containers.\nKube_URL            https://kubernetes.default.svc:443\nKube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\nKube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token\nMerge_Log           Off\nMerge_Log_Key       log_processed\nK8S-Logging.Parser  On\nK8S-Logging.Exclude On\n[FILTER]\nName nest\nMatch kube.*\nOperation lift\nNested_under kubernetes\nAdd_prefix kubernetes.\n[FILTER]\nName modify\nMatch kube.*\nCopy kubernetes.container_name tags.container\nCopy log message\nCopy kubernetes.container_image tags.image\nCopy kubernetes.namespace_name tags.namespace\n[FILTER]\nName nest\nMatch kube.*\nOperation nest\nWildcard tags.*\nNested_under tags\nRemove_prefix tags.\n\n[OUTPUT]\nName            es\nMatch           kube.*\nIndex           fluent-bit-kube\nHost            elasticsearch-master\nPort            9200\nHTTP_User       ${ES_USER}\nHTTP_Passwd     ${ES_PASSWORD}\nLogstash_Format Off\nTime_Key       @timestamp\nType            flb_type\nReplace_Dots    On\nRetry_Limit     False\nTrace_Error     Off\n</code></pre> </li> <li> <p>Create index pattern (Data View starting from Kibana v8.0):</p> <p>Go to <code>Management</code> \u2192 <code>Stack Management</code> \u2192 <code>Kibana</code> \u2192 <code>Index patterns</code> and create an index with the <code>fluent-bit-kube-*</code> pattern:</p> <p> Index Pattern </p> </li> <li> <p>Check logs in Kibana. Navigate to <code>Analytics</code> \u2192 <code>Discover</code>:</p> <p> Logs in Kibana </p> <p>Note</p> <p>In addition, in the top-right corner of the <code>Discover</code> window, there is a button called <code>Inspect</code>. Clicking on it will reveal the query that Kibana is sending to Elasticsearch. These queries can be used in Dev Tools.</p> </li> <li> <p>Monitor the created indices:</p> <pre><code>GET _cat/indices/fluent-bit-kube-*\n</code></pre> <p>Note</p> <p>Physically, the indices are located on the <code>elasticsearch</code> Kubernetes pod in <code>/usr/share/elasticsearch/data/nodes/0/indices</code>. It is recommended to backup indices only via Snapshots.</p> </li> </ol> <p>We've configured the index rollover process. Now the index will be rolled over to a new one once it reaches the indicated size or time in the policy, and old indices will be removed according to the policy as well.</p> <p>When you create an empty index that corresponds to the pattern indicated in the index template, the index template attaches <code>rollover_alias</code> with the <code>fluent-bit-kube</code> name, policy and other configured data. Then the Fluent Bit Elasticsearch output plugin sends logs to the <code>Index fluent-bit-kube</code> rollover alias. The index rollover process is managed by ILM that increments our indices united by the <code>rollover_alias</code> and distributes the log data to the latest index.</p>"},{"location":"operator-guide/kibana-ilm-rollover/#ilm-without-rollover-policy","title":"ILM Without Rollover Policy","text":"<p>It is also possible to manage index lifecycle without rollover indicated in the policy. If this is the case, this section will explain how to refactor the index to make it look that way: <code>fluent-bit-kube-2023.03.18</code>.</p> <p>Note</p> <p>The main drawback of this method is that the indices can be managed only by their creation date.</p> <p>To manage index lifecycle without rollover policy, follow the steps below:</p> <ol> <li> <p>Create a Policy without <code>rollover</code> but with indices deletion:</p> Index Lifecycle Policy <pre><code>PUT _ilm/policy/fluent-bit-policy\n{\n\"policy\": {\n\"phases\": {\n\"hot\": {\n\"min_age\": \"0ms\",\n\"actions\": {\n\"set_priority\": {\n\"priority\": 100\n}\n}\n},\n\"delete\": {\n\"min_age\": \"7d\",\n\"actions\": {\n\"delete\": {\n\"delete_searchable_snapshot\": true\n}\n}\n}\n}\n}\n}\n</code></pre> </li> <li> <p>Create an index template with the <code>rollover_alias</code> parameter:</p> Index Template <pre><code>PUT /_index_template/fluent-bit\n{\n\"index_patterns\": [\"fluent-bit-kube-*\"],\n\"template\": {\n\"settings\": {\n\"index\": {\n\"lifecycle\": {\n\"name\": \"fluent-bit-policy\",\n\"rollover_alias\": \"fluent-bit-kube\"\n},\n\"number_of_shards\": \"1\",\n\"number_of_replicas\": \"0\"\n}\n}\n}\n}\n</code></pre> </li> <li> <p>Change the Fluent Bit <code>[OUTPUT]</code> config to this one:</p> ConfigMap fluent-bit <pre><code>[OUTPUT]\nName            es\nMatch           kube.*\nHost            elasticsearch-master\nPort            9200\nHTTP_User       ${ES_USER}\nHTTP_Passwd     ${ES_PASSWORD}\nLogstash_Format On\nLogstash_Prefix fluent-bit-kube\nLogstash_DateFormat %Y.%m.%d\nTime_Key        @timestamp\nType            flb_type\nReplace_Dots    On\nRetry_Limit     False\nTrace_Error     On\n</code></pre> </li> <li> <p>Restart Fluent Bit pods.</p> </li> </ol> <p>Fluent Bit will be producing a new index every day with the new date in its name like in the <code>fluent-bit-kube-2023.03.18</code> name. Index deleting will be performed according to the policy.</p>"},{"location":"operator-guide/kibana-ilm-rollover/#tips-on-fluent-bit-debugging","title":"Tips on Fluent Bit Debugging","text":"<p>If you experience a lot of difficulties when dealing with Fluent Bit, this section may help you.</p> <p>Fluent Bit has docker images labelled <code>-debug</code>, e.g., <code>cr.fluentbit.io/fluent/fluent-bit:2.0.9-debug</code>.</p> <p>Change that image in the Kubernetes Fluent Bit DaemonSet and add the <code>Trace_Error On</code> parameter to the <code>[OUTPUT]</code> section in the Fluent Bit configmap:</p> <pre><code>[OUTPUT]\nTrace_Error On\n</code></pre> <p>After adding the parameter above, you will start seeing more informative logs that will probably help you find out the reason of the problem.</p>"},{"location":"operator-guide/kibana-ilm-rollover/#related-articles","title":"Related Articles","text":"<ul> <li>Index Lifecycle Management</li> <li>Elasticsearch Output</li> </ul>"},{"location":"operator-guide/kubernetes-cluster-settings/","title":"Set Up Kubernetes","text":"<p>Make sure the cluster meets the following conditions:</p> <ol> <li> <p>Kubernetes cluster is installed with minimum 2 worker nodes with total capacity 8 Cores and 32Gb RAM.</p> </li> <li> <p>Machine with kubectl is installed with a cluster-admin access to the Kubernetes cluster.</p> </li> <li> <p>Ingress controller is installed in a cluster, for example ingress-nginx.</p> </li> <li> <p>Ingress controller is configured with the disabled HTTP/2 protocol and header size of 64k support.</p> <p>Find below an example of the Config Map for the NGINX Ingress controller:</p> <pre><code>kind: ConfigMap\napiVersion: v1\nmetadata:\nname: nginx-configuration\nnamespace: ingress-nginx\nlabels:\napp.kubernetes.io/name: ingress-nginx\napp.kubernetes.io/part-of: ingress-nginx\ndata:\nclient-header-buffer-size: 64k\nlarge-client-header-buffers: 4 64k\nuse-http2: \"false\"\n</code></pre> </li> <li> <p>Load balancer (if any exists in front of the Ingress controller) is configured with session stickiness, disabled HTTP/2 protocol and header size of 32k support.</p> </li> <li> <p>Cluster nodes and pods have access to the cluster via external URLs. For instance, add in AWS the VPC NAT gateway elastic IP to the cluster external load balancers security group).</p> </li> <li> <p>Keycloak instance is installed. To get accurate information on how to install Keycloak, please refer to the Install Keycloak instruction.</p> </li> <li> <p>Helm 3.10 or higher is installed on the installation machine with the help of the Installing Helm instruction.</p> </li> <li> <p>Storage classes are used with the Retain Reclaim Policy and Delete Reclaim Policy.</p> </li> <li> <p>We recommended using our storage class as default storage class.</p> <p>Info</p> <p>By default, EDP uses the default Storage Class in a cluster. The EDP development team recommends using the following Storage Classes. See an example below.</p> <p>Storage class templates with the Retain and Delete Reclaim Policies:</p> ebs-scgp3gp3-retain <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\nname: ebs-sc\nannotations:\nstorageclass.kubernetes.io/is-default-class: 'true'\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Retain\nvolumeBindingMode: Immediate\n</code></pre> <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp3\nannotations:\nstorageclass.kubernetes.io/is-default-class: 'true'\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Delete\nvolumeBindingMode: Immediate\nallowVolumeExpansion: true\n</code></pre> <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp3-retain\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Retain\nvolumeBindingMode: Immediate\nallowVolumeExpansion: true\n</code></pre> </li> </ol>"},{"location":"operator-guide/kubernetes-cluster-settings/#related-articles","title":"Related Articles","text":"<ul> <li>Install Amazon EBS CSI Driver</li> <li>Install NGINX Ingress Controller</li> <li>Install Keycloak</li> </ul>"},{"location":"operator-guide/logsight-integration/","title":"Logsight Integration","text":"<p>Logsight can be integrated with the CI/CD pipeline. It connects to log data sources, analyses collected logs, and evaluates deployment risk scores.</p>"},{"location":"operator-guide/logsight-integration/#overview","title":"Overview","text":"<p>In order to understand if a microservice or a component is ready for the deployment, EDP suggests analysing logs via Logsight to decide if the deployment is risky or not.</p> <p>Please find more about Logsight in the official documentation:</p> <ul> <li>Logsight key features and workflow</li> <li>Log analysis</li> <li>Stage verification</li> </ul>"},{"location":"operator-guide/logsight-integration/#logsight-as-a-quality-gate","title":"Logsight as a Quality Gate","text":"<p>Integration with Logsight allows enhancing and optimizing software releases by creating an additional quality gate.</p> <p>Logsight can be configured in two ways:</p> <ul> <li>SAAS - online system; for this solution a connection string is required.</li> <li>Self-deployment - local installation.</li> </ul> <p>To work with Logsight, a new Deployment Risk stage must be added to the pipeline. On this stage, the logs are analysed with the help of Logsight mechanisms.</p> <p>On the verification screen of Logsight, continuous verification of the application deployment can be monitored, and tests can be compared for detecting test flakiness.</p> <p>For example, two versions of a microservice can be compared in order to detect critical differences. Risk score will be calculated for the state reached by version A and version B. Afterwards, the deployment risk will be calculated based on individual risk scores.</p> <p>If the deployment failure risk is greater than a predefined threshold, the verification gate blocks the deployment from going to the target environment. In such case, the Deployment Risk stage of the pipeline is not passed, and additional attention is required. The exact log messages can be displayed in the Logsight verification screen, to help debug the problem.</p>"},{"location":"operator-guide/logsight-integration/#use-logsight-for-edp-development","title":"Use Logsight for EDP Development","text":"<p>Please find below the detailed description of Logsight integration with EDP.</p>"},{"location":"operator-guide/logsight-integration/#deployment-approach","title":"Deployment Approach","text":"<p>EDP uses Logsight in a self-deploying mode.</p> <p>Logsight provides a deployment approach using Helm charts. Please find below the stack of components that must be deployed:</p> <ul> <li><code>logsight</code>\u00a0- the core component.</li> <li><code>logsight-backend</code>\u00a0- the backend that provides all necessary APIs and user management.</li> <li><code>logsight-frontend</code>\u00a0- the frontend that provides the user interface.</li> <li><code>logsight-result-api</code>\u00a0- responsible for obtaining results, for example, during the verification.</li> </ul> <p>Below is a diagram of interaction when integrating the components:</p> <p> Logsight Structure </p>"},{"location":"operator-guide/logsight-integration/#configure-fluentbit-for-sending-log-data","title":"Configure FluentBit for Sending Log Data","text":"<p>Logsight is integrated with the EDP logging stack. The integration is based on top of the EFK (ElasticSearch-FluentBit-Kibana) stack. It is necessary to deploy a stack with the security support, namely, enable the certificate support.</p> <p>A FluentBit config indicates the namespace from which the logs will be received for further analysis. Below is an example of the FluentBit config for getting logs from the <code>edp-delivery-edp-delivery-sit</code> namespace:</p> View: fluent-bit.conf <pre><code>[INPUT]\nName              tail\nTag               kube.sit.*\nPath              /var/log/containers/*edp-delivery-edp-delivery-sit*.log\nParser            docker\nMem_Buf_Limit     5MB\nSkip_Long_Lines   Off\nRefresh_Interval  10\n\n[FILTER]\nName                kubernetes\nMatch               kube.sit.*\nKube_URL            https://kubernetes.default.svc:443\nKube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\nKube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token\nKube_Tag_Prefix     kube.sit.var.log.containers.\nMerge_Log           Off\nK8S-Logging.Parser  On\nK8S-Logging.Exclude On\n\n[FILTER]\nName nest\nMatch kube.sit.*\nOperation lift\nNested_under kubernetes\nAdd_prefix kubernetes.\n\n[FILTER]\nName modify\nMatch kube.sit.*\nCopy kubernetes.container_name tags.container\nCopy log message\nCopy kubernetes.container_image tags.image\nCopy kubernetes.namespace_name tags.namespace\n\n[FILTER]\nName nest\nMatch kube.sit.*\nOperation nest\nWildcard kubernetes.*\nNested_under kubernetes\nRemove_prefix kubernetes.\n\n[OUTPUT]\nName            es\nMatch           kube.sit.*\nHost            elasticsearch-master\nPort            9200\nHTTP_User elastic\nHTTP_Passwd *****\nLogstash_Format On\nLogstash_Prefix sit\nTime_Key        @timestamp\nType            flb_type\nReplace_Dots    On\nRetry_Limit     False\n\n[OUTPUT]\nMatch kube.sit.*\nName  http\nHost logsight-backend\nPort 8080\nhttp_User logsight@example.com\nhttp_Passwd *****\nuri /api/v1/logs/singles\nFormat json\njson_date_format iso8601\njson_date_key timestamp\n</code></pre>"},{"location":"operator-guide/logsight-integration/#deployment-risk-analysis","title":"Deployment Risk Analysis","text":"<p>A <code>deployment-risk</code> stage is added to the EDP CD pipeline.</p> <p> Deployment Risk </p> <p>If the deployment risk is above 70%, the red state of the pipeline is expected.</p> <p>EDP consists of a set of containerized components. For the convenience of tracking the risk deployment trend for each component, this data is stored as Jenkins artifacts.</p> <p>If the deployment risk is higher than the threshold of 70%, the EDP promotion of artifacts for the next environments does not pass. The deployment risk report can be analysed in order to avoid the potential problems with updating the components.</p> <p>To study the report in detail, use the link from the Jenkins pipeline to the Logsight verification screen:</p> <p> Logsight Insights Logsight Insights </p> <p>In this example, logs from different versions of the <code>gerrit-operator</code> were analyzed. As can be seen from the report, a large number of new messages appeared in the logs, and the output frequency of other notifications has also changed, which led to the high deployment risk.</p> <p>The environment on which the analysis is performed can exist for different time periods. Logsight only processes the minimum total number of logs since the creating of the environment.</p>"},{"location":"operator-guide/logsight-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Customize CD Pipeline</li> <li>Adjust Jira Integration</li> </ul>"},{"location":"operator-guide/loki-irsa/","title":"IAM Roles for Loki Service Accounts","text":"<p>Note</p> <p>Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation.</p> <p>It is possible to use Amazon Simple Storage Service Amazon S3 as object storage for Loki. In this case Loki requires access to AWS resources. Follow the steps below to create a required role:</p> <ol> <li> <p>Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki_policy\":</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:ListObjects\",\n                \"s3:ListBucket\",\n                \"s3:PutObject\",\n                \"s3:GetObject\",\n                \"s3:DeleteObject\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::loki-*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:ListBucket\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::loki-*\"\n            ]\n        }\n    ]\n}\n</code></pre> </li> <li> <p>Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" with trust relationships:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;OIDC_PROVIDER&gt;\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"&lt;OIDC_PROVIDER&gt;:sub\": \"system:serviceaccount:&lt;LOKI_NAMESPACE&gt;:edp-loki\"\n       }\n     }\n   }\n ]\n}\n</code></pre> </li> <li> <p>Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" role.</p> </li> <li> <p>Make sure that Amazon S3 bucket with name loki-\u2039CLUSTER_NAME\u203a exists.</p> </li> <li> <p>Provide key value eks.amazonaws.com/role-arn: \"arn:aws:iam:::role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" into the serviceAccount.annotations parameter in values.yaml during the Loki Installation."},{"location":"operator-guide/loki-irsa/#related-articles","title":"Related Articles","text":"<ul> <li>Associate IAM Roles With Service Accounts</li> <li>Install Grafana Loki</li> </ul>"},{"location":"operator-guide/manage-custom-certificate/","title":"Manage Custom Certificates","text":"<p>Familiarize yourself with the detailed instructions on adding certificates to EDP resources as well as with the respective setup for Keycloak.</p> <p>EDP components that support custom certificates can be found in the table below:</p> Helm Chart Sub Resources admin-console-operator admin-console gerrit-operator edp-gerrit jenkins-operator jenkins-operator, edp-jenkins, jenkins agents sonar-operator sonar-operator, edp-sonar keycloak-operator keycloak-operator nexus-operator oauth2-proxy edp-install oauth2-proxy edp-headlamp edp-headlamp"},{"location":"operator-guide/manage-custom-certificate/#prerequisites","title":"Prerequisites","text":"<ul> <li>The certificate in the <code>*.crt</code> format is used;</li> <li>Kubectl version 1.23.0 is installed;</li> <li>Helm version 3.10.2 is installed;</li> <li>Java with the <code>keytool</code> command inside;</li> <li>jq is installed.</li> </ul>"},{"location":"operator-guide/manage-custom-certificate/#enable-the-spi-truststore-of-keycloak","title":"Enable the SPI Truststore of Keycloak","text":"<p>To import custom certificates to Keycloak, follow the steps below:</p> <ol> <li> <p>Generate the <code>cacerts</code> local keystore and import the certificate there using the keytool tool:</p> <pre><code>keytool -importcert -file CA.crt \\\n-alias CA.crt -keystore ./cacerts \\\n-storepass changeit -trustcacerts \\\n-noprompt\n</code></pre> </li> <li> <p>Create the <code>custom-keycloak-keystore</code> keystore secret from the <code>cacerts</code> file in the <code>security</code> namespace:</p> <pre><code>kubectl -n security create secret generic custom-keycloak-keystore \\\n--from-file=./cacerts\n</code></pre> </li> <li> <p>Create the <code>spi-truststore-data</code> SPI truststore secret in the <code>security</code> namespace:</p> <pre><code>kubectl -n security create secret generic spi-truststore-data \\\n--from-literal=KC_SPI_TRUSTSTORE_FILE_FILE=/opt/keycloak/spi-certs/cacerts \\\n--from-literal=KC_SPI_TRUSTSTORE_FILE_PASSWORD=changeit\n</code></pre> </li> <li> <p>Update the Keycloak <code>values.yaml</code> file from the Install Keycloak page.</p> View: values.yaml <pre><code>...\nextraVolumeMounts: |\n...\n# Use the Keycloak truststore for SPI connection over HTTPS/TLS\n- name: spi-certificates\nmountPath: /opt/keycloak/spi-certs\nreadOnly: true\n...\n\nextraVolumes: |\n...\n# Use the Keycloak truststore for SPI connection over HTTPS/TLS\n- name: spi-certificates\nsecret:\nsecretName: custom-keycloak-keystore\ndefaultMode: 420\n...\n\n...\nextraEnvFrom: |\n- secretRef:\nname: spi-truststore-data\n...\n</code></pre> </li> </ol>"},{"location":"operator-guide/manage-custom-certificate/#enable-custom-certificates-in-edp-components","title":"Enable Custom Certificates in EDP Components","text":"<p>Creating custom certificates is a necessary but not sufficient condition for applying, therefore, certificates should be enabled as well.</p> <ol> <li> <p>Create the <code>custom-ca-certificates</code> secret in the EDP namespace.</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic custom-ca-certificates \\\n--from-file=CA.crt\n</code></pre> </li> <li> <p>Add the certificate by mounting the <code>custom-ca-certificates</code> secret to the operator pod as a volume.</p> <p>Example of specifying custom certificates for the <code>keycloak-operator</code>:</p> <pre><code>...\nkeycloak-operator:\nenabled: true\n\n# -- Additional volumes to be added to the pod\nextraVolumes:\n- name: custom-ca\nsecret:\ndefaultMode: 420\nsecretName: custom-ca-certificates\n\n# -- Additional volumeMounts to be added to the container\nextraVolumeMounts:\n- name: custom-ca\nmountPath: /etc/ssl/certs/CA.crt\nreadOnly: true\nsubPath: CA.crt\n...\n</code></pre> </li> <li> <p>For Sonar, Jenkins and Gerrit, change the flag in the <code>caCerts.enabled</code> field to <code>true</code>. Also, change the name of the secret in the <code>caCerts.secret</code> field to <code>custom-ca-certificates</code>.</p> <p>Example of specifying custom certificates for <code>Gerrit</code> via the <code>gerrit-operator</code> helm chart values:</p> <pre><code>...\ngerrit-operator:\nenabled: true\ngerrit:\ncaCerts:\n# -- Flag for enabling additional CA certificates\nenabled: true\n# -- Change init CA certificates container image\nimage: adoptopenjdk/openjdk11:alpine\n# -- Name of the secret containing additional CA certificates\nsecret: custom-ca-certificates\n...\n</code></pre> </li> </ol>"},{"location":"operator-guide/manage-custom-certificate/#integrate-custom-certificates-into-jenkins-agents","title":"Integrate Custom Certificates Into Jenkins Agents","text":"<p>This section describes how to add custom certificates to Jenkins agents to use them from Java applications.</p> <p>Info</p> <p>For example, <code>curl</code> doesn't use keystore files specified in this part of the documentation.</p> <p>EDP Jenkins agents keep keystore files in two places:</p> <ul> <li><code>/etc/ssl/certs/java</code> folder with the <code>cacerts</code> file;</li> <li><code>/opt/java/openjdk/lib/security</code> folder with the <code>blocked.certs</code>, <code>cacerts</code>, <code>default.policy</code> and <code>public_suffix_list.dat</code> files.</li> </ul> <ol> <li> <p>Copy the files in <code>/etc/ssl/certs/java</code> and <code>/opt/java/openjdk/lib/security</code> directories from Jenkins agent pod to the local <code>tmp</code> folder. There is a <code>copy_certs.sh</code> script below that can manage this. It copies the files in <code>/etc/ssl/certs/java</code> and <code>/opt/java/openjdk/lib/security</code> directories from Jenkins agent pod to the local <code>tmp</code> folder and imports the custom certificate into the keystore files, after which it creates the  <code>jenkins-agent-opt-java-openjdk-lib-security-cacerts</code> and <code>jenkins-agent-etc-ssl-certs-java-cacerts</code> secrets from updated keystore files in EDP namespace. Also, the <code>jenkins-agent-opt-java-openjdk-lib-security-cacerts</code> secret contains three additional files: <code>blocked.certs</code>, <code>default.policy</code> and <code>public_suffix_list.dat</code> which managed by the <code>copy_certs.sh</code> script as well. Expand the drop-down button below to see the contents of the <code>copy_certs.sh</code> script.</p> View: copy_certs.sh <pre><code># Fill in the variables `ns` and `ca_file`\nns=\"edp-project\"\nca_file=\"/tmp/CA.crt\"\n\nimages=$(kubectl get -n \"${ns}\" cm jenkins-slaves -ojson | jq -r \".data[]\" | grep image\\&gt; | sed 's/\\s*&lt;.*&gt;\\(.*\\)&lt;.*&gt;/\\1/')\n\nimage=$(for i in ${images[@]}; do echo $i; done | grep maven-java8)\npod_name=$(echo \"${image}\" | tr '.:/' '-')\n\noverrides=\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Pod\\\",\\\"metadata\\\":{\\\"name\\\":\\\"${pod_name}\\\", \\\"namespace\\\": \\\"${ns}\\\"},\n\\\"spec\\\":{\\\"containers\\\":[{\\\"name\\\":\\\"${pod_name}\\\",\\\"image\\\":\\\"${image}\\\",\n\\\"command\\\":[\\\"sh\\\",\\\"-c\\\",\\\"while true;do sleep 30;done;\\\"]}]}}\"\n\nkubectl run -n \"${ns}\" \"${pod_name}\" --image \"${image}\" --overrides=\"${overrides}\"\n\nkubectl wait --for=condition=ready pod \"${pod_name}\" -n \"${ns}\"\n\ncacerts_location=$(kubectl exec -n \"${ns}\" \"${pod_name}\" \\\n-- find / -name cacerts -exec ls -la \"{}\" \\; 2&gt;/dev/null | grep -v ^l | awk '{print $9}')\n\nfor cacerts in ${cacerts_location[@]}; do echo $(dirname \"${cacerts}\"); kubectl exec -n \"${ns}\" \"${pod_name}\" -- ls $(dirname \"${cacerts}\"); done\n\nfor cacerts in ${cacerts_location[@]}; do \\\necho $(dirname \"${cacerts}\"); \\\nmkdir -p \"/tmp$(dirname \"${cacerts}\")\"; \\\nfrom_files=''; \\\nfor file in $(kubectl exec -n \"${ns}\" \"${pod_name}\" -- ls $(dirname \"${cacerts}\")); do \\\nkubectl exec -n \"${ns}\" \"${pod_name}\" -- cat \"$(dirname \"${cacerts}\")/${file}\" &gt; \"/tmp$(dirname \"${cacerts}\")/${file}\"; \\\nfrom_files=\"${from_files} --from-file=/tmp$(dirname \"${cacerts}\")/${file}\"\ndone ; \\\nkeytool -import -storepass changeit -alias kubernetes -file ${ca_file} -noprompt -keystore \"/tmp${cacerts}\"; \\\nkubectl -n \"${ns}\" create secret generic \"jenkins-agent${cacerts//\\//-}\" $from_files \\\ndone\n\nkubectl delete -n \"${ns}\" pod \"${pod_name}\" --force --grace-period=0\n</code></pre> <p>Before using the <code>copy_certs.sh</code> script, keep in mind the following:</p> <ul> <li>assign actual values to the variables <code>ns</code> and <code>ca_file</code>;</li> <li>the script collects all the images from the <code>jenkins-slaves</code> ConfigMap and uses the image of   the <code>maven-java8</code> agent as the base image of the temporary pod to get the keystore files;</li> <li>custom certificate is imported using the <code>keytool</code> application;</li> <li>the <code>jenkins-agent-opt-java-openjdk-lib-security-cacerts</code> and <code>jenkins-agent-etc-ssl-certs-java-cacerts</code> secrets will be created   in the EDP namespace.</li> </ul> </li> <li> <p>Run the <code>copy_certs.sh</code> script from the previous point after the requirements are met.</p> </li> <li> <p>Update manually the <code>jenkins-slaves</code> ConfigMap.</p> <p>Add this block with the mount of secrets to the <code>&lt;volumes&gt;&lt;/volumes&gt;</code> block of each Jenkins agent:</p> <pre><code>...\n        &lt;org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;\n&lt;mountPath&gt;/etc/ssl/certs/java&lt;/mountPath&gt;\n&lt;secretName&gt;jenkins-agent-etc-ssl-certs-java-cacerts&lt;/secretName&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;\n&lt;mountPath&gt;/opt/java/openjdk/lib/security&lt;/mountPath&gt;\n&lt;secretName&gt;jenkins-agent-opt-java-openjdk-lib-security-cacerts&lt;/secretName&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;\n...\n</code></pre> <p>As an example, the template of <code>gradle-java11-template</code> is shown below:</p> <pre><code>...\n      &lt;/workspaceVolume&gt;\n&lt;volumes&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;\n&lt;mountPath&gt;/etc/ssl/certs/java&lt;/mountPath&gt;\n&lt;secretName&gt;jenkins-agent-etc-ssl-certs-java-cacerts&lt;/secretName&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;\n&lt;mountPath&gt;/opt/java/openjdk/lib/security&lt;/mountPath&gt;\n&lt;secretName&gt;jenkins-agent-opt-java-openjdk-lib-security-cacerts&lt;/secretName&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.volumes.SecretVolume&gt;\n&lt;/volumes&gt;\n&lt;containers&gt;\n...\n</code></pre> </li> <li> <p>Reload the Jenkins pod:</p> <pre><code>ns=\"&lt;edp-project&gt;\"\nkubectl rollout restart -n \"${ns}\" deployment/jenkins\n</code></pre> </li> </ol>"},{"location":"operator-guide/manage-custom-certificate/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Install Keycloak</li> </ul>"},{"location":"operator-guide/manage-jenkins-cd-job-provision/","title":"Manage Jenkins CD Pipeline Job Provisioner","text":"<p>The Jenkins CD job provisioner (or seed-job) is used to create and manage the cd-pipeline folder, and its Deploy pipelines. There is a special job-provisions/cd folder in Jenkins for these provisioners. Explore the steps for managing different provisioner types below.</p>"},{"location":"operator-guide/manage-jenkins-cd-job-provision/#default","title":"Default","text":"<p>During the EDP deployment, a default provisioner is created to deploy application with container and custom deployment type.</p> <ol> <li> <p>Find the configuration in job-provisions/cd/default.</p> </li> <li> <p>Default template is presented below:</p> View: Default template <pre><code>/* Copyright 2022 EPAM Systems.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport groovy.json.*\nimport jenkins.model.Jenkins\n\nJenkins jenkins = Jenkins.instance\n\ndef pipelineName = \"${PIPELINE_NAME}-cd-pipeline\"\ndef stageName = \"${STAGE_NAME}\"\ndef qgStages = \"${QG_STAGES}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID}\"\ndef sourceType = \"${SOURCE_TYPE}\"\ndef libraryURL = \"${LIBRARY_URL}\"\ndef libraryBranch = \"${LIBRARY_BRANCH}\"\ndef isAutoDeploy = \"${AUTODEPLOY}\"\ndef scriptPath = \"Jenkinsfile\"\ndef containerDeploymentType = \"container\"\ndef deploymentType = \"${DEPLOYMENT_TYPE}\"\ndef codebaseFolder = jenkins.getItem(pipelineName)\n\ndef autoDeploy = '{\"name\":\"auto-deploy-input\",\"step_name\":\"auto-deploy-input\"}'\ndef manualDeploy = '{\"name\":\"manual-deploy-input\",\"step_name\":\"manual-deploy-input\"}'\ndef runType = isAutoDeploy.toBoolean() ? autoDeploy : manualDeploy\n\ndef stages = buildStages(deploymentType, containerDeploymentType, qgStages, runType)\n\nif (codebaseFolder == null) {\nfolder(pipelineName)\n}\n\nif (deploymentType == containerDeploymentType) {\ncreateContainerizedCdPipeline(pipelineName, stageName, stages, scriptPath, sourceType,\nlibraryURL, libraryBranch, gitCredentialsId, gitServerCrVersion,\nisAutoDeploy)\n} else {\ncreateCustomCdPipeline(pipelineName, stageName)\n}\n\ndef buildStages(deploymentType, containerDeploymentType, qgStages, runType) {\nreturn deploymentType == containerDeploymentType\n? '[{\"name\":\"init\",\"step_name\":\"init\"},' + runType + ',{\"name\":\"deploy\",\"step_name\":\"deploy\"},' + qgStages + ',{\"name\":\"promote-images\",\"step_name\":\"promote-images\"}]'\n: ''\n}\n\ndef createContainerizedCdPipeline(pipelineName, stageName, stages, pipelineScript, sourceType, libraryURL, libraryBranch, libraryCredId, gitServerCrVersion, isAutoDeploy) {\npipelineJob(\"${pipelineName}/${stageName}\") {\nif (sourceType == \"library\") {\ndefinition {\ncpsScm {\nscm {\ngit {\nremote {\nurl(libraryURL)\ncredentials(libraryCredId)\n}\nbranches(\"${libraryBranch}\")\nscriptPath(\"${pipelineScript}\")\n}\n}\n}\n}\n} else {\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nDeploy()\")\nsandbox(true)\n}\n}\n}\nproperties {\ndisableConcurrentBuilds()\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${stages}\", \"Consequence of stages in JSON format to be run during execution\")\n\nif (isAutoDeploy?.trim() &amp;&amp; isAutoDeploy.toBoolean()) {\nstringParam(\"CODEBASE_VERSION\", null, \"Codebase versions to deploy.\")\n}\n}\n}\n}\n\ndef createCustomCdPipeline(pipelineName, stageName) {\npipelineJob(\"${pipelineName}/${stageName}\") {\nproperties {\ndisableConcurrentBuilds()\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\n}\n}\n}\n</code></pre> </li> </ol>"},{"location":"operator-guide/manage-jenkins-cd-job-provision/#custom","title":"Custom","text":"<p>In some cases, it is necessary to modify or update the job provisioner logic. For example, when adding a new stage requires a custom job provisioner created on the basis of an existing one out of the box. Take the steps below to add a custom job provision.</p> <ol> <li> <p>Navigate to the Jenkins main page and open the job-provisions/cd folder, click New Item and type the name of job provisions, for example - custom.</p> <p> CD provisioner name </p> <p>Scroll down to the Copy from field, enter \"/job-provisions/cd/default\", and click OK:   Copy CD provisioner </p> </li> <li> <p>Update the required parameters in the new provisioner. For example, if it is necessary to implement a new stage clean, add the following code to the provisioner:</p> <pre><code>   def buildStages(deploymentType, containerDeploymentType, qgStages) {\n       return deploymentType == containerDeploymentType\n? '[{\"name\":\"init\",\"step_name\":\"init\"},{\"name\":\"clean\",\"step_name\":\"clean\"},{\"name\":\"deploy\",\"step_name\":\"deploy\"},' + qgStages + ',{\"name\":\"promote-images-ecr\",\"step_name\":\"promote-images\"}]'\n: ''\n}\n</code></pre> <p>Note</p> <p>Make sure the support for the above mentioned logic is implemented. Please refer to the How to Redefine or Extend the EDP Pipeline Stages Library section of the guide.</p> <p>After the steps above are performed, the new custom job-provision will be available in Adding Stage during the CD pipeline creation in Admin Console.</p> <p> Custom CD provision </p> </li> </ol>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/","title":"Manage Jenkins CI Pipeline Job Provisioner","text":"<p>The Jenkins CI job provisioner (or seed-job) is used to create and manage the application folder, and its Code Review, Build and Create Release pipelines. Depending on the version control system, different job provisioners are used. EDP supports integration with the following version control systems:</p> <ul> <li>Gerrit (default)</li> <li>GitHub (github)</li> <li>GitLab (gitlab)</li> </ul> <p>By default, the Jenkins operator creates a pipeline for several types of application and libraries. There is a special job-provisions/ci folder in Jenkins for these provisioners. During the EDP deployment, a default provisioner is created for integration with Gerrit version control system. To configure integration with other version control systems, you need to add the required job provisioners to job-provisions/ci folder in Jenkins.</p>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#create-custom-provisioner-custom-defaultgithubgitlab","title":"Create Custom Provisioner (custom-default/github/gitlab)","text":"<p>In some cases it is necessary to modify or update the job provisioner logic, for example when an added other code language needs to create a custom job provisioner on the basis of an existing one out of the box. Take the steps below to add a custom job provision:</p> <ol> <li> <p>Navigate to the Jenkins main page and open the job-provisions/ci folder, click New Item and type the name of job-provisions, for example - custom-github.</p> <p> CI provisioner name </p> <p>Scroll down to the Copy from field and enter \"/job-provisions/ci/github\", and click OK:   Copy ci provisioner </p> </li> <li> <p>Update the required parameters in the new provisioner. For example, if it is necessary to implement a new build tool docker, several parameters are to be updated. Add the following stages to the docker Code Review and Build pipelines for docker application:</p> <pre><code>stages['Code-review-application-docker'] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"},{\"name\": \"build\"}]'\n...\nstages['Build-application-docker'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"lint\"},{\"name\": \"build\"},{\"name\": \"push\"},{\"name\": \"git-tag\"}]'\n...\ndef getStageKeyName(buildTool) {\n    ...\n    if (buildTool.toString().equalsIgnoreCase('docker')) {\n    return \"Code-review-application-docker\"\n}\n    ...\n}\n</code></pre> <p>Note</p> <p>Make sure the support for the above mentioned logic is implemented. Please refer to the How to Redefine or Extend the EDP Pipeline Stages Library section of the guide.</p> <p>Note</p> <p>The default template should be changed if there is another creation logic for the Code Review, Build and Create Release pipelines. Furthermore, all pipeline types should have the necessary stages as well.</p> <p>After the steps above are performed, the new custom job provision will be available in Advanced Settings during the application creation in the Headlamp UI:</p> <p> Custom ci provision </p> </li> </ol>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#gerrit-default","title":"Gerrit (default)","text":"<p>During the EDP deployment, a default provisioner is created for integration with Gerrit version control system.</p> <ol> <li> <p>Find the configuration in job-provisions/ci/default.</p> </li> <li> <p>Default template is presented below:</p> View: Default template <pre><code>/* Copyright 2022 EPAM Systems.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport groovy.json.*\nimport jenkins.model.Jenkins\n\nJenkins jenkins = Jenkins.instance\ndef stages = [:]\ndef jiraIntegrationEnabled = Boolean.parseBoolean(\"${JIRA_INTEGRATION_ENABLED}\" as String)\ndef commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : ''\ndef createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : ''\ndef platformType = \"${PLATFORM_TYPE}\"\ndef buildStage = platformType.toString() == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}'\ndef buildTool = \"${BUILD_TOOL}\"\ndef goBuildStage = buildTool.toString() == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}'\n\nstages['Code-review-application'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + goBuildStage +\n',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]'\nstages['Code-review-library'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}]'\nstages['Code-review-autotests'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + ']'\nstages['Code-review-default'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ']'\nstages['Code-review-library-terraform'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"terraform-lint\"}]'\nstages['Code-review-library-opa'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"}]'\nstages['Code-review-library-codenarc'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}]'\nstages['Code-review-library-kaniko'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"dockerbuild-verify\"}]'\n\nstages['Build-library-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-npm'] = stages['Build-library-maven']\nstages['Build-library-gradle'] = stages['Build-library-maven']\nstages['Build-library-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' +\n',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-opa'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-codenarc'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-autotests-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-autotests-gradle'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-application-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-npm'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-gradle'] = stages['Build-application-maven']\nstages['Build-application-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-go'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"tests\"}' +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"}' +\n\"${buildStage}\" + ',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Create-release'] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]'\n\ndef defaultBuild = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']'\n\ndef codebaseName = \"${NAME}\"\ndef gitServerCrName = \"${GIT_SERVER_CR_NAME}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\"\ndef repositoryPath = \"${REPOSITORY_PATH}\"\ndef defaultBranch = \"${DEFAULT_BRANCH}\"\n\ndef codebaseFolder = jenkins.getItem(codebaseName)\nif (codebaseFolder == null) {\nfolder(codebaseName)\n}\n\ncreateListView(codebaseName, \"Releases\")\ncreateReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"CreateRelease\",\nrepositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch)\n\nif (buildTool.toString().equalsIgnoreCase('none')) {\nreturn true\n}\n\nif (BRANCH) {\ndef branch = \"${BRANCH}\"\ndef formattedBranch = \"${branch.toUpperCase().replaceAll(/\\//, \"-\")}\"\ncreateListView(codebaseName, formattedBranch)\n\ndef type = \"${TYPE}\"\ndef crKey = getStageKeyName(buildTool)\ncreateCiPipeline(\"Code-review-${codebaseName}\", codebaseName, stages[crKey], \"CodeReview\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\ndef buildKey = \"Build-${type}-${buildTool.toLowerCase()}\".toString()\nif (type.equalsIgnoreCase('application') || type.equalsIgnoreCase('library') || type.equalsIgnoreCase('autotests')) {\ndef jobExists = false\nif(\"${formattedBranch}-Build-${codebaseName}\".toString() in Jenkins.instance.getAllItems().collect{it.name})\njobExists = true\n\ncreateCiPipeline(\"Build-${codebaseName}\", codebaseName, stages.get(buildKey, defaultBuild), \"Build\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\nif(!jobExists)\nqueue(\"${codebaseName}/${formattedBranch}-Build-${codebaseName}\")\n}\n}\n\ndef createCiPipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId, watchBranch, gitServerCrName, gitServerCrVersion) {\npipelineJob(\"${codebaseName}/${watchBranch.toUpperCase().replaceAll(/\\//, \"-\")}-${pipelineName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\ntriggers {\ngerrit {\nevents {\nif (pipelineName.contains(\"Build\"))\nchangeMerged()\nelse\npatchsetCreated()\n}\nproject(\"plain:${codebaseName}\", [\"plain:${watchBranch}\"])\n}\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nstringParam(\"BRANCH\", \"${watchBranch}\", \"Branch to build artifact from\")\n}\n}\n}\n}\n\ndef getStageKeyName(buildTool) {\nif (buildTool.toString().equalsIgnoreCase('terraform')) {\nreturn \"Code-review-library-terraform\"\n}\nif (buildTool.toString().equalsIgnoreCase('opa')) {\nreturn \"Code-review-library-opa\"\n}\nif (buildTool.toString().equalsIgnoreCase('codenarc')) {\nreturn \"Code-review-library-codenarc\"\n}\nif (buildTool.toString().equalsIgnoreCase('kaniko')) {\nreturn \"Code-review-library-kaniko\"\n}\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\nreturn supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\"\n}\n\ndef createReleasePipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId,\ngitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch) {\npipelineJob(\"${codebaseName}/${pipelineName}\") {\nlogRotator {\nnumToKeep(14)\ndaysToKeep(30)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"STAGES\", \"${codebaseStages}\", \"\")\nif (pipelineName.contains(\"Create-release\")) {\nstringParam(\"JIRA_INTEGRATION_ENABLED\", \"${jiraIntegrationEnabled}\", \"Is Jira integration enabled\")\nstringParam(\"PLATFORM_TYPE\", \"${platformType}\", \"Platform type\")\nstringParam(\"GERRIT_PROJECT\", \"${codebaseName}\", \"\")\nstringParam(\"RELEASE_NAME\", \"\", \"Name of the release(branch to be created)\")\nstringParam(\"COMMIT_ID\", \"\", \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\")\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"REPOSITORY_PATH\", \"${repository}\", \"Full repository path\")\nstringParam(\"DEFAULT_BRANCH\", \"${defaultBranch}\", \"Default repository branch\")\n}\n}\n}\n}\n}\n\ndef createListView(codebaseName, branchName) {\nlistView(\"${codebaseName}/${branchName}\") {\nif (branchName.toLowerCase() == \"releases\") {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^Create-release.*\")\n}\n}\n} else {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^${branchName}-(Code-review|Build).*\")\n}\n}\n}\ncolumns {\nstatus()\nweather()\nname()\nlastSuccess()\nlastFailure()\nlastDuration()\nbuildButton()\n}\n}\n}\n</code></pre> <p>Job Provision Pipeline Parameters</p> <p>The job-provisions pipeline consists of the following parameters of type string:</p> </li> </ol> <ul> <li>NAME - the application name;</li> </ul> <ul> <li>TYPE - the codebase type (the application / library / autotest);</li> </ul> <ul> <li>BUILD_TOOL - a tool that is used to build the application;</li> </ul> <ul> <li>BRANCH - a branch name;</li> </ul> <ul> <li>GIT_SERVER_CR_NAME - the name of the application Git server custom resource;</li> </ul> <ul> <li>GIT_SERVER_CR_VERSION - the version of the application Git server custom resource;</li> </ul> <ul> <li>GIT_CREDENTIALS_ID - the secret name where Git server credentials are stored (default 'gerrit-ciuser-sshkey');</li> </ul> <ul> <li>REPOSITORY_PATH - the full repository path;</li> </ul> <ul> <li>JIRA_INTEGRATION_ENABLED - the Jira integration is enabled or not;</li> </ul> <ul> <li>PLATFORM_TYPE - the type of platform (kubernetes or openshift);</li> </ul> <ul> <li>DEFAULT_BRANCH - the default repository branch.</li> </ul>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#github-github","title":"GitHub (github)","text":"<p>To create a new job provision for work with GitHub, take the following steps:</p> <ol> <li> <p>Navigate to the Jenkins main page and open the job-provisions/ci folder.</p> </li> <li> <p>Click New Item and type the name of job-provisions - github.</p> </li> <li> <p>Select the Freestyle project option and click OK.</p> </li> <li> <p>Select the Discard old builds check box and configure a few parameters:</p> <p>Strategy: Log Rotation</p> <p>Days to keep builds: 10</p> <p>Max # of builds to keep: 10</p> </li> <li> <p>Select the This project is parameterized check box and add a few input parameters (the type of the variables is string):</p> <ul> <li>NAME;</li> </ul> <ul> <li>TYPE;</li> </ul> <ul> <li>BUILD_TOOL;</li> </ul> <ul> <li>BRANCH;</li> </ul> <ul> <li>GIT_SERVER_CR_NAME;</li> </ul> <ul> <li>GIT_SERVER_CR_VERSION;</li> </ul> <ul> <li>GIT_CREDENTIALS_ID;</li> </ul> <ul> <li>REPOSITORY_PATH;</li> </ul> <ul> <li>JIRA_INTEGRATION_ENABLED;</li> </ul> <ul> <li>PLATFORM_TYPE;</li> </ul> <ul> <li>DEFAULT_BRANCH.</li> </ul> </li> <li> <p>Check the Execute concurrent builds if necessary option.</p> </li> <li> <p>Check the Restrict where this project can be run option.</p> </li> <li> <p>Fill in the Label Expression field by typing master to ensure job runs on Jenkins Master.</p> </li> <li> <p>In the Build section, perform the following:</p> <ul> <li>Select DSL Script;</li> </ul> <ul> <li>Select the Use the provided DSL script check box:</li> </ul> <p> DSL script check box </p> </li> <li> <p>As soon as all the steps above are performed, insert the code:</p> View: Template <pre><code>import groovy.json.*\nimport jenkins.model.Jenkins\nimport javaposse.jobdsl.plugin.*\nimport com.cloudbees.hudson.plugins.folder.*\n\nJenkins jenkins = Jenkins.instance\ndef stages = [:]\ndef jiraIntegrationEnabled = Boolean.parseBoolean(\"${JIRA_INTEGRATION_ENABLED}\" as String)\ndef commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : ''\ndef createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : ''\ndef platformType = \"${PLATFORM_TYPE}\"\ndef buildStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}'\ndef buildTool = \"${BUILD_TOOL}\"\ndef goBuildStage = buildTool.toString() == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}'\n\nstages['Code-review-application'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + goBuildStage +\n',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]'\nstages['Code-review-library'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"compile\"},{\"name\": \"tests\"},' +\n'{\"name\": \"sonar\"}]'\nstages['Code-review-autotests'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + ']'\nstages['Code-review-default'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ']'\nstages['Code-review-library-terraform'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"terraform-lint\"}]'\nstages['Code-review-library-opa'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"}]'\nstages['Code-review-library-codenarc'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}]'\nstages['Code-review-library-kaniko'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"dockerbuild-verify\"}]'\n\nstages['Build-library-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-npm'] = stages['Build-library-maven']\nstages['Build-library-gradle'] = stages['Build-library-maven']\nstages['Build-library-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' +\n',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-opa'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-codenarc'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-autotests-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-autotests-gradle'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-application-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-npm'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-gradle'] = stages['Build-application-maven']\nstages['Build-application-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-go'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build\"}' + \"${buildStage}\" + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}' +\n\"${buildStage}\" + ',{\"name\":\"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Create-release'] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]'\n\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef defaultStages = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']'\n\ndef codebaseName = \"${NAME}\"\ndef gitServerCrName = \"${GIT_SERVER_CR_NAME}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\"\ndef repositoryPath = \"${REPOSITORY_PATH.replaceAll(~/:\\d+\\\\//,\"/\")}\"\ndef githubRepository = \"https://${repositoryPath.split(\"@\")[1]}\"\ndef defaultBranch = \"${DEFAULT_BRANCH}\"\n\ndef codebaseFolder = jenkins.getItem(codebaseName)\nif (codebaseFolder == null) {\n    folder(codebaseName)\n}\n\ncreateListView(codebaseName, \"Releases\")\ncreateReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"CreateRelease\",\n        repositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch)\n\nif (buildTool.toString().equalsIgnoreCase('none')) {\n    return true\n}\n\nif (BRANCH) {\n    def branch = \"${BRANCH}\"\n    def formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \"-\")}\"\ncreateListView(codebaseName, formattedBranch)\n\ndef type = \"${TYPE}\"\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\ndef crKey = getStageKeyName(buildTool).toString()\ncreateCodeReviewPipeline(\"Code-review-${codebaseName}\", codebaseName, stages.get(crKey, defaultStages), \"CodeReview\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion, githubRepository)\nregisterWebHook(repositoryPath)\n\n\ndef buildKey = \"Build-${type}-${buildTool.toLowerCase()}\".toString()\n\nif (type.equalsIgnoreCase('application') || type.equalsIgnoreCase('library') || type.equalsIgnoreCase('autotests')) {\ndef jobExists = false\nif(\"${formattedBranch}-Build-${codebaseName}\".toString() in Jenkins.instance.getAllItems().collect{it.name})\njobExists = true\ncreateBuildPipeline(\"Build-${codebaseName}\", codebaseName, stages.get(buildKey, defaultStages), \"Build\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion, githubRepository)\nregisterWebHook(repositoryPath, 'build')\n\nif(!jobExists)\nqueue(\"${codebaseName}/${formattedBranch}-Build-${codebaseName}\")\n}\n}\n\ndef getStageKeyName(buildTool) {\nif (buildTool.toString().equalsIgnoreCase('terraform')) {\nreturn \"Code-review-library-terraform\"\n}\nif (buildTool.toString().equalsIgnoreCase('opa')) {\nreturn \"Code-review-library-opa\"\n}\nif (buildTool.toString().equalsIgnoreCase('codenarc')) {\nreturn \"Code-review-library-codenarc\"\n}\nif (buildTool.toString().equalsIgnoreCase('kaniko')) {\nreturn \"Code-review-library-kaniko\"\n}\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\nreturn supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\"\n}\n\ndef createCodeReviewPipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId, defaultBranch, gitServerCrName, gitServerCrVersion, githubRepository) {\npipelineJob(\"${codebaseName}/${defaultBranch.toUpperCase().replaceAll(/\\\\//, \"-\")}-${pipelineName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nif (pipelineName.contains(\"Build\"))\nstringParam(\"BRANCH\", \"${defaultBranch}\", \"Branch to build artifact from\")\nelse\nstringParam(\"BRANCH\", \"\\${ghprbActualCommit}\", \"Branch to build artifact from\")\n}\n}\ntriggers {\ngithubPullRequest {\ncron('')\nonlyTriggerPhrase(false)\nuseGitHubHooks(true)\npermitAll(true)\nautoCloseFailedPullRequests(false)\ndisplayBuildErrorsOnDownstreamBuilds(false)\nwhiteListTargetBranches([defaultBranch.toString()])\nextensions {\ncommitStatus {\ncontext('Jenkins Code-Review')\ntriggeredStatus('Build is Triggered')\nstartedStatus('Build is Started')\naddTestResults(true)\ncompletedStatus('SUCCESS', 'Verified')\ncompletedStatus('FAILURE', 'Failed')\ncompletedStatus('PENDING', 'Penging')\ncompletedStatus('ERROR', 'Error')\n}\n}\n}\n}\nproperties {\ngithubProjectProperty {\nprojectUrlStr(\"${githubRepository}\")\n}\n}\n}\n}\n\ndef createBuildPipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId, defaultBranch, gitServerCrName, gitServerCrVersion, githubRepository) {\npipelineJob(\"${codebaseName}/${defaultBranch.toUpperCase().replaceAll(/\\\\//, \"-\")}-${pipelineName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nnode {\\n    git credentialsId: \\'${credId}\\', url: \\'${repository}\\', branch: \\'${BRANCH}\\'\\n}\\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nstringParam(\"BRANCH\", \"${defaultBranch}\", \"Branch to run from\")\n}\n}\ntriggers {\ngitHubPushTrigger()\n}\nproperties {\ngithubProjectProperty {\nprojectUrlStr(\"${githubRepository}\")\n}\n}\n}\n}\n\n\ndef createListView(codebaseName, branchName) {\nlistView(\"${codebaseName}/${branchName}\") {\nif (branchName.toLowerCase() == \"releases\") {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^Create-release.*\")\n}\n}\n} else {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^${branchName}-(Code-review|Build).*\")\n}\n}\n}\ncolumns {\nstatus()\nweather()\nname()\nlastSuccess()\nlastFailure()\nlastDuration()\nbuildButton()\n}\n}\n}\n\ndef createReleasePipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId,\ngitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch) {\npipelineJob(\"${codebaseName}/${pipelineName}\") {\nlogRotator {\nnumToKeep(14)\ndaysToKeep(30)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"STAGES\", \"${codebaseStages}\", \"\")\nif (pipelineName.contains(\"Create-release\")) {\nstringParam(\"JIRA_INTEGRATION_ENABLED\", \"${jiraIntegrationEnabled}\", \"Is Jira integration enabled\")\nstringParam(\"PLATFORM_TYPE\", \"${platformType}\", \"Platform type\")\nstringParam(\"GERRIT_PROJECT\", \"${codebaseName}\", \"\")\nstringParam(\"RELEASE_NAME\", \"\", \"Name of the release(branch to be created)\")\nstringParam(\"COMMIT_ID\", \"\", \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\")\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"REPOSITORY_PATH\", \"${repository}\", \"Full repository path\")\nstringParam(\"DEFAULT_BRANCH\", \"${defaultBranch}\", \"Default repository branch\")\n}\n}\n}\n}\n}\n\ndef registerWebHook(repositoryPath, type = 'code-review') {\ndef url = repositoryPath.split('@')[1].split('/')[0]\ndef owner = repositoryPath.split('@')[1].split('/')[1]\ndef repo = repositoryPath.split('@')[1].split('/')[2]\ndef apiUrl = 'https://api.' + url + '/repos/' + owner + '/' + repo + '/hooks'\ndef webhookUrl = ''\ndef webhookConfig = [:]\ndef config = [:]\ndef events = []\n\nif (type.equalsIgnoreCase('build')) {\nwebhookUrl = System.getenv('JENKINS_UI_URL') + \"/github-webhook/\"\nevents = [\"push\"]\nconfig[\"url\"] = webhookUrl\nconfig[\"content_type\"] = \"json\"\nconfig[\"insecure_ssl\"] = 0\nwebhookConfig[\"name\"] = \"web\"\nwebhookConfig[\"config\"] = config\nwebhookConfig[\"events\"] = events\nwebhookConfig[\"active\"] = true\n\n} else {\nwebhookUrl = System.getenv('JENKINS_UI_URL') + \"/ghprbhook/\"\nevents = [\"issue_comment\",\"pull_request\"]\nconfig[\"url\"] = webhookUrl\nconfig[\"content_type\"] = \"form\"\nconfig[\"insecure_ssl\"] = 0\nwebhookConfig[\"name\"] = \"web\"\nwebhookConfig[\"config\"] = config\nwebhookConfig[\"events\"] = events\nwebhookConfig[\"active\"] = true\n}\n\ndef requestBody = JsonOutput.toJson(webhookConfig)\ndef http = new URL(apiUrl).openConnection() as HttpURLConnection\nhttp.setRequestMethod('POST')\nhttp.setDoOutput(true)\nprintln(apiUrl)\nhttp.setRequestProperty(\"Accept\", 'application/json')\nhttp.setRequestProperty(\"Content-Type\", 'application/json')\nhttp.setRequestProperty(\"Authorization\", \"token ${getSecretValue('github-access-token')}\")\nhttp.outputStream.write(requestBody.getBytes(\"UTF-8\"))\nhttp.connect()\nprintln(http.responseCode)\n\nif (http.responseCode == 201) {\nresponse = new JsonSlurper().parseText(http.inputStream.getText('UTF-8'))\n} else {\nresponse = new JsonSlurper().parseText(http.errorStream.getText('UTF-8'))\n}\n\nprintln \"response: ${response}\"\n}\n\ndef getSecretValue(name) {\ndef creds = com.cloudbees.plugins.credentials.CredentialsProvider.lookupCredentials(\ncom.cloudbees.plugins.credentials.common.StandardCredentials.class,\nJenkins.instance,\nnull,\nnull\n)\n\ndef secret = creds.find { it.properties['id'] == name }\nreturn secret != null ? secret['secret'] : null\n}\n</code></pre> <p>After the steps above are performed, the new custom job-provision will be available in Advanced Settings during the application creation in the Headlamp UI:</p> <p> Github job provision </p> </li> </ol>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#gitlab-gitlab","title":"GitLab (gitlab)","text":"<p>To create a new job provision for work with GitLab, take the following steps:</p> <ol> <li> <p>Navigate to the Jenkins main page and open the job-provisions/ci folder.</p> </li> <li> <p>Click New Item and type the name of job-provisions - gitlab.</p> </li> <li> <p>Select the Freestyle project option and click OK.</p> </li> <li> <p>Select the Discard old builds check box and configure a few parameters:</p> <p>Strategy: Log Rotation</p> <p>Days to keep builds: 10</p> <p>Max # of builds to keep: 10</p> </li> <li> <p>Select the This project is parameterized check box and add a few input parameters as the following strings (the type of the variables is string):</p> <ul> <li>NAME;</li> </ul> <ul> <li>TYPE;</li> </ul> <ul> <li>BUILD_TOOL;</li> </ul> <ul> <li>BRANCH;</li> </ul> <ul> <li>GIT_SERVER_CR_NAME;</li> </ul> <ul> <li>GIT_SERVER_CR_VERSION;</li> </ul> <ul> <li>GIT_SERVER;</li> </ul> <ul> <li>GIT_SSH_PORT;</li> </ul> <ul> <li>GIT_USERNAME;</li> </ul> <ul> <li>GIT_CREDENTIALS_ID;</li> </ul> <ul> <li>REPOSITORY_PATH;</li> </ul> <ul> <li>JIRA_INTEGRATION_ENABLED;</li> </ul> <ul> <li>PLATFORM_TYPE;</li> </ul> <ul> <li>DEFAULT_BRANCH;</li> </ul> </li> <li> <p>Check the Execute concurrent builds if necessary option.</p> </li> <li> <p>Check the Restrict where this project can be run option.</p> </li> <li> <p>Fill in the Label Expression field by typing master to ensure job runs on Jenkins Master.</p> </li> <li> <p>In the Build Steps section, perform the following:</p> <ul> <li>Select Add build step;</li> </ul> <ul> <li>Choose Process Job DSLs; </li> </ul> <ul> <li>Select the Use the provided DSL script check box:</li> </ul> <p> DSL script check box </p> </li> <li> <p>As soon as all the steps above are performed, insert the code:</p> View: Template <pre><code>import groovy.json.*\nimport jenkins.model.Jenkins\n\nJenkins jenkins = Jenkins.instance\ndef stages = [:]\ndef jiraIntegrationEnabled = Boolean.parseBoolean(\"${JIRA_INTEGRATION_ENABLED}\" as String)\ndef commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : ''\ndef createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : ''\ndef platformType = \"${PLATFORM_TYPE}\"\ndef buildTool = \"${BUILD_TOOL}\"\ndef buildImageStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"},' : ',{\"name\": \"build-image-from-dockerfile\"},'\ndef goBuildImageStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}'\ndef goBuildStage = buildTool.toString() == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}'\n\nstages['Code-review-application'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + goBuildStage +\n',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]'\nstages['Code-review-library'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"compile\"},{\"name\": \"tests\"},' +\n'{\"name\": \"sonar\"}]'\nstages['Code-review-autotests'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + ']'\nstages['Code-review-default'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ']'\nstages['Code-review-library-terraform'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"terraform-lint\"}]'\nstages['Code-review-library-opa'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"}]'\nstages['Code-review-library-codenarc'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}]'\nstages['Code-review-library-kaniko'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"dockerbuild-verify\"}]'\n\nstages['Build-library-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-npm'] = stages['Build-library-maven']\nstages['Build-library-gradle'] = stages['Build-library-maven']\nstages['Build-library-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' +\n',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-opa'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-codenarc'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-autotests-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-autotests-gradle'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-application-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildImageStage}\" +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}' +\n\"${buildImageStage}\" + '{\"name\":\"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-npm'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildImageStage}\" +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-gradle'] = stages['Build-application-maven']\nstages['Build-application-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildImageStage}\" +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"tool-init\"},' +\n'{\"name\": \"lint\"},{\"name\": \"git-tag\"}]'\nstages['Build-application-helm'] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"}]'\nstages['Build-application-docker'] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"}]'\nstages['Build-application-go'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build\"}' + \"${goBuildImageStage}\" + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Create-release'] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]'\n\ndef defaultStages = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']'\n\n\ndef codebaseName = \"${NAME}\"\ndef gitServerCrName = \"${GIT_SERVER_CR_NAME}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitServer = \"${GIT_SERVER ? GIT_SERVER : 'gerrit'}\"\ndef gitSshPort = \"${GIT_SSH_PORT ? GIT_SSH_PORT : '29418'}\"\ndef gitUsername = \"${GIT_USERNAME ? GIT_USERNAME : 'jenkins'}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\"\ndef defaultRepoPath = \"ssh://${gitUsername}@${gitServer}:${gitSshPort}/${codebaseName}\"\ndef repositoryPath = \"${REPOSITORY_PATH ? REPOSITORY_PATH : defaultRepoPath}\"\ndef defaultBranch = \"${DEFAULT_BRANCH}\"\n\ndef codebaseFolder = jenkins.getItem(codebaseName)\nif (codebaseFolder == null) {\nfolder(codebaseName)\n}\n\ncreateListView(codebaseName, \"Releases\")\ncreateReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"CreateRelease\",\nrepositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch)\n\nif (BRANCH) {\ndef branch = \"${BRANCH}\"\ndef formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \"-\")}\"\ncreateListView(codebaseName, formattedBranch)\n\ndef type = \"${TYPE}\"\ndef crKey = getStageKeyName(buildTool).toString()\ncreateCiPipeline(\"Code-review-${codebaseName}\", codebaseName, stages.get(crKey, defaultStages), \"CodeReview\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\ndef buildKey = \"Build-${type}-${buildTool.toLowerCase()}\".toString()\n\nif (type.equalsIgnoreCase('application') || type.equalsIgnoreCase('library') || type.equalsIgnoreCase('autotests')) {\ndef jobExists = false\nif(\"${formattedBranch}-Build-${codebaseName}\".toString() in Jenkins.instance.getAllItems().collect{it.name}) {\njobExists = true\n}\ncreateCiPipeline(\"Build-${codebaseName}\", codebaseName, stages.get(buildKey, defaultStages), \"Build\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\nif(!jobExists) {\nqueue(\"${codebaseName}/${formattedBranch}-Build-${codebaseName}\")\n}\n}\n}\n\n\ndef createCiPipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId, defaultBranch, gitServerCrName, gitServerCrVersion) {\ndef jobName = \"${defaultBranch.toUpperCase().replaceAll(/\\\\//, \"-\")}-${pipelineName}\"\ndef existingJob = Jenkins.getInstance().getItemByFullName(\"${codebaseName}/${jobName}\")\ndef webhookToken = null\nif (existingJob) {\ndef triggersMap = existingJob.getTriggers()\ntriggersMap.each { key, value -&gt;\nwebhookToken = value.getSecretToken()\n}\n} else {\ndef random = new byte[16]\nnew java.security.SecureRandom().nextBytes(random)\nwebhookToken = random.encodeHex().toString()\n}\npipelineJob(\"${codebaseName}/${jobName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\nproperties {\ngitLabConnection {\ngitLabConnection('gitlab')\n}\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nif (pipelineName.contains(\"Build\"))\nstringParam(\"BRANCH\", \"${defaultBranch}\", \"Branch to build artifact from\")\nelse\nstringParam(\"BRANCH\", \"\\${gitlabMergeRequestLastCommit}\", \"Branch to build artifact from\")\n}\n}\ntriggers {\ngitlabPush {\nbuildOnMergeRequestEvents(pipelineName.contains(\"Build\") ? false : true)\nbuildOnPushEvents(pipelineName.contains(\"Build\") ? true : false)\nenableCiSkip(false)\nsetBuildDescription(true)\nrebuildOpenMergeRequest(pipelineName.contains(\"Build\") ? 'never' : 'source')\ncommentTrigger(\"Build it please\")\nskipWorkInProgressMergeRequest(true)\ntargetBranchRegex(\"${defaultBranch}\")\n}\n}\nconfigure {\nit / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' &lt;&lt; secretToken(webhookToken)\nit / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' &lt;&lt; triggerOnApprovedMergeRequest(pipelineName.contains(\"Build\") ? false : true)\nit / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' &lt;&lt; pendingBuildName(pipelineName.contains(\"Build\") ? \"\" : \"Jenkins\")\n}\n}\nregisterWebHook(repository, codebaseName, jobName, webhookToken)\n}\n\ndef getStageKeyName(buildTool) {\nif (buildTool.toString().equalsIgnoreCase('terraform')) {\nreturn \"Code-review-library-terraform\"\n}\nif (buildTool.toString().equalsIgnoreCase('opa')) {\nreturn \"Code-review-library-opa\"\n}\nif (buildTool.toString().equalsIgnoreCase('codenarc')) {\nreturn \"Code-review-library-codenarc\"\n}\nif (buildTool.toString().equalsIgnoreCase('kaniko')) {\nreturn \"Code-review-library-kaniko\"\n}\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\nreturn supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\"\n}\n\ndef createReleasePipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId,\ngitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch) {\npipelineJob(\"${codebaseName}/${pipelineName}\") {\nlogRotator {\nnumToKeep(14)\ndaysToKeep(30)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"STAGES\", \"${codebaseStages}\", \"\")\nif (pipelineName.contains(\"Create-release\")) {\nstringParam(\"JIRA_INTEGRATION_ENABLED\", \"${jiraIntegrationEnabled}\", \"Is Jira integration enabled\")\nstringParam(\"PLATFORM_TYPE\", \"${platformType}\", \"Platform type\")\nstringParam(\"GERRIT_PROJECT\", \"${codebaseName}\", \"\")\nstringParam(\"RELEASE_NAME\", \"\", \"Name of the release(branch to be created)\")\nstringParam(\"COMMIT_ID\", \"\", \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\")\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"REPOSITORY_PATH\", \"${repository}\", \"Full repository path\")\nstringParam(\"DEFAULT_BRANCH\", \"${defaultBranch}\", \"Default repository branch\")\n}\n}\n}\n}\n}\n\ndef createListView(codebaseName, branchName) {\nlistView(\"${codebaseName}/${branchName}\") {\nif (branchName.toLowerCase() == \"releases\") {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^Create-release.*\")\n}\n}\n} else {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^${branchName}-(Code-review|Build).*\")\n}\n}\n}\ncolumns {\nstatus()\nweather()\nname()\nlastSuccess()\nlastFailure()\nlastDuration()\nbuildButton()\n}\n}\n}\n\ndef registerWebHook(repositoryPath, codebaseName, jobName, webhookToken) {\ndef apiUrl = 'https://' + repositoryPath.replaceAll(\"ssh://\", \"\").split('@')[1].replace('/', \"%2F\").replaceAll(~/:\\d+%2F/, '/api/v4/projects/') + '/hooks'\ndef jobWebhookUrl = \"${System.getenv('JENKINS_UI_URL')}/project/${codebaseName}/${jobName}\"\ndef gitlabToken = getSecretValue('gitlab-access-token')\n\nif (checkWebHookExist(apiUrl, jobWebhookUrl, gitlabToken)) {\nprintln(\"[JENKINS][DEBUG] Webhook for job ${jobName} is already exist\\r\\n\")\nreturn\n}\n\nprintln(\"[JENKINS][DEBUG] Creating webhook for job ${jobName}\")\ndef webhookConfig = [:]\nwebhookConfig[\"url\"] = jobWebhookUrl\nwebhookConfig[\"push_events\"] = jobName.contains(\"Build\") ? \"true\" : \"false\"\nwebhookConfig[\"merge_requests_events\"] = jobName.contains(\"Build\") ? \"false\" : \"true\"\nwebhookConfig[\"issues_events\"] = \"false\"\nwebhookConfig[\"confidential_issues_events\"] = \"false\"\nwebhookConfig[\"tag_push_events\"] = \"false\"\nwebhookConfig[\"note_events\"] = \"true\"\nwebhookConfig[\"job_events\"] = \"false\"\nwebhookConfig[\"pipeline_events\"] = \"false\"\nwebhookConfig[\"wiki_page_events\"] = \"false\"\nwebhookConfig[\"enable_ssl_verification\"] = \"true\"\nwebhookConfig[\"token\"] = webhookToken\ndef requestBody = JsonOutput.toJson(webhookConfig)\ndef httpConnector = new URL(apiUrl).openConnection() as HttpURLConnection\nhttpConnector.setRequestMethod('POST')\nhttpConnector.setDoOutput(true)\n\nhttpConnector.setRequestProperty(\"Accept\", 'application/json')\nhttpConnector.setRequestProperty(\"Content-Type\", 'application/json')\nhttpConnector.setRequestProperty(\"PRIVATE-TOKEN\", \"${gitlabToken}\")\nhttpConnector.outputStream.write(requestBody.getBytes(\"UTF-8\"))\nhttpConnector.connect()\n\nif (httpConnector.responseCode == 201)\nprintln(\"[JENKINS][DEBUG] Webhook for job ${jobName} has been created\\r\\n\")\nelse {\nprintln(\"[JENKINS][ERROR] Responce code - ${httpConnector.responseCode}\")\ndef response = new JsonSlurper().parseText(httpConnector.errorStream.getText('UTF-8'))\nprintln(\"[JENKINS][ERROR] Failed to create webhook for job ${jobName}. Response - ${response}\")\n}\n}\n\ndef checkWebHookExist(apiUrl, jobWebhookUrl, gitlabToken) {\nprintln(\"[JENKINS][DEBUG] Checking if webhook ${jobWebhookUrl} exists\")\ndef httpConnector = new URL(apiUrl).openConnection() as HttpURLConnection\nhttpConnector.setRequestMethod('GET')\nhttpConnector.setDoOutput(true)\n\nhttpConnector.setRequestProperty(\"Accept\", 'application/json')\nhttpConnector.setRequestProperty(\"Content-Type\", 'application/json')\nhttpConnector.setRequestProperty(\"PRIVATE-TOKEN\", \"${gitlabToken}\")\nhttpConnector.connect()\n\nif (httpConnector.responseCode == 200) {\ndef response = new JsonSlurper().parseText(httpConnector.inputStream.getText('UTF-8'))\nreturn response.find { it.url == jobWebhookUrl } ? true : false\n}\n}\n\ndef getSecretValue(name) {\ndef creds = com.cloudbees.plugins.credentials.CredentialsProvider.lookupCredentials(\ncom.cloudbees.plugins.credentials.common.StandardCredentials.class,\nJenkins.instance,\nnull,\nnull\n)\n\ndef secret = creds.find { it.properties['id'] == name }\nreturn secret != null ? secret['secret'] : null\n}\n</code></pre> <p>After the steps above are performed, the new custom job-provision will be available in Advanced Settings during the application creation in the Headlamp UI:</p> <p> Gitlab job provision </p> </li> </ol>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#related-articles","title":"Related Articles","text":"<ul> <li>CI Pipeline for Container</li> <li>GitLab Webhook Configuration</li> <li>GitHub Webhook Configuration</li> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> </ul>"},{"location":"operator-guide/migrate-ci-pipelines-from-jenkins-to-tekton/","title":"Migrate CI Pipelines From Jenkins to Tekton","text":"<p>To migrate the CI pipelines for a codebase from Jenkins to Tekton, follow the steps below:</p> <ul> <li>Migrate CI Pipelines From Jenkins to Tekton</li> <li>Deploy a Custom EDP Scenario With Tekton and Jenkins CI Tools</li> <li>Disable Jenkins Triggers</li> <li>Manage Tekton Triggers the Codebase(s)</li> <li>Switch CI Tool for Codebase(s)</li> </ul>"},{"location":"operator-guide/migrate-ci-pipelines-from-jenkins-to-tekton/#deploy-a-custom-edp-scenario-with-tekton-and-jenkins-ci-tools","title":"Deploy a Custom EDP Scenario With Tekton and Jenkins CI Tools","text":"<p>Make sure that Tekton stack is deployed according to the documentation. Enable Tekton as an EDP subcomponent:</p> values.yaml<pre><code>edp-tekton:\nenabled: true\n</code></pre>"},{"location":"operator-guide/migrate-ci-pipelines-from-jenkins-to-tekton/#disable-jenkins-triggers","title":"Disable Jenkins Triggers","text":"<p>To disable Jenkins Triggers for the codebase, add the following code to the provisioner:</p> job-provisioner<pre><code>def tektonCodebaseList = [\"&lt;codebase_name&gt;\"]\nif (!tektonCodebaseList.contains(codebaseName.toString())){\ntriggers {\ngerrit {\nevents {\nif (pipelineName.contains(\"Build\"))\nchangeMerged()\nelse\npatchsetCreated()\n}\nproject(\"plain:${codebaseName}\", [\"plain:${watchBranch}\"])\n}\n}\n}\n</code></pre> <p>Note</p> <p>The sample above shows the usage of Gerrit VCS where the <code>&lt;codebase_name&gt;</code> value is your codebase name.</p> <ul> <li>If using GitHub or GitLab, additionally remove the webhook from the relevant repository.</li> <li>If webhooks generation for new codebase(s) is not required, correct the code above so that it creates a webhook in the job-provisioner.</li> <li>To recreate the pipeline in Jenkins, trigger the job-provisioner.</li> <li>Check that the new pipeline is created without triggering Gerrit events.</li> </ul>"},{"location":"operator-guide/migrate-ci-pipelines-from-jenkins-to-tekton/#manage-tekton-triggers-the-codebases","title":"Manage Tekton Triggers the Codebase(s)","text":"<p>By default, each Gerrit project inherits configuration from the All-Projects repository.</p> <p>To exclude triggering in Jenkins and Tekton CI tools simultaneously, edit the configuration in the All-Projects repository or in the project which inherits rights from your project.</p> <p>Edit the webhooks.config file in the refs/meta/config and remove all context from this configuration.</p> <p>Warning</p> <p>The clearance of the webhooks.config file will disable the pipeline trigger in Tekton.</p> <p>To use Tekton pipelines, add the configuration to the corresponding Gerrit project (webhooks.config file in the refs/meta/config):</p> webhooks.config<pre><code>[remote \"changemerged\"]\nurl = http://el-gerrit-listener:8080\nevent = change-merged\n[remote \"patchsetcreated\"]\nurl = http://el-gerrit-listener:8080\nevent = patchset-created\n</code></pre>"},{"location":"operator-guide/migrate-ci-pipelines-from-jenkins-to-tekton/#switch-ci-tool-for-codebases","title":"Switch CI Tool for Codebase(s)","text":"<p>Go to the codebase Custom Resource and change the <code>spec.ciTool</code> field from <code>jenkins</code> to <code>tekton</code>.</p>"},{"location":"operator-guide/migrate-ci-pipelines-from-jenkins-to-tekton/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Install Tekton</li> </ul>"},{"location":"operator-guide/multitenant-logging/","title":"Multitenant Logging","text":"<p>Get acquainted with the multitenant logging components and the project logs location in the Shared cluster.</p>"},{"location":"operator-guide/multitenant-logging/#logging-components","title":"Logging Components","text":"<p>To configure the multitenant logging, it is necessary to deploy the following components:</p> <ul> <li>Grafana</li> <li>Loki</li> <li>Logging-operator</li> <li>Logging-operator stack-fluentbit</li> </ul> <p>In Grafana, every tenant represents an organization, i.e. it is necessary to create an organization for every namespace in the cluster. To get more details regarding the architecture of the Logging Operator, please review the Diagram 1.</p> <p> Logging operator scheme </p> <p>Note</p> <p>It is necessary to deploy Loki with the <code>auth_enabled: true</code> flag with the aim to ensure that the logs are separated for each tenant. For the authentication, Loki requires the HTTP header X-Scope-OrgID.</p>"},{"location":"operator-guide/multitenant-logging/#review-project-logs-in-grafana","title":"Review Project Logs in Grafana","text":"<p>To find the project logs, navigate to Grafana and follow the steps below:</p> <p>Note</p> <p>Grafana is a common service for different customers where each customer works in its own separated Grafana Organization and doesn't have any access to another project.</p> <ol> <li> <p>Choose the organization by clicking the Current Organization drop-down list. If a user is assigned to several organizations, switch easily by using the Switch button.</p> <p> Current organization </p> </li> <li> <p>Navigate to the left-side menu and click the Explore button to see the Log Browser:</p> <p> Grafana explore </p> </li> <li> <p>Click the Log Browser button to see the labels that can be used to filter logs (e.g., hostname, namespace, application name, pod, etc.):</p> <p>Note</p> <p>Enable the correct data source, select the relevant logging data from the top left-side corner, and pay attention that the data source name always follows the \u2039project_name\u203a-logging pattern.</p> <p> Log browser </p> </li> <li> <p>Filter out logs by clicking the Show logs button or write the query and click the Run query button.</p> </li> <li> <p>Review the results with the quantity of logs per time, see the example below:</p> <p> Logs example </p> <ul> <li>Expand the logs to get detailed information about the object entry:</li> </ul> <p> Expand logs </p> <ul> <li>Use the following buttons to include or remove the labels from the query:</li> </ul> <p> Addition button </p> <ul> <li>See the ad-hoc statistics for a particular label:</li> </ul> <p> Ad-hoc stat example </p> </li> </ol>"},{"location":"operator-guide/multitenant-logging/#related-articles","title":"Related Articles","text":"<ul> <li>Grafana Documentation</li> </ul>"},{"location":"operator-guide/namespace-management/","title":"Manage Namespace","text":"<p>EDP provides the ability to deploy services to namespaces. By default, EDP creates these namespaces automatically. This chapter describes the alternative way of namespace creation and management.</p>"},{"location":"operator-guide/namespace-management/#overview","title":"Overview","text":"<p>Namespaces are typically created by the platform when running CD Pipelines. The operator creates them according to the specific format: <code>&lt;edp-project&gt;-&lt;application-name&gt;-&lt;stage-name&gt;</code>. The <code>cd-pipeline-operator</code> should have the permissions to automatically create namespaces when deploying application and delete when uninstalling application.</p>"},{"location":"operator-guide/namespace-management/#disable-automatic-namespace-creation","title":"Disable Automatic Namespace Creation","text":"<p>Occasionally, there are cases when automatic creation of namespaces is not allowed. For example, due to security reasons of the project, EDP user may need to disable this setting. This option is manipulated by the <code>manageNamespace</code> parameter which is located in the values.yaml file. The <code>manageNamespace</code> parameter is set to <code>true</code> by default, but it can be changed to false. As an aftermath, after setting the <code>manageNamespace</code> parameter users are supposed to face the problem that they can not deploy their application in Headlamp UI because of permission restrictions:</p> <p> Namespace creation error </p> <p>The error message shown above says that user needs to create the namespace in the <code>&lt;edp-project&gt;-&lt;application-name&gt;-&lt;stage-name&gt;</code> format first before creating stages. In addition to it, the <code>cd-pipeline-operator</code> must be granted with the administrator permissions to have the ability to manage this namespace. The manual namespace creation procedure does not depend on the deployment scenario whether Jenkins or Tekton is used. To create namespace manually, follow the steps below:</p> <ol> <li> <p>Create the namespace by running the command below:</p> <pre><code> kubectl create namespace &lt;edp_namespace&gt;-&lt;pipelineName&gt;-&lt;stageName&gt;\n</code></pre> </li> <li> <p>Create the administrator RoleBinding resource by applying the file below with the <code>kubectl apply -f grant_admin_permissions.yaml</code> command:</p> View: grant_admin_permissions.yaml <pre><code> kind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\nname: edp-cd-pipeline-operator-admin\nnamespace: &lt;edp_namespace&gt;-&lt;pipelineName&gt;-&lt;stageName&gt;\nsubjects:\n- kind: ServiceAccount\nname: edp-cd-pipeline-operator\nnamespace: &lt;edp_namespace&gt;\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: ClusterRole\nname: admin\n</code></pre> </li> <li> <p>Restart the cd-pipeline-operator pod, in order not to wait for the operator reconciliation.</p> </li> </ol>"},{"location":"operator-guide/namespace-management/#cd-pipeline-operator-rbac-model","title":"CD Pipeline Operator RBAC Model","text":"<p>The <code>manageNamespace</code> parameter also defines the resources that will be created depending on the cluster deployed whether it is OpenShift or Kubernetes. This scheme displays the nesting of operator input parameters:</p> <p> CD Pipeline Operator Input Parameter Scheme </p> <p>Note</p> <p>When deploying application on the OpenShift cluster, the <code>registry-view</code> RoleBinding is created in the main namespace.</p>"},{"location":"operator-guide/namespace-management/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Access Model</li> <li>EKS OIDC With Keycloak</li> </ul>"},{"location":"operator-guide/nexus-sonatype/","title":"Nexus Sonatype Integration","text":"<p>This documentation guide provides comprehensive instructions for integrating external Nexus with the EPAM Delivery Platform.</p>"},{"location":"operator-guide/nexus-sonatype/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure that you have the following prerequisites:</p> <ul> <li>Kubectl version 1.26.0 is installed.</li> <li>Helm version 3.12.0+ is installed.</li> </ul> <p>EDP includes a pre-configured Nexus Sonatype instance, eliminating the need for extra setup and enabling immediate, hassle-free artifact management. Nevertheless, EDP also provides the versatility to incorporate external Nexus Sonatype instances, finely tuned to meet project-specific demands.</p>"},{"location":"operator-guide/nexus-sonatype/#switch-to-external-nexus","title":"Switch to External Nexus","text":"<ol> <li> <p>To use external Nexus in EDP, redefine the following parameters in the EDP-install values.yaml file before installation. In the <code>nexusUrl</code> parameter, input the appropriate values for Nexus service, namespace and a port <code>http://&lt;service-name&gt;.&lt;nexus-namespace&gt;:8081</code>. Alternatively, use the address and a port to external Nexus <code>http(s)://&lt;endpoint&gt;</code> instead.</p> <pre><code>global:\nnexusUrl: \"\"\n\nnexus-operator:\nenabled: false\n</code></pre> </li> <li> <p>Proceed with the installation of EDP by following the Install EDP guide.</p> </li> </ol> <p>Note</p> <p>You can install preconfigured nexus with edp-nexus-operator using EDP addons approach.</p>"},{"location":"operator-guide/nexus-sonatype/#configuration","title":"Configuration","text":"<p>To ensure strong authentication and accurate access control, creating a Nexus Sonatype service account with the name  ci.user  is crucial. This user serves as a unique identifier, facilitating connection with the EDP ecosystem.</p> <p>To create the Nexus <code>ci.user</code>and define repository parameters follow the steps below: </p> <ol> <li> <p>Open the Nexus UI and navigate to <code>Server administration and configuration</code> -&gt; <code>Security</code> -&gt; <code>User</code>. Click the <code>Create local user</code> button to create a new user:</p> <p> Nexus user settings </p> </li> <li> <p>Type the <code>ci-user</code> username, define an expiration period, and click the <code>Generate</code> button to create the token:</p> <p> Nexus create user </p> </li> <li> <p>EDP relies on a predetermined repository naming convention all repository names are predefined. Navigate to <code>Server administration and configuration</code> -&gt; <code>Repository</code> -&gt; <code>Repositories</code> in Nexus. You can only create a repository with the required language.</p> <p> Nexus repository list </p> JavaJavaScriptDotnetPython <p>a) Click Create a repository by selecting \"maven2(proxy)\" and set the name as \"edp-maven-proxy\". Enter the remote storage URL as \"https://repo1.maven.org/maven2/\". Save the configuration.</p> <p>b) Click Create a repository by selecting \"maven2(hosted)\" and set the name as \"edp-maven-snapshot\". Change the Version policy to \"snapshot\". Save the configuration.</p> <p>c) Click Create a repository by selecting \"maven2(hosted)\" and set the name as \"edp-maven-releases\". Change the Version policy to \"release\". Save the configuration.</p> <p>d) Click Create a repository by selecting \"maven2(group)\" and set the name as \"edp-maven-group\". Change the Version policy to \"release\". Add repository to group. Save the configuration.</p> <p>a) Click Create a repository by selecting \"npm(proxy)\" and set the name as \"edp-npm-proxy\". Enter the remote storage URL as \"https://registry.npmjs.org\". Save the configuration.</p> <p>b) Click Create a repository by selecting \"npm(hosted)\" and set the name as \"edp-npm-snapshot\". Save the configuration.</p> <p>c) Click Create a repository by selecting \"npm(hosted)\" and set the name as \"edp-npm-releases\". Save the configuration.</p> <p>d) Click Create a repository by selecting \"npm(hosted)\" and set the name as \"edp-npm-hosted\". Save the configuration.</p> <p>e) Click Create a repository by selecting \"npm(group)\" and set the name as \"edp-npm-group\". Add repository to group. Save the configuration.</p> <p>a) Click Create a repository by selecting \"nuget(proxy)\" and set the name as \"edp-dotnet-proxy\". Select Protocol version NuGet V3. Enter the remote storage URL as \"https://api.nuget.org/v3/index.json\". Save the configuration.</p> <p>b) Click Create a repository by selecting \"nuget(hosted)\" and set the name as \"edp-dotnet-snapshot\". Save the configuration.</p> <p>c) Click Create a repository by selecting \"nuget(hosted)\" and set the name as \"edp-dotnet-releases\". Save the configuration.</p> <p>d) Click Create a repository by selecting \"nuget(hosted)\" and set the name as \"edp-dotnet-hosted\". Save the configuration.</p> <p>e) Click Create a repository by selecting \"nuget(group)\" and set the name as \"edp-dotnet-group\". Add repository to group. Save the configuration.</p> <p>a) Click Create a repository by selecting \"pypi(proxy)\" and set the name as \"edp-python-proxy\". Enter the remote storage URL as \"https://pypi.org\". Save the configuration.</p> <p>b) Click Create a repository by selecting \"pypi(hosted)\" and set the name as \"edp-python-snapshot\". Save the configuration.</p> <p>c) Click Create a repository by selecting \"pypi(hosted)\" and set the name as \"edp-python-releases\". Save the configuration.</p> <p>d) Click Create a repository by selecting \"pypi(group)\" and set the name as \"edp-python-group\". Add repository to group. Save the configuration.</p> </li> <li> <p>Provision secrets using manifest, EDP Portal or with the externalSecrets operator</p> </li> </ol> manifestEDP Portal UIExternal Secrets Operator <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: nexus-ci.user\nnamespace: &lt;edp-namespace&gt;\nlabels:\napp.edp.epam.com/secret-type: nexus\ntype: Opaque\nstringData:\npassword: &lt;nexus-user-password&gt;\nusername: &lt;nexus-user-id&gt;\n</code></pre> <p>Go to the <code>EDP Platform</code> open <code>EDP</code> -&gt; <code>Configuration</code> -&gt; <code>Nexus Integration</code> change <code>&lt;nexus-user-id&gt;</code> and <code>&lt;nexus-user-password&gt;</code> and click <code>save</code> button.</p> <p> Nexus update manual secret </p> <pre><code>\"nexus-ci.user\":\n{\n\"nexus-user-id\": \"XXXXXXX\",\n\"nexus-user-password\": \"XXXXXXX\"\n},\n</code></pre> <p>Go to the <code>EDP Platform</code> open <code>EDP</code> -&gt; <code>Configuration</code> -&gt; <code>Nexus Integration</code> yo will see message <code>Managed by External Secret</code>.</p> <p> Nexus managed by external secret operator </p> <p>More detail of External Secrets Operator Integration can found on the following page</p>"},{"location":"operator-guide/nexus-sonatype/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP With Values File</li> <li>Install External Secrets Operator</li> <li>External Secrets Operator Integration</li> </ul>"},{"location":"operator-guide/notification-msteams/","title":"Microsoft Teams Notification","text":"<p>This section describes how to set up and add notification status to Tekton pipelines by sending pipeline status to the Microsoft Teams channel.</p>"},{"location":"operator-guide/notification-msteams/#create-incoming-webhook","title":"Create Incoming WebHook","text":"<p>To create a link to Incoming Webhook for the Microsoft Teams channel, follow the steps below:</p> <p>1. Open the channel which will be receiving notifications and click the <code>\u2022\u2022\u2022</code> button from the upper-right corner. Select <code>Connectors</code> in the dropdown menu:      Microsoft Teams menu </p> <p>2. In the search field, type <code>Incoming Webhook</code> and click <code>Configure</code>:      Connectors </p> <p>3. Provide a name and upload an image for the webhook if necessary. Click <code>Create</code>:      Connectors setup </p> <p>4. Copy and save the unique <code>WebHookURL</code> presented in the dialog. Click <code>Done</code>:      WebHookURL </p> <p>5. Create a secret with the  within the  namespace. <pre><code>  kubectl -n &lt;edp-project&gt; create secret generic microsoft-teams-webhook-url \\\n--from-literal=url=&lt;webhookURL&gt;\n</code></pre> <p>6. Add the notification task to the pipeline and add the code below in <code>final-block</code> in the pipeline and save:</p> <pre><code>{{ include \"send-to-microsoft-teams-build\" . | nindent 4 }}\n</code></pre>"},{"location":"operator-guide/notification-msteams/#customize-notification-message","title":"Customize Notification Message","text":"<p>To make notification message informative, relevant text should be added to the message. Here are the steps to implement it:</p> <ol> <li> <p>Create a new pipeline with a unique name or modify your custom pipeline created before.</p> </li> <li> <p>Add the task below in the <code>finally</code> block with a unique name. Edit the <code>params.message</code> value if necessary:</p> </li> </ol> View: Task send-to-microsoft-teams <pre><code>- name: 'microsoft-teams-pipeline-status-notification-failed\nparams:\n- name: webhook-url-secret\nvalue: microsoft-teams-webhook-url\n- name: webhook-url-secret-key\nvalue: url\n- name: message\nvalue: &gt;-\nBuild Failed project: $(params.CODEBASE_NAME)&lt;br&gt; branch: $(params.git-source-revision)&lt;br&gt; pipeline: &lt;a href=$(params.pipelineUrl)&gt;$(context.pipelineRun.name)&lt;/a&gt;&lt;br&gt; commit message: $(params.COMMIT_MESSAGE)\ntaskRef:\nkind: Task\nname: send-to-microsoft-teams\nwhen:\n- input: $(tasks.status)\noperator: in\nvalues:\n- Failed\n- PipelineRunTimeout\n</code></pre> <p>After customization, the following message is supposed to appear in the channel when failing pipelines:</p> <p> Notification example </p>"},{"location":"operator-guide/notification-msteams/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Install Tekton</li> </ul>"},{"location":"operator-guide/oauth2-proxy/","title":"Protect Endpoints","text":"<p>OAuth2-Proxy is a versatile tool that serves as a reverse proxy, utilizing the OAuth 2.0 protocol with various providers like Google, GitHub, and Keycloak to provide both authentication and authorization. This guide instructs readers on how to protect their applications' endpoints using OAuth2-Proxy. By following these steps, users can strengthen their endpoints' security without modifying their current application code. In the context of EDP, it has integration with the Keycloak OIDC provider, enabling it to link with any component that lacks built-in authentication.</p> <p>Note</p> <p>OAuth2-Proxy is disabled by default when installing EDP.</p>"},{"location":"operator-guide/oauth2-proxy/#prerequisites","title":"Prerequisites","text":"<ul> <li>Keycloak with OIDC authentication is installed.</li> </ul>"},{"location":"operator-guide/oauth2-proxy/#enable-oauth2-proxy","title":"Enable OAuth2-Proxy","text":"<p>Enabling OAuth2-Proxy implies the following general steps:</p> <ol> <li>Update your EDP deployment using command <code>--set 'oauth2_proxy.enabled=true'</code> or the <code>--values</code> file by enabling the oauth2_proxy parameter.</li> <li>Check that OAuth2-Proxy is deployed successfully.</li> <li>Enable authentication for your Ingress by adding <code>auth-signin</code> and <code>auth-url</code> of OAuth2-Proxy to its annotation.</li> </ol> <p>This will deploy and connect OAuth2-Proxy to your application endpoint.</p>"},{"location":"operator-guide/oauth2-proxy/#enable-oauth2-proxy-on-tekton-dashboard","title":"Enable OAuth2-Proxy on Tekton Dashboard","text":"<p>The example below illustrates how to use OAuth2-Proxy in practice when using the Tekton dashboard:</p> KubernetesOpenshift <ol> <li>Run <code>helm upgrade</code> to update edp-install release: <pre><code>helm upgrade --version &lt;version&gt; --set 'oauth2_proxy.enabled=true' edp-install --namespace &lt;edp-project&gt;\n</code></pre></li> <li>Check that OAuth2-Proxy is deployed successfully.</li> <li>Edit the Tekton dashboard Ingress annotation by adding <code>auth-signin</code> and <code>auth-url</code> of oauth2-proxy by <code>kubectl</code> command: <pre><code>kubectl annotate ingress &lt;application-ingress-name&gt; nginx.ingress.kubernetes.io/auth-signin='https://&lt;oauth-ingress-host&gt;/oauth2/start?rd=https://$host$request_uri' nginx.ingress.kubernetes.io/auth-url='http://oauth2-proxy.&lt;edp-project&gt;.svc.cluster.local:8080/oauth2/auth'\n</code></pre></li> </ol> <ol> <li>Generate a cookie-secret for proxy with the following command: <pre><code>tekton_dashboard_cookie_secret=$(openssl rand -base64 32 | head -c 32)\n</code></pre></li> <li>Create <code>tekton-dashboard-proxy-cookie-secret</code> in the  namespace: <pre><code>kubectl -n &lt;edp-project&gt; create secret generic tekton-dashboard-proxy-cookie-secret \\\n--from-literal=cookie-secret=${tekton_dashboard_cookie_secret}\n</code></pre> <li>Run <code>helm upgrade</code> to update edp-install release: <pre><code>helm upgrade --version &lt;version&gt; --set 'edp-tekton.dashboard.openshift_proxy.enabled=true' edp-install --namespace &lt;edp-project&gt;\n</code></pre></li>"},{"location":"operator-guide/oauth2-proxy/#related-articles","title":"Related Articles","text":"<p>Keycloak Installation Keycloak OIDC Installation Tekton Installation</p>"},{"location":"operator-guide/openshift-cluster-settings/","title":"Set Up OpenShift","text":"<p>Make sure the cluster meets the following conditions:</p> <ol> <li> <p>OpenShift cluster is installed with minimum 2 worker nodes with total capacity 8 Cores and 32Gb RAM.</p> </li> <li> <p>Load balancer (if any exists in front of OpenShift router or ingress controller) is configured with session stickiness, disabled HTTP/2 protocol and header size of 64k support.</p> <p>Find below an example of the Config Map for the NGINX Ingress Controller:</p> <pre><code>kind: ConfigMap\napiVersion: v1\nmetadata:\nname: nginx-configuration\nnamespace: ingress-nginx\nlabels:\napp.kubernetes.io/name: ingress-nginx\napp.kubernetes.io/part-of: ingress-nginx\ndata:\nclient-header-buffer-size: 64k\nlarge-client-header-buffers: 4 64k\nuse-http2: \"false\"\n</code></pre> </li> <li> <p>Cluster nodes and pods have access to the cluster via external URLs. For instance, add in AWS the VPC NAT gateway elastic IP to the cluster external load balancers security group).</p> </li> <li> <p>Keycloak instance is installed. To get accurate information on how to install Keycloak, please refer to the Install Keycloak instruction.</p> </li> <li> <p>The installation machine with oc is installed with the cluster-admin access to the OpenShift cluster.</p> </li> <li> <p>Helm 3.10 is installed on the installation machine with the help of the Installing Helm instruction.</p> </li> <li> <p>Storage classes are used with the Retain Reclaim Policy and Delete Reclaim Policy.</p> </li> <li> <p>We recommended using our storage class as default storage class.</p> <p>Info</p> <p>By default, EDP uses the default Storage Class in a cluster. The EDP development team recommends using the following Storage Classes. See an example below.</p> <p>Storage class templates with the Retain and Delete Reclaim Policies:</p> ebs-scgp3gp3-retain <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\nname: ebs-sc\nannotations:\nstorageclass.kubernetes.io/is-default-class: 'true'\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Retain\nvolumeBindingMode: Immediate\n</code></pre> <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp3\nannotations:\nstorageclass.kubernetes.io/is-default-class: 'true'\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Delete\nvolumeBindingMode: Immediate\nallowVolumeExpansion: true\n</code></pre> <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp3-retain\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Retain\nvolumeBindingMode: WaitForFirstConsumer\nallowVolumeExpansion: true\n</code></pre> </li> </ol>"},{"location":"operator-guide/openshift-cluster-settings/#related-articles","title":"Related Articles","text":"<ul> <li>Install Amazon EBS CSI Driver</li> <li>Install Keycloak</li> </ul>"},{"location":"operator-guide/overview-devsecops/","title":"Secure Delivery on the Platform","text":"<p>The EPAM Delivery Platform emphasizes the importance of incorporating security practices into the software development lifecycle through the DevSecOps approach. By integrating a diverse range of open-source and enterprise security tools tailored to specific functionalities, organizations can ensure efficient and secure software development. These tools, combined with fundamental DevSecOps principles such as collaboration, continuous security, and automation, contribute to the identification and remediation of vulnerabilities early in the process, minimizes risks, and fosters a security-first culture across the organization.</p> <p>The EPAM Delivery Platform enabling seamless integration with various security tools and vulnerability management systems, enhancing the security of source code and ensuring compliance.</p>"},{"location":"operator-guide/overview-devsecops/#supported-solutions","title":"Supported Solutions","text":"<p>The below table categorizes various open-source and enterprise security tools based on their specific functionalities. It provides a comprehensive view of the available options for each security aspect. This classification facilitates informed decision-making when selecting and integrating security tools into a development pipeline, ensuring an efficient and robust security stance. EDP supports the integration of both open-source and enterprise security tools, providing a flexible and versatile solution for security automation. See table below for more details.</p> Functionality Open-Source Tools (integrated in Pipelines) Enterprise Tools (available for Integration) Hardcoded Credentials Scanner TruffleHog, GitLeaks, GitSecrets GitGuardian, SpectralOps, Bridgecrew Static Application Security Testing SonarQube, Semgrep CLI Veracode, Checkmarx, Coverity Software Composition Analysis OWASP Dependency-Check, cdxgen, Nancy Black Duck Hub, Mend, Snyk Container Security Trivy, Grype, Clair Aqua Security, Sysdig Secure, Snyk Infrastructure as Code Security Checkov, Tfsec Bridgecrew, Prisma Cloud, Snyk Dynamic Application Security Testing OWASP Zed Attack Proxy Fortify WebInspect, Rapid7 InsightAppSec, Checkmarx Continuous Monitoring and Logging ELK Stack, OpenSearch, Loki Splunk, Datadog Security Audits and Assessments OpenVAS Tenable Nessus, QualysGuard, BurpSuite Professional Vulnerability Management and Reporting DefectDojo, OWASP Dependency-Track - <p>For obtaining and managing report post scanning, deployment of various vulnerability management systems and security tools is required. These include:</p>"},{"location":"operator-guide/overview-devsecops/#defectdojo","title":"DefectDojo","text":"<p>DefectDojo is a comprehensive vulnerability management and security orchestration platform facilitating the handling of uploaded security reports. Examine the prerequisites and fundamental instructions for installing DefectDojo on Kubernetes or OpenShift platforms.</p>"},{"location":"operator-guide/overview-devsecops/#owasp-dependency-track","title":"OWASP Dependency Track","text":"<p>Dependency Track is an intelligent Software Composition Analysis (SCA) platform that provides a comprehensive solution for managing vulnerabilities in third-party and open-source components.</p>"},{"location":"operator-guide/overview-devsecops/#gitleaks","title":"Gitleaks","text":"<p>Gitleaks is a versatile SAST tool used to scan Git repositories for hardcoded secrets, such as passwords and API keys, to prevent potential data leaks and unauthorized access.</p>"},{"location":"operator-guide/overview-devsecops/#trivy","title":"Trivy","text":"<p>Trivy is a simple and comprehensive vulnerability scanner for containers and other artifacts, providing insight into potential security issues across multiple ecosystems.</p>"},{"location":"operator-guide/overview-devsecops/#grype","title":"Grype","text":"<p>Grype is a fast and reliable vulnerability scanner for container images and filesystems, maintaining an up-to-date vulnerability database for efficient and accurate scanning.</p>"},{"location":"operator-guide/overview-devsecops/#tfsec","title":"Tfsec","text":"<p>Tfsec is an effective Infrastructure as Code (IaC) security scanner, tailored specifically for reviewing Terraform templates. It helps identify potential security issues related to misconfigurations and non-compliant practices, enabling developers to address vulnerabilities and ensure secure infrastructure deployment.</p>"},{"location":"operator-guide/overview-devsecops/#checkov","title":"Checkov","text":"<p>Checkov is a robust static code analysis tool designed for IaC security, supporting various IaC frameworks such as Terraform, CloudFormation, and Kubernetes. It assists in detecting and mitigating security and compliance misconfigurations, promoting best practices and adherence to industry standards across the infrastructure.</p>"},{"location":"operator-guide/overview-devsecops/#cdxgen","title":"Cdxgen","text":"<p>Cdxgen is a lightweight and efficient tool for generating Software Bill of Materials (SBOM) using CycloneDX, a standard format for managing component inventory. It helps organizations maintain an up-to-date record of all software components, their versions, and related vulnerabilities, streamlining monitoring and compliance within the software supply chain.</p>"},{"location":"operator-guide/overview-devsecops/#semgrep-cli","title":"Semgrep CLI","text":"<p>Semgrep CLI is a versatile and user-friendly command-line interface for the Semgrep security scanner, enabling developers to perform Static Application Security Testing (SAST) for various programming languages. It focuses on detecting and preventing potential security vulnerabilities, code quality issues, and custom anti-patterns, ensuring secure and efficient code development.</p>"},{"location":"operator-guide/overview-manage-jenkins-pipelines/","title":"Overview","text":"<p>Jenkins job provisioners are responsible for creating and managing pipelines in Jenkins. In other words, provisioners configure all Jenkins pipelines and bring them to the state described in the provisioners code. Two types of provisioners are available in EDP:</p> <ul> <li>CI-provisioner - manages the application folder, and its Code Review, Build and Create Release pipelines.</li> </ul> <ul> <li>CD-provisioner - manages the Deploy pipelines.</li> </ul> <p>The subsections describe the creation/update process of provisioners and their content depending on EDP customization.</p>"},{"location":"operator-guide/overview-sast/","title":"Static Application Security Testing Overview","text":"<p>EPAM Delivery Platform provides the implemented Static Application Security Testing support allowing to work with the Semgrep security scanner and the DefectDojo vulnerability management system to check the source code for known vulnerabilities.</p>"},{"location":"operator-guide/overview-sast/#supported-languages","title":"Supported Languages","text":"<p>EDP SAST supports a number of languages and package managers.</p> Language (Package Managers) Scan Tool Build Tool Java Semgrep Maven, Gradle Go Semgrep Go React Semgrep Npm"},{"location":"operator-guide/overview-sast/#supported-vulnerability-management-system","title":"Supported Vulnerability Management System","text":"<p>To get and then manage a SAST report after scanning, it is necessary to deploy the vulnerability management system, for instance, DefectDojo.</p>"},{"location":"operator-guide/overview-sast/#defectdojo","title":"DefectDojo","text":"<p>DefectDojo is a vulnerability management and security orchestration platform that allows managing the uploaded security reports.</p> <p>Inspect the prerequisites and the main steps for installing DefectDojo on Kubernetes or OpenShift platforms.</p>"},{"location":"operator-guide/overview-sast/#related-articles","title":"Related Articles","text":"<ul> <li>Add Security Scanner</li> <li>Semgrep</li> </ul>"},{"location":"operator-guide/perf-integration/","title":"Perf Server Integration","text":"<p>Integration with Perf Server allows connecting to the PERF Board (Project Performance Board) and monitoring the overall team performance as well as setting up necessary metrics.</p> <p>Note</p> <p>To adjust the PERF Server integration, make sure that PERF Operator is deployed. To get more information about the PERF Operator installation and architecture, please refer to the PERF Operator page.</p> <p>For integration, take the following steps:</p> <ol> <li> <p>Create Secret in the OpenShift/Kubernetes namespace for Perf Server account with the username and password fields:</p> <pre><code>apiVersion: v1\ndata:\npassword: passwordInBase64\nusername: usernameInBase64\nkind: Secret\nmetadata:\nname: epam-perf-user\ntype: kubernetes.io/basic-auth\n</code></pre> </li> <li> <p>In the edp-config config map, enable the perf_integration flag and click Save:</p> <pre><code> perf_integration_enabled: 'true'\n</code></pre> </li> <li> <p>Being in Admin Console, navigate to the Advanced Settings menu to check that the Integrate with Perf Server check box appeared:</p> <p> Advanced settings </p> </li> </ol>"},{"location":"operator-guide/perf-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> </ul>"},{"location":"operator-guide/prerequisites/","title":"EDP Installation Prerequisites Overview","text":"<p>Before installing EDP:</p> <ul> <li>Install and configure Kubernetes or OpenShift cluster.</li> <li>Install EDP components for the selected EDP installation scenario.</li> </ul>"},{"location":"operator-guide/prerequisites/#edp-installation-scenarios","title":"EDP Installation Scenarios","text":"<p>There are two EDP installation scenarios based on the selected CI tool: Tekton (default) or Jenkins.</p> <p>Scenario 1: Tekton CI tool. By default, EDP uses Tekton as a CI tool and EDP Headlamp as a UI tool.</p> <p>Scenario 2: Jenkins CI tool. To use Jenkins as a CI tool, it is required to install the deprecated Admin Console UI tool. Admin Console is used only as a dependency for Jenkins, and Headlamp will still be used as a UI tool.</p> <p>Note</p> <p>Starting from version 3.0.0, all the new enhancements and functionalities will be introduced only for Tekton deploy scenario. Jenkins deploy scenario will be supported at the bug fix and security breach level only. We understand that some users may need additional functionality in Jenkins, so if any, please create your request here. To stay up-to-date with all the updates, please check the Release Notes page.</p> <p>Find below the list of the components to be installed for each scenario:</p> Component Tekton CI tool Jenkins CI tool Cluster Tekton Mandatory - NGINX Ingress Controller1 Mandatory Mandatory Keycloak Mandatory Mandatory DefectDojo Mandatory Mandatory Argo CD Mandatory Optional ReportPortal Optional Optional Kiosk Optional Optional External Secrets Optional Optional Harbor Optional Optional <p>Note</p> <p>Alternatively, use Helmfiles to install the EDP components.</p> <p>After setting up the cluster and installing EDP components according to the selected scenario, proceed to the EDP installation.</p>"},{"location":"operator-guide/prerequisites/#related-articles","title":"Related Articles","text":"<ul> <li>Set Up Kubernetes</li> <li>Set Up OpenShift</li> <li>Install EDP</li> </ul> <ol> <li> <p>OpenShift cluster uses Routes to provide access to pods from external resources.\u00a0\u21a9</p> </li> </ol>"},{"location":"operator-guide/report-portal-integration-tekton/","title":"Integration With Tekton","text":"<p>ReportPortal integration with Tekton allows managing all automation results and reports in one place, visualizing metrics and analytics, team collaborating to associate statistics results.</p> <p>For integration, take the following steps:</p> <ol> <li> <p>Log in to the ReportPortal console and navigate to the User Profile menu:</p> <p> ReportPortal profile </p> </li> <li> <p>Copy the Access token and use it as a value while creating a kubernetes secret for the ReportPortal credentials:</p> <pre><code>apiVersion: v1\nkind: Secret\ntype: Opaque\nmetadata:\nname: rp-credentials\nnamespace: &lt;edp-project&gt;\nstringData:\nrp_uuid: &lt;access-token&gt;\n</code></pre> </li> <li> <p>In the Configuration examples section of the ReportPortal User Profile menu, copy the following <code>REQUIRED</code> fields: <code>rp.endpoint</code>, <code>rp.launch</code> and <code>rp.project</code>. Insert these fields to the <code>pytest.ini</code> file in root directory of your project:</p> <pre><code>[pytest]\naddopts = -rsxX -l --tb=short --junitxml test-report.xml\nrp_endpoint = &lt;endpoint&gt;\nrp_launch = &lt;launch&gt;\nrp_project = &lt;project&gt;\n</code></pre> </li> <li> <p>In root directory of the project create/update requirements.txt file and fill with following. it's mandatory to install report-portal python library (version may vary):   <pre><code>pytest-reportportal == 5.1.2\n</code></pre></p> </li> <li> <p>Create a custom Tekton task:</p> View: Custom Tekton task <pre><code>apiVersion: tekton.dev/v1beta1\nkind: Task\nmetadata:\nlabels:\napp.kubernetes.io/version: '0.1'\nname: pytest-reportportal\nnamespace: &lt;edp-project&gt;\nspec:\ndescription: |-\nThis task can be used to run pytest integrated with report portal.\nparams:\n- default: .\ndescription: The path where package.json of the project is defined.\nname: PATH_CONTEXT\ntype: string\n- name: EXTRA_COMMANDS\ntype: string\n- default: python:3.8-alpine3.16\ndescription: The python image you want to use.\nname: BASE_IMAGE\ntype: string\n- default: rp-credentials\ndescription: name of the secret holding the rp token\nname: rp-secret\ntype: string\nsteps:\n- env:\n- name: HOME\nvalue: $(workspaces.source.path)\n- name: RP_UUID\nvalueFrom:\nsecretKeyRef:\nkey: rp_uuid\nname: $(params.rp-secret)\nimage: $(params.BASE_IMAGE)\nname: pytest\nresources: {}\nscript: &gt;\n#!/usr/bin/env sh\nset -e\nexport PATH=$PATH:$HOME/.local/bin\n$(params.EXTRA_COMMANDS)\n# tests are being run from ./test directory in the project\npytest ./tests --reportportal\nworkingDir: $(workspaces.source.path)/$(params.PATH_CONTEXT)\nworkspaces:\n- name: source\n</code></pre> </li> <li> <p>Add this task ref to your Tekton pipeline after tasks:</p> View: Tekton pipeline <pre><code>- name: pytest\nparams:\n- name: BASE_IMAGE\nvalue: $(params.image)\n- name: EXTRA_COMMANDS\nvalue: |\nset -ex\npip3 install -r requirements.txt\n[ -f run_service.py ] &amp;&amp; python run_service.py &amp;\nrunAfter:\n- compile\ntaskRef:\nkind: Task\nname: pytest-reportportal\nworkspaces:\n- name: source\nworkspace: shared-workspace\n</code></pre> </li> <li> <p>Launch your Tekton pipeline and check that the custom task has been successfully executed:</p> <p> Tekton task successfully executed </p> </li> <li> <p>Test reports will be displayed in the Launches section of the ReportPortal:</p> <p> Test report results </p> </li> </ol>"},{"location":"operator-guide/report-portal-integration-tekton/#related-articles","title":"Related Articles","text":"<ul> <li>ReportPortal Installation</li> <li>Keycloak Integration</li> <li>Pytest Integration With ReportPortal</li> </ul>"},{"location":"operator-guide/reportportal-keycloak/","title":"Keycloak Integration","text":"<p>Follow the steps below to integrate the ReportPortal with Keycloak.</p>"},{"location":"operator-guide/reportportal-keycloak/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed Keycloak. Please follow the instruction for details.</li> <li>Installed ReportPortal. Please follow the instruction to install it from Helmfile or using the Helm Chart.</li> </ul>"},{"location":"operator-guide/reportportal-keycloak/#keycloak-configuration","title":"Keycloak Configuration","text":"<ol> <li> <p>Navigate to Client Scopes &gt; Create client scope and create a new scope with the SAML protocol type.</p> </li> <li> <p>Navigate to Client Scopes &gt; your_scope_name &gt; Mappers &gt; Configure a new mapper &gt; select the User Attribute mapper type. Add three mappers for the email, first name, and last name by typing <code>lastName</code>, <code>firstName</code>, and <code>email</code> in the User Attribute field:</p> <ul> <li>Name is a display name in Keycloak.</li> <li>User Attribute is a user property for mapping.</li> <li>SAML Attribute Name is an attribute used for requesting information in the ReportPortal configuration.</li> <li>SAML Attribute NameFormat: <code>Basic</code>.</li> <li>Aggregate attribute values: <code>Off</code>.</li> </ul> <p> User mapper sample Scope mappers </p> </li> <li> <p>Navigate to Clients &gt; Create client and fill in the following fields:</p> <ul> <li>Client type: <code>SAML</code>.</li> <li>Client ID: <code>report.portal.sp.id</code>.</li> </ul> <p>Warning</p> <p>The <code>report.portal.sp.id</code> Client ID is a constant value.</p> </li> <li> <p>Navigate to Client &gt; your_client &gt; Settings and add <code>https://&lt;report-portal-url\\&gt;/*</code> to the Valid redirect URIs.</p> </li> <li> <p>Navigate to Client &gt; your_client &gt; Keys and disable Client signature required.</p> <p> Client keys </p> </li> <li> <p>Navigate to Client &gt; your_client &gt; Client scopes and add the scope created on step 3 with the default Assigned type.</p> <p> Client scopes </p> </li> </ol>"},{"location":"operator-guide/reportportal-keycloak/#reportportal-configuration","title":"ReportPortal Configuration","text":"<ol> <li> <p>Log in to the ReportPortal with the admin permissions.</p> </li> <li> <p>Navigate to Client &gt; Administrate &gt; Plugins and select the SAML plugin.</p> <p> Plugins menu </p> </li> <li> <p>To add a new integration, fill in the following fields:</p> <p> Add SAML configuration </p> <ul> <li>Provider name is the display name in the ReportPortal login page.</li> <li>Metadata URL: <code>https://&lt;keycloak_url\\&gt;/auth/realms/&lt;realm\\&gt;/protocol/saml/descriptor</code>.</li> <li>Email is the value from the SAML Attribute Name field in the Keycloak mapper.</li> <li>RP callback URL: <code>https://&lt;report_portal_url\\&gt;/uat</code>.</li> <li>Name attributes mode is the first &amp; last name (type based on your mapper).</li> <li>First name is the value from the SAML Attribute Name field in the Keycloak mapper.</li> <li>Last name is the value from the SAML Attribute Name field in the Keycloak mapper.</li> </ul> </li> <li> <p>Log in to the ReportPortal.</p> <p>Note</p> <p>By default, after the first login, ReportPortal creates the &lt;your_email&gt;_personal project and adds an account with the <code>Project manager</code> role.</p> <p> Report portal login page </p> </li> </ol>"},{"location":"operator-guide/reportportal-keycloak/#related-articles","title":"Related Articles","text":"<ul> <li>ReportPortal Installation</li> <li>Integration With Tekton</li> </ul>"},{"location":"operator-guide/restore-edp-with-velero/","title":"Restore EDP Tenant With Velero","text":"<p>You can use the Velero tool to restore a EDP tenant. Explore the main steps for backup and restoring below.</p> <ol> <li> <p>Delete all related entities in Keycloak: realm and clients from master/openshift realms. Navigate to the entities list in the Keycloak, select the necessary ones, and click the deletion icon on the entity overview page.    If there are customized configs in Keycloak, save them before making backup.</p> <p> Remove keycloak realm </p> </li> <li> <p>To restore EDP, install and configure the Velero tool. Please refer to the Install Velero documentation for details.</p> </li> <li> <p>Remove all locks for operators. Delete all config maps that have \u2039OPERATOR_NAME\u203a-operator-lock names. Then restart all pods with operators, or simply run the following command:</p> <pre><code>     kubectl -n &lt;EDP_NAMESPACE&gt; delete cm $(kubectl -n &lt;EDP_NAMESPACE&gt; get cm | grep 'operator-lock' | awk '{print $1}')\n</code></pre> </li> <li> <p>Recreate the admin password and delete the Jenkins pod. Or change the script to update the admin password in Jenkins every time when the pod is updated.</p> </li> </ol>"},{"location":"operator-guide/sast-scaner-semgrep/","title":"Semgrep","text":"<p>Semgrep is an open-source static source code analyzer for finding bugs and enforcing code standards.</p> <p>Semgrep scanner is installed on the EDP Jenkins SAST agent and runs on the <code>sast</code> pipeline stage. For details, please refer to the edp-library-stages repository.</p>"},{"location":"operator-guide/sast-scaner-semgrep/#supported-languages","title":"Supported Languages","text":"<p>Semgrep supports more than 20 languages, see the full list in the official documentation. EDP uses Semgrep to scan Java, JavaScript and Go languages.</p>"},{"location":"operator-guide/sast-scaner-semgrep/#related-articles","title":"Related Articles","text":"<ul> <li>Add Security Scanner</li> </ul>"},{"location":"operator-guide/schedule-pods-restart/","title":"Schedule Pods Restart","text":"<p>In case it is necessary to restart pods, use a CronJob according to the following template:</p> View: template <pre><code>---\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\nnamespace: &lt;NAMESPACE&gt;\nname: apps-restart\nrules:\n- apiGroups: [\"apps\"]\nresources:\n- deployments\n- statefulsets\nverbs:\n- 'get'\n- 'list'\n- 'patch'\n---\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\nname: apps-restart\nnamespace: &lt;NAMESPACE&gt;\nsubjects:\n- kind: ServiceAccount\nname: apps-restart-sa\nnamespace: &lt;NAMESPACE&gt;\nroleRef:\nkind: Role\nname: apps-restart\napiGroup: \"\"\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: apps-restart-sa\nnamespace: &lt;NAMESPACE&gt;\n---\napiVersion: batch/v1beta1\nkind: CronJob\nmetadata:\nname: apps-rollout-restart\nnamespace: &lt;NAMESPACE&gt;\nspec:\nschedule: \"0 9 * * MON-FRI\"\njobTemplate:\nspec:\ntemplate:\nspec:\nserviceAccountName: apps-restart-sa\ncontainers:\n- name: kubectl-runner\nimage: bitnami/kubectl\ncommand:\n- /bin/sh\n- -c\n- kubectl get -n &lt;NAMESPACE&gt; -o name deployment,statefulset | grep &lt;NAME_PATTERN&gt;| xargs kubectl -n &lt;NAMESPACE&gt; rollout restart\nrestartPolicy: Never\n</code></pre> <p>Modify the Cron expression in the CronJob manifest if needed.</p>"},{"location":"operator-guide/sonarqube/","title":"SonarQube Integration","text":"<p>This documentation guide provides comprehensive instructions for integrating external SonarQube with the EPAM Delivery Platform.</p>"},{"location":"operator-guide/sonarqube/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure that you have the following prerequisites:</p> <ul> <li>Kubectl version 1.26.0 is installed.</li> <li>Helm version 3.12.0+ is installed.</li> </ul> <p>EDP includes a pre-installed SonarQube instance, which is ready to use with no extra configuration, delivering code analysis capabilities out of the box. Yet, EDP maintains the option to integrate external SonarQube instances tailored to specific project needs.</p>"},{"location":"operator-guide/sonarqube/#switch-to-external-sonarqube","title":"Switch to External Sonarqube","text":"<ol> <li> <p>To use external SonarQube in EDP, redefine the following parameters in the EDP-install values.yaml file. In the <code>sonarUrl</code> parameter, input the appropriate values for your SonarQube service, namespace and a port <code>http://&lt;service-name&gt;.&lt;sonarqube-namespace&gt;:9000</code>. Alternatively, use the address and a port to external SonarQube <code>http(s)://&lt;endpoint&gt;</code> instead.</p> <pre><code>global:\nsonarUrl: \"\"\n\nsonar-operator:\nenabled: false\n</code></pre> </li> <li> <p>Proceed with the installation of EDP by following the Install EDP guide.</p> </li> </ol> <p>Note</p> <p>You can install preconfigured SonarQube with edp-sonar-operator using EDP addons approach.</p>"},{"location":"operator-guide/sonarqube/#configuration","title":"Configuration","text":"<p>To establish robust authentication and precise access control, generating a SonarQube token is essential. This token is a distinct identifier, enabling effortless integration between SonarQube and EDP. To generate the SonarQube token, proceed with the following steps:</p> <ol> <li> <p>Open the SonarQube UI and navigate to <code>Administration</code> -&gt; <code>Security</code> -&gt; <code>User</code>. Create a new user or select an existing one. Click the <code>Options List</code> icon to create a token:</p> <p> SonarQube user settings </p> </li> <li> <p>Type the <code>ci-user</code> username, define an expiration period, and click the <code>Generate</code> button to create the token:</p> <p> SonarQube create token </p> </li> <li> <p>Click the <code>Copy</code> button to copy the generated <code>&lt;Sonarqube-token&gt;</code>:</p> <p> SonarQube token </p> </li> <li> <p>Provision secrets using kubectl, EDP Portal or with the externalSecrets operator</p> </li> </ol> kubectlManual SecretExternal Secrets Operator <pre><code>kubectl -n &lt;edp_namespace&gt; create secret generic sonar-ciuser-token \\\n--from-literal=username=&lt;username&gt; \\\n--from-literal=secret=&lt;Sonarqube-token&gt;\n</code></pre> <p>Go to the <code>EDP Portal UI</code> open <code>EDP</code> -&gt; <code>Configuration</code> -&gt; <code>Sonarqube Integration</code> change or apply <code>User</code> and <code>password</code> and click <code>save</code> button.</p> <p> SonarQube update manual secret </p> <pre><code>\"sonar-ciuser-token\":\n{\n\"username\": \"XXXXXXXXXXXX\",\n\"secret\": \"XXXXXXXXXXXX\"\n},\n</code></pre> <p>Go to the <code>EDP Platform UI</code> open <code>EDP</code> -&gt; <code>Configuration</code> -&gt; <code>Sonarqube Integration</code> yo will se message <code>Managed by External Secret</code>.</p> <p> SonarQube managed by external secret operator </p> <p>More detail of External Secrets Operator Integration can found on the following page</p>"},{"location":"operator-guide/sonarqube/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP With Values File</li> <li>Install External Secrets Operator</li> <li>External Secrets Operator Integration</li> </ul>"},{"location":"operator-guide/ssl-automation-okd/","title":"Use Cert-Manager in OpenShift","text":"<p>The following material covers Let's Encrypt certificate automation with cert-manager using AWS Route53.</p> <p>The cert-manager is a Kubernetes/OpenShift operator that allows to issue and automatically renew SSL certificates. In this tutorial, the steps to secure DNS Name will be demonstrated.</p> <p>Below is an instruction on how to automatically issue and install wildcard certificates on OpenShift Ingress Controller and API Server covering all cluster Routes. To secure separate OpenShift Routes, please refer to the OpenShift Route Support project for <code>cert-manager</code>.</p>"},{"location":"operator-guide/ssl-automation-okd/#prerequisites","title":"Prerequisites","text":"<ul> <li>The cert-manager;</li> <li>OpenShift v4.7 - v4.11;</li> <li>Connection to the OpenShift Cluster;</li> <li>Enabled AWS IRSA;</li> <li>The latest <code>oc</code> utility. The <code>kubectl</code> tool can also be used for most of the commands.</li> </ul>"},{"location":"operator-guide/ssl-automation-okd/#install-cert-manager-operator","title":"Install Cert-Manager Operator","text":"<p>Install the <code>cert-manager</code> operator via OpenShift OperatorHub that uses Operator Lifecycle Manager (OLM):</p> <ol> <li> <p>Go to the OpenShift Admin Console \u2192 OperatorHub, search for the <code>cert-manager</code>, and click Install:</p> <p> Cert-Manager Installation </p> </li> <li> <p>Modify the <code>ClusterServiceVersion</code> OLM resource, by selecting the Update approval \u2192 Manual. If selecting Update approval \u2192 Automatic after the automatic operator update, the parameters in the <code>ClusterServiceVersion</code> will be reset to default.</p> <p>Note</p> <p>Installing an operator with Manual approval causes all operators installed in namespace <code>openshift-operators</code> to function as manual approval strategy. In case the Manual approval is chosen, review the manual installation plan and approve it.</p> <p> Cert-Manager Installation </p> </li> <li> <p>Navigate to Operators \u2192 Installed Operators and check the operator status to be Succeeded:</p> <p> Cert-Manager Installation </p> </li> <li> <p>In case of errors, troubleshoot the Operator issues:</p> <pre><code>oc describe operator cert-manager -n openshift-operators\noc describe sub cert-manager -n openshift-operators\n</code></pre> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#create-aws-role-for-route53","title":"Create AWS Role for Route53","text":"<p>The <code>cert-manager</code> should be configured to validate Wildcard certificates using the DNS-based method.</p> <ol> <li> <p>Check the DNS Hosted zone ID in AWS Route53 for your domain.</p> <p> Hosted Zone ID </p> </li> <li> <p>Create Route53 Permissions policy in AWS for <code>cert-manager</code> to be able to create DNS TXT records for the certificate validation. In this example, <code>cert-manager</code> permissions are given for a particular DNS zone only. Replace Hosted zone ID XXXXXXXX in the \"Resource\": \"arn:aws:route53:::hostedzone/XXXXXXXXXXXX\".</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": \"route53:GetChange\",\n\"Resource\": \"arn:aws:route53:::change/*\"\n},\n{\n\"Effect\": \"Allow\",\n\"Action\": [\n\"route53:ChangeResourceRecordSets\",\n\"route53:ListResourceRecordSets\"\n],\n\"Resource\": \"arn:aws:route53:::hostedzone/XXXXXXXXXXXX\"\n}\n]\n}\n</code></pre> </li> <li> <p>Create an AWS Role with Custom trust policy for the <code>cert-manager</code> service account to use the AWS IRSA feature and then attach the created policy. Replace the following:</p> <ul> <li><code>${aws-account-id}</code> with the AWS account ID of the EKS cluster.</li> <li><code>${aws-region}</code> with the region where the EKS cluster is located.</li> <li><code>${eks-hash}</code> with the hash in the EKS API URL; this will be a random 32 character hex string, for example, 45DABD88EEE3A227AF0FA468BE4EF0B5.</li> <li><code>${namespace}</code> with the namespace where cert-manager is running.</li> <li><code>${service-account-name}</code> with the name of the ServiceAccount object created by cert-manager.</li> <li>By default, it is \"system:serviceaccount:openshift-operators:cert-manager\" if <code>cert-manager</code> is installed via OperatorHub.</li> <li>Attach the created Permission policy for Route53 to the Role.</li> <li> <p>Optionally, add Permissions boundary to the Role.</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": \"sts:AssumeRoleWithWebIdentity\",\n\"Principal\": {\n\"Federated\": \"arn:aws:iam::* ${aws-account-id}:oidc-provider/oidc.eks.${aws-region}.amazonaws.com/id/${eks-hash}\"\n},\n\"Condition\": {\n\"StringEquals\": {\n\"oidc.eks.${aws-region}.amazonaws.com/id/${eks-hash}:sub\": \"system:serviceaccount:${namespace}:${service-account-name}\"\n}\n}\n}\n]\n}\n</code></pre> </li> </ul> </li> <li> <p>Copy the created Role ARN.</p> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#configure-cert-manager-integration-with-aws-route53","title":"Configure Cert-Manager Integration With AWS Route53","text":"<ol> <li> <p>Annotate the <code>ServiceAccount</code> created by <code>cert-manager</code> (required for AWS IRSA), and restart the <code>cert-manager</code> pod.</p> </li> <li> <p>Replace the <code>eks.amazonaws.com/role-arn</code> annotation value with your own Role ARN.</p> <pre><code>oc edit sa cert-manager -n openshift-operators\n</code></pre> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\nannotations:\neks.amazonaws.com/role-arn: arn:aws:iam::XXXXXXXXXXXX:role/cert-manager\n</code></pre> </li> <li> <p>Modify the <code>cert-manager</code> <code>Deployment</code> with the correct file system permissions <code>fsGroup: 1001</code>, so that the <code>ServiceAccount</code> token can be read.</p> <p>Note</p> <p>In case the <code>ServiceAccount</code> token cannot be read and the operator is installed using the OperatorHub, add <code>fsGroup: 1001</code> via OpenShift ClusterServiceVersion OLM resource. It should be a <code>cert-manager</code> controller spec. These actions are not required for OpenShift v4.10.</p> <pre><code>oc get csv\noc edit csv cert-manager.${VERSION}\n</code></pre> <pre><code>spec:\ntemplate:\nspec:\nsecurityContext:\nfsGroup: 1001\nserviceAccountName: cert-manager\n</code></pre> <p> Cert-Manager System Permissions </p> <p>Info</p> <p>A mutating admission controller will automatically modify all pods running with the service account:</p> <p> cert-manager controller pod <pre><code>apiVersion: apps/v1\nkind: Pod\n# ...\nspec:\n# ...\nserviceAccountName: cert-manager\nserviceAccount: cert-manager\ncontainers:\n- name: ...\n# ...\nenv:\n- name: AWS_ROLE_ARN\nvalue: &gt;-\narn:aws:iam::XXXXXXXXXXX:role/cert-manager\n- name: AWS_WEB_IDENTITY_TOKEN_FILE\nvalue: /var/run/secrets/eks.amazonaws.com/serviceaccount/token\nvolumeMounts:\n- name: aws-iam-token\nreadOnly: true\nmountPath: /var/run/secrets/eks.amazonaws.com/serviceaccount\nvolumes:\n- name: aws-iam-token\nprojected:\nsources:\n- serviceAccountToken:\naudience: sts.amazonaws.com\nexpirationSeconds: 86400\npath: token\ndefaultMode: 420\n</code></pre> </p> </li> <li> <p>If you have separate public and private DNS zones for the same domain (split-horizon DNS), modify the <code>cert-manager</code> <code>Deployment</code> in order to validate DNS TXT records via public recursive nameservers.</p> <p>Note</p> <p>Otherwise, you will be getting an error during a record validation:</p> <p><pre><code>Waiting for DNS-01 challenge propagation: NS ns-123.awsdns-00.net.:53 returned REFUSED for _acme-challenge.\n</code></pre> To avoid the error, add <code>--dns01-recursive-nameservers-only --dns01-recursive-nameservers=8.8.8.8:53,1.1.1.1:53</code> as ARGs to the <code>cert-manager</code> controller <code>Deployment</code>.</p> <pre><code>oc get csv\noc edit csv cert-manager.${VERSION}\n</code></pre> <pre><code>  labels:\napp: cert-manager\napp.kubernetes.io/component: controller\napp.kubernetes.io/instance: cert-manager\napp.kubernetes.io/name: cert-manager\napp.kubernetes.io/version: v1.9.1\nspec:\ncontainers:\n- args:\n- '--v=2'\n- '--cluster-resource-namespace=$(POD_NAMESPACE)'\n- '--leader-election-namespace=kube-system'\n- '--dns01-recursive-nameservers-only'\n- '--dns01-recursive-nameservers=8.8.8.8:53,1.1.1.1:53'\n</code></pre> <p>Note</p> <p>The <code>Deployment</code> must be modified via OpenShift ClusterServiceVersion OLM resource if the operator was installed using the OperatorHub. The OpenShift <code>ClusterServiceVersion</code> OLM resource includes several Deployments, and the ARGs must be modified only for the <code>cert-manager</code> controller.</p> <ul> <li>Save the resource. After that, OLM will try to reload the resource automatically and save it to the YAML file. If OLM resets the config file, double-check the entered values.</li> </ul> <p> Cert-Manager Nameservers </p> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#configure-clusterissuers","title":"Configure ClusterIssuers","text":"<p><code>ClusterIssuer</code> is available on the whole cluster.</p> <ol> <li> <p>Create the ClusterIssuer resource for Let's Encrypt Staging and Prod environments that signs a Certificate using <code>cert-manager</code>.</p> <p>Note</p> <p>Let's Encrypt has a limit of duplicate certificates in the Prod environment. Therefore, a <code>ClusterIssuer</code> has been created for Let's Encrypt Staging environment. By default, Let's Encrypt Staging certificates will not be trusted in your browser. The certificate validation cannot be tested in the Let's Encrypt Staging environment.</p> <ul> <li>Change <code>user@example.com</code> with your contact email.</li> <li>Replace <code>hostedZoneID</code> XXXXXXXXXXX with the DNS Hosted zone ID in AWS for your domain.</li> <li>Replace the region value <code>${region}</code>.</li> <li>The secret under <code>privateKeySecretRef</code> will be created automatically by the <code>cert-manager</code> operator.</li> </ul> <pre><code>apiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\nname: letsencrypt-staging\nspec:\nacme:\nemail: user@example.com\nserver: https://acme-staging-v02.api.letsencrypt.org/directory\nprivateKeySecretRef:\nname: letsencrypt-staging-issuer-account-key\nsolvers:\n- dns01:\nroute53:\nregion: ${region}\nhostedZoneID: XXXXXXXXXXX\n</code></pre> <pre><code>apiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\nname: letsencrypt-prod\nspec:\nacme:\nemail: user@example.com\nserver: https://acme-v02.api.letsencrypt.org/directory\nprivateKeySecretRef:\nname: letsencrypt-prod-issuer-account-key\nsolvers:\n- dns01:\nroute53:\nregion: ${region}\nhostedZoneID: XXXXXXXXXXX\n</code></pre> <p> Cert-Manager ClusterIssuer </p> </li> <li> <p>Check the <code>ClusterIssuer</code> status:</p> <p> Cert-Manager ClusterIssuer </p> <pre><code>oc describe clusterissuer letsencrypt-prod\noc describe clusterissuer letsencrypt-staging\n</code></pre> </li> <li> <p>If the <code>ClusterIssuer</code> state is not ready, investigate <code>cert-manager</code> controller pod logs:</p> <pre><code>oc get pod -n openshift-operators | grep 'cert-manager'\noc logs -f cert-manager-${replica_set}-${random_string} -n openshift-operators\n</code></pre> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#configure-certificates","title":"Configure Certificates","text":"<ol> <li> <p>In two different namespaces, create a Certificate resource for the OpenShift Router (Ingress controller for OpenShift) and for the OpenShift APIServer.</p> <ul> <li>OpenShift Router supports a single wildcard certificate for Ingress/Route resources in different namespaces (so called, default SSL certificate). The Ingress controller expects the certificates in a <code>Secret</code> to be created in the <code>openshift-ingress</code> namespace; the API Server, in the <code>openshift-config</code> namespace. The <code>cert-manager</code> operator will automatically create these secrets from the <code>Certificate</code> resource.</li> <li>Replace <code>${DOMAIN}</code> with your domain name. It can be checked with <code>oc whoami --show-server</code>. Put domain names in quotes.</li> </ul> The certificate for OpenShift Router in the `openshift-ingress` namespace <pre><code>apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\nname: router-certs\nnamespace: openshift-ingress\nlabels:\napp: cert-manager\nspec:\nsecretName: router-certs\nsecretTemplate:\nlabels:\napp: cert-manager\nduration: 2160h # 90d\nrenewBefore: 360h # 15d\nsubject:\norganizations:\n- Org Name\ncommonName: '*.${DOMAIN}'\nprivateKey:\nalgorithm: RSA\nencoding: PKCS1\nsize: 2048\nrotationPolicy: Always\nusages:\n- server auth\n- client auth\ndnsNames:\n- '*.${DOMAIN}'\n- '*.apps.${DOMAIN}'\nissuerRef:\nname: letsencrypt-staging\nkind: ClusterIssuer\n</code></pre> The certificate for OpenShift APIServer in the `openshift-config` namespace <pre><code>apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\nname: api-certs\nnamespace: openshift-config\nlabels:\napp: cert-manager\nspec:\nsecretName: api-certs\nsecretTemplate:\nlabels:\napp: cert-manager\nduration: 2160h # 90d\nrenewBefore: 360h # 15d\nsubject:\norganizations:\n- Org Name\ncommonName: '*.${DOMAIN}'\nprivateKey:\nalgorithm: RSA\nencoding: PKCS1\nsize: 2048\nrotationPolicy: Always\nusages:\n- server auth\n- client auth\ndnsNames:\n- '*.${DOMAIN}'\n- '*.apps.${DOMAIN}'\nissuerRef:\nname: letsencrypt-staging\nkind: ClusterIssuer\n</code></pre> <p>Info</p> <ul> <li> <p><code>cert-manager</code> supports ECDSA key pairs in the <code>Certificate</code> resource. To use it, change RSA <code>privateKey</code> to ECDSA:</p> <pre><code>privateKey:\nalgorithm: ECDSA\nencoding: PKCS1\nsize: 256\nrotationPolicy: Always\n</code></pre> </li> </ul> <ul> <li><code>rotationPolicy: Always</code> is highly recommended since <code>cert-manager</code> does not rotate private keys by default.</li> <li>Full <code>Certificate</code> spec is described in the <code>cert-manager</code> API documentation.</li> </ul> </li> <li> <p>Check that the certificates in the namespaces are ready:</p> <p> Cert-Manager Certificate Status </p> <p> Cert-Manager Certificate Status </p> </li> <li> <p>Check the details of the certificates via CLI:</p> <pre><code>oc describe certificate api-certs -n openshift-config\noc describe certificate router-certs -n openshift-ingress\n</code></pre> </li> <li> <p>Check the cert-manager controller pod logs if the Staging Certificate condition is not ready for more than 7 minutes:</p> <pre><code>oc get pod -n openshift-operators | grep 'cert-manager'\noc logs -f cert-manager-${replica_set}-${random_string} -n openshift-operators\n</code></pre> </li> <li> <p>When the certificate is ready, its private key will be put into the OpenShift <code>Secret</code> in the namespace indicated in the <code>Certificate</code> resource:</p> <pre><code>oc describe secret api-certs -n openshift-config\noc describe secret router-certs -n openshift-ingress\n</code></pre> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#modify-openshift-router-and-api-server-custom-resources","title":"Modify OpenShift Router and API Server Custom Resources","text":"<ol> <li> <p>Update the Custom Resource of your Router (Ingress controller). Patch the <code>defaultCertificate</code> object value with <code>{ \"name\": \"router-certs\" }</code>:</p> <pre><code>oc patch ingresscontroller default -n openshift-ingress-operator --type=merge --patch='{\"spec\": { \"defaultCertificate\": { \"name\": \"router-certs\" }}}' --insecure-skip-tls-verify\n</code></pre> <p>Info</p> <p>After updating the <code>IngressController</code> object, the OpenShift Ingress operator redeploys the router.</p> </li> <li> <p>Update the Custom Resource for the OpenShift API Server:</p> <ul> <li> <p>Export the name of <code>APIServer</code>:</p> <pre><code>export OKD_API=$(oc whoami --show-server --insecure-skip-tls-verify | cut -f 2 -d ':' | cut -f 3 -d '/' | sed 's/-api././')\n</code></pre> </li> </ul> <ul> <li> <p>Patch the <code>servingCertificate</code> object value with <code>{ \"name\": \"api-certs\" }</code>:</p> <pre><code>oc patch apiserver cluster --type merge --patch=\"{\\\"spec\\\": {\\\"servingCerts\\\": {\\\"namedCertificates\\\": [ { \\\"names\\\": [  \\\"$OKD_API\\\"  ], \\\"servingCertificate\\\": {\\\"name\\\": \\\"api-certs\\\" }}]}}}\" --insecure-skip-tls-verify\n</code></pre> </li> </ul> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#move-from-lets-encrypt-staging-environment-to-prod","title":"Move From Let's Encrypt Staging Environment to Prod","text":"<ol> <li> <p>Test the Staging certificate on the OpenShift Admin Console. The <code>--insecure</code> flag is used because Let's Encrypt Staging certificates are not trusted in browsers by default:</p> <pre><code>curl -v --insecure https://console-openshift-console.apps.${DOMAIN}\n</code></pre> </li> <li> <p>Change <code>issuerRef</code> to <code>letsencrypt-prod</code> in both <code>Certificate</code> resources:</p> <pre><code>oc edit certificate api-certs -n openshift-config\noc edit certificate router-certs -n openshift-ingress\n</code></pre> <pre><code>issuerRef:\nname: letsencrypt-prod\nkind: ClusterIssuer\n</code></pre> <p>Note</p> <p>In case the certificate reissue is not triggered after that, try to force the certificate renewal with cmctl:</p> <pre><code>cmctl renew router-certs -n openshift-ingress\ncmctl renew api-certs -n openshift-config\n</code></pre> <p>If this won't work, delete the <code>api-certs</code> and <code>router-certs</code> secrets. It should trigger the Prod certificates issuance:</p> <pre><code>oc delete secret router-certs -n openshift-ingress\noc delete secret api-certs -n openshift-config\n</code></pre> <p>Please note that these actions will lead to logging your account out of the OpenShift Admin Console, since certificates will be deleted. Accept the certificate warning in the browser and log in again after that.</p> </li> <li> <p>Check the status of the Prod certificates:</p> <pre><code>oc describe certificate api-certs -n openshift-config\noc describe certificate router-certs -n openshift-ingress\n</code></pre> <pre><code>cmctl status certificate api-certs -n openshift-config\ncmctl status certificate router-certs -n openshift-ingress\n</code></pre> </li> <li> <p>Check the web console and make sure it has secure connection:</p> <pre><code>curl -v https://console-openshift-console.apps.${DOMAIN}\n</code></pre> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#troubleshoot-certificates","title":"Troubleshoot Certificates","text":"<p>Below is an example of the DNS TXT <code>challenge</code> record created by the <code>cert-manager</code> operator:</p> <p> DNS Validation </p> <p>Use <code>nslookup</code> or <code>dig</code> tools to check if the DNS propagation for the TXT record is complete:</p> <pre><code>nslookup -type=txt _acme-challenge.${DOMAIN}\ndig txt _acme-challenge.${DOMAIN}\n</code></pre> <p>Otherwise, use web tools like Google Admin Toolbox:</p> <p> DNS Validation </p> <p>If the correct TXT value is shown (the value corresponds to the current TXT value in the DNS zone), it means that the DNS propagation is complete and Let's Encrypt is able to access the record in order to validate it and issue a trusted certificate.</p> <p>Note</p> <p>If the DNS validation challenge self check fails, <code>cert-manager</code> will retry the self check with a fixed 10-second retry interval. Challenges that do not ever complete the self check will continue retrying until the user intervenes by either retrying the <code>Order</code> (by deleting the <code>Order</code> resource) or amending the associated <code>Certificate</code> resource to resolve any configuration errors.</p> <p>As soon as the domain ownership has been verified, any <code>cert-manager</code> affected validation TXT records in the AWS Route53 DNS zone will be cleaned up.</p> <p>Please find below the issues that may occur and their troubleshooting:</p> <ul> <li>When certificates are not issued for a long time, or a <code>cert-manager</code> resource is not in a Ready state, describing a resource may show the reason for the error.</li> </ul> <ul> <li>Basically, the <code>cert-manager</code> creates the following resources during a <code>Certificate</code> issuance: <code>CertificateRequest</code>, <code>Order</code>, and <code>Challenge</code>. Investigate each of them in case of errors.</li> </ul> <ul> <li>Use the cmctl tool to show the state of a <code>Certificate</code> and its associated resources.</li> </ul> <ul> <li> <p>Check the <code>cert-manager</code> controller pod logs:</p> <pre><code>oc get pod -n openshift-operators | grep 'cert-manager'\noc logs -f cert-manager-${replica_set}-${random_string} -n openshift-operators\n</code></pre> </li> </ul> <ul> <li> <p>Certificate error debugging:   a. Decode certificate chain located in the secrets:</p> <pre><code>oc get secret router-certs -n openshift-ingress -o 'go-template={{index .data \"tls.crt\"}}' | base64 -d | while openssl x509 -noout -text; do :; done 2&gt;/dev/null\noc get secret api-certs -n openshift-config -o 'go-template={{index .data \"tls.crt\"}}' | base64 -d | while openssl x509 -noout -text; do :; done 2&gt;/dev/null\n</code></pre> <pre><code>cmctl inspect secret router-certs -n openshift-ingress\ncmctl inspect secret api-certs -n openshift-config\n</code></pre> <p>b. Check the SSL RSA private key consistency:</p> <pre><code>oc get secret router-certs -n openshift-ingress -o 'go-template={{index .data \"tls.key\"}}' | base64 -d | openssl rsa -check -noout\noc get secret api-certs -n openshift-config -o 'go-template={{index .data \"tls.key\"}}' | base64 -d | openssl rsa -check -noout\n</code></pre> <p>c. Match the SSL certificate public key against its RSA private key. Their modulus must be identical:</p> <pre><code>diff &lt;(oc get secret api-certs -n openshift-config -o 'go-template={{index .data \"tls.crt\"}}' | base64 -d | openssl x509 -noout -modulus | openssl md5) &lt;(oc get secret api-certs -n openshift-config -o 'go-template={{index .data \"tls.key\"}}' | base64 -d | openssl rsa -noout -modulus | openssl md5)\ndiff &lt;(oc get secret router-certs -n openshift-ingress -o 'go-template={{index .data \"tls.crt\"}}' | base64 -d | openssl x509 -noout -modulus | openssl md5) &lt;(oc get secret router-certs -n openshift-ingress -o 'go-template={{index .data \"tls.key\"}}' | base64 -d | openssl rsa -noout -modulus | openssl md5)\n</code></pre> </li> </ul>"},{"location":"operator-guide/ssl-automation-okd/#remove-obsolete-certificate-authority-data-from-kubeconfig","title":"Remove Obsolete Certificate Authority Data From Kubeconfig","text":"<p>After updating the certificates, the access to the cluster via Lens or CLI will be denied because of the untrusted certificate errors:</p> <pre><code>$ oc whoami\nUnable to connect to the server: x509: certificate signed by unknown authority\n</code></pre> <p>Such behavior appears because the <code>oc</code> tool references an old CA data in the kubeconfig file.</p> <p>Note</p> <p>Examine the Certificate Authority data using the following command:</p> <pre><code>oc config view --minify --raw -o jsonpath='{.clusters[].cluster.certificate-authority-data}' | base64 -d | openssl x509 -text\n</code></pre> <p>This certificate has the <code>CA:TRUE</code> parameter, which means that this is a self-signed root CA certificate.</p> <p>To fix the error, remove the old CA data from your OpenShift kubeconfig file:</p> <pre><code>sed -i \"/certificate-authority-data/d\" $KUBECONFIG\n</code></pre> <p>Since this field will be absent in the kubeconfig file, system root SSL certificate will be used to validate the cluster certificate trust chain. On Ubuntu, Let's Encrypt OpenShift cluster certificates will be validated against <code>Internet Security Research Group</code> root in <code>/etc/ssl/certs/ca-certificates.crt</code>.</p>"},{"location":"operator-guide/ssl-automation-okd/#certificate-renewals","title":"Certificate Renewals","text":"<p>The <code>cert-manager</code> automatically renews the certificates based on the X.509 certificate's duration and the <code>renewBefore</code> value. The minimum value for the <code>spec.duration</code> is 1 hour; for <code>spec.renewBefore</code>, 5 minutes. It is also required that <code>spec.duration</code> &gt; <code>spec.renewBefore</code>.</p> <p>Use the cmctl tool to manually trigger a single instant certificate renewal:</p> <pre><code>cmctl renew router-certs -n openshift-ingress\ncmctl renew api-certs -n openshift-config\n</code></pre> <p>Otherwise, manually renew all certificates in all namespaces with the <code>app=cert-manager</code> label:</p> <pre><code>cmctl renew --all-namespaces -l app=cert-manager\n</code></pre> <p>Run the <code>cmctl renew --help</code> command to get more details.</p>"},{"location":"operator-guide/ssl-automation-okd/#related-articles","title":"Related Articles","text":"<ul> <li>Cert-Manager Official Documentation</li> <li>Installing the Cert-Manager Operator for Red Hat OpenShift</li> <li>Checking Issued Certificate Details</li> </ul>"},{"location":"operator-guide/tekton-monitoring/","title":"Monitoring","text":"<p>This documentation describes how to integrate tekton-pipelines metrics with Prometheus and Grafana monitoring stack.</p>"},{"location":"operator-guide/tekton-monitoring/#prerequisites","title":"Prerequisites","text":"<p>Ensure the following requirements are met first before moving ahead:</p> <ul> <li>Kube prometheus stack is installed;</li> <li>Tekton pipeline is installed.</li> </ul>"},{"location":"operator-guide/tekton-monitoring/#create-and-apply-the-additional-scrape-config","title":"Create and Apply the Additional Scrape Config","text":"<p>To create and apply the additional scrape config, follow the steps below:</p> <ol> <li> <p>Create the kubernetes secret file with the additional scrape config:</p> additional-scrape-configs.yaml file<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: additional-scrape-configs\nstringData:\n  prometheus-additional-job.yaml: |\n    - job_name: \"tekton-pipelines\"\n      scrape_interval: 30s\n      static_configs:\n      - targets: [\"tekton-pipelines-controller.&lt;tekton-pipelines-namespace&gt;.svc.cluster.local:9090\"]\n</code></pre> </li> <li> <p>Apply the created secret:</p> <pre><code>kubectl apply -f additional-scrape-configs.yaml -n &lt;monitoring-namespace&gt;\n</code></pre> </li> <li> <p>Update the prometheus stack:</p> <pre><code>helm update --install prometheus prometheus-community/kube-prometheus-stack --values values.yaml -n &lt;monitoring-namespace&gt;\n</code></pre> <p>The <code>values.yaml</code> file should have the following contents:</p> values.yaml file<pre><code>prometheus:\nprometheusSpec:\nadditionalScrapeConfigsSecret:\nenabled: true\nname: additional-scrape-configs\nkey: prometheus-additional-job.yaml\n</code></pre> </li> <li> <p>Download the EDP Tekton Pipeline dashboard:</p> <p> Import Grafana dashboard </p> <p>a. Click on the dashboard menu;</p> <p>b. In the dropdown menu, click the <code>+ Import</code> button;</p> <p>c. Select the created <code>edp-tekton-overview_rev1.json</code> file;</p> <p> Import Grafana dashboard: Options </p> <p>d. Type the name of the dashboard;</p> <p>e. Select the folder for the dashboard;</p> <p>f. Type the UID (set of eight numbers or letters and symbols);</p> <p>g. Click the <code>Import</code> button.</p> </li> </ol> <p>As soon as the dashboard procedure is completed, you can track the newcoming metrics in the dashboard menu:</p> <p> Tekton dashboard </p>"},{"location":"operator-guide/tekton-monitoring/#related-articles","title":"Related Articles","text":"<ul> <li>Install Tekton</li> <li>Install EDP</li> <li>Install via Helmfile</li> </ul>"},{"location":"operator-guide/tekton-overview/","title":"Tekton Overview","text":"<p>EPAM Delivery Platform provides Continuous Integration based on Tekton.</p> <p>Tekton is an open-source Kubernetes native framework for creating CI pipelines, allowing a user to compile, build and test applications.</p> <p>The edp-tekton GitHub repository provides all Tekton implementation logic on the platform. The Helm charts are used to deploy the resources inside the Kubernetes cluster. Tekton logic is decoupled into separate components:</p> <p> Edp-tekton components diagram </p> <p>The diagram above describes the following:</p> <ul> <li><code>Common-library</code> is the Helm chart of Library type which stores the common logic shareable across all Tekton pipelines. This library contains Helm templates that generate common Tekton resources.</li> </ul> <ul> <li><code>Pipelines-library</code> is the Helm chart of the Application type which stores the core logic for the EDP pipelines. Tekton CRs like Pipelines, Tasks, EventListeners, Triggers, TriggerTemplates, and other resources are delivered with this chart.</li> </ul> <ul> <li><code>Custom-pipelines</code> is the Helm chart of the Application type which implements custom logic running specifically for internal EDP development, for example, CI and Release. It also demonstrates the customization flow on the platform.</li> </ul> <ul> <li><code>Tekton-dashboard</code> is a multitenancy-adopted implementation of the upstream Tekton Dashboard. It is configured to share Tekton resources across a single namespace.</li> </ul> <ul> <li><code>EDP Interceptor</code> is the custom Tekton Interceptor which enriches the payload from the VCSs events with EDP data from the Codebase CR specification. These data are used to define the Pipeline logic.</li> </ul> <p>Inspect the schema below that describes the logic behind the Tekton functionality on the platform:</p> <p> Component view for the Tekton on EDP </p> <p>The platform logic consists of the following:</p> <ol> <li> <p>The <code>EventListener</code> exposes a dedicated Pod that runs the sink logic and receives incoming events from the VCSs (Gerrit, GitHub, GitLab) through the Ingress. It contains triggers with filtering and routing rules for incoming requests.</p> </li> <li> <p>Upon the Event Payload arrival, the <code>EventListener</code> runs triggers to process information or validate it via different interceptors.</p> </li> <li> <p>The <code>EDP Interceptor</code> extracts information from the codebases.v2.edp.epam.com CR and injects the received data into top-level 'extensions' field of the Event Payload. The Interceptor consists of running Pod and Service.</p> </li> <li> <p>The <code>Tekton Cel Interceptor</code> does simple transformations of the resulting data and prepares them for the Pipeline parameters substitution.</p> </li> <li> <p>The <code>TriggerTemplate</code> creates a PipelineRun instance with the required parameters extracted from the Event Payload by Interceptors. These parameters are mandatory for Pipelines.</p> </li> <li> <p>The <code>PipelineRun</code> has a mapping to the EDP Tekton Pipelines using a template approach which reduces code duplication. Each Pipeline is designed for a specific VCS (Gerrit, GitLab, GitHub), technology stack (such as Java or Python), and type (code-review, build).</p> </li> <li> <p>A <code>Pipeline</code> consists of separate EDP Tekton or open-source Tasks. They are arranged in a specific order of execution in the Pipeline.</p> </li> <li> <p>Each <code>Task</code> is executed as a Pod on the Kubernetes cluster. Also, Tasks can have a different number of steps that are executed as a \u0421ontainer in Pod.</p> </li> <li> <p>The Kubernetes native approach allows the creation of PipelineRun either with the kubectl tool or using the EDP Headlamp UI.</p> </li> </ol>"},{"location":"operator-guide/upgrade-edp-2.10/","title":"Upgrade EDP v2.9 to 2.10","text":"<p>This section provides the details on the EDP upgrade to 2.10.2. Explore the actions and requirements below.</p> <p>Note</p> <p>Kiosk is optional for EDP v.2.9.0 and higher, and is enabled by default. To disable it, add the following parameter to the <code>values.yaml</code> file: <code>global.kioskEnabled: false</code>. Please refer to the Set Up Kiosk documentation for the details.</p> <p>Note</p> <p>In the process of updating the EDP, it is necessary to migrate the database for SonarQube, before performing the update procedure, please carefully read section 4 of this guide.</p> <ol> <li> <p>Before updating EDP to 2.10.2, delete SonarQube plugins by executing the following command in SonarQube pod:</p> <pre><code>rm -r /opt/sonarqube/extensions/plugins/*\n</code></pre> </li> <li> <p>Update Custom Resource Definitions. Run the following command to apply all the necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.10/deploy-templates/crds/v2_v1alpha1_jenkins_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakclient_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmcomponent_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmidentityprovider_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmrole_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloak_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.10/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml\n</code></pre> </li> <li> <p>To upgrade EDP to the v.2.10.2, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.10.2\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.10.2  --dry-run</code></p> </li> <li> <p>Migrate the database for SonarQube according to the official documentation.</p> <p>Note</p> <p>Please be aware of possible tables duplication for speeding up the migration process during the upgrade. Due to the duplication, the database disk usage can be temporarily increased to twice as the normal usage. Therefore, the recommended database disk usage is below 50% before the migration start.</p> <ul> <li> <p>Navigate to the project http://SonarQubeServerURL/setup link and follow the setup instructions:</p> <p> Migrate SonarQube database </p> </li> </ul> <ul> <li>Click the Upgrade button and wait for the end of the migration process.</li> </ul> </li> <li> <p>Remove the resources related to the deprecated Sonar Gerrit Plugin that is deleted in EDP 2.10.2:</p> <ul> <li>Remove Sonar Gerrit Plugin from Jenkins (go to Manage Jenkins -&gt; Manage Plugins -&gt; Installed -&gt; Uninstall Sonar Gerrit Plugin).</li> <li>In Gerrit, clone the All-Projects repository.</li> <li>Edit the project.config file in the All-Projects repository and remove the Sonar-Verified label declaration:<pre><code>[label \"Sonar-Verified\"]\nfunction = MaxWithBlock\nvalue = -1 Issues found\nvalue = 0 No score\nvalue = +1 Verified\ndefaultValue = 0\n</code></pre> </li> </ul> <ul> <li>Also, remove the following permissions for the Sonar-Verified label in the project.config file:<pre><code>label-Sonar-Verified = -1..+1 group Administrators\nlabel-Sonar-Verified = -1..+1 group Project Owners\nlabel-Sonar-Verified = -1..+1 group Service Users\n</code></pre> </li> </ul> <ul> <li>Save the changes, and commit and push the repository to HEAD:refs/meta/config bypassing the Gerrit code review:<pre><code>git push origin HEAD:refs/meta/config\n</code></pre> </li> </ul> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images should be:<pre><code>epamedp/edp-jenkins-codenarc-agent:1.0.1\nepamedp/edp-jenkins-dotnet-21-agent:1.0.5\nepamedp/edp-jenkins-dotnet-31-agent:1.0.4\nepamedp/edp-jenkins-go-agent:1.0.6\nepamedp/edp-jenkins-gradle-java8-agent:1.0.3\nepamedp/edp-jenkins-gradle-java11-agent:2.0.3\nepamedp/edp-jenkins-helm-agent:1.0.10\nepamedp/edp-jenkins-maven-java8-agent:1.0.3\nepamedp/edp-jenkins-maven-java11-agent:2.0.4\nepamedp/edp-jenkins-npm-agent:2.0.3\nepamedp/edp-jenkins-opa-agent:1.0.2\nepamedp/edp-jenkins-python-38-agent:2.0.4\nepamedp/edp-jenkins-terraform-agent:2.0.5\n</code></pre> </li> </ul> <ul> <li>Restart the Jenkins pod.</li> </ul> </li> <li> <p>Since EDP version v.2.10.x, the create-release.groovy, code-review.groovy, and build.groovy files are deprecated (<code>pipeline script from SCM</code> is replaced with <code>pipeline script</code>, see below).</p> <ul> <li>Pipeline script from SCM:    Pipeline script from scm example </li> </ul> <ul> <li>Pipeline script:     Pipeline script example </li> </ul> <ul> <li>Update the job-provisioner code and restart the codebase-operator pod. Consult the default job-provisioners code section.</li> </ul> </li> </ol>"},{"location":"operator-guide/upgrade-edp-2.10/#related-articles","title":"Related Articles","text":"<ul> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Set Up Kiosk</li> <li>SonarQube Upgrade Guide</li> </ul>"},{"location":"operator-guide/upgrade-edp-2.11/","title":"Upgrade EDP v2.10 to 2.11","text":"<p>This section provides the details on the EDP upgrade to 2.11. Explore the actions and requirements below.</p> <ol> <li> <p>Update Custom Resource Definitions. Run the following command to apply all the necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.12/deploy-templates/crds/edp_v1alpha1_cd_stage_deploy_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.11/deploy-templates/crds/v2_v1alpha1_merge_request_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.11/deploy-templates/crds/edp_v1alpha1_user_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.11/deploy-templates/crds/edp_v1alpha1_cdpipeline_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.11/deploy-templates/crds/v2_v1alpha1_jenkinssharedlibrary_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.11/deploy-templates/crds/v2_v1alpha1_cdstagejenkinsdeployment_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.11/deploy-templates/crds/v1_v1alpha1_keycloakauthflow_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.11/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.12/deploy-templates/crds/edp_v1alpha1_codebaseimagestream_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.12/deploy-templates/crds/edp_v1alpha1_codebase_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.11/deploy-templates/crds/edp_v1alpha1_sonar_group_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.11/deploy-templates/crds/edp_v1alpha1_permission_template_crd.yaml\n</code></pre> </li> <li> <p>Backup kaniko-template config-map and then remove it. This component will be delivered during upgrade.</p> </li> <li> <p>Set required awsRegion parameter. Pay attention that the nesting of the kanikoRoleArn parameter has been changed to the kaniko.roleArn parameter. Check the parameters in the EDP installation chart. For details, please refer to the values.yaml file. To upgrade EDP to the v.2.11.x, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.11.x\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.11.x  --dry-run</code></p> </li> <li> <p>Update Sonar Project Key:</p> <p>Note</p> <p>Avoid using special characters when creating projects in SonarQube. Allowed characters are: <code>letters</code>, <code>numbers</code>, <code>-</code>, <code>_</code>, <code>.</code> and <code>:</code>, with at least one non-digit. For details, please refer to the SonarQube documentation. As the result, the project name will be: <code>project-name-release-0.0</code> or <code>project-name-branchName</code>.</p> <p>Such actions are required to be followed with the aim to store the SonarQube statistics from the previous EDP version:</p> <p>Warning</p> <p>Do not run any pipeline with the updated sonar stage on any existing application before the completion of the first step.</p> <p>4.1. Update the project key in SonarQube from old to new format by adding the default branch name.</p> <p>- Navigate to Project Settings -&gt; Update Key:   Update SonarQube project key    - Enter the default branch name and click Update:   Update SonarQube project key </p> <p>4.2. As the result, after the first run, the project name will be changed to a new format containing all previous statistics:</p> <p> SonarQube project history activity </p> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images should be:<pre><code>epamedp/edp-jenkins-codenarc-agent:3.0.4\nepamedp/edp-jenkins-dotnet-21-agent:3.0.4\nepamedp/edp-jenkins-dotnet-31-agent:3.0.3\nepamedp/edp-jenkins-go-agent:3.0.5\nepamedp/edp-jenkins-gradle-java11-agent:3.0.2\nepamedp/edp-jenkins-gradle-java8-agent:3.0.2\nepamedp/edp-jenkins-helm-agent:3.0.3\nepamedp/edp-jenkins-maven-java11-agent:3.0.3\nepamedp/edp-jenkins-maven-java8-agent:3.0.3\nepamedp/edp-jenkins-npm-agent:3.0.4\nepamedp/edp-jenkins-opa-agent:3.0.2\nepamedp/edp-jenkins-python-38-agent:3.0.2\nepamedp/edp-jenkins-terraform-agent:3.0.3\n</code></pre> </li> </ul> <ul> <li> <p>Add Jenkins agent by following the template:</p> <p> View: values.yaml <pre><code>kaniko-docker-template: |-\n&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;kaniko-docker&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;kaniko-docker&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;epamedp/edp-jenkins-kaniko-docker-agent:1.0.4&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n</code></pre> <ul> <li>Restart the Jenkins pod.</li> </ul> <li> <p>Update the Jenkins plugins with the 'pipeline' name and 'HTTP Request Plugin'.</p> </li> <li> <p>Update Jenkins provisioners according to the Manage Jenkins CI Pipeline Job Provisioner and Manage Jenkins CD Pipeline Job Provisioner documentation.</p> </li> <li> <p>Restart the codebase-operator to recreate the Code-review and Build pipelines for codebases.</p> </li> <li>Run the CD job-provisioners for every CD pipeline to align the CD stages.</li>"},{"location":"operator-guide/upgrade-edp-2.12/","title":"Upgrade EDP v2.11 to 2.12","text":"<p>Important</p> <p>We suggest making a backup of the EDP environment before starting the upgrade procedure.</p> <p>This section provides the details on the EDP upgrade to 2.12. Explore the actions and requirements below.</p> <p>Notes</p> <ul> <li>EDP now supports Kubernetes 1.22: Ingress Resources use <code>networking.k8s.io/v1</code>, and Ingress Operators use CustomResourceDefinition <code>apiextensions.k8s.io/v1</code>.</li> <li>EDP Team now delivers its own Gerrit Docker image: epamedp/edp-gerrit. It is based on the openfrontier Gerrit Docker image.</li> </ul> <ol> <li> <p>EDP now uses DefectDojo as a SAST tool. It is mandatory to deploy DefectDojo before updating EDP to v.2.12.x.</p> </li> <li> <p>Update Custom Resource Definitions (CRDs). Run the following command to apply all necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-admin-console-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_adminconsoles.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_cdpipelines.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_cdstagedeployments.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_cdstagejenkinsdeployments.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_codebasebranches.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_codebaseimagestreams.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_codebases.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-component-operator/release/0.12/deploy-templates/crds/v1.edp.epam.com_edpcomponents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritgroupmembers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritgroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritmergerequests.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritprojectaccesses.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritprojects.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritreplicationconfigs.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerrits.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_gitservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_gittags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_imagestreamtags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkins.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsagents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsauthorizationrolemappings.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsauthorizationroles.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsfolders.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsjobbuildruns.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsjobs.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsscripts.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsserviceaccounts.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinssharedlibraries.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_jiraissuemetadatas.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_jiraservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakauthflows.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakclients.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakclientscopes.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmcomponents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmgroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmidentityproviders.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmrolebatches.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmroles.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealms.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmusers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloaks.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_nexuses.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_nexususers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_perfdatasourcegitlabs.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_perfdatasourcejenkinses.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_perfdatasourcesonars.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_perfservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_sonargroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_sonarpermissiontemplates.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_sonars.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_stages.yaml\n</code></pre> </li> <li> <p>Set the required parameters. For details, please refer to the values.yaml file.</p> <ul> <li>In version v.2.12.x, EDP contains Gerrit <code>v3.6.1</code>. According to the Official Gerrit Upgrade flow, a user must initially upgrade to Gerrit <code>v3.5.2</code>, and then upgrade to <code>v3.6.1</code>. Therefore, define the <code>gerrit-operator.gerrit.version=3.5.2</code> value in the edp-install <code>values.yaml</code> file.</li> </ul> <ul> <li> <p>Two more components are available with the new functionality:</p> <ul> <li><code>edp-argocd-operator</code></li> <li><code>external-secrets</code></li> </ul> </li> </ul> <ul> <li>If there is no need to use these new operators, define <code>false</code> values for them in the existing <code>value.yaml</code> file:<p> View: values.yaml <pre><code>gerrit-operator:\ngerrit:\nversion: \"3.5.2\"\nexternalSecrets:\nenabled: false\nargocd:\nenabled: false\n</code></pre> <li> <p>The <code>edp-jenkins-role</code> is renamed to the <code>jenkins-resources-role</code>. Delete the <code>edp-jenkins-role</code> with the following command:</p> <pre><code>  kubectl delete role edp-jenkins-role -n &lt;edp-namespace&gt;\n</code></pre> <p>The <code>jenkins-resources-role</code> role will be created automatically while EDP upgrade.</p> </li> <li> <p>Recreate the <code>edp-jenkins-resources-permissions</code> RoleBinding according to the following template:</p> <p> View: jenkins-resources-role <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: edp-jenkins-resources-permissions\nnamespace: &lt;edp-namespace&gt;\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: Role\nname: jenkins-resources-role\n</code></pre> <li> <p>To upgrade EDP to the v.2.12.x, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.x\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the following command: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.x  --dry-run</code></p> </li> <li> <p>After the update, please remove the <code>gerrit-operator.gerrit.version</code> value. In this case, the default value will be used, and Gerrit will be updated to the <code>v3.6.1</code> version. Run the following command:</p> <pre><code>  helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.x\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the following command: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.x  --dry-run</code></p> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images must be the following:<pre><code>epamedp/edp-jenkins-codenarc-agent:3.0.8\nepamedp/edp-jenkins-dotnet-21-agent:3.0.7\nepamedp/edp-jenkins-dotnet-31-agent:3.0.7\nepamedp/edp-jenkins-go-agent:3.0.11\nepamedp/edp-jenkins-gradle-java11-agent:3.0.5\nepamedp/edp-jenkins-gradle-java8-agent:3.0.7\nepamedp/edp-jenkins-helm-agent:3.0.8\nepamedp/edp-jenkins-maven-java11-agent:3.0.6\nepamedp/edp-jenkins-maven-java8-agent:3.0.8\nepamedp/edp-jenkins-npm-agent:3.0.7\nepamedp/edp-jenkins-opa-agent:3.0.5\nepamedp/edp-jenkins-python-38-agent:3.0.5\nepamedp/edp-jenkins-terraform-agent:3.0.6\n</code></pre> </li> </ul> <ul> <li> <p>Add Jenkins agents by following the template:</p> <p> View: jenkins-slaves <pre><code>  sast-template: |\n&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;sast&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;sast&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;epamedp/edp-jenkins-sast-agent:0.1.3&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n</code></pre> <ul> <li> <p>If required, update the requests and limits for the following Jenkins agents:</p> <ul> <li><code>edp-jenkins-codenarc-agent</code></li> <li><code>edp-jenkins-go-agent</code></li> <li><code>edp-jenkins-gradle-java11-agent</code></li> <li><code>edp-jenkins-gradle-java8-agent</code></li> <li><code>edp-jenkins-maven-java11-agent</code></li> <li><code>edp-jenkins-maven-java8-agent</code></li> <li><code>edp-jenkins-npm-agent</code></li> <li><code>edp-jenkins-dotnet-21-agent</code></li> <li><code>edp-jenkins-dotnet-31-agent</code></li> </ul> <p>EDP requires to start with the following values:</p> <p> View: jenkins-slaves <pre><code>  &lt;resourceRequestCpu&gt;500m&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;1Gi&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;2&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;5Gi&lt;/resourceLimitMemory&gt;\n</code></pre> <ul> <li>Restart the Jenkins pod.</li> </ul> <li> <p>Update Jenkins provisioners according to the Manage Jenkins CI Pipeline Job Provisioner instruction.</p> </li> <li> <p>Restart the <code>codebase-operator</code>, to recreate the Code Review and Build pipelines for the codebases.</p> </li> <p>Warning</p> <p>In case there are different EDP versions on one cluster, the following error may occur on the <code>init</code> stage of Jenkins Groovy pipeline: <code>java.lang.NumberFormatException: For input string: \"\"</code>. To fix this issue, please run the following command using <code>kubectl</code> v1.24.4+:</p> <pre><code>kubectl patch codebasebranches.v2.edp.epam.com &lt;codebase-branch-name&gt;  -n &lt;edp-namespace&gt;  '--subresource=status' '--type=merge' -p '{\"status\": {\"build\": \"0\"}}'\n</code></pre>"},{"location":"operator-guide/upgrade-edp-2.12/#upgrade-edp-to-2122","title":"Upgrade EDP to 2.12.2","text":"<p>Important</p> <p>We suggest making a backup of the EDP environment before starting the upgrade procedure.</p> <p>This section provides the details on the EDP upgrade to 2.12.2. Explore the actions and requirements below.</p> <ol> <li> <p>Update Custom Resource Definitions (CRDs). Run the following command to apply all necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.12.2/deploy-templates/crds/v2.edp.epam.com_jenkins.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/v2.12.1/deploy-templates/crds/v2.edp.epam.com_gerrits.yaml\n</code></pre> </li> <li> <p>To upgrade EDP to 2.12.2, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.2\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the following command: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.2  --dry-run</code></p> </li> </ol>"},{"location":"operator-guide/upgrade-edp-2.8/","title":"Upgrade EDP v2.7 to 2.8","text":"<p>This section provides the details on the EDP upgrade to 2.8.4. Explore the actions and requirements below.</p> <p>Note</p> <p>Kiosk is implemented and mandatory for EDP v.2.8.4 and is optional for EDP v.2.9.0 and higher.</p> <p>To upgrade EDP to 2.8.4, take the following steps:</p> <ol> <li> <p>Deploy and configure Kiosk (create a Service Account, Account, and ClusterRoleBinging) according to the Set Up Kiosk documentation.</p> <ul> <li>Update the spec field in the Kiosk space:<pre><code>apiVersion: tenancy.kiosk.sh/v1alpha1\nkind: Space\nmetadata:\nname: &lt;edp-project&gt;\nspec:\naccount: &lt;edp-project&gt;-admin\n</code></pre> </li> </ul> <ul> <li> <p>Create RoleBinding (required for namespaces created before using Kiosk):</p> <p>Note</p> <p>In the uid field under the ownerReferences in the Kubernetes manifest, indicate the Account Custom Resource ID from accounts.config.kiosk.sh <code>kubectl get account &lt;edp-project&gt;-admin -o=custom-columns=NAME:.metadata.uid --no-headers=true</code></p> <p> View: rolebinding-kiosk.yaml <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\ngenerateName: &lt;edp-project&gt;-admin-\nnamespace: &lt;edp-project&gt;\nownerReferences:\n- apiVersion: config.kiosk.sh/v1alpha1\nblockOwnerDeletion: true\ncontroller: true\nkind: Account\nname: &lt;edp-project&gt;-admin\nuid: ''\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: ClusterRole\nname: kiosk-space-admin\nsubjects:\n- kind: ServiceAccount\nname: &lt;edp-project&gt;\nnamespace: security\n</code></pre> <pre><code>kubectl create -f rolebinding-kiosk.yaml\n</code></pre> <li> <p>With Amazon Elastic Container Registry to store the images, there are two options:</p> <ul> <li>Enable IRSA and create AWS IAM Role for Kaniko image builder. Please refer to the IAM Roles for Kaniko Service Accounts section for the details.</li> <li>The Amazon Elastic Container Registry Roles can be stored in an instance profile.</li> </ul> </li> <li> <p>Update Custom Resource Definitions by applying all the necessary CRD to the cluster with the command below:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_cdpipeline_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_codebase_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_cd_stage_deploy_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_jenkinsjobbuildrun_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_cdstagejenkinsdeployment_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_jenkinsjob_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.8/deploy-templates/crds/v1_v1alpha1_keycloakauthflow_crd.yaml\n</code></pre> </li> <li> <p>With Amazon Elastic Container Registry to store and Kaniko to build the images, add the kanikoRoleArn parameter to the values before starting the update process. This parameter is indicated in AWS Roles once IRSA is enabled and AWS IAM Role is created for Kaniko. The value should look as follows:</p> <pre><code>kanikoRoleArn: arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\n</code></pre> </li> <li> <p>To upgrade EDP to the v.2.8.4, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.8.4\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.8.4  --dry-run</code></p> </li> <li> <p>Remove the following Kubernetes resources left from the previous EDP installation (it is optional):</p> <pre><code>kubectl delete cm luminatesec-conf -n &lt;edp-namespace&gt;\nkubectl delete sa edp edp-perf-operator -n &lt;edp-namespace&gt;\nkubectl delete deployment perf-operator -n &lt;edp-namespace&gt;\nkubectl delete clusterrole edp-&lt;edp-namespace&gt; edp-perf-operator-&lt;edp-namespace&gt;\nkubectl delete clusterrolebinding edp-&lt;edp-namespace&gt; edp-perf-operator-&lt;edp-namespace&gt;\nkubectl delete rolebinding edp-&lt;edp-namespace&gt; edp-perf-operator-&lt;edp-namespace&gt;-admin -n &lt;edp-namespace&gt;\nkubectl delete perfserver epam-perf -n &lt;edp-namespace&gt;\nkubectl delete services.v2.edp.epam.com postgres rabbit-mq -n &lt;edp-namespace&gt;\n</code></pre> </li> <li> <p>Update the CI and CD Jenkins job provisioners:</p> <p>Note</p> <p>Please refer to the Manage Jenkins CI Pipeline Job Provisioner section for the details.</p> View: Default CI provisioner template for EDP 2.8.4 <pre><code>/* Copyright 2021 EPAM Systems.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport groovy.json.*\nimport jenkins.model.Jenkins\nimport hudson.model.*\n\nJenkins jenkins = Jenkins.instance\ndef stages = [:]\ndef jiraIntegrationEnabled = Boolean.parseBoolean(\"${JIRA_INTEGRATION_ENABLED}\" as String)\ndef commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : ''\ndef createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : ''\ndef buildTool = \"${BUILD_TOOL}\"\ndef goBuildStage = buildTool.toString() == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}'\n\nstages['Code-review-application'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + goBuildStage +\n',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]'\nstages['Code-review-library'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"compile\"},{\"name\": \"tests\"},' +\n'{\"name\": \"sonar\"}]'\nstages['Code-review-autotests'] = '[{\"name\": \"gerrit-checkout\"},{\"name\": \"get-version\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${createJIMStage}\" + ']'\nstages['Code-review-default'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ']'\nstages['Code-review-library-terraform'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"terraform-lint\"}]'\nstages['Code-review-library-opa'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"}]'\nstages['Code-review-library-codenarc'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}]'\n\nstages['Build-library-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-npm'] = stages['Build-library-maven']\nstages['Build-library-gradle'] = stages['Build-library-maven']\nstages['Build-library-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' +\n',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-opa'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-codenarc'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\n\nstages['Build-application-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},[{\"name\": \"sonar\"}],{\"name\": \"build\"},{\"name\": \"build-image-kaniko\"},' +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-npm'] = stages['Build-application-maven']\nstages['Build-application-gradle'] = stages['Build-application-maven']\nstages['Build-application-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},[{\"name\": \"sonar\"}],{\"name\": \"build-image-kaniko\"},' +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-go'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build\"},{\"name\": \"build-image-kaniko\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build-image-kaniko\"},{\"name\": \"push\"}' + \"${createJIMStage}\" +\n',{\"name\": \"git-tag\"}]'\n\nstages['Create-release'] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]'\n\ndef defaultBuild = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']'\n\ndef codebaseName = \"${NAME}\"\ndef gitServerCrName = \"${GIT_SERVER_CR_NAME}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\"\ndef repositoryPath = \"${REPOSITORY_PATH}\"\ndef defaultBranch = \"${DEFAULT_BRANCH}\"\n\ndef codebaseFolder = jenkins.getItem(codebaseName)\nif (codebaseFolder == null) {\nfolder(codebaseName)\n}\n\ncreateListView(codebaseName, \"Releases\")\ncreateReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"create-release.groovy\",\nrepositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, defaultBranch)\n\nif (buildTool.toString().equalsIgnoreCase('none')) {\nreturn true\n}\n\nif (BRANCH) {\ndef branch = \"${BRANCH}\"\ndef formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \"-\")}\"\ncreateListView(codebaseName, formattedBranch)\n\ndef type = \"${TYPE}\"\ndef crKey = getStageKeyName(buildTool)\ncreateCiPipeline(\"Code-review-${codebaseName}\", codebaseName, stages[crKey], \"code-review.groovy\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\ndef buildKey = \"Build-${type}-${buildTool.toLowerCase()}\".toString()\nif (type.equalsIgnoreCase('application') || type.equalsIgnoreCase('library')) {\ndef jobExists = false\nif(\"${formattedBranch}-Build-${codebaseName}\".toString() in Jenkins.instance.getAllItems().collect{it.name})\njobExists = true\n\ncreateCiPipeline(\"Build-${codebaseName}\", codebaseName, stages.get(buildKey, defaultBuild), \"build.groovy\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\nif(!jobExists)\nqueue(\"${codebaseName}/${formattedBranch}-Build-${codebaseName}\")\n}\n}\n\ndef createCiPipeline(pipelineName, codebaseName, codebaseStages, pipelineScript, repository, credId, watchBranch, gitServerCrName, gitServerCrVersion) {\npipelineJob(\"${codebaseName}/${watchBranch.toUpperCase().replaceAll(/\\\\//, \"-\")}-${pipelineName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\ntriggers {\ngerrit {\nevents {\nif (pipelineName.contains(\"Build\"))\nchangeMerged()\nelse\npatchsetCreated()\n}\nproject(\"plain:${codebaseName}\", [\"plain:${watchBranch}\"])\n}\n}\ndefinition {\ncpsScm {\nscm {\ngit {\nremote {\nurl(repository)\ncredentials(credId)\n}\nbranches(\"${watchBranch}\")\nscriptPath(\"${pipelineScript}\")\n}\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nstringParam(\"BRANCH\", \"${watchBranch}\", \"Branch to build artifact from\")\n}\n}\n}\n}\n}\n\ndef getStageKeyName(buildTool) {\nif (buildTool.toString().equalsIgnoreCase('terraform')) {\nreturn \"Code-review-library-terraform\"\n}\nif (buildTool.toString().equalsIgnoreCase('opa')) {\nreturn \"Code-review-library-opa\"\n}\nif (buildTool.toString().equalsIgnoreCase('codenarc')) {\nreturn \"Code-review-library-codenarc\"\n}\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\nreturn supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\"\n}\n\ndef createReleasePipeline(pipelineName, codebaseName, codebaseStages, pipelineScript, repository, credId,\ngitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, defaultBranch) {\npipelineJob(\"${codebaseName}/${pipelineName}\") {\nlogRotator {\nnumToKeep(14)\ndaysToKeep(30)\n}\ndefinition {\ncpsScm {\nscm {\ngit {\nremote {\nurl(repository)\ncredentials(credId)\n}\nbranches(\"${defaultBranch}\")\nscriptPath(\"${pipelineScript}\")\n}\n}\nparameters {\nstringParam(\"STAGES\", \"${codebaseStages}\", \"\")\nif (pipelineName.contains(\"Create-release\")) {\nstringParam(\"JIRA_INTEGRATION_ENABLED\", \"${jiraIntegrationEnabled}\", \"Is Jira integration enabled\")\nstringParam(\"GERRIT_PROJECT\", \"${codebaseName}\", \"\")\nstringParam(\"RELEASE_NAME\", \"\", \"Name of the release(branch to be created)\")\nstringParam(\"COMMIT_ID\", \"\", \"Commit ID that will be used to create branch from for new release. If empty, HEAD of master will be used\")\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"REPOSITORY_PATH\", \"${repository}\", \"Full repository path\")\nstringParam(\"DEFAULT_BRANCH\", \"${defaultBranch}\", \"Default repository branch\")\n}\n}\n}\n}\n}\n}\n\ndef createListView(codebaseName, branchName) {\nlistView(\"${codebaseName}/${branchName}\") {\nif (branchName.toLowerCase() == \"releases\") {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^Create-release.*\")\n}\n}\n} else {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^${branchName}-(Code-review|Build).*\")\n}\n}\n}\ncolumns {\nstatus()\nweather()\nname()\nlastSuccess()\nlastFailure()\nlastDuration()\nbuildButton()\n}\n}\n}\n</code></pre> <p>Note</p> <p>Please refer to the Manage Jenkins CD Pipeline Job Provisioner page for the details.</p> View: Default CD provisioner template for EDP 2.8.4 <pre><code>/* Copyright 2021 EPAM Systems.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport groovy.json.*\nimport jenkins.model.Jenkins\n\nJenkins jenkins = Jenkins.instance\n\ndef pipelineName = \"${PIPELINE_NAME}-cd-pipeline\"\ndef stageName = \"${STAGE_NAME}\"\ndef qgStages = \"${QG_STAGES}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID}\"\ndef sourceType = \"${SOURCE_TYPE}\"\ndef libraryURL = \"${LIBRARY_URL}\"\ndef libraryBranch = \"${LIBRARY_BRANCH}\"\ndef autodeploy = \"${AUTODEPLOY}\"\ndef scriptPath = \"Jenkinsfile\"\ndef containerDeploymentType = \"container\"\ndef deploymentType = \"${DEPLOYMENT_TYPE}\"\n\ndef stages = buildStages(deploymentType, containerDeploymentType, qgStages)\n\ndef codebaseFolder = jenkins.getItem(pipelineName)\nif (codebaseFolder == null) {\nfolder(pipelineName)\n}\n\nif (deploymentType == containerDeploymentType) {\ncreateContainerizedCdPipeline(pipelineName, stageName, stages, scriptPath, sourceType,\nlibraryURL, libraryBranch, gitCredentialsId, gitServerCrVersion,\nautodeploy)\n} else {\ncreateCustomCdPipeline(pipelineName, stageName)\n}\n\ndef buildStages(deploymentType, containerDeploymentType, qgStages) {\nreturn deploymentType == containerDeploymentType\n? '[{\"name\":\"init\",\"step_name\":\"init\"},{\"name\":\"deploy\",\"step_name\":\"deploy\"},' + qgStages + ',{\"name\":\"promote-images-ecr\",\"step_name\":\"promote-images\"}]'\n: ''\n}\n\ndef createContainerizedCdPipeline(pipelineName, stageName, stages, pipelineScript, sourceType, libraryURL, libraryBranch, libraryCredId, gitServerCrVersion, autodeploy) {\npipelineJob(\"${pipelineName}/${stageName}\") {\nif (sourceType == \"library\") {\ndefinition {\ncpsScm {\nscm {\ngit {\nremote {\nurl(libraryURL)\ncredentials(libraryCredId)\n}\nbranches(\"${libraryBranch}\")\nscriptPath(\"${pipelineScript}\")\n}\n}\n}\n}\n} else {\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nDeploy()\")\nsandbox(true)\n}\n}\n}\nproperties {\ndisableConcurrentBuilds()\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${stages}\", \"Consequence of stages in JSON format to be run during execution\")\n\nif (autodeploy?.trim() &amp;&amp; autodeploy.toBoolean()) {\nstringParam(\"AUTODEPLOY\", \"${autodeploy}\", \"Is autodeploy enabled?\")\nstringParam(\"CODEBASE_VERSION\", null, \"Codebase versions to deploy.\")\n}\n}\n}\n}\n\ndef createCustomCdPipeline(pipelineName, stageName) {\npipelineJob(\"${pipelineName}/${stageName}\") {\nproperties {\ndisableConcurrentBuilds()\n}\n}\n}\n</code></pre> <ul> <li>It is also necessary to add the string parameter DEPLOYMENT_TYPE to the CD provisioner:<ul> <li>Go to job-provisions - &gt; cd -&gt; default -&gt; configure;</li> <li>Add Parameter - &gt; String parameter;</li> <li>Name -&gt; DEPLOYMENT_TYPE</li> </ul> </li> </ul> </li> <li> <p>Update Jenkins pipelines and stages to the new release tag:</p> <ul> <li>In Jenkins, go to Manage Jenkins -&gt; Configure system -&gt; Find the Global Pipeline Libraries menu.</li> <li>Change the Default version for edp-library-stages from build/2.8.0-RC.6 to build/2.9.0-RC.5</li> <li>Change the Default version for edp-library-pipelines from build/2.8.0-RC.4 to build/2.9.0-RC.3</li> </ul> </li> <li> <p>Update the edp-admin-console Custom Resource in the KeycloakClient Custom Resource Definition:</p> View: keycloakclient.yaml <pre><code>kind: KeycloakClient\napiVersion: v1.edp.epam.com/v1alpha1\nmetadata:\nname: edp-admin-console\nnamespace: &lt;edp-namespace&gt;\nspec:\nadvancedProtocolMappers: false\nattributes: null\naudRequired: true\nclientId: admin-console-client\ndirectAccess: true\npublic: false\nsecret: admin-console-client\nserviceAccount:\nenabled: true\nrealmRoles:\n- developer\ntargetRealm: &lt;keycloak-edp-realm&gt;\nwebUrl: &gt;-\nhttps://edp-admin-console-example.com\n</code></pre> <pre><code>kubectl apply -f keycloakclient.yaml\n</code></pre> </li> <li> <p>Remove the admin-console-client client ID in the edp-namespace-main realm in Keycloak, restart the keycloak-operator pod and check that the new KeycloakClient is created with the confidential access type.</p> <p>Note</p> <p>If \"Internal error\" occurs, regenerate the admin-console-client secret in the Credentials tab in Keycloak and update the admin-console-client secret key \"clientSecret\" and \"password\".</p> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images should be:<pre><code>epamedp/edp-jenkins-dotnet-21-agent:1.0.2\nepamedp/edp-jenkins-dotnet-31-agent:1.0.2\nepamedp/edp-jenkins-go-agent:1.0.3\nepamedp/edp-jenkins-gradle-java11-agent:2.0.2\nepamedp/edp-jenkins-gradle-java8-agent:1.0.2\nepamedp/edp-jenkins-helm-agent:1.0.6\nepamedp/edp-jenkins-maven-java11-agent:2.0.3\nepamedp/edp-jenkins-maven-java8-agent:1.0.2\nepamedp/edp-jenkins-npm-agent:2.0.2\nepamedp/edp-jenkins-python-38-agent:2.0.3\nepamedp/edp-jenkins-terraform-agent:2.0.4\n</code></pre> </li> </ul> <ul> <li>Add new Jenkins agents under the data field:</li> </ul> View <pre><code>data:\ncodenarc-template: |-\n&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;codenarc&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;codenarc&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;epamedp/edp-jenkins-codenarc-agent:1.0.0&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\nopa-template: |-\n&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;opa&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;opa&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;epamedp/edp-jenkins-opa-agent:1.0.1&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n</code></pre> <ul> <li>Restart the Jenkins pod.</li> </ul> </li> <li> <p>Update compatible plugins in Jenkins and install additional plugins:</p> <ul> <li>Go to Manage Jenkins -&gt; Manage Plugins -&gt; Select Compatible -&gt; Click Download now and install after restart</li> <li>Install the following additional plugins (click the Available plugins tab in Jenkins):<ul> <li>Groovy Postbuild</li> <li>CloudBees AWS Credentials</li> <li>Badge</li> <li>Timestamper</li> </ul> </li> </ul> </li> <li> <p>Add the annotation <code>deploy.edp.epam.com/previous-stage-name: ''</code> (it should be empty if the CD pipeline contains one stage) to each Custom Resource in the Custom Resource Definition Stage, for example:</p> <ul> <li>List all Custom Resources in Stage: <code>kubectl get stages.v2.edp.epam.com -n &lt;edp-namespace&gt;</code></li> </ul> <ul> <li>Edit resources: <code>kubectl edit stages.v2.edp.epam.com &lt;cd-stage-name&gt; -n &lt;edp-namespace&gt;</code><pre><code>apiVersion: v2.edp.epam.com/v1alpha1\nkind: Stage\nmetadata:\nannotations:\ndeploy.edp.epam.com/previous-stage-name: ''\n</code></pre> </li> </ul> <p>Note</p> <p>If a pipeline contains several stages, add a previous stage name indicated in the EDP Admin Console to the annotation, for example: <code>deploy.edp.epam.com/previous-stage-name: 'dev'</code>.</p> </li> <li> <p>Execute script to align CDPipeline resources to the new API (jq command-line JSON processor is required):</p> <pre><code>pipelines=$( kubectl get cdpipelines -n &lt;edp-namespace&gt; -ojson | jq -c '.items[]' )\nfor p in $pipelines; do\necho \"$p\" | \\\n    jq '. | .spec.inputDockerStreams = .spec.input_docker_streams | del(.spec.input_docker_streams) | .spec += { \"deploymentType\": \"container\" } ' | \\\n    kubectl apply -f -\ndone\n</code></pre> </li> <li> <p>Update the database in the edp-db pod in the edp-namespace:</p> <ul> <li>Log in to the pod:<pre><code>kubectl exec -i -t -n &lt;edp-namespace&gt; edp-db-&lt;pod&gt; -c edp-db \"--\" sh -c \"(bash || ash || sh)\"\n</code></pre> </li> </ul> <ul> <li>Log in to the Postgress DB (where \"admin\" is the user the secret was created for):<pre><code>psql edp-db &lt;admin&gt;;\nSET search_path to '&lt;edp-namespace&gt;';\nUPDATE cd_pipeline SET deployment_type = 'container';\n</code></pre> </li> </ul> </li> <li> <p>Add <code>\"AUTODEPLOY\":\"true/false\",\"DEPLOYMENT_TYPE\":\"container\"</code> to every Custom Resource in <code>jenkinsjobs.v2.edp.epam.com</code>:</p> <ul> <li>Edit Kubernetes resources:<pre><code>kubectl get jenkinsjobs.v2.edp.epam.com -n &lt;edp-namespace&gt;\n\nkubectl edit jenkinsjobs.v2.edp.epam.com &lt;cd-pipeline-name&gt; -n &lt;edp-namespace&gt;\n</code></pre> </li> </ul> <ul> <li>Alternatively, use this script to update all the necessary jenkinsjobs Custom Resources:<pre><code>edp_namespace=&lt;epd_namespace&gt;\nfor stages in $(kubectl get jenkinsjobs -o=name -n $edp_namespace); do kubectl get $stages -n $edp_namespace -o yaml | grep -q \"container\" &amp;&amp; echo -e \"\\n$stages is already updated\" || kubectl get $stages -n $edp_namespace -o yaml | sed 's/\"GIT_SERVER_CR_VERSION\"/\"AUTODEPLOY\":\"false\",\"DEPLOYMENT_TYPE\":\"container\",\"GIT_SERVER_CR_VERSION\"/g' | kubectl apply -f -; done\n</code></pre> </li> </ul> <ul> <li>Make sure the edited resource looks as follows:<pre><code>job:\nconfig: '{\"AUTODEPLOY\":\"false\",\"DEPLOYMENT_TYPE\":\"container\",\"GIT_SERVER_CR_VERSION\":\"v2\",\"PIPELINE_NAME\":\"your-pipeline-name\",\"QG_STAGES\":\"{\\\"name\\\":\\\"manual\\\",\\\"step_name\\\":\\\"your-step-name\\\"}\",\"SOURCE_TYPE\":\"default\",\"STAGE_NAME\":\"your-stage-name\"}'\nname: job-provisions/job/cd/job/default\n</code></pre> </li> </ul> <ul> <li>Restart the Jenkins operator pod and wait until the CD job provisioner in Jenkins creates the updated pipelines.</li> </ul> </li>"},{"location":"operator-guide/upgrade-edp-2.8/#possible-issues","title":"Possible Issues","text":"<ol> <li> <p>SonarQube fails during the CI pipeline run. The previous builds of SonarQube used the latest version of the OpenID Connect Authentication for SonarQube plugin. Version 2.1.0 of this plugin may have issues with the connection, so it is necessary to downgrade it in order to get rid of errors in the pipeline. Take the following steps:</p> <ul> <li>Log in to the Sonar pod:<pre><code>kubectl exec -i -t -n &lt;edp-namespace&gt; sonar-&lt;pod&gt; -c sonar \"--\" sh -c \"(bash || ash || sh)\"\n</code></pre> </li> </ul> <ul> <li>Run the command in the Sonar container:<pre><code>rm extensions/plugins/sonar-auth-oidc-plugin*\n</code></pre> </li> </ul> <ul> <li>Install the OpenID Connect Authentication for SonarQube plugin v2.0.0:<pre><code>curl -L  https://github.com/vaulttec/sonar-auth-oidc/releases/download/v2.0.0/sonar-auth-oidc-plugin-2.0.0.jar --output extensions/plugins/sonar-auth-oidc-plugin-2.0.0.jar\n</code></pre> </li> </ul> <ul> <li>Restart the SonarQube pod;</li> </ul> </li> <li> <p>The Helm lint checker in EDP 2.8.4 has some additional rules. There can be issues with it during the Code Review pipeline in Jenkins for applications that were transferred from previous EDP versions to EDP 2.8.4. To fix this, add the following annotation to the <code>Chart.yaml</code> file:</p> <ul> <li>Go to the Git repository -&gt; Choose the application -&gt; Edit the <code>deploy-templates/Chart.yaml</code> file.</li> <li>It is necessary to add the following lines to the bottom of the <code>Chart.yaml</code> file:<pre><code>home: https://github.com/your-repo.git\nsources:\n- https://github.com/your-repo.git\nmaintainers:\n- name: DEV Team\n</code></pre> </li> </ul> <ul> <li>Add a new line character at the end of the last line. Please be aware it is important.</li> </ul> </li> </ol>"},{"location":"operator-guide/upgrade-edp-2.8/#related-articles","title":"Related Articles","text":"<ul> <li>Set Up Kiosk</li> <li>IAM Roles for Kaniko Service Accounts</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"operator-guide/upgrade-edp-2.9/","title":"Upgrade EDP v2.8 to 2.9","text":"<p>This section provides the details on the EDP upgrade to 2.9.0. Explore the actions and requirements below.</p> <p>Note</p> <p>Kiosk is optional for EDP v.2.9.0 and higher, and enabled by default. To disable it, add the following parameter to the <code>values.yaml</code> file: <code>kioskEnabled: false</code>. Please refer to the Set Up Kiosk documentation for the details.</p> <ol> <li> <p>With Amazon Elastic Container Registry to store the images, there are two options:</p> <ul> <li>Enable IRSA and create AWS IAM Role for Kaniko image builder. Please refer to the IAM Roles for Kaniko Service Accounts section for the details.</li> <li>The Amazon Elastic Container Registry Roles can be stored in an instance profile.</li> </ul> </li> <li> <p>Before updating EDP to 2.9.0, update the <code>gerrit-is-credentials</code> secret by adding the new <code>clientSecret</code> key with the value from <code>gerrit-is-credentials.client_secret</code>:</p> <pre><code>kubectl edit secret gerrit-is-credentials -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>Make sure it looks as follows (replace with the necessary key value):<pre><code>data:\nclient_secret: example\nclientSecret: example\n</code></pre> </li> </ul> </li> <li> <p>Update Custom Resource Definitions. This command will apply all the necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritgroupmember_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritgroup_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritprojectaccess_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritproject_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkins_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsagent_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsauthorizationrolemapping_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsauthorizationrole_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.9/deploy-templates/crds/v1_v1alpha1_keycloakclientscope_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.9/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.9/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml\n</code></pre> </li> <li> <p>With Amazon Elastic Container Registry to store and Kaniko to build the images, add the kanikoRoleArn parameter to the values before starting the update process. This parameter is indicated in AWS Roles once IRSA is enabled and AWS IAM Role is created for Kaniko.The value should look as follows:</p> <pre><code>kanikoRoleArn: arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\n</code></pre> </li> <li> <p>To upgrade EDP to the v.2.9.0, run the following command:</p> <pre><code>helm upgrade --install edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.9.0\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with: <code>helm upgrade --install edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.9.0  --dry-run</code></p> </li> <li> <p>Remove the following Kubernetes resources left from the previous EDP installation (it is optional):</p> <pre><code>kubectl delete rolebinding edp-cd-pipeline-operator-&lt;edp-namespace&gt;-admin -n &lt;edp-namespace&gt;\n</code></pre> </li> <li> <p>After EDP update, please restart the 'sonar-operator' pod to address the proper Sonar plugin versioning. After 'sonar-operator' is restarted, check the list of installed plugins in the corresponding SonarQube menu.</p> </li> <li> <p>Update Jenkins pipelines and stages to the new release tag:</p> <ul> <li>Restart the Jenkins pod</li> <li>In Jenkins, go to Manage Jenkins -&gt; Configure system -&gt; Find the Global Pipeline Libraries menu</li> <li>Make sure that the Default version for edp-library-stages is build/2.10.0-RC.1</li> <li>Make sure that the Default version for edp-library-pipelines is build/2.10.0-RC.1</li> </ul> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images should be:<pre><code>epamedp/edp-jenkins-codenarc-agent:1.0.1\nepamedp/edp-jenkins-dotnet-21-agent:1.0.3\nepamedp/edp-jenkins-dotnet-31-agent:1.0.3\nepamedp/edp-jenkins-go-agent:1.0.4\nepamedp/edp-jenkins-gradle-java8-agent:1.0.3\nepamedp/edp-jenkins-gradle-java11-agent:2.0.3\nepamedp/edp-jenkins-helm-agent:1.0.7\nepamedp/edp-jenkins-maven-java8-agent:1.0.3\nepamedp/edp-jenkins-maven-java11-agent:2.0.4\nepamedp/edp-jenkins-npm-agent:2.0.3\nepamedp/edp-jenkins-opa-agent:1.0.2\nepamedp/edp-jenkins-python-38-agent:2.0.4\nepamedp/edp-jenkins-terraform-agent:2.0.5\n</code></pre> </li> </ul> <ul> <li>Restart the Jenkins pod.</li> </ul> </li> <li> <p>Update the compatible plugins in Jenkins:</p> <ul> <li>Go to Manage Jenkins -&gt; Manage Plugins -&gt; Select Compatible -&gt; Click Download now and install after restart</li> </ul> </li> </ol>"},{"location":"operator-guide/upgrade-edp-2.9/#related-articles","title":"Related Articles","text":"<ul> <li>Set Up Kiosk</li> <li>IAM Roles for Kaniko Service Accounts</li> </ul>"},{"location":"operator-guide/upgrade-edp-3.0/","title":"Upgrade EDP v2.12 to 3.0","text":"<p>Important</p> <ul> <li>Before starting the upgrade procedure, please make the necessary backups.</li> <li>Kiosk integration is disabled by default. With EDP below v.3.0.x, define the <code>global.kioskEnabled</code> parameter in the values.yaml file. For details, please refer to the Set Up Kiosk page.</li> <li>The <code>gerrit-ssh-port</code> parameter is moved from the <code>gerrit-operator.gerrit.sshport</code> to <code>global.gerritSSHPort</code> values.yaml file.</li> <li>In edp-gerrit-operator, the <code>gitServer.user</code> value is changed from the <code>jenkins</code> to <code>edp-ci</code>values.yaml file.</li> </ul> <p>This section provides the details on upgrading EDP to 3.0. Explore the actions and requirements below.</p> <ol> <li> <p>Update Custom Resource Definitions (CRDs). Run the following command to apply all necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/d9a4d15244c527ef6d1d029af27574282a281b98/deploy-templates/crds/v2.edp.epam.com_gerrits.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_cdstagedeployments.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_codebasebranches.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_codebaseimagestreams.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_codebases.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_gitservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_gittags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_imagestreamtags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_jiraissuemetadatas.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_jiraservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakauthflows.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakclients.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakclientscopes.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmcomponents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmgroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmidentityproviders.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmrolebatches.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmroles.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealms.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmusers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloaks.yaml\n</code></pre> </li> <li> <p>Set the required parameters. For more details, please refer to the values.yaml file.</p> View: values.yaml <pre><code>edp-tekton:\nenabled: false\nadmin-console-operator:\nenabled: true\njenkins-operator:\nenabled: true\n</code></pre> </li> <li> <p>Add proper Helm annotations and labels as indicated below. This step is necessary starting from the release v.3.0.x as custom resources are managed by Helm and removed from the Keycloak Controller logic.       <pre><code>  kubectl label EDPComponent main-keycloak app.kubernetes.io/managed-by=Helm -n &lt;edp-namespace&gt;\n  kubectl annotate EDPComponent main-keycloak meta.helm.sh/release-name=&lt;edp-release-name&gt; -n &lt;edp-namespace&gt;\n  kubectl annotate EDPComponent main-keycloak meta.helm.sh/release-namespace=&lt;edp-namespace&gt; -n &lt;edp-namespace&gt;\n  kubectl label KeycloakRealm main app.kubernetes.io/managed-by=Helm -n &lt;edp-namespace&gt;\n  kubectl annotate KeycloakRealm main meta.helm.sh/release-name=&lt;edp-release-name&gt; -n &lt;edp-namespace&gt;\n  kubectl annotate KeycloakRealm main meta.helm.sh/release-namespace=&lt;edp-namespace&gt; -n &lt;edp-namespace&gt;\n</code></pre></p> </li> <li> <p>To upgrade EDP to 3.0, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.0.x\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the following command: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.0.x  --dry-run</code></p> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images must be the following:<pre><code>epamedp/edp-jenkins-codenarc-agent:3.0.10\nepamedp/edp-jenkins-dotnet-31-agent:3.0.9\nepamedp/edp-jenkins-go-agent:3.0.17\nepamedp/edp-jenkins-gradle-java11-agent:3.0.7\nepamedp/edp-jenkins-gradle-java8-agent:3.0.10\nepamedp/edp-jenkins-helm-agent:3.0.11\nepamedp/edp-jenkins-kaniko-docker-agent:1.0.9\nepamedp/edp-jenkins-maven-java11-agent:3.0.7\nepamedp/edp-jenkins-maven-java8-agent:3.0.10\nepamedp/edp-jenkins-npm-agent:3.0.9\nepamedp/edp-jenkins-opa-agent:3.0.7\nepamedp/edp-jenkins-python-38-agent:3.0.8\nepamedp/edp-jenkins-sast-agent:0.1.5\nepamedp/edp-jenkins-terraform-agent:3.0.9\n</code></pre> </li> </ul> <ul> <li>Remove the <code>edp-jenkins-dotnet-21-agent</code> agent manifest.</li> </ul> <ul> <li>Restart the Jenkins pod.</li> </ul> </li> <li> <p>Attach the <code>id_rsa.pub</code> SSH public key from the <code>gerrit-ciuser-sshkey</code> secret to the <code>edp-ci</code> Gerrit user in the <code>gerrit</code> pod:</p> <pre><code>ssh -p &lt;gerrit_ssh_port&gt; &lt;host&gt; gerrit set-account --add-ssh-key ~/id_rsa.pub\n</code></pre> <p>Notes</p> <ul> <li>For this operation, use the <code>gerrit-admin</code> SSH key from secrets.</li> <li><code>&lt;host&gt;</code> is admin@localhost or any other user with permissions.</li> </ul> </li> <li> <p>Change the username from <code>jenkins</code> to <code>edp-ci</code> in the <code>gerrit-ciuser-sshkey</code> secret:</p> <pre><code>kubectl -n &lt;edp-namespace&gt; patch secret gerrit-ciuser-sshkey\\\n --patch=\"{\\\"data\\\": { \\\"username\\\": \\\"$(echo -n edp-ci |base64 -w0)\\\" }}\" -oyaml\n</code></pre> </li> </ol> <p>Warning</p> <p>In EDP v.3.0.x, Admin Console is deprecated, and EDP interface is available only via Headlamp.</p>"},{"location":"operator-guide/upgrade-edp-3.0/#related-articles","title":"Related Articles","text":"<ul> <li>Migrate CI Pipelines From Jenkins to Tekton</li> </ul>"},{"location":"operator-guide/upgrade-edp-3.1/","title":"Upgrade EDP v3.0 to 3.1","text":"<p>Important</p> <p>We suggest making a backup of the EDP environment before starting the upgrade procedure.</p> <p>This section provides the details on the EDP upgrade to v3.1. Explore the actions and requirements below.</p> <ol> <li> <p>Update Custom Resource Definitions (CRDs). Run the following command to apply all necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.13.2/deploy-templates/crds/v2.edp.epam.com_jenkins.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/v2.13.4/deploy-templates/crds/v2.edp.epam.com_gerrits.yaml\n</code></pre> </li> <li> <p>To upgrade EDP to the v3.1, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.1.0\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the following command: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.1.0  --dry-run</code></p> </li> </ol>"},{"location":"operator-guide/upgrade-edp-3.2/","title":"Upgrade EDP v3.1 to 3.2","text":"<p>Important</p> <p>We suggest making a backup of the EDP environment before starting the upgrade procedure.</p> <p>This section provides the details on the EDP upgrade to v3.2.2. Explore the actions and requirements below.</p> <ol> <li> <p>Update Custom Resource Definitions (CRDs). Run the following command to apply all necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_cdstagedeployments.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_codebasebranches.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_codebaseimagestreams.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_codebases.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_gitservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_gittags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_imagestreamtags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_jiraissuemetadatas.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_jiraservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_cdstagejenkinsdeployments.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkins.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkinsagents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkinsauthorizationrolemappings.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkinsauthorizationroles.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkinsfolders.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkinsjobbuildruns.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkinsjobs.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkinsscripts.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkinsserviceaccounts.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_jenkinssharedlibraries.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-component-operator/v0.13.0/deploy-templates/crds/v1.edp.epam.com_edpcomponents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/v2.14.1/deploy-templates/crds/v2.edp.epam.com_cdpipelines.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/v2.14.1/deploy-templates/crds/v2.edp.epam.com_stages.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/v2.14.1/deploy-templates/crds/v2.edp.epam.com_nexuses.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/v2.14.1/deploy-templates/crds/v2.edp.epam.com_nexususers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_sonargroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_sonarpermissiontemplates.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_sonars.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_gerritgroupmembers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_gerritgroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_gerritmergerequests.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_gerritprojectaccesses.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_gerritprojects.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_gerritreplicationconfigs.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/v2.14.0/deploy-templates/crds/v2.edp.epam.com_gerrits.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/v2.13.0/deploy-templates/crds/v2.edp.epam.com_perfdatasourcegitlabs.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/v2.13.0/deploy-templates/crds/v2.edp.epam.com_perfdatasourcejenkinses.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/v2.13.0/deploy-templates/crds/v2.edp.epam.com_perfdatasourcesonars.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/v2.13.0/deploy-templates/crds/v2.edp.epam.com_perfservers.yaml\n</code></pre> </li> <li> <p>Generate a cookie-secret for proxy with the following command:</p> <p><pre><code>nexus_proxy_cookie_secret=$(openssl rand -base64 32 | head -c 32)\n</code></pre> Create <code>nexus-proxy-cookie-secret</code> in the  namespace: <pre><code>kubectl -n &lt;edp-project&gt; create secret generic nexus-proxy-cookie-secret \\\n--from-literal=cookie-secret=${nexus_proxy_cookie_secret}\n</code></pre> <li> <p>EDP 3.2.2 features OIDC configuration for Headlamp. If this parameter is required, create <code>keycloak-client-headlamp-secret</code> as described in this article:</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic keycloak-client-headlamp-secret \\\n--from-literal=clientSecret=&lt;keycloak_client_secret_key&gt;\n</code></pre> </li> <li> <p>Delete the following resources:</p> <pre><code>kubectl -n &lt;edp-project&gt; delete KeycloakClient nexus\nkubectl -n &lt;edp-project&gt; delete EDPComponent nexus\nkubectl -n &lt;edp-project&gt; delete Ingress nexus\nkubectl -n &lt;edp-project&gt; delete deployment edp-tekton-dashboard\n</code></pre> </li> <li> <p>EDP release 3.2.2 uses the default cluster storageClass and we must check previous storageClass parameters. Align , if required, the <code>storageClassName</code> in EDP <code>values.yaml</code> to the same that were used by EDP PVC. For example:</p> <pre><code>edp-tekton:\nbuildTool:\ngo:\ncache:\npersistentVolume:\n# -- Specifies storageClass type. If not specified, a default storageClass for go-cache volume is used\nstorageClass: ebs-sc\n\njenkins-operator:\nenabled: true\njenkins:\nstorage:\n# -- Storageclass for Jenkins data volume\nclass: gp2\n\nsonar-operator:\nsonar:\nstorage:\ndata:\n# --  Storageclass for Sonar data volume\nclass: gp2\ndatabase:\n# --  Storageclass for database data volume\nclass: gp2\n\ngerrit-operator:\ngerrit:\nstorage:\n# --  Storageclass for Gerrit data volume\nclass: gp2\n\nnexus-operator:\nnexus:\nstorage:\n# --  Storageclass for Nexus data volume\nclass: gp2\n</code></pre> </li> <li> <p>To upgrade EDP to the v3.2.2, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.2.2\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the following command: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.2.2  --dry-run</code></p> </li>"},{"location":"operator-guide/upgrade-edp-3.3/","title":"Upgrade EDP v3.2 to 3.3","text":"<p>Important</p> <p>We suggest making a backup of the EDP environment before starting the upgrade procedure.</p> <p>Note</p> <p>We currently disabled cache volumes for go and npm in the EDP 3.3 release.</p> <p>This section provides the details on the EDP upgrade to v3.3.0. Explore the actions and requirements below.</p> <ol> <li> <p>Update Custom Resource Definitions (CRDs). Run the following command to apply all necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/v2.16.0/deploy-templates/crds/v2.edp.epam.com_codebases.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/v2.15.0/deploy-templates/crds/v2.edp.epam.com_jenkins.yaml\n</code></pre> </li> <li> <p>If you use Gerrit VCS, delete the corresponding resource due to changes in annotations:</p> <p><pre><code>kubectl -n &lt;edp-project&gt; delete EDPComponent gerrit\n</code></pre> The deployment will create a new EDPComponent called <code>gerrit</code> instead.</p> </li> <li> <p>To upgrade EDP to the v3.3.0, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.3.0\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the <code>--dry-run</code> tag: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.3.0  --dry-run</code></p> </li> <li> <p>In EDP v3.3.0, a new feature was introduced allowing manual pipeline re-triggering by sending a comment with <code>/recheck</code>. To enable the re-trigger feature for applications that were added before the upgrade, please proceed with the following:</p> <p>4.1 For Gerrit VCS, add the following event to the <code>webhooks.config</code> configuration file in the <code>All-Projects</code> repository:</p> <pre><code>[remote \"commentadded\"]\n  url = http://el-gerrit-listener:8080\n  event = comment-added\n</code></pre> <p>4.2 For GitHub VCS, check the <code>Issue comments</code> permission for each webhook in every application added before the EDP upgrade to 3.3.0.</p> <p>4.3 For GitLab VCS, check the <code>Comments</code> permission for each webhook in every application added before the EDP upgrade to 3.3.0.</p> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/","title":"Upgrade Keycloak v17.0 to 19.0","text":"<p>Starting from Keycloak v.18.x.x, the Keycloak server has been moved from the Wildfly (JBoss) Application Server to Quarkus framework and is called Keycloak.X.</p> <p>There are two ways to upgrade Keycloak v.17.0.x-legacy to v.19.0.x on Kubernetes, please perform the steps described in the Prerequisites section of this tutorial, and then select a suitable upgrade strategy for your environment:</p> <ul> <li>Upgrade Postgres database to a minor release v.11.17</li> <li>Migrate Postgres database from Postgres v.11.x to v.14.5</li> </ul>"},{"location":"operator-guide/upgrade-keycloak-19.0/#prerequisites","title":"Prerequisites","text":"<p>Before upgrading Keycloak, please perform the steps below:</p> <ol> <li> <p>Create a backup/snapshot of the Keycloak database volume. Locate the AWS <code>volumeID</code> and then create its snapshot on AWS:</p> <ul> <li> <p>Find the <code>PVC</code> name attached to the Postgres pod. It can be similar to <code>data-keycloak-postgresql-0</code> if the Postgres <code>StatefulSet</code> name is <code>keycloak-postgresql</code>:</p> <pre><code>kubectl get pods keycloak-postgresql-0 -n security -o jsonpath='{.spec.volumes[*].persistentVolumeClaim.claimName}{\"\\n\"}'\n</code></pre> </li> </ul> <ul> <li> <p>Locate the <code>PV</code> <code>volumeName</code> in the <code>data-keycloak-postgresql-0</code> Persistent Volume Claim:</p> <pre><code>kubectl get pvc data-keycloak-postgresql-0 -n security -o jsonpath='{.spec.volumeName}{\"\\n\"}'\n</code></pre> </li> </ul> <ul> <li> <p>Get <code>volumeID</code> in the Persistent Volume:</p> <pre><code>kubectl get pv ${pv_name} -n security -o jsonpath='{.spec.awsElasticBlockStore.volumeID}{\"\\n\"}'\n</code></pre> </li> </ul> </li> <li> <p>Add two additional keys: <code>password</code> and <code>postgres-password</code>, to the <code>keycloak-postgresql</code> secret in the Keycloak namespace.</p> <p>Note</p> <ul> <li>The <code>password</code> key must have the same value as the <code>postgresql-password</code> key.</li> <li>The <code>postgres-password</code> key must have the same value as the <code>postgresql-postgres-password</code> key.</li> </ul> <p>The latest chart for Keycloak.X does not have an option to override Postgres password and admin password keys in the secret, and it uses the Postgres defaults, therefore, a new secret scheme must be implemented:</p> <pre><code>kubectl -n security edit secret keycloak-postgresql\n</code></pre> <pre><code>data:\npostgresql-password: XXXXXX\npostgresql-postgres-password: YYYYYY\npassword: XXXXXX\npostgres-password: YYYYYY\n</code></pre> </li> <li> <p>Save Keycloak <code>StatefulSet</code> names, for example, <code>keycloak</code> and <code>keycloak-postgresql</code>. These names will be used in the new Helm deployments:</p> <pre><code>$ kubectl get statefulset -n security\nNAME                  READY   AGE\nkeycloak              1/1     18h\nkeycloak-postgresql   1/1     18h\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/#upgrade-postgres-database-to-a-minor-release-v1117","title":"Upgrade Postgres Database to a Minor Release v.11.17","text":"<p>To upgrade Keycloak by upgrading Postgres Database to a minor release v.11.17, perform the steps described in the Prerequisites section of this tutorial, and then perform the following steps:</p>"},{"location":"operator-guide/upgrade-keycloak-19.0/#delete-keycloak-resources","title":"Delete Keycloak Resources","text":"<ol> <li> <p>Delete <code>Keycloak</code> and <code>Prostgres</code> <code>StatefulSets</code>:</p> <pre><code>kubectl delete statefulset keycloak keycloak-postgresql -n security\n</code></pre> </li> <li> <p>Delete the Keycloak <code>Ingress</code>object, to prevent hostname duplication issues:</p> <pre><code>kubectl delete ingress keycloak -n security\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/#upgrade-keycloak","title":"Upgrade Keycloak","text":"<ol> <li> <p>Make sure the Keycloak chart repository is added:</p> <pre><code>helm repo add codecentric https://codecentric.github.io/helm-charts\nhelm repo update\n</code></pre> </li> <li> <p>Create values for Keycloak:</p> <p>Note</p> <p>Since the Keycloak.X release, Keycloak  and Postgres database charts are separated. Upgrade Keycloak, and then install the Postgres database.</p> <p>Note</p> <ul> <li><code>nameOverride: \"keycloak\"</code> sets the name of the Keycloak pod. It must be the same Keycloak name as in the previous <code>StatefulSet</code>.</li> <li>Change Ingress host name to the Keycloak host name.</li> <li><code>hostname: keycloak-postgresql</code> is the hostname of the pod with the Postgres database that is the same as Postgres StatefulSet name, for example, <code>keycloak-postgresql</code>.</li> <li><code>\"/opt/keycloak/bin/kc.sh start --auto-build\"</code> was used in the legacy Keycloak version. However, it is no longer required in the new Keycloak version since it is deprecated and used by default.</li> <li> <p>Optionally, use the following command for applying the old Keycloak theme:</p> <p><pre><code>bin/kc.sh start --features-disabled=admin2\n</code></pre> </p> </li> </ul> View: keycloak-values.yaml <pre><code>nameOverride: \"keycloak\"\n\nreplicas: 1\n\n# Deploy the latest verion\nimage:\ntag: \"19.0.1\"\n\n# start: create OpenShift realm which is required by EDP\nextraInitContainers: |\n- name: realm-provider\nimage: busybox\nimagePullPolicy: IfNotPresent\ncommand:\n- sh\nargs:\n- -c\n- |\necho '{\"realm\": \"openshift\",\"enabled\": true}' &gt; /opt/keycloak/data/import/openshift.json\nvolumeMounts:\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumeMounts: |\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumes: |\n- name: realm\nemptyDir: {}\n\ncommand:\n- \"/opt/keycloak/bin/kc.sh\"\n- \"--verbose\"\n- \"start\"\n- \"--http-enabled=true\"\n- \"--http-port=8080\"\n- \"--hostname-strict=false\"\n- \"--hostname-strict-https=false\"\n- \"--spi-events-listener-jboss-logging-success-level=info\"\n- \"--spi-events-listener-jboss-logging-error-level=warn\"\n- \"--import-realm\"\n\nextraEnv: |\n- name: KC_PROXY\nvalue: \"passthrough\"\n- name: KEYCLOAK_ADMIN\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: username\n- name: KEYCLOAK_ADMIN_PASSWORD\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: password\n- name: JAVA_OPTS_APPEND\nvalue: &gt;-\n-XX:+UseContainerSupport\n-XX:MaxRAMPercentage=50.0\n-Djava.awt.headless=true\n-Djgroups.dns.query={{ include \"keycloak.fullname\" . }}-headless\n\n# This block should be uncommented if you install Keycloak on Kubernetes\ningress:\nenabled: true\nannotations:\nkubernetes.io/ingress.class: nginx\ningress.kubernetes.io/affinity: cookie\nrules:\n- host: keycloak.&lt;ROOT_DOMAIN&gt;\npaths:\n- path: '{{ tpl .Values.http.relativePath $ | trimSuffix \"/\" }}/'\npathType: Prefix\n\n# This block should be uncommented if you set Keycloak to OpenShift and change the host field\n# route:\n#   enabled: false\n#   # Path for the Route\n#   path: '/'\n#   # Host name for the Route\n#   host: \"keycloak.&lt;ROOT_DOMAIN&gt;\"\n#   # TLS configuration\n#   tls:\n#     enabled: true\n\nresources:\nlimits:\nmemory: \"2048Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"512Mi\"\n\n# Check database readiness at startup\ndbchecker:\nenabled: true\n\ndatabase:\nvendor: postgres\nexistingSecret: keycloak-postgresql\nhostname: keycloak-postgresql\nport: 5432\nusername: admin\ndatabase: keycloak\n</code></pre> </li> <li> <p>Upgrade the Keycloak Helm chart:</p> <p>Note</p> <ul> <li>The Helm chart is substituted with the new Keyacloak.X instance.</li> <li>Change the namespace and the values file name if required.</li> </ul> <pre><code>helm upgrade keycloak codecentric/keycloakx --version 1.6.0 --values keycloak-values.yaml -n security\n</code></pre> <p>Note</p> <p>If there are error messages when upgrading via Helm, make sure that <code>StatefulSets</code> are removed. If they are removed and the error still persists, try to add the <code>--force</code> flag to the Helm command:</p> <pre><code>helm upgrade keycloak codecentric/keycloakx --version 1.6.0 --values keycloak-values.yaml -n security --force\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/#install-postgres","title":"Install Postgres","text":"<ol> <li> <p>Add Bitnami chart repository and update Helm repos:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Create values for Postgres:</p> <p>Note</p> <ul> <li>Postgres v.11 and Postgres v.14.5 are not compatible.</li> <li>Postgres image will be upgraded to a minor release v.11.17.</li> <li><code>fullnameOverride: \"keycloak-postgresql\"</code> sets the name of the Postgres StatefulSet. It must be the same as in the previous <code>StatefulSet</code>.</li> </ul> View: postgres-values.yaml <pre><code>fullnameOverride: \"keycloak-postgresql\"\n\n# PostgreSQL read only replica parameters\nreadReplicas:\n# Number of PostgreSQL read only replicas\nreplicaCount: 1\n\nglobal:\npostgresql:\nauth:\nusername: admin\nexistingSecret: keycloak-postgresql\nsecretKeys:\nadminPasswordKey: postgres-password\nuserPasswordKey: password\ndatabase: keycloak\n\nimage:\nregistry: docker.io\nrepository: bitnami/postgresql\ntag: 11.17.0-debian-11-r3\n\nauth:\nexistingSecret: keycloak-postgresql\nsecretKeys:\nadminPasswordKey: postgres-password\nuserPasswordKey: password\n\nprimary:\npersistence:\nenabled: true\nsize: 3Gi\n# If the StorageClass with reclaimPolicy: Retain is used, install an additional StorageClass before installing PostgreSQL\n# (the code is given below).\n# If the default StorageClass will be used - change \"gp2-retain\" to \"gp2\"\nstorageClass: \"gp2-retain\"\n</code></pre> </li> <li> <p>Install the Postgres database chart:</p> <p>Note</p> <p>Change the namespace and the values file name if required.</p> <pre><code>helm install postgresql bitnami/postgresql \\\n--version 11.7.6 \\\n--values postgres-values.yaml \\\n--namespace security\n</code></pre> </li> <li> <p>Log in to Keycloak and check that everything works as expected.</p> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/#clean-and-analyze-database","title":"Clean and Analyze Database","text":"<p>Optionally, run the vacuumdb application on the database, to recover space occupied by \"dead tuples\" in the tables, analyze the contents of database tables, and collect statistics for PostgreSQL query engine to improve performance:</p> <p><pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" vacuumdb --analyze --verbose -d keycloak -U postgres\n</code></pre> For all databases, run the following command:</p> <pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" vacuumdb --analyze --verbose --all -U postgres\n</code></pre>"},{"location":"operator-guide/upgrade-keycloak-19.0/#migrate-postgres-database-from-postgres-v11x-to-v145","title":"Migrate Postgres Database From Postgres v.11.x to v.14.5","text":"<p>Info</p> <p>There is a Postgres database migration script at the end of this tutorial. Please read the section below before using the script.</p> <p>To upgrade Keycloak by migrating Postgres database from Postgres v.11.x to v.14.5, perform the steps described in the Prerequisites section of this tutorial, and then perform the following steps:</p>"},{"location":"operator-guide/upgrade-keycloak-19.0/#export-postgres-databases","title":"Export Postgres Databases","text":"<ol> <li> <p>Log in to the current Keycloak Postgres pod and create a logical backup of all roles and databases using the pg_dumpall application. If there is no access to the Postgres Superuser, backup the Keycloak database with the pg_dump application:</p> <p>Note</p> <ul> <li>The secret key <code>postgresql-postgres-password</code> is for the <code>postgres</code> Superuser and <code>postgresql-password</code> is for <code>admin</code> user. The <code>admin</code> user is indicated by default in the Postgres Helm chart. The <code>admin</code> user may not have enough permissions to dump all Postgres databases and roles, so the preferred option for exporting all objects is using the <code>pg_dumpall</code> tool with the <code>postgres</code> Superuser.</li> <li>If the <code>PGPASSWORD</code> variable is not specified before using the <code>pg_dumpall</code> tool, you will be prompted to enter a password for each database during the export.</li> <li>If the <code>-l keycloak</code> parameter is specified, <code>pg_dumpall</code> will connect to the <code>keycloak</code> database for dumping global objects and discovering what other databases should be dumped. By default, <code>pg_dumpall</code> will try to connect to <code>postgres</code> or <code>template1</code> databases. This parameter is optional.</li> <li>The <code>pg_dumpall --clean</code> option adds SQL commands to the dumped file for dropping databases before recreating them during import, as well as <code>DROP</code> commands for roles and tablespaces (<code>pg_dump</code> also has this option). If the <code>--clean</code> parameter is specified, connect to the <code>postgres</code> database initially during import via <code>psql</code>. The <code>psql</code> script will attempt to drop other databases immediately, and that will fail for the database you are connected to. This flag is optional, and it is not included into this tutorial.</li> </ul> <pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" pg_dumpall -h localhost -p 5432 -U postgres -l keycloak &gt; /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> <p>Note</p> <p>If there is no working password for the <code>postgres</code> Superuser, try the <code>admin</code> user using the pg_dump tool to export the <code>keycloak</code> database without global roles:</p> <pre><code>PGPASSWORD=\"${postgresql_password}\" pg_dump -h localhost -p 5432 -U admin -d keycloak &gt; /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> <p>Info</p> <p>Double-check that the contents of the dumped file is not empty. It usually contains more than 4000 lines.</p> </li> <li> <p>Copy the file with the database dump to a local machine. Since <code>tar</code> may not be present in the pod and <code>kubectl cp</code> will not work without <code>tar</code>, use the following command:</p> <pre><code>kubectl exec -n security ${postgresql_pod} -- cat /tmp/keycloak_wildfly_db_dump.sql  &gt; keycloak_wildfly_db_dump.sql\n</code></pre> <p>Note</p> <p>Please find below the alternative commands for exporting the database to the local machine without copying the file to a pod for Postgres and admin users:</p> <pre><code>kubectl exec -n security ${postgresql_pod} \"--\" sh -c \"PGPASSWORD='\"${postgresql_postgres-password}\"' pg_dumpall -h localhost -p 5432 -U postgres\" &gt; keycloak_wildfly_db_dump.sql\nkubectl exec -n security ${postgresql_pod} \"--\" sh -c \"PGPASSWORD='\"${postgresql_password}\"' pg_dump -h localhost -p 5432 -U admin -d keycloak\" &gt; keycloak_wildfly_db_dump.sql\n</code></pre> </li> <li> <p>Delete the dumped file from the pod for security reasons:</p> <pre><code>kubectl exec -n security ${postgresql_pod} \"--\" sh -c \"rm /tmp/keycloak_wildfly_db_dump.sql\"\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/#delete-keycloak-resources_1","title":"Delete Keycloak Resources","text":"<ol> <li> <p>Delete all previous Keycloak resources along with the Postgres database and keycloak <code>StatefulSets</code>, <code>Ingress</code>, and custom resources via Helm, or via the tool used for their deployment.</p> <pre><code>helm list -n security\nhelm delete keycloak -n security\n</code></pre> <p>Warning</p> <p>Don't delete the whole namespace. Keep the <code>keycloak-postgresql</code> and <code>keycloak-admin-creds</code> secrets.</p> </li> <li> <p>Delete the volume in AWS, from which a snapshot has been created. Then delete the PVC:</p> <pre><code>kubectl delete pvc data-keycloak-postgresql-0 -n security\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/#install-postgres_1","title":"Install Postgres","text":"<ol> <li> <p>Add Bitnami chart repository and update Helm repos:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Create Postgres values:</p> <p>Note</p> <p><code>fullnameOverride: \"keycloak-postgresql\"</code> sets the name of the Postgres StatefulSet. It must be same as in the previous <code>StatefulSet</code>.</p> View: postgres-values.yaml <pre><code>nameOverride: \"keycloak-postgresql\"\n\n# PostgreSQL read only replica parameters\nreadReplicas:\n# Number of PostgreSQL read only replicas\nreplicaCount: 1\n\nglobal:\npostgresql:\nauth:\nusername: admin\nexistingSecret: keycloak-postgresql\nsecretKeys:\nadminPasswordKey: postgres-password\nuserPasswordKey: password\ndatabase: keycloak\n\nauth:\nexistingSecret: keycloak-postgresql\nsecretKeys:\nadminPasswordKey: postgres-password\nuserPasswordKey: password\n\nprimary:\npersistence:\nenabled: true\nsize: 3Gi\n# If the StorageClass with reclaimPolicy: Retain is used, install an additional StorageClass before installing PostgreSQL\n# (the code is given below).\n# If the default StorageClass will be used - change \"gp2-retain\" to \"gp2\"\nstorageClass: \"gp2-retain\"\n</code></pre> </li> <li> <p>Install the Postgres database:</p> <p>Note</p> <p>Change the namespace and the values file name if required.</p> <pre><code>helm install postgresql bitnami/postgresql \\\n--version 11.7.6 \\\n--values postgres-values.yaml \\\n--namespace security\n</code></pre> </li> <li> <p>Wait for the database to be ready.</p> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/#import-postgres-databases","title":"Import Postgres Databases","text":"<ol> <li> <p>Upload the database dump to the new Keycloak Postgres pod:</p> <pre><code>cat keycloak_wildfly_db_dump.sql | kubectl exec -i -n security ${postgresql_pod} \"--\" sh -c \"cat &gt; /tmp/keycloak_wildfly_db_dump.sql\"\n</code></pre> <p>Warning</p> <p>Database import must be done before deploying Keycloak, because Keycloak will write its own data to the database during the start, and the import will partially fail. If that happened, scale down the keycloak <code>StatefulSet</code>, and try to drop the Keycloak database in the Postgres pod:</p> <pre><code>dropdb -i -e keycloak -p 5432 -h localhost -U postgres\n</code></pre> <p>If there still are some conflicting objects like roles, drop them via the DROP ROLE command.</p> <p>If the previous steps do not help, downscale the Keycloak and Postgres <code>StatefulSets</code> and delete the attached <code>PVC</code> (save the <code>volumeID</code> before removing), and delete the volume on AWS if using <code>gp2-retain</code>. In case of using <code>gp2</code>, the volume will be deleted automatically after removing PVC. After that, redeploy the Postgres database, so that the new <code>PVC</code> is automatically created.</p> </li> <li> <p>Import the SQL dump file to the Postgres database cluster:</p> <p>Info</p> <p>Since the databases were exported in the <code>sql</code> format, the psql tool will be used to restore (reload) them. pg_restore does not support this plain-text format.</p> <ul> <li> <p>If the entire Postgres database cluster was migrated with the <code>postgres</code> Superuser using <code>pg_dumpall</code>, use the import command without indicating the database:</p> <pre><code>psql -U postgres -f /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> </li> </ul> <ul> <li> <p>If the database was migrated with the <code>admin</code> user using <code>pg_dump</code>, the <code>postgres</code> Superuser still can be used to restore it, but, in this case, a database must be indicated:</p> <p>Warning</p> <p>If the database name was not indicated during the import for the file dumped with <code>pg_dump</code>, the <code>psql</code> tool will import this database to a default Postgres database called <code>postgres</code>.</p> <pre><code>psql -U postgres -d keycloak -f /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> </li> </ul> <ul> <li> <p>If the <code>postgres</code> Superuser is not accessible in the Postgres pod, run the command under the <code>admin</code> or any other user that has the database permissions. In this case, indicate the database as well:</p> <pre><code>psql -U admin -d keycloak -f /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> </li> </ul> </li> <li> <p>After a successful import, delete the dump file from the pod for security reasons:</p> <pre><code>kubectl exec -n security ${postgresql_pod} \"--\" sh -c \"rm /tmp/keycloak_wildfly_db_dump.sql\"\n</code></pre> <p>Note</p> <p>Please find below the alternative commands for importing the database from the local machine to the pod without storing the backup on a pod for <code>postgres</code> or <code>admin</code> users:</p> <pre><code>cat \"keycloak_wildfly_db_dump.sql\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" sh -c \"cat | PGPASSWORD='\"${postgresql_superuser_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\"\"\ncat \"keycloak_wildfly_db_dump.sql\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" sh -c \"cat | PGPASSWORD='\"${postgresql_superuser_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\ncat \"keycloak_wildfly_db_dump.sql\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" sh -c \"cat | PGPASSWORD='\"${postgresql_admin_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/#install-keycloak","title":"Install Keycloak","text":"<ol> <li> <p>Make sure the Keycloak chart repository is added:</p> <pre><code>helm repo add codecentric https://codecentric.github.io/helm-charts\nhelm repo update\n</code></pre> </li> <li> <p>Create Keycloak values:</p> <p>Note</p> <ul> <li><code>nameOverride: \"keycloak\"</code> sets the name of the Keycloak pod. It must be the same Keycloak name as in the previous <code>StatefulSet</code>.</li> <li>Change Ingress host name to the Keycloak host name.</li> <li><code>hostname: keycloak-postgresql</code> is the hostname of the pod with the Postgres database that is the same as Postgres StatefulSet name, for example, <code>keycloak-postgresql</code>.</li> <li><code>\"/opt/keycloak/bin/kc.sh start --auto-build\"</code> was used in the legacy Keycloak version. However, it is no longer required in the new Keycloak version since it is deprecated and used by default.</li> <li> <p>Optionally, use the following command for applying the old Keycloak theme:</p> <pre><code>bin/kc.sh start --features-disabled=admin2\n</code></pre> </li> </ul> <p>Info</p> <p>Automatic database migration will start after the Keycloak installation.</p> View: keycloak-values.yaml <pre><code>nameOverride: \"keycloak\"\n\nreplicas: 1\n\n# Deploy the latest verion\nimage:\ntag: \"19.0.1\"\n\n# start: create OpenShift realm which is required by EDP\nextraInitContainers: |\n- name: realm-provider\nimage: busybox\nimagePullPolicy: IfNotPresent\ncommand:\n- sh\nargs:\n- -c\n- |\necho '{\"realm\": \"openshift\",\"enabled\": true}' &gt; /opt/keycloak/data/import/openshift.json\nvolumeMounts:\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumeMounts: |\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumes: |\n- name: realm\nemptyDir: {}\n\ncommand:\n- \"/opt/keycloak/bin/kc.sh\"\n- \"--verbose\"\n- \"start\"\n- \"--http-enabled=true\"\n- \"--http-port=8080\"\n- \"--hostname-strict=false\"\n- \"--hostname-strict-https=false\"\n- \"--spi-events-listener-jboss-logging-success-level=info\"\n- \"--spi-events-listener-jboss-logging-error-level=warn\"\n- \"--import-realm\"\n\nextraEnv: |\n- name: KC_PROXY\nvalue: \"passthrough\"\n- name: KEYCLOAK_ADMIN\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: username\n- name: KEYCLOAK_ADMIN_PASSWORD\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: password\n- name: JAVA_OPTS_APPEND\nvalue: &gt;-\n-XX:+UseContainerSupport\n-XX:MaxRAMPercentage=50.0\n-Djava.awt.headless=true\n-Djgroups.dns.query={{ include \"keycloak.fullname\" . }}-headless\n\n# This block should be uncommented if you install Keycloak on Kubernetes\ningress:\nenabled: true\nannotations:\nkubernetes.io/ingress.class: nginx\ningress.kubernetes.io/affinity: cookie\nrules:\n- host: keycloak.&lt;ROOT_DOMAIN&gt;\npaths:\n- path: '{{ tpl .Values.http.relativePath $ | trimSuffix \"/\" }}/'\npathType: Prefix\n\n# This block should be uncommented if you set Keycloak to OpenShift and change the host field\n# route:\n#   enabled: false\n#   # Path for the Route\n#   path: '/'\n#   # Host name for the Route\n#   host: \"keycloak.&lt;ROOT_DOMAIN&gt;\"\n#   # TLS configuration\n#   tls:\n#     enabled: true\n\nresources:\nlimits:\nmemory: \"2048Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"512Mi\"\n\n# Check database readiness at startup\ndbchecker:\nenabled: true\n\ndatabase:\nvendor: postgres\nexistingSecret: keycloak-postgresql\nhostname: keycloak-postgresql\nport: 5432\nusername: admin\ndatabase: keycloak\n</code></pre> </li> <li> <p>Deploy Keycloak:</p> <p>Note</p> <p>Change the namespace and the values file name if required.</p> <pre><code>helm install keycloak codecentric/keycloakx --version 1.6.0 --values keycloak-values.yaml -n security\n</code></pre> </li> <li> <p>Log in to Keycloak and check if everything has been imported correctly.</p> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-19.0/#clean-and-analyze-database_1","title":"Clean and Analyze Database","text":"<p>Optionally, run the vacuumdb application on the database, to analyze the contents of database tables and collect statistics for the Postgres query optimizer:</p> <p><pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" vacuumdb --analyze --verbose -d keycloak -U postgres\n</code></pre> For all databases, run the following command:</p> <pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" vacuumdb --analyze --verbose --all -U postgres\n</code></pre>"},{"location":"operator-guide/upgrade-keycloak-19.0/#postgres-database-migration-script","title":"Postgres Database Migration Script","text":"<p>Info</p> <p>Please read the Migrate Postgres Database From Postgres v.11.x to v.14.5 section of this tutorial before using the script.</p> <p>Note</p> <ul> <li>The <code>kubectl</code> tool is required for using this script.</li> <li>This script will likely work for any other Postgres database besides Keycloak after some adjustments. It queries the <code>pg_dump</code>, <code>pg_dumpall</code>, <code>psql</code>, and <code>vacuumdb</code> commands under the hood.</li> </ul> <p>The following script can be used for exporting and importing Postgres databases as well as optimizing them with the vacuumdb application. Please examine the code and make the adjustments if required.</p> <ul> <li> <p>By default, the following command exports Keycloak Postgres databases from a Kubernetes pod to a local machine:</p> <pre><code>./script.sh\n</code></pre> <p>After running the command, please follow the prompt.</p> </li> </ul> <ul> <li>To import a database backup to a newly created Postgres Kubernetes pod, pass a database dump sql file to the script:<pre><code>./script.sh path-to/db_dump.sql\n</code></pre> </li> </ul> <ul> <li>The <code>-h</code> flag prints help, and <code>-c|-v</code> runs the <code>vacuumdb</code> garbage collector and analyzer.</li> </ul> View: keycloak_db_migration.sh <pre><code>#!/bin/bash\n\n# set -x\n\ndb_migration_help(){\necho \"Keycloak Postgres database migration\"\necho\necho \"Usage:\"\necho \"------------------------------------------\"\necho \"Export Keycloak Postgres database from pod\"\necho \"Run without parameters:\"\necho \"      $0\"\necho \"------------------------------------------\"\necho \"Import Keycloak Postgres database to pod\"\necho \"Pass filename to script:\"\necho \"      $0 path/to/db_dump.sql\"\necho \"------------------------------------------\"\necho \"Additional options: \"\necho \"      $0 [OPTIONS...]\"\necho \"Options:\"\necho \"h     Print Help.\"\necho \"c|v   Run garbage collector and analyzer.\"\n}\n\nkeycloak_ns(){\nprintf '%s\\n' 'Enter keycloak namespace: '\nread -r keycloak_namespace\n\n    if [ -z \"${keycloak_namespace}\" ]; then\necho \"Don't skip namespace\"\nexit 1\nfi\n}\n\npostgres_pod(){\nprintf '%s\\n' 'Enter postgres pod name: '\nread -r postgres_pod_name\n\n    if [ -z \"${postgres_pod_name}\" ]; then\necho \"Don't skip pod name\"\nexit 1\nfi\n}\n\npostgres_user(){\nprintf '%s\\n' 'Enter postgres username: '\nprintf '%s' \"Skip to use [postgres] superuser: \"\nread -r postgres_username\n\n    if [ -z \"${postgres_username}\" ]; then\npostgres_username='postgres'\nfi\n}\n\npgdb_host_info(){\ndatabase_name='keycloak'\ndb_host='localhost'\ndb_port='5432'\n}\n\npostgresql_admin_pass(){\npostgresql_password='POSTGRES_PASSWORD'\npostgresql_admin_password=\"$(kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"printenv ${postgresql_password}\")\"\n}\n\npostgresql_su_pass(){\npostgresql_postgres_password='POSTGRES_POSTGRES_PASSWORD'\npostgresql_superuser_password=\"$(kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"printenv ${postgresql_postgres_password}\")\"\n\nif [ -z \"${postgresql_superuser_password}\" ]; then\necho \"SuperUser password variable does not exist. Using user password instead...\"\npostgresql_admin_pass\n        postgresql_superuser_password=\"${postgresql_admin_password}\"\nfi\n}\n\nkeycloak_pgdb_export(){\ncurrent_cluster=\"$(kubectl config current-context | tr -dc '[:alnum:]-')\"\nexported_db_name=\"keycloak_db_dump_${current_cluster}_${keycloak_namespace}_${postgres_username}_$(date +\"%Y%m%d%H%M\").sql\"\n\nif [ \"${postgres_username}\" == 'postgres' ]; then\n# call a function to get a pass for postgres user\npostgresql_su_pass\n        kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"PGPASSWORD='\"${postgresql_superuser_password}\"' pg_dumpall -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\"\" &gt; \"${exported_db_name}\"\nelse\n# call a function to get a pass for admin user\npostgresql_admin_pass\n        kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"PGPASSWORD='\"${postgresql_admin_password}\"' pg_dump -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\" &gt; \"${exported_db_name}\"\nfi\n\nseparate_lines=\"---------------\"\n\nif [ ! -s \"${exported_db_name}\" ]; then\nrm -f \"${exported_db_name}\"\necho \"${separate_lines}\"\necho \"Something went wrong. The database dump file is empty and was not saved.\"\nelse\necho \"${separate_lines}\"\ngrep 'Dumped' \"${exported_db_name}\" | sort -u\n        echo \"Database has been exported to $(pwd)/${exported_db_name}\"\nfi\n}\n\nkeycloak_pgdb_import(){\necho \"Preparing Import\"\necho \"----------------\"\n\nif [ ! -f \"$1\" ]; then\necho \"The file $1 does not exist.\"\nexit 1\nfi\n\nkeycloak_ns\n    postgres_pod\n    postgres_user\n    pgdb_host_info\n\n    if [ \"${postgres_username}\" == 'postgres' ]; then\n# restore full backup with all databases and roles as superuser or a single database\npostgresql_su_pass\n        if [ -n \"$(cat \"$1\" | grep 'CREATE ROLE')\" ]; then\ncat \"$1\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"cat | PGPASSWORD='\"${postgresql_superuser_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\"\"\nelse\ncat \"$1\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"cat | PGPASSWORD='\"${postgresql_superuser_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\nfi\nelse\n# restore a single database\npostgresql_admin_pass\n        cat \"$1\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"cat | PGPASSWORD='\"${postgresql_admin_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\nfi\n}\n\nvacuum_pgdb(){\necho \"Preparing garbage collector and analyzer\"\necho \"----------------------------------------\"\n\nkeycloak_ns\n    postgres_pod\n    postgres_user\n    pgdb_host_info\n\n    if [ \"${postgres_username}\" == 'postgres' ]; then\npostgresql_su_pass\n        kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"PGPASSWORD='\"${postgresql_superuser_password}\"' vacuumdb --analyze --all -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\"\"\nelse\npostgresql_admin_pass\n        kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"PGPASSWORD='\"${postgresql_admin_password}\"' vacuumdb --analyze -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\nfi\n}\n\nwhile [ \"$#\" -eq 1 ]; do\ncase \"$1\" in\n-h | --help)\ndb_migration_help\n            exit 0\n;;\n-c | --clean | -v | --vacuum)\nvacuum_pgdb\n            exit 0\n;;\n--)\nbreak\n;;\n-*)\necho \"Invalid option '$1'. Use -h|--help to see the valid options\" &gt;&amp;2\nexit 1\n;;\n*)\nkeycloak_pgdb_import \"$1\"\nexit 0\n;;\nesac\nshift\ndone\n\nif [ \"$#\" -gt 1 ]; then\necho \"Please pass a single file to the script\"\nexit 1\nfi\n\necho \"Preparing Export\"\necho \"----------------\"\nkeycloak_ns\npostgres_pod\npostgres_user\npgdb_host_info\nkeycloak_pgdb_export\n</code></pre>"},{"location":"operator-guide/upgrade-keycloak-19.0/#related-articles","title":"Related Articles","text":"<ul> <li>Deploy OKD 4.10 Cluster</li> </ul>"},{"location":"operator-guide/vcs/","title":"Overview","text":"<p>The Version Control Systems (VCS) section is dedicated to delivering comprehensive information on VCS within the EPAM Delivery Platform. This section comprises detailed descriptions of all the deployment strategies, along with valuable recommendations for their optimal usage, and the list of supported VCS, facilitating seamless integration with EDP.</p>"},{"location":"operator-guide/vcs/#supported-vcs","title":"Supported VCS","text":"<p>EDP can be integrated with the following Version Control Systems:</p> <ul> <li>Gerrit (used by default);</li> <li>GitHub;</li> <li>GitLab.</li> </ul> <p>Note</p> <p>So far, EDP doesn't support authorization mechanisms in the upstream GitLab.</p>"},{"location":"operator-guide/vcs/#vcs-deployment-strategies","title":"VCS Deployment Strategies","text":"<p>EDP offers the following strategies to work with repositories:</p> <ul> <li>Create from template \u2013 creates a project on the pattern in accordance with an application language, a build tool, and a framework selected while creating application. This strategy is recommended for projects that start developing their applications from scratch.</li> </ul> <p>Note</p> <p>Under the hood, all the built-in application frameworks, build tools and frameworks are stored in our public GitHub repository.</p> <ul> <li>Import project - enables working with the repository located in the added Git server. This scenario is preferred when the users already have an application stored in their own pre-configured repository and intends to continue working with their repository while also utilizing EDP simultaneously.</li> </ul> <p>Note</p> <p>In order to use the Import project strategy, make sure to adjust it with the Integrate GitHub/GitLab in Jenkins or Integrate GitHub/GitLab in Tekton page. The Import project strategy is not applicable for Gerrit. Also, it is impossible to choose the Empty project field when using the Import project strategy while creating appication since it is implied that you already have a ready-to-work application in your own repository, whereas the \"Empty project\" option creates a repository but doesn't put anything in it.</p> <ul> <li>Clone project \u2013 clones the indicated repository into EPAM Delivery Platform. In this scenario, the application repository is forked from the original application repository to EDP. Since EDP doesn't support multiple VCS integration for now, this strategy is recommended when the user has several applications located in several repositories.</li> </ul>"},{"location":"operator-guide/vcs/#related-articles","title":"Related Articles","text":"<ul> <li>Add Git Server</li> <li>Add Application</li> <li>Integrate GitHub/GitLab in Jenkins</li> <li>Integrate GitHub/GitLab in Tekton</li> </ul>"},{"location":"operator-guide/velero-irsa/","title":"IAM Roles for Velero Service Accounts","text":"<p>Note</p> <p>Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation.</p> <p>Velero AWS plugin requires access to AWS resources. Follow the steps below to create a required role:</p> <ol> <li> <p>Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero_policy\":</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": [\n\"ec2:DescribeVolumes\",\n\"ec2:DescribeSnapshots\",\n\"ec2:CreateTags\",\n\"ec2:CreateVolume\",\n\"ec2:CreateSnapshot\",\n\"ec2:DeleteSnapshot\"\n],\n\"Resource\": \"*\"\n},\n{\n\"Effect\": \"Allow\",\n\"Action\": [\n\"s3:GetObject\",\n\"s3:DeleteObject\",\n\"s3:PutObject\",\n\"s3:AbortMultipartUpload\",\n\"s3:ListMultipartUploadParts\"\n],\n\"Resource\": [\n\"arn:aws:s3:::velero-*/*\"\n]\n},\n{\n\"Effect\": \"Allow\",\n\"Action\": [\n\"s3:ListBucket\"\n],\n\"Resource\": [\n\"arn:aws:s3:::velero-*\"\n]\n}\n]\n}\n</code></pre> </li> <li> <p>Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" with trust relationships:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;OIDC_PROVIDER&gt;\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"&lt;OIDC_PROVIDER&gt;:sub\": \"system:serviceaccount:&lt;VELERO_NAMESPACE&gt;:edp-velero\"\n       }\n     }\n   }\n ]\n}\n</code></pre> </li> <li> <p>Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" role.</p> </li> <li> <p>Make sure that Amazon S3 bucket with name velero-\u2039CLUSTER_NAME\u203a exists.</p> </li> <li> <p>Provide key value eks.amazonaws.com/role-arn: \"arn:aws:iam:::role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" into the serviceAccount.server.annotations parameter in values.yaml during the Velero Installation."},{"location":"operator-guide/velero-irsa/#related-articles","title":"Related Articles","text":"<ul> <li>Associate IAM Roles With Service Accounts</li> <li>Install Velero</li> </ul>"},{"location":"operator-guide/waf-tf-configuration/","title":"Configure AWS WAF With Terraform","text":"<p>This page contains accurate information on how to configure AWS WAF using Terraform with the aim to have a secured traffic exposure and to prevent the Host Header vulnerabilities.</p>"},{"location":"operator-guide/waf-tf-configuration/#prerequisites","title":"Prerequisites","text":"<p>To follow the instruction, check the following prerequisites:</p> <ol> <li>Deployed infrastructure includes Nginx Ingress Controller</li> <li>Deployed services for testing</li> <li>Separate and exposed AWS ALB</li> <li>terraform 0.14.10</li> <li>hishicorp/aws = 4.8.0</li> </ol>"},{"location":"operator-guide/waf-tf-configuration/#solution-overview","title":"Solution Overview","text":"<p>The solution includes two parts:</p> <ol> <li>Prerequisites (mostly the left part of the scheme) - AWS ALB, Compute Resources (EC2, EKS, etc.).</li> <li>WAF configuration (the right part of the scheme).</li> </ol> <p>The WAF ACL resource is the main resource used for the configuration; The default web ACL option is Block.</p> <p> Overview WAF Solution </p> <p>The ACL includes three managed AWS rules that secure the exposed traffic:</p> <ul> <li>AWS-AWSManagedRulesCommonRuleSet</li> <li>AWS-AWSManagedRulesLinuxRuleSet</li> <li>AWS-AWSManagedRulesKnownBadInputsRuleSet</li> </ul> <p>AWS provides a lot of rules such as baseline and use-case specific rules, for details, please refer to the Baseline rule groups.</p> <p>There is the PreventHostInjections rule that prevents the Host Header vulnerabilities. This rule includes one statement that declares that the Host Header should match Regex Pattern Set, thus only in this case it will be passed.</p> <p>The Regex Pattern Set is another resource that helps to organize regexes, in fact, is a set of regexes. All regexes added to the single set are matched by the OR statement, i.e. when exposing several URLs, it is necessary to add this statement to the set and refer to it in the rule.</p>"},{"location":"operator-guide/waf-tf-configuration/#waf-acl-configuration","title":"WAF ACL Configuration","text":"<p>To create the Regex Pattern Set, inspect the following code:</p> <pre><code>resource \"aws_wafv2_regex_pattern_set\" \"common\" {\nname  = \"Common\"\nscope = \"REGIONAL\"\n\nregular_expression {\nregex_string = \"^.*(some-url).*((.edp-epam)+)\\\\.com$\"\n}\n\n  #  Add here additional regular expressions for other endpoints, they are merging with OR operator, e.g.\n\n  /*\n   regular_expression {\n      regex_string = \"^.*(jenkins).*((.edp-epam)+)\\\\.com$\"\n   }\n   */\n\ntags = var.tags\n}\n</code></pre> <p>It includes 'regex_string', for example: url - some-url.edp-epam.com, In addition, it is possible to add other links to the same resource using the regular_expression element.</p> <p>There is the Terraform code for the aws_wafv2_web_acl resource:</p> <pre><code>resource \"aws_wafv2_web_acl\" \"external\" {\nname  = \"ExternalACL\"\nscope = \"REGIONAL\"\n\ndefault_action {\nblock {}\n}\n\nrule {\nname     = \"AWS-AWSManagedRulesCommonRuleSet\"\npriority = 1\n\noverride_action {\nnone {}\n}\n\nstatement {\nmanaged_rule_group_statement {\nname        = \"AWSManagedRulesCommonRuleSet\"\nvendor_name = \"AWS\"\n}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"AWS-AWSManagedRulesCommonRuleSet\"\nsampled_requests_enabled   = true\n}\n}\n\nrule {\nname     = \"AWS-AWSManagedRulesLinuxRuleSet\"\npriority = 2\n\nstatement {\nmanaged_rule_group_statement {\nname        = \"AWSManagedRulesLinuxRuleSet\"\nvendor_name = \"AWS\"\n}\n}\n\noverride_action {\nnone {}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"AWS-AWSManagedRulesLinuxRuleSet\"\nsampled_requests_enabled   = true\n}\n}\n\nrule {\nname     = \"AWS-AWSManagedRulesKnownBadInputsRuleSet\"\npriority = 3\n\noverride_action {\nnone {}\n}\n\nstatement {\nmanaged_rule_group_statement {\nname        = \"AWSManagedRulesKnownBadInputsRuleSet\"\nvendor_name = \"AWS\"\n}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"AWS-AWSManagedRulesKnownBadInputsRuleSet\"\nsampled_requests_enabled   = true\n}\n}\n\nrule {\nname     = \"PreventHostInjections\"\npriority = 0\n\nstatement {\nregex_pattern_set_reference_statement {\narn = aws_wafv2_regex_pattern_set.common.arn\n\nfield_to_match {\nsingle_header {\nname = \"host\"\n}\n}\n\ntext_transformation {\npriority = 0\ntype     = \"NONE\"\n}\n}\n}\n\naction {\nallow {}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"PreventHostInjections\"\nsampled_requests_enabled   = true\n}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"ExternalACL\"\nsampled_requests_enabled   = true\n}\n\ntags = var.tags\n}\n</code></pre> <p>As mentioned previously, ACL includes three managed AWS rules (group rules), for visibility, enabling sampling, and CloudWatch in the config. The 'PreventHostInjections' custom rule refers to the created pattern set and declares the Host Header, as well as sets the 'Action' if matched to 'Allow'.</p>"},{"location":"operator-guide/waf-tf-configuration/#associate-aws-resource","title":"Associate AWS Resource","text":"<p>To have the created ACL working, it is necessary to associate an AWS resource with it, in this case, it is AWS ALB:</p> <pre><code>resource \"aws_wafv2_web_acl_association\" \"waf_alb\" {\nresource_arn = aws_lb.&lt;aws_alb_for_waf&gt;.arn\nweb_acl_arn  = aws_wafv2_web_acl.external.arn\n}\n</code></pre> <p>Note</p> <p>AWS ALB can be created in the scope of this Terraform code or created previously. When creating ALB to expose links, the ALB should have a security group that allows some external traffic.</p> <p>When ALB is associated with the WAF ACL, direct the traffic to the ALB by the Route53 CNAME record:</p> <pre><code>module \"some_url_exposure\" {\nsource  = \"terraform-aws-modules/route53/aws//modules/records\"\nversion = \"2.0.0\"\n\nzone_name = \"edp-epam.com\"\n\nrecords = [\n{\nname    = \"some-url\"\ntype    = \"CNAME\"\nttl     = 300\nrecords = [aws_lb.&lt;aws_alb_for_waf&gt;.dns_name]\n}\n]\n}\n</code></pre> <p>In the sample above, the module is used, but it is also possible to use a Terraform resource.</p>"},{"location":"use-cases/","title":"Overview","text":"<p>The Use Cases section provides useful recommendations of how to operate with the EPAM Delivery Platform tools and manage the custom resources. Get acquainted with the description of technical scenarios and solutions.</p> <ul> <li>Scaffold and Deploy FastAPI Application</li> <li>Deploy Application With Custom Build Tool/Framework</li> <li>Secured Secrets Management for Application Deployment</li> <li>Autotest as a Quality Gate</li> </ul>"},{"location":"use-cases/application-scaffolding/","title":"Scaffold and Deploy FastAPI Application","text":""},{"location":"use-cases/application-scaffolding/#overview","title":"Overview","text":"<p>This use case describes the creation and deployment of a FastAPI application to enable a developer to quickly generate a functional code structure for a FastAPI web application (with basic read functionality), customize it to meet specific requirements, and deploy it to a development environment. By using a scaffolding tool and a standardized process for code review, testing and deployment, developers can reduce the time and effort required to build and deploy a new application while improving the quality and reliability of the resulting code. Ultimately, the goal is to enable the development team to release new features and applications more quickly and efficiently while maintaining high code quality and reliability.</p> <p></p>"},{"location":"use-cases/application-scaffolding/#roles","title":"Roles","text":"<p>This documentation is tailored for the Developers and Team Leads.</p>"},{"location":"use-cases/application-scaffolding/#goals","title":"Goals","text":"<ul> <li>Create a new FastAPI application quickly.</li> <li>Deploy the initial code to the DEV environment.</li> <li>Check CI pipelines.</li> <li>Perform code review.</li> <li>Delivery update by deploying the new version.</li> </ul>"},{"location":"use-cases/application-scaffolding/#preconditions","title":"Preconditions","text":"<ul> <li>EDP instance is configured with Gerrit, Tekton and Argo CD.</li> <li>Developer has access to the EDP instances using the Single-Sign-On approach.</li> <li>Developer has the <code>Administrator</code> role (to perform merge in Gerrit).</li> </ul>"},{"location":"use-cases/application-scaffolding/#scenario","title":"Scenario","text":"<p>To scaffold and deploy FastAPI Application, follow the steps below.</p>"},{"location":"use-cases/application-scaffolding/#scaffold-the-new-fastapi-application","title":"Scaffold the New FastAPI Application","text":"<ol> <li> <p>Open Headlamp URL. Use the Sign-In option.</p> <p> Logging screen </p> </li> <li> <p>Ensure <code>Namespace</code> value in the User <code>Settings</code> tab points to the namespace with the EDP installation.</p> <p> Settings button </p> </li> <li> <p>Create the new <code>Codebase</code> with the <code>Application</code> type using the <code>Create</code> strategy. To do this, open EDP tab.</p> <p> Cluster overview </p> </li> <li> <p>Select the <code>Components</code> Section under the EDP tab and push the create <code>+</code> button.</p> <p> Components tab </p> </li> <li> <p>Select the <code>Application</code> Codebase type because we are going to deliver our application as a container and deploy it inside the Kubernetes cluster. Choose the <code>Create</code> strategy to scaffold our application from the template provided by the EDP and press the <code>Proceed</code> button.</p> <p> Step codebase info </p> </li> <li> <p>On the Application Info tab, define the following values and press the <code>Proceed</code> button:</p> <ul> <li>Application name: <code>fastapi-demo</code></li> <li>Default branch: <code>main</code></li> <li>Application code language: <code>Python</code></li> <li>Language version/framework: <code>FastAPI</code></li> <li>Build tool: <code>Python</code></li> </ul> <p> Application info </p> </li> <li> <p>On the <code>Advances Settings</code> tab, define the below values and push the <code>Apply</code> button:</p> <ul> <li>CI tool: <code>Tekton</code></li> <li>Codebase versioning type: <code>edp</code></li> <li>Start version from: <code>0.0.1</code> and <code>SNAPSHOT</code></li> </ul> <p> Advanced settings </p> </li> <li> <p>Check the application status. It should be green:</p> <p> Application status </p> </li> </ol>"},{"location":"use-cases/application-scaffolding/#deploy-the-application-to-the-development-environment","title":"Deploy the Application to the Development Environment","text":"<p>This section describes the application deployment approach from the latest branch commit. The general steps are:</p> <ul> <li>Build the initial version (generated from the template) of the application from the last commit of the <code>main</code> branch.</li> </ul> <ul> <li>Create a <code>CD Pipeline</code> to establish continuous delivery to the development environment. </li> </ul> <ul> <li>Deploy the initial version to the development env.</li> </ul> <p>To succeed with the steps above, follow the instructions below:</p> <ol> <li> <p>Build Container from the latest branch commit. To build the initial version of the application's main branch, go to the fastapi-demo application -&gt; branches -&gt; main and select the <code>Build</code> menu.</p> <p> Application building </p> </li> <li> <p>Build pipeline for the <code>fastapi-demo</code> application starts.</p> <p> Pipeline building </p> </li> <li> <p>Track Pipeline's status by accessing Tekton Dashboard by clicking the <code>fastapi-demo-main-build-lb57m</code> application link.</p> <p> Console logs </p> </li> <li> <p>Ensure that Build Pipeline was successfully completed.</p> </li> <li> <p>Create CD Pipeline. To enable application deployment create a CD Pipeline with a single environment - Development (with the name <code>dev</code>).</p> </li> <li> <p>Go to Headlamp -&gt; EDP -&gt; CD Pipelines tab and push the <code>+</code> button to create pipeline. In the <code>Create CD Pipeline</code> dialog, define the below values:</p> <ul> <li> <p>Pipeline tab:</p> <ul> <li>Pipeline name: <code>mypipe</code></li> <li>Deployment type: <code>Container</code>, since we are going to deploy containers</li> </ul> <p> Pipeline tab with parameters </p> </li> </ul> <ul> <li> <p>Applications tab. Add <code>fastapi-demo</code> application, select <code>main</code> branch, and leave <code>Promote in pipeline</code> unchecked:</p> <p> Applications tab with parameters </p> </li> </ul> <ul> <li> <p>Stages tab. Add the <code>dev</code> stage with the values below:</p> <ul> <li>Stage name: <code>dev</code></li> <li>Description: <code>Development Environment</code></li> <li>Trigger type: <code>Manual</code>. We plan to deploy applications to this environment manually</li> <li>Quality gate type: <code>Manual</code></li> <li>Step name: <code>approve</code></li> <li>Push the <code>Apply</code> button</li> </ul> <p> Stages tab with parameters </p> </li> </ul> </li> <li> <p>Deploy the initial version of the application to the development environment:</p> <ul> <li>Open CD Pipeline with the name <code>mypipe</code>.</li> <li>Select the <code>dev</code> stage from the Stages tab.</li> <li>In the <code>Image stream version</code> select version <code>0.0.1-SNAPSHOT.1</code> and push the <code>Deploy</code> button.</li> </ul> <p> CD Pipeline deploy </p> </li> </ol>"},{"location":"use-cases/application-scaffolding/#check-the-application-status","title":"Check the Application Status","text":"<p>To ensure the application is deployed successfully, follow the steps below:</p> <ol> <li> <p>Ensure application status is <code>Healthy</code> and <code>Synced</code>, and the <code>Deployed version</code> points to <code>0.0.1-SNAPSHOT.1</code>:</p> <p> Pipeline health status </p> </li> <li> <p>Check that the selected version of the container is deployed on the <code>dev</code> environment. <code>${EDP_ENV}</code> - is the EDP namespace name:</p> <pre><code># Check the deployment status of fastapi-demo application\n$ kubectl get deployments -n ${EDP_ENV}-mypipe-dev\nNAME                 READY   UP-TO-DATE   AVAILABLE   AGE\nfastapi-demo-dl1ft   1/1     1            1           30m\n\n# Check the image version of fastapi-demo application\n$ kubectl get pods -o jsonpath=\"{.items[*].spec.containers[*].image}\" -n ${EDP_ENV}-mypipe-dev\n012345678901.dkr.ecr.eu-central-1.amazonaws.com/${EDP_ENV}/fastapi-demo:0.0.1-SNAPSHOT.1\n</code></pre> </li> </ol>"},{"location":"use-cases/application-scaffolding/#deliver-new-code","title":"Deliver New Code","text":"<p>This section describes the <code>Code Review</code> process for a new code. We need to deploy a new version of our <code>fastapi-demo</code> application that deploys <code>Ingress</code> object to expose API outside the Kubernetes cluster.</p> <p>Perform the below steps to merge new code (Pull Request) that passes the Code Review flow. For the steps below, we use Gerrit UI but the same actions can be performed using the command line and git tool:</p> <ol> <li> <p>Login to Gerrit UI, select <code>fastapi-demo</code> project, and create a change request.</p> </li> <li> <p>Browse Gerrit Repositories and select <code>fastapi-demo</code> project.</p> <p> Browse Gerrit repositories </p> </li> <li> <p>In the <code>Commands</code> section of the project, push the <code>Create Change</code> button.</p> <p> Create Change request </p> </li> <li> <p>In the <code>Create Change</code> dialog, provide the branch <code>main</code> and the <code>Description</code> (commit message):</p> <pre><code>Enable ingress for application\n\nCloses: #xyz\n</code></pre> </li> <li> <p>Push the <code>Create</code> button.</p> <p> Create Change </p> </li> <li> <p>Push the <code>Edit</code> button of the merge request and add <code>deployment-templates/values.yaml</code> for modification.</p> <p> Update values.yaml file </p> </li> <li> <p>Review the <code>deployment-templates/values.yaml</code> file and change the <code>ingress.enabled</code> flag from <code>false</code> to <code>true</code>. Then push the <code>SAVE &amp; PUBLISH</code> button. As soon as you get <code>Verified +1</code> from CI, you are ready for review: Push the <code>Mark as Active</code> button.</p> <p> Review Change </p> </li> <li> <p>You can always check your pipelines status from:</p> <ul> <li>Gerrit UI.</li> </ul> <p> Pipeline Status Gerrit </p> <ul> <li>Headlamp.</li> </ul> <p> Pipeline Status Headlamp </p> </li> <li> <p>With no Code Review Pipeline issues, set <code>Code-Review +2</code> for the patchset and push the <code>Submit</code> button. Then, your code is merged to the <code>main</code> branch, triggering the Build Pipeline. The build Pipeline produces the new version of artifact: <code>0.0.1-SNAPSHOT.2</code>, which is available for the deployment.</p> <p> Gerrit Code Review screen </p> </li> <li> <p>Deliver the New Version to the Environment. Before the new version deployment, check the ingress object in <code>dev</code> namespace:</p> <pre><code>$ kubectl get ingress -n ${EDP_ENV}-mypipe-dev\nNo resources found in ${EDP_ENV}-mypipe-dev namespace.\n</code></pre> <p>No ingress object exists as expected.</p> </li> <li> <p>Deploy the new version <code>0.0.1-SNAPSHOT.2</code> which has the ingress object in place. Since we use <code>Manual</code> deployment approach, we perform version upgrade by hand.</p> <ul> <li>Go to the <code>CD Pipelines</code> section of the <code>Headlamp</code>, select <code>mypipe</code> pipeline and choose <code>dev</code> stage.</li> <li>In the <code>Image stream version</code> select the new version <code>0.0.1-SNAPSHOT.2</code> and push the <code>Update</code> button.</li> <li>Check that the new version is deployed: application status is <code>Healthy</code> and <code>Synced</code>, and the <code>Deployed version</code> points to <code>0.0.1-SNAPSHOT.2</code>.</li> </ul> <p> CD Pipeline Deploy New Version </p> </li> <li> <p>Check that the new version with Ingress is deployed:</p> <pre><code># Check the version of the deployed image\nkubectl get pods -o jsonpath=\"{.items[*].spec.containers[*].image}\" -n ${EDP_ENV}-mypipe-dev\n012345678901.dkr.ecr.eu-central-1.amazonaws.com/edp-delivery-tekton-dev/fastapi-demo:0.0.1-SNAPSHOT.2\n\n# Check Ingress object\nkubectl get ingress -n ${EDP_ENV}-mypipe-dev\nNAME                 CLASS    HOSTS                            ADDRESS          PORTS   AGE\nfastapi-demo-ko1zs   &lt;none&gt;   fastapi-demo-ko1zs-example.com   12.123.123.123   80      115s\n\n# Check application external URL\ncurl https://your-hostname-appeared-in-hosts-column-above.example.com/\n{\"Hello\":\"World\"}\n</code></pre> </li> </ol>"},{"location":"use-cases/application-scaffolding/#related-articles","title":"Related Articles","text":"<ul> <li>Use Cases</li> </ul>"},{"location":"use-cases/autotest-as-quality-gate/","title":"Autotest as a Quality Gate","text":"<p>This use case describes the flow of adding an autotest as a quality gate to a newly created CD pipeline with a selected build version of an application to be promoted. The purpose of autotests is to check if application meets predefined criteria for stability and functionality, ensuring that only reliable versions are promoted. The promotion feature allows users to implement complicated testing, thus improving application stability.</p>"},{"location":"use-cases/autotest-as-quality-gate/#roles","title":"Roles","text":"<p>This documentation is tailored for the Developers and Quality Assurance specialists.</p>"},{"location":"use-cases/autotest-as-quality-gate/#goals","title":"Goals","text":"<ul> <li>Create several applications and autotests quickly.</li> <li>Create a pipeline for Continuous Deployment.</li> <li>Perform testing.</li> <li>Update delivery by deploying the new version.</li> </ul>"},{"location":"use-cases/autotest-as-quality-gate/#preconditions","title":"Preconditions","text":"<ul> <li>EDP instance is configured with Gerrit, Tekton and Argo CD.</li> <li>Developer has access to the EDP instances using the Single-Sign-On approach.</li> <li>Developer has the Administrator role (to perform merge in Gerrit).</li> </ul>"},{"location":"use-cases/autotest-as-quality-gate/#create-applications","title":"Create Applications","text":"<p>To implement autotests as Quality Gates, follow the steps below:</p> <ol> <li> <p>Ensure the namespace is specified in the cluster settings. Click the Settings icon in the top right corner and select Cluster settings:</p> <p> Cluster settings </p> </li> <li> <p>Enter the name of the default namespace, then enter your default namespace in the Allowed namespaces field and click the + button. You can also add other namespaces to the Allowed namespaces:</p> <p> Specify namespace </p> </li> <li> <p>Create several applications using the Create strategy. Navigate to the EDP tab, choose Components, click the + button:</p> <p> Add component </p> </li> <li> <p>Select Application and Create from template:</p> <p> Create new component menu </p> <p>Note</p> <p>Please refer to the Add Application section for details.</p> </li> <li> <p>On the Codebase info tab, define the following values and press the Proceed button:</p> <ul> <li>Git server: <code>gerrit</code></li> <li>Git repo relative path: <code>js-application</code></li> <li>Component name: <code>js-application</code></li> <li>Description: <code>js application</code></li> <li>Application code language: <code>JavaScript</code></li> <li>Language version/Provider: <code>Vue</code></li> <li>Build tool: <code>NPM</code></li> </ul> <p> Codebase info tab </p> </li> <li> <p>On the Advanced settings tab, define the below values and push the Apply button:</p> <ul> <li>Default branch: <code>main</code></li> <li>Codebase versioning type: <code>default</code></li> </ul> <p> Advanced settings tab </p> </li> <li> <p>Repeat the procedure twice to create the go-application and python-application applications. These applications will have the following parameters:</p> <p>go-application:</p> <ul> <li>Git server: <code>gerrit</code></li> <li>Git repo relative path: <code>go-application</code></li> <li>Component name: <code>go-application</code></li> <li>Description: <code>go application</code></li> <li>Application code language: <code>Go</code></li> <li>Language version/Provider: <code>Gin</code></li> <li>Build tool: <code>Go</code></li> <li>Default branch: <code>main</code></li> <li>Codebase versioning type: <code>default</code></li> </ul> <p>python-application:</p> <ul> <li>Git server: <code>gerrit</code></li> <li>Git repo relative path: <code>python-application</code></li> <li>Component name: <code>python-application</code></li> <li>Description: <code>python application</code></li> <li>Application code language: <code>Python</code></li> <li>Language version/Provider: <code>FastAPI</code></li> <li>Build tool: <code>Python</code></li> <li>Default branch: <code>main</code></li> <li>Codebase versioning type: <code>default</code></li> </ul> </li> <li> <p>In the Components tab, click one of the applications name to enter the application menu:</p> <p> Components list </p> </li> <li> <p>Click the three dots (\u22ee) button, select Build:</p> <p> Application menu </p> </li> <li> <p>Click the down arrow (v) to observe and wait for the application to be built:</p> <p> Application building </p> </li> <li> <p>Click the application run name to watch the building logs in Tekton:</p> <p> Tekton pipeline run </p> </li> <li> <p>Wait till the build is successful:</p> <p> Successful build </p> </li> <li> <p>Repeat steps 8-12 for the rest of the applications.</p> </li> </ol>"},{"location":"use-cases/autotest-as-quality-gate/#create-autotests","title":"Create Autotests","text":"<p>The steps below instruct how to create autotests in EDP:</p> <ol> <li> <p>Create a couple of autotests using the Create strategy. Navigate to the EDP tab, choose Components, click on the + button. Select Autotest and Clone project:</p> <p> Add autotest </p> <p>Note</p> <p>Please refer to the Add Autotest section for details.</p> </li> <li> <p>On the Codebase info tab, define the following values and press the Proceed button:</p> <ul> <li>Repository URL: <code>https://github.com/SergK/autotests.git</code></li> <li>Git server: <code>gerrit</code></li> <li>Git repo relative path: <code>demo-autotest-gradle</code></li> <li>Component name: <code>demo-autotest-gradle</code></li> <li>Description: <code>demo-autotest-gradle</code></li> <li>Autotest code language: <code>Java</code></li> <li>Language version/framework: <code>Java11</code></li> <li>Build tool: <code>Gradle</code></li> <li>Autotest report framework: <code>Allure</code></li> </ul> <p> Codebase info tab for autotests </p> </li> <li> <p>On the Advanced settings tab, leave the settings as is and click the Apply button:</p> <p> Advanced settings tab for autotests </p> </li> <li> <p>Repeat the steps 1-3 to create one more autotest with the parameters below:</p> <ul> <li>Repository URL: <code>https://github.com/Rolika4/autotests.git</code></li> <li>Git server: <code>gerrit</code></li> <li>Git repo relative path: <code>demo-autotest-maven</code></li> <li>Component name: <code>demo-autotest-maven</code></li> <li>Description: <code>demo-autotest-maven</code></li> <li>Autotest code language: <code>Java</code></li> <li>Language version/framework: <code>Java11</code></li> <li>Build tool: <code>Maven</code></li> <li>Autotest report framework: <code>Allure</code></li> </ul> </li> </ol>"},{"location":"use-cases/autotest-as-quality-gate/#create-cd-pipeline","title":"Create CD Pipeline","text":"<p>Now that applications and autotests are created, create pipeline for them by following the steps below:</p> <ol> <li> <p>Navigate to the CD Pipelines tab and click the + button:</p> <p> CD pipelines tab </p> </li> <li> <p>On the Pipeline tab, in the Pipeline name field, enter demo-pipeline:</p> <p> Pipeline tab </p> </li> <li> <p>On the Applications tab, add all the three applications, specify the main branch for all for them and check Promote in pipeline for Go and JavaScript applications:</p> <p> Applications tab </p> </li> <li> <p>On the Stages tab, click the Add stage button to open the Create stage menu:</p> <p> Stages tab </p> </li> <li> <p>In the Create stage menu, specify the following parameters and click Apply:</p> <ul> <li>Cluster: <code>In cluster</code></li> <li>Stage name: <code>dev</code></li> <li>Description: <code>dev</code></li> <li>Trigger type: <code>manual</code></li> <li>Quality gate type: <code>Autotests</code></li> <li>Step name: <code>dev</code></li> <li>Autotest: <code>demo-autotest-gradle</code></li> <li>Autotest branch: <code>main</code></li> </ul> <p> Create stage menu </p> </li> <li> <p>After the dev stage is added, click Apply:</p> <p> Create stage menu </p> </li> <li> <p>After the pipeline is created, click its name to open the pipeline details page:</p> <p> Enter pipeline </p> </li> <li> <p>In the pipeline details page, click the Create button to create a new stage:</p> <p> Create a new stage </p> </li> <li> <p>In the Create stage menu, specify the following parameters:</p> <ul> <li>Cluster: <code>In cluster</code></li> <li>Stage name: <code>sit</code></li> <li>Description: <code>sit</code></li> <li>Trigger type: <code>manual</code></li> <li>Quality gate type: <code>Autotests</code></li> <li>Step name: <code>dev</code></li> <li>Autotest: <code>demo-autotest-maven</code></li> <li>Autotest branch: <code>main</code></li> </ul> </li> </ol>"},{"location":"use-cases/autotest-as-quality-gate/#run-autotests","title":"Run Autotests","text":"<p>After the CD pipeline is created, deploy applications and run autotests by following the steps below:</p> <ol> <li> <p>Click the dev stage name to expand its details, specify image versions for each of the applications in the Image stream version field and click Deploy:</p> <p> Deploy applications </p> </li> <li> <p>Once applications are built, scroll down to Quality Gates and click Promote:</p> <p> Promote in pipeline </p> </li> <li> <p>Once promotion procedure is finished, the promoted applications will become available in the Sit stage. You will be able to select image stream versions for the promoted applications. The non-promoted application will stay grey in the stage and won't be allowed to get deployed:</p> <p> Sit stage </p> </li> </ol>"},{"location":"use-cases/autotest-as-quality-gate/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add CD Pipeline</li> <li>Add Quality Gate</li> </ul>"},{"location":"use-cases/external-secrets/","title":"Secured Secrets Management for Application Deployment","text":"<p>This Use Case demonstrates how to securely manage sensitive data, such as passwords, API keys, and other credentials, that are consumed by application during development or runtime in production. The approach involves storing sensitive data in an external secret store that is located in a \"vault\" namespace (but can be Vault, AWS Secret Store or any other provider). The process implies transmitting confidential information from the vault namespace to the deployed namespace for the purpose of establishing a connection to a database.</p>"},{"location":"use-cases/external-secrets/#roles","title":"Roles","text":"<p>This documentation is tailored for the Developers and Team Leads.</p>"},{"location":"use-cases/external-secrets/#goals","title":"Goals","text":"<ul> <li>Make confidential information usage secure in the deployment environment.</li> </ul>"},{"location":"use-cases/external-secrets/#preconditions","title":"Preconditions","text":"<ul> <li>EDP instance is configured with Gerrit, Tekton and Argo CD;</li> <li>External Secrets is installed;</li> <li>Developer has access to the EDP instances using the Single-Sign-On approach;</li> <li>Developer has the <code>Administrator</code> role (to perform merge in Gerrit);</li> <li>Developer has access to manage secrets in demo-vault namespace.</li> </ul>"},{"location":"use-cases/external-secrets/#scenario","title":"Scenario","text":"<p>To use External Secret in EDP approach, follow the steps below:</p>"},{"location":"use-cases/external-secrets/#add-application","title":"Add Application","text":"<p>To begin, you will need an application first. Here are the steps to create it:</p> <ol> <li> <p>Open Headlamp URL. Use the <code>Sign-In</code> option:</p> <p> Logging screen </p> </li> <li> <p>In the top right corner, enter the <code>Cluster settings</code> and ensure that both <code>Default namespace</code> and <code>Allowed namespace</code> are set:</p> <p> Cluster settings </p> </li> <li> <p>Create the new <code>Codebase</code> with the <code>Application</code> type using the <code>Create</code> strategy. To do this, click the <code>EDP</code> tab:</p> <p> Cluster overview </p> </li> <li> <p>Select the <code>Components</code> section under the EDP tab and push the <code>+</code> button:</p> <p> Components tab </p> </li> <li> <p>Select the <code>Application</code> Codebase type because we are going to deliver our application as a container and deploy it inside the Kubernetes cluster. Select the <code>Create</code> strategy to use predefined template:</p> <p> Step codebase info </p> </li> <li> <p>On the <code>Application Info</code> tab, define the following values and press the <code>Proceed</code> button:</p> <ul> <li>Application name: <code>es-usage</code></li> <li>Default branch: <code>master</code></li> <li>Application code language: <code>Java</code></li> <li>Language version/framework: <code>Java 17</code></li> <li>Build tool: <code>Maven</code></li> </ul> <p> Step application info </p> </li> <li> <p>On the <code>Advanced Settings</code> tab, define the below values and push the <code>Apply</code> button:</p> <ul> <li>CI tool: <code>Tekton</code></li> <li>Codebase versioning type: <code>default</code></li> </ul> <p> Step application info </p> </li> <li> <p>Check the application status. It should be green:</p> <p> Application status </p> </li> </ol>"},{"location":"use-cases/external-secrets/#create-cd-pipeline","title":"Create CD Pipeline","text":"<p>This section outlines the process of establishing a CD pipeline within Headlamp. There are two fundamental steps in this procedure:</p> <ul> <li>Build the application from the last commit of the <code>master</code> branch;</li> </ul> <ul> <li>Create a <code>CD Pipeline</code> to establish continuous delivery to the SIT environment.</li> </ul> <p>To succeed with the steps above, follow the instructions below:</p> <ol> <li> <p>Create CD Pipeline. To enable application deployment, create a CD Pipeline with a single environment - System Integration Testing (SIT for short). Select the <code>CD Pipelines</code> section under the <code>EDP</code> tab and push the <code>+</code> button:</p> <p> CD-Pipeline tab </p> </li> <li> <p>On the <code>Pipeline</code> tab, define the following values and press the <code>Proceed</code> button:</p> <ul> <li>Pipeline name: <code>deploy</code></li> <li>Deployment type: <code>Container</code></li> </ul> <p> Pipeline tab </p> </li> <li> <p>On the <code>Applications</code> tab, add <code>es-usage</code> application, select <code>master</code> branch, leave <code>Promote in pipeline</code> unchecked and press the <code>Proceed</code> button:</p> <p> Pipeline tab </p> </li> <li> <p>On the <code>Stage</code> tab, add the <code>sit</code> stage with the values below and push the <code>Apply</code> button:</p> <ul> <li>Stage name: <code>sit</code></li> <li>Description: <code>System integration testing</code></li> <li>Trigger type: <code>Manual</code>. We plan to deploy applications to this environment manually</li> <li>Quality gate type: <code>Manual</code></li> <li> <p>Step name: <code>approve</code></p> <p> Stage tab </p> </li> </ul> </li> </ol>"},{"location":"use-cases/external-secrets/#configure-rbac-for-external-secret-store","title":"Configure RBAC for External Secret Store","text":"<p>Note</p> <p>In this scenario, three namespaces are used: <code>demo</code>, which is the namespace where EDP is deployed, <code>demo-vault</code>, which is the vault where developers store secrets, and<code>demo-deploy-sit</code>, which is the namespace used for deploying the application. The target namespace name for deploying application is formed with the pattern: <code>&lt;edp-project&gt;-&lt;cd_pipeline_name&gt;-&lt;stage_name&gt;</code>.</p> <p>To make the system to function properly, it is imperative to create the following resources:</p> <ol> <li> <p>Create namespace <code>demo-vault</code> to store secrets:</p> <pre><code> kubectl create namespace demo-vault\n</code></pre> </li> <li> <p>Create Secret:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: mongo\nnamespace: demo-vault\nstringData:\npassword: pass\nusername: user\ntype: Opaque\n</code></pre> </li> <li> <p>Create Role to access the secret:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nnamespace: demo-vault\nname: external-secret-store\nrules:\n- apiGroups: [\"\"]\nresources:\n- secrets\nverbs:\n- get\n- list\n- watch\n- apiGroups:\n- authorization.k8s.io\nresources:\n- selfsubjectrulesreviews\nverbs:\n- create\n</code></pre> </li> <li> <p>Create RoleBinding:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: eso-from-edp\nnamespace: demo-vault\nsubjects:\n- kind: ServiceAccount\nname: secret-manager\nnamespace: demo-deploy-sit\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: Role\nname: external-secret-store\n</code></pre> </li> </ol>"},{"location":"use-cases/external-secrets/#add-external-secret-to-helm-chart","title":"Add External Secret to Helm Chart","text":"<p>Now that RBAC is configured properly, it is time to add external secrets templates to application Helm chart. Follow the instructions provided below:</p> <ol> <li> <p>Navigate to <code>Headlamp</code> -&gt; <code>EDP</code> -&gt; <code>Overview</code>, and push the Gerrit link:</p> <p> Overview page </p> </li> <li> <p>Log in to Gerrit UI, select <code>Repositories</code> and select <code>es-usage</code> project:</p> <p> Browse Gerrit repositories </p> </li> <li> <p>In the <code>Commands</code> section of the project, push the <code>Create Change</code> button:</p> <p> Create Change request </p> </li> <li> <p>In the <code>Create Change</code> dialog, provide the branch <code>master</code> and fill in the <code>Description</code> (commit message) field and push the <code>Create</code> button:</p> <pre><code>Add external secrets templates\n</code></pre> <p> Create Change </p> </li> <li> <p>Push the <code>Edit</code> button of the merge request and then the <code>ADD/OPEN/UPLOAD</code> button and add files:</p> <p> Add files to repository </p> <p>Once the file menu is opened, and click <code>SAVE</code> after editing each of the files:</p> <ol> <li> <p>deploy-templates/templates/sa.yaml:</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: secret-manager\nnamespace: demo-deploy-sit\n</code></pre> </li> <li> <p>deploy-templates/templates/secret-store.yaml:</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\nname: demo\nnamespace: demo-deploy-sit\nspec:\nprovider:\nkubernetes:\nremoteNamespace: demo-vault\nauth:\nserviceAccount:\nname: secret-manager\nserver:\ncaProvider:\ntype: ConfigMap\nname: kube-root-ca.crt\nkey: ca.crt\n</code></pre> </li> <li> <p>deploy-templates/templates/external-secret.yaml:</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\nname: mongo                            # target secret name\nnamespace: demo-deploy-sit    # target namespace\nspec:\nrefreshInterval: 1h\nsecretStoreRef:\nkind: SecretStore\nname: demo\ndata:\n- secretKey: username                   # target value property\nremoteRef:\nkey: mongo                          # remote secret key\nproperty: username                  # value will be fetched from this field\n- secretKey: password                   # target value property\nremoteRef:\nkey: mongo                          # remote secret key\nproperty: password                  # value will be fetched from this field\n</code></pre> </li> <li> <p>deploy-templates/templates/deployment.yaml. Add the environment variable for mongodb to the existing deployment configuration that used the secret:</p> <pre><code>          env:\n- name: MONGO_USERNAME\nvalueFrom:\nsecretKeyRef:\nname: mongo\nkey: username\n- name: MONGO_PASSWORD\nvalueFrom:\nsecretKeyRef:\nname: mongo\nkey: password\n</code></pre> </li> </ol> </li> <li> <p>Push the <code>Publish Edit</code> button.</p> </li> <li> <p>As soon as review pipeline finished, and you get <code>Verified +1</code> from CI, you are ready for review. Click <code>Mark as Active</code> -&gt; <code>Code-Review +2</code> -&gt; <code>Submit</code>:</p> <p> Apply change </p> </li> </ol>"},{"location":"use-cases/external-secrets/#deploy-application","title":"Deploy Application","text":"<p>Deploy the application by following the steps provided below:</p> <ol> <li> <p>When build pipeline is finished, navigate to <code>Headlamp</code> -&gt; <code>EDP</code> -&gt; <code>CD-Pipeline</code> and select <code>deploy</code> pipeline.</p> </li> <li> <p>Deploy the initial version of the application to the SIT environment:</p> <ul> <li>Select the <code>sit</code> stage from the Stages tab;</li> <li>In the <code>Image stream version</code>, select latest version and push the <code>Deploy</code> button.</li> </ul> </li> <li> <p>Ensure application status is <code>Healthy</code> and <code>Synced</code>:</p> <p> CD-Pipeline status </p> </li> </ol>"},{"location":"use-cases/external-secrets/#check-application-status","title":"Check Application Status","text":"<p>To ensure the application is deployed successfully, do the following:</p> <ol> <li> <p>Check that the resources are deployed:</p> <pre><code>kubectl get secretstore -n demo-deploy-sit\nNAME                           AGE     STATUS   READY\ndemo                           5m57s   Valid    True\n</code></pre> <pre><code>kubectl get externalsecret -n demo-deploy-sit\nNAME    STORE                          REFRESH INTERVAL   STATUS         READY\nmongo   demo                           1h                 SecretSynced   True\n</code></pre> </li> <li> <p>In the top right corner, enter the <code>Cluster settings</code> and add <code>demo-deploy-sit</code> to the <code>Allowed namespace</code>.</p> </li> <li> <p>Navigate <code>Headlamp</code> -&gt; <code>Configuration</code> -&gt; <code>Secrets</code> and ensure that secret was created:</p> <p> Secrets </p> </li> <li> <p>Navigate <code>Headlamp</code> -&gt; <code>Workloads</code> -&gt; <code>Pods</code> and select deployed application:</p> <p> Pod information </p> </li> </ol>"},{"location":"use-cases/external-secrets/#related-articles","title":"Related Articles","text":"<ul> <li>Use Cases</li> <li>Add Application</li> <li>CD Pipeline</li> </ul>"},{"location":"use-cases/tekton-custom-pipelines/","title":"Deploy Application With Custom Build Tool/Framework","text":"<p>This Use Case describes the procedure of adding custom Tekton libraries that include pipelines with tasks. In addition to it, the process of modifying custom pipelines and tasks is enlightened as well.</p>"},{"location":"use-cases/tekton-custom-pipelines/#goals","title":"Goals","text":"<ul> <li>Add custom Tekton pipeline library;</li> <li>Modify existing pipelines and tasks in a custom Tekton library.</li> </ul>"},{"location":"use-cases/tekton-custom-pipelines/#preconditions","title":"Preconditions","text":"<ul> <li>EDP instance with Gerrit and Tekton inside is configured;</li> <li>Developer has access to the EDP instances using the Single-Sign-On approach;</li> <li>Developer has the <code>Administrator</code> role to perform merge in Gerrit.</li> </ul>"},{"location":"use-cases/tekton-custom-pipelines/#scenario","title":"Scenario","text":"<p>Note</p> <p>This case is based on our predefined repository and application. Your case may be different.</p> <p>To create and then modify a custom Tekton library, please follow the steps below:</p>"},{"location":"use-cases/tekton-custom-pipelines/#add-custom-application-to-edp","title":"Add Custom Application to EDP","text":"<ol> <li> <p>Open Headlamp URL. Use the Sign-In option:</p> <p> Logging screen </p> </li> <li> <p>In the top right corner, enter the <code>Cluster settings</code> and ensure that both <code>Default namespace</code> and <code>Allowed namespace</code> are set:</p> <p> Cluster settings </p> </li> <li> <p>Create the new <code>Codebase</code> with the <code>Application</code> type using the <code>Clone</code> strategy. To do this, click the EDP tab:</p> <p> Cluster overview </p> </li> <li> <p>Select the <code>Components</code> section under the EDP tab and push the create <code>+</code> button:</p> <p> Components tab </p> </li> <li> <p>Select the <code>Application</code> codebase type because is meant to be delivered as a container and deployed inside the Kubernetes cluster. Choose the <code>Clone</code> strategy and this example repository:</p> <p> Step codebase info </p> </li> <li> <p>In the Application Info tab, define the following values and click the <code>Proceed</code> button:</p> <ul> <li>Application name: <code>tekton-hello-world</code></li> <li>Default branch: <code>master</code></li> <li>Application code language: <code>Other</code></li> <li>Language version/framework: <code>go</code></li> <li>Build tool: <code>shell</code></li> </ul> <p> Application info </p> <p>Note</p> <p>These application details are required to match the Pipeline name <code>gerrit-shell-go-app-build-default</code>.</p> <p>The PipelineRun name is formed with the help of TriggerTemplates in <code>pipelines-library</code> so the Pipeline name should correspond to the following structure: <pre><code>  pipelineRef:\n    name: gerrit-$(tt.params.buildtool)-$(tt.params.framework)-$(tt.params.cbtype)-build-$(tt.params.versioning-type)\n</code></pre> The PipelineRun is created as soon as Gerrit (or, if configured, GitHub, GitLab) sends a payload during Merge Request events.</p> </li> <li> <p>In the <code>Advances Settings</code> tab, define the below values and click the <code>Apply</code> button:</p> <ul> <li>CI tool: <code>Tekton</code></li> <li>Codebase versioning type: <code>default</code></li> <li>Leave <code>Specify the pattern to validate a commit message</code> empty.</li> </ul> <p> Advanced settings </p> </li> <li> <p>Check the application status. It should be green:</p> <p> Application status </p> <p>Now that the application is created successfully, proceed to adding the Tekton library.</p> </li> </ol>"},{"location":"use-cases/tekton-custom-pipelines/#add-tekton-library","title":"Add Tekton Library","text":"<ol> <li> <p>Select the <code>Components</code> section under the EDP tab and push the create <code>+</code> button:</p> <p> Components tab </p> </li> <li> <p>Create a new Codebase with the <code>Library</code> type using the <code>Create</code> strategy:</p> <p> Step codebase info </p> <p>Note</p> <p>The EDP Create strategy will automatically pull the code for the Tekton Helm application from here.</p> </li> <li> <p>In the Application Info tab, define the following values and click the <code>Proceed</code> button:</p> <ul> <li>Application name: <code>custom-tekton-chart</code></li> <li>Default branch: <code>master</code></li> <li>Application code language: <code>Helm</code></li> <li>Language version/framework: <code>Pipeline</code></li> <li>Build tool: <code>Helm</code></li> </ul> <p> Step codebase info </p> </li> <li> <p>In the <code>Advances Settings</code> tab, define the below values and click the <code>Apply</code> button:</p> <ul> <li>CI tool: <code>Tekton</code></li> <li>Codebase versioning type: <code>default</code></li> <li>Leave <code>Specify the pattern to validate a commit message</code> empty.</li> </ul> <p> Advanced settings </p> </li> <li> <p>Check the codebase status:</p> <p> Codebase status </p> </li> </ol>"},{"location":"use-cases/tekton-custom-pipelines/#modify-tekton-pipeline","title":"Modify Tekton Pipeline","text":"<p>Note</p> <p>Our recommendation is to avoid modifying the default Tekton resources. Instead, we suggest creating and modifying your own custom Tekton library.</p> <p>Now that the Tekton Helm library is created, it is time to clone, modify and then apply it to the Kubernetes cluster.</p> <ol> <li> <p>Generate SSH key to work with Gerrit repositories:</p> <pre><code>ssh-keygen -t ed25519 -C \"your_email@example.com\"\n</code></pre> </li> <li> <p>Log into Gerrit UI.</p> </li> <li> <p>Go to Gerrit <code>Settings</code> -&gt; <code>SSH keys</code>, paste your generated public SSH key to the <code>New SSH key</code> field and click <code>ADD NEW SSH KEY</code>:</p> <p> Gerrit settings Gerrit settings </p> </li> <li> <p>Browse Gerrit Repositories and select <code>custom-tekton-chart</code> project:</p> <p> Browse Gerrit repositories </p> </li> <li> <p>Clone the repository with <code>SSH</code> using <code>Clone with commit-msg hook</code> command:</p> <p> Gerrit clone </p> <p>Note</p> <p>In case of the strict firewall configurations, please use the <code>HTTP</code> protocol to pull and configure the <code>HTTP Credentials</code> in Gerrit.</p> </li> <li> <p>Examine the repository structure. It should look this way by default:</p> <pre><code>custom-tekton-chart\n  \u251c\u2500\u2500 Chart.yaml\n  \u251c\u2500\u2500 chart_schema.yaml\n  \u251c\u2500\u2500 ct.yaml\n  \u251c\u2500\u2500 lintconf.yaml\n  \u251c\u2500\u2500 templates\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 pipelines\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 hello-world\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gerrit-build-default.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gerrit-build-edp.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gerrit-build-lib-default.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gerrit-build-lib-edp.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gerrit-review-lib.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gerrit-review.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 github-build-default.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 github-build-edp.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 github-build-lib-default.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 github-build-lib-edp.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 github-review-lib.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 github-review.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gitlab-build-default.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gitlab-build-edp.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gitlab-build-lib-default.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gitlab-build-lib-edp.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 gitlab-review-lib.yaml\n  \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 gitlab-review.yaml\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 tasks\n  \u2502\u00a0\u00a0     \u2514\u2500\u2500 task-hello-world.yaml\n  \u2514\u2500\u2500 values.yaml\n</code></pre> <p>Note</p> <p>Change the values in the <code>values.yaml</code> file.</p> <p>The <code>gitProvider</code> parameter is the git hosting provider, Gerrit in this example. The similar approach be made with GitHub, or GitLab.</p> <p>The dnsWildCard parameter is the cluster DNS address.</p> <p>The gerritSSHPort parameter is the SSH port of the Gerrit service on Kubernetes. Check the Gerrit port in your edp installation  global section.</p> <p>Note</p> <p>Our custom Helm chart includes edp-tekton-common-library dependencies in the <code>Chart.yaml</code> file. This library allows to use our predefined code snippets.</p> <p>Here is an example of the filled in <code>values.yaml</code> file:</p> <pre><code>nameOverride: \"\"\nfullnameOverride: \"\"\n\nglobal:\n  gitProvider: gerrit\n  dnsWildCard: \"example.domain.com\"\n  gerritSSHPort: \"30009\"\n</code></pre> </li> <li> <p>Modify and add tasks or pipelines.</p> <p>As an example, let's assume that we need to add the <code>helm-lint</code> pipeline task to the review pipeline. To implement this, insert the code below to the gerrit-review.yaml file underneath the hello task:</p> <pre><code>    - name: hello\n      taskRef:\n        name: hello\n      runAfter:\n      - init-values\n      params:\n      - name: BASE_IMAGE\n        value: \"$(params.shell-image-version)\"\n      - name: username\n        value: \"$(params.username)\"\n      workspaces:\n        - name: source\n          workspace: shared-workspace\n\n    - name: helm-lint\n      taskRef:\n        kind: Task\n        name: helm-lint\n      runAfter:\n        - hello\n      params:\n        - name: EXTRA_COMMANDS\n          value: |\n            ct lint --validate-maintainers=false --charts deploy-templates/\n      workspaces:\n        - name: source\n          workspace: shared-workspace\n</code></pre> <p>Note</p> <p>The <code>helm-lint</code> task references to the default <code>pipeline-library</code> Helm chart which is applied to the cluster during EDP installation.</p> <p>The <code>runAfter</code> parameter shows that this Pipeline task will be run after the <code>hello</code> pipeline task.</p> </li> <li> <p>Build Helm dependencies in the custom chart:</p> <pre><code>helm dependency update .\n</code></pre> </li> <li> <p>Ensure that the chart is valid and all the indentations are fine:</p> <pre><code>helm lint .\n</code></pre> <p>To validate if the values are substituted in the templates correctly, render the templated YAML files with the values using the following command. It generates and displays all the manifest files with the substituted values:</p> <pre><code>helm template .\n</code></pre> </li> <li> <p>Install the custom chart with the command below. You can also use the <code>--dry-run</code> flag to simulate the chart installation and catch possible errors:</p> <pre><code>helm upgrade --install edp-tekton-custom . -n &lt;edp-project&gt; --dry-run\n</code></pre> <pre><code>helm upgrade --install edp-tekton-custom . -n &lt;edp-project&gt;\n</code></pre> </li> <li> <p>Check the created pipelines and tasks in the cluster:</p> <pre><code>kubectl get tasks -n &lt;edp-project&gt;\nkubectl get pipelines -n &lt;edp-project&gt;\n</code></pre> </li> <li> <p>Commit and push the modified Tekton Helm chart to Gerrit:</p> <pre><code>git add .\ngit commit -m \"Add Helm chart testing for go-shell application\"\ngit push origin HEAD:refs/for/master\n</code></pre> </li> <li> <p>Check the Gerrit code review for the custom Helm chart pipelines repository in Tekton:</p> <p> Gerrit code review status </p> </li> <li> <p>Go to <code>Changes</code> -&gt; <code>Open</code>, click <code>CODE-REVIEW</code> and submit the merge request:</p> <p> Gerrit merge Gerrit merge </p> </li> <li> <p>Check the build Pipeline status for the custom Pipelines Helm chart repository in Tekton:</p> <p> Tekton status </p> </li> </ol>"},{"location":"use-cases/tekton-custom-pipelines/#create-application-merge-request","title":"Create Application Merge Request","text":"<p>Since we applied the Tekton library to the Kubernetes cluster in the previous step, let's test the review and build pipelines for our <code>tekton-hello-world</code> application.</p> <p>Perform the below steps to merge new code (Merge Request) that passes the Code Review flow. For the steps below, we use Gerrit UI but the same actions can be performed using the command line and Git tool:</p> <ol> <li> <p>Log into Gerrit UI, select <code>tekton-hello-world</code> project, and create a change request.</p> </li> <li> <p>Browse Gerrit Repositories and select <code>tekton-hello-world</code> project:</p> <p> Browse Gerrit repositories </p> </li> <li> <p>Clone the  <code>tekton-hello-world</code> repository to make the necessary changes or click the <code>Create Change</code> button in the <code>Commands</code> section of the project to make changes via Gerrit GUI:</p> <p> Create Change request </p> </li> <li> <p>In the <code>Create Change</code> dialog, provide the branch <code>master</code>, write some text in the <code>Description</code> (commit message) and click the <code>Create</code> button:</p> <p> Create Change </p> </li> <li> <p>Click the <code>Edit</code> button of the merge request and add <code>deployment-templates/values.yaml</code> to modify it and change the <code>ingress.enabled flag</code> from <code>false</code> to <code>true</code>:</p> <p> Update values.yaml file Update values.yaml file </p> </li> <li> <p>Check the Review Pipeline status. The <code>helm-lint</code> pipeline task should be displayed there:</p> <p> Review Change </p> </li> <li> <p>Review the <code>deployment-templates/values.yaml</code> file and push the <code>SAVE &amp; PUBLISH</code> button. As soon as you get <code>Verified +1</code> from CI bot, the change is ready for review. Click the <code>Mark as Active</code> and <code>Code-review</code> buttons:</p> <p> Review Change </p> </li> <li> <p>Click the <code>Submit</code> button. Then, your code is merged to the main branch, triggering the Build Pipeline.</p> <p> Review Change </p> <p>Note</p> <p>If the build is added and configured, push steps in the pipeline, it will produce a new version of artifact, which will be available for the deployment in Headlamp.</p> </li> <li> <p>Check the pipelines in the Tekton dashboard:</p> <p> Tekton custom piplines Tekton custom piplines </p> </li> </ol> <p>What happens under the hood:   1) Gerrit sends a payload during Merge Request event to the Tekton EventListener;   2) EventListener catches it with the help of Interceptor;   3) TriggerTemplate creates a PipelineRun.</p> <p>The detailed scheme is shown below:</p> <pre><code>graph LR;\n    A[Gerrit events] --&gt; |Payload| B(Tekton EventListener) --&gt; C(Tekton Interceptor CEL filter) --&gt; D(TriggerTemplate)--&gt; E(PipelineRun)</code></pre> <p>This chart will be using the core of <code>common-library</code> and <code>pipelines-library</code> and custom resources on the top of them.</p>"},{"location":"use-cases/tekton-custom-pipelines/#related-articles","title":"Related Articles","text":"<ul> <li>Tekton Overview</li> <li>Add Application to Headlamp</li> </ul>"},{"location":"user-guide/","title":"Overview","text":"<p>Important</p> <p>Admin Console is deprecated and replaced by the Headlamp tool. Please see the Headlamp User guide.</p> <p>The EDP User guide is intended for developers and provides details on working with EDP Admin Console, different codebase types and EDP CI/CD flow.</p>"},{"location":"user-guide/#admin-console","title":"Admin Console","text":"<p>Admin Console is a central management tool in the EDP ecosystem that provides the ability to define pipelines, project resources and new technologies in a simple way. Using Admin Console enables to manage business entities:</p> <ul> <li>Create such codebase types as Applications, Libraries and Autotests;</li> <li>Create/Update CD Pipelines;</li> </ul> <p>Note</p> <p>To interact with Admin Console via REST API, explore the Create Codebase Entity page.</p> <p> Overview page </p> <ul> <li>Navigation bar \u2013 consists of six sections: Overview, Continuous Delivery, Applications, Autotests, Libraries, and Delivery Dashboard Diagram. Click the necessary section to add an entity, open a home page or check the diagram.</li> <li>User name \u2013 displays the registered user name.</li> <li>Main links \u2013 displays the corresponding links to the major adjusted toolset, to the management tool and to the OpenShift cluster.</li> </ul> <p>Admin Console is a complete tool allowing to manage and control added to the environment codebases (applications, autotests, libraries) as well as to create a CD pipeline and check the visualization diagram. Inspect the main features available in Admin Console by following the corresponding link:</p> <ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Add CD Pipeline</li> <li>Delivery Dashboard Diagram</li> </ul>"},{"location":"user-guide/add-application/","title":"Add Application","text":"<p>Admin Console allows to create, clone, import an application and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins.</p> <p>To add an application, navigate to the Applications section on the left-side navigation bar and click the Create button.</p> <p>Once clicked, the three-step menu will appear:</p> <ul> <li>The Codebase Info Menu</li> <li>The Application Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"user-guide/add-application/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p> Create application </p> <ol> <li> <p>In the Codebase Integration Strategy field, select the necessary configuration strategy:</p> <ul> <li>Create \u2013 creates a project on the pattern in accordance with an application language, a build tool, and a framework.</li> </ul> <ul> <li>Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well.</li> </ul> <ul> <li>Import - allows configuring a replication from the Git server. While importing the existing repository, you have to select the Git server and define the respective path to the repository.</li> </ul> <p>Note</p> <p>In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page. The Import strategy is not applicable for Gerrit.</p> </li> <li> <p>In the Git Repository URL field, specify the link to the repository that is to be cloned.   If the Import strategy is selected, specify the following fields:</p> <p> Select import strategy </p> <p>a. Git Server where the repository is located.</p> <p>b. Relative path to the repository on the server.</p> </li> <li> <p>With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields:</p> <ul> <li>Repository Login \u2013 enter your login data.</li> </ul> <ul> <li>Repository password (or API Token) \u2013 enter your password or indicate the API Token.</li> </ul> <p>Note</p> <p>The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Type the name of the application in the Application Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> </li> <li> <p>Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> </li> <li> <p>To create an application with an empty repository in Gerrit, select the Empty project check box.</p> <p>Note</p> <p>The empty repository option is available only for the Create strategy.</p> </li> <li> <p>Select any of the supported application languages with its framework in the Application Code Language/framework field:</p> <ul> <li>Java \u2013 selecting Java allows using Java 8 or Java 11.</li> <li>JavaScript - selecting JavaScript allows using the React framework.</li> <li>DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1.</li> <li>Go - selecting Go allows using the Beego and Operator SDK frameworks.</li> <li>Python - selecting Python allows using the Python v.3.8.</li> <li>Other - selecting Other allows extending the default code languages when creating a codebase with the clone/import strategy. To add another code language, inspect the Add Other Code Language section.</li> </ul> <p>Note</p> <p>The Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>Choose the necessary build tool in the Select Build Tool field:</p> <ul> <li>Java - selecting Java allows using the Gradle or Maven tool.</li> <li>JavaScript - selecting JavaScript allows using the NPM tool.</li> <li>.Net - selecting .Net allows using the .Net tool.</li> </ul> <p>Note</p> <p>The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language.</p> </li> <li> <p>Select the Multi-Module Project check box that becomes available if the Java code language and the Maven build tool are selected.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select CI pipeline provisioner that will be handling a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner.</p> </li> <li>Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent.</li> <li> <p>Select the necessary codebase versioning type:</p> <ul> <li>default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number that will be used for all the artifacts stored in artifactory: binaries, pom.xml, metadata, etc. The version stored in repository (e.g. pom.xml) will not be affected or used. Using this versioning overrides any version stored in the repository files without changing actual file.</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> Edp versioning </p> <p>a. Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> </li> <li> <p>In the Select Deployment Script field, specify one of the available options: helm-chart / openshift-template that are predefined in case it is OpenShift or EKS.</p> </li> <li> <p>In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> <p> Integrate with jira server </p> </li> <li> <p>Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and setup the Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> </li> <li> <p>In the Select Jira Server field, select the Jira server.</p> </li> <li>Indicate the pattern using any character, which is followed on the project, to validate a commit message.</li> <li>Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message.</li> <li> <p>In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed.</p> <p> Advance mapping </p> <p>a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> <p>b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value.</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira;</li> <li>For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator;</li> <li>For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> <p>c. Click the plus icon to add more Jira field names.</p> <p>d. Click the delete icon to remove the Jira field name.</p> <p> Integrate with perf server </p> </li> <li> <p>Select the Integrate with Perf Server check box to enable the integration with the PERF Board (Project Performance Board) for monitoring the overall team performance and setting up necessary metrics.</p> <p>Note</p> <p>If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu.</p> </li> <li> <p>In the Select Perf Server field, select the name of the Perf server with which the integration should be performed. Click the Proceed button to switch to the next menu.</p> <p> Perf integration </p> </li> <li> <p>Select the necessary DataSource (Jenkins, Sonar, GitLab) from which the data should be transferred to the Project Performance Board.</p> </li> <li> <p>Click the Create button, check the CONFIRMATION summary, and click Continue to complete the application addition.</p> </li> </ol> <p>Note</p> <p>After the complete adding of the application, inspect the Application Overview part.</p>"},{"location":"user-guide/add-application/#the-application-info-menu","title":"The Application Info Menu","text":"<p> Application info </p>"},{"location":"user-guide/add-application/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p> Advanced settings </p>"},{"location":"user-guide/add-application/#related-articles","title":"Related Articles","text":"<ul> <li>Application Overview</li> <li>Delivery Dashboard Diagram</li> </ul> <ul> <li>Add CD Pipelines</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> <li>Promote Application in CD Pipeline</li> </ul>"},{"location":"user-guide/add-autotest/","title":"Add Autotests","text":"<p>Admin Console enables to clone or import an autotest, add it to the environment with its subsequent deployment in Gerrit (in case the Clone strategy is used) and building of the Code Review pipeline in Jenkins, as well as to use it for work with an application under development.  It is also possible to use autotests as quality gates in a newly created CD pipeline.</p> <p>Info</p> <p>Please refer to the Add Application section for the details on how to add an application codebase type. For the details on how to use autotests as quality gates, please refer to the the Stages Menu section of the Add CD Pipeline documentation.</p> <p>Navigate to the Autotests section on the left-side navigation bar and click the Create button.</p> <p>Once clicked, the three-step menu will appear:</p> <ul> <li>The Codebase Info Menu</li> <li>The Autotest Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"user-guide/add-autotest/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p>There are two available strategies: clone and import. The Clone strategy flow is displayed below:</p> <p> Clone autotest </p> <ol> <li>Clone - this strategy allows cloning the autotest from the indicated repository into EPAM Delivery Platform.    While cloning the existing repository, you have to fill in the additional fields as well.</li> <li>In the Git Repository URL field, specify the link to the repository with the autotest.</li> <li> <p>With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields:</p> <ul> <li>Repository Login \u2013 enter your login data.</li> <li> <p>Repository password (or API Token) \u2013 enter your password or indicate the API Token.</p> <p>Note</p> <p>The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials.</p> </li> </ul> <p>If there is a necessity to use the Import strategy that allows configuring a replication from the Git server, explore the steps below:</p> <p> Import autotest </p> <p>a. Import - this strategy allows configuring a replication from the Git server.</p> <p>Note</p> <p>In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page.</p> <p>b. In the Git Server field, select the necessary Git server from the drop-down list.</p> <p>c. In the Relative path field, indicate the respective path to the repository, e.g. /epmd-edp/examples/basic/edp-auto-tests-simple-example.</p> </li> <li> <p>After completing the Codebase Info menu step, click the Proceed button to switch to the next menu.</p> </li> <li> <p>Fill in the Autotest Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> <p>Info</p> <p>The Import strategy does not have an Autotest Name field.</p> </li> <li> <p>Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> </li> <li> <p>Type the necessary description in the Description field.</p> </li> <li> <p>In the Autotest Code Language field, select the Java code language (specify Java 8 or Java 11 to be used) and get the default Maven build tool OR add another code language. Selecting Other allows extending the default code languages and get the necessary build tool, for details, inspect the Add Other Code Language section.</p> <p>Note</p> <p>Using the Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>The Select Build Tool field can dispose of the default Maven tool, Gradle or other built tool in accordance with the selected code language.</p> </li> <li> <p>All the autotest reports will be created in the Allure framework that is available in the Autotest Report Framework field by default. Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner.</p> </li> <li> <p>Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent.</p> </li> <li> <p>Select the necessary codebase versioning type:</p> <ul> <li>default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml).</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> Edp versioning </p> <p>a. Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> </li> <li> <p>In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and     the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> <p> Jira integration </p> </li> <li> <p>Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> </li> <li> <p>As soon as the Jira server is set, select it in the Select Jira Server field.</p> </li> <li> <p>Indicate the pattern using any character, which is followed on the project, to validate a commit message.</p> </li> <li> <p>Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message.</p> </li> <li> <p>In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed.</p> <p> Advance mapping </p> <p>a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> <p>b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value.</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira;</li> </ul> <ul> <li>For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator;</li> </ul> <ul> <li>For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> <p>c. Click the plus icon to add more Jira field names.</p> <p>d. Click the delete icon to remove the Jira field name.</p> <p> Integrate with perf server </p> </li> <li> <p>Select the Integrate with Perf Server check box to enable the integration with the PERF Board (Project Performance Board) for monitoring the overall team performance and setting up necessary metrics.</p> <p>Note</p> <p>If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu.</p> </li> <li> <p>In the Select Perf Server field, select the name of the Perf server with which the integration should be performed and click the Proceed button to switch to the next menu.</p> <p> Perf integration </p> </li> <li> <p>Select the necessary DataSource (Jenkins/GitLab, Sonar) from which the data should be transferred to the Project Performance Board.</p> </li> <li> <p>Click the Create button to create an autotest, check the CONFIRMATION summary, click Continue to add an autotest to the Autotests list.</p> </li> </ol> <p>Note</p> <p>After the complete adding of the autotest, inspect the Autotest Overview part.</p>"},{"location":"user-guide/add-autotest/#the-autotest-info-menu","title":"The Autotest Info Menu","text":"<p> Autotest info </p>"},{"location":"user-guide/add-autotest/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p> Advanced settings </p>"},{"location":"user-guide/add-autotest/#related-articles","title":"Related Articles","text":"<ul> <li>Autotest Overview</li> <li>Delivery Dashboard Diagram</li> </ul> <ul> <li>Add Application</li> <li>Add CD Pipelines</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> </ul>"},{"location":"user-guide/add-cd-pipeline/","title":"Add CD Pipeline","text":"<p>Admin Console provides the ability to deploy an environment on your own and specify the essential components as well.</p> <p>Navigate to the Continuous Delivery section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear:</p> <ul> <li>The Pipeline Menu</li> <li>The Applications Menu</li> <li>The Stages Menu</li> </ul> <p>The creation of the CD pipeline becomes available as soon as an application is created including its provisioning in a branch and the necessary entities for the environment.</p> <p>After the complete adding of the CD pipeline, inspect the Check CD Pipeline Availability part.</p>"},{"location":"user-guide/add-cd-pipeline/#the-pipeline-menu","title":"The Pipeline Menu","text":"<p> Create CD pipeline </p> <ol> <li> <p>Type the name of the pipeline in the Pipeline Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> <p>Note</p> <p>The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name]. Please be aware that the namespace length should not exceed 63 symbols.</p> </li> <li> <p>Select the deployment type from the drop-down list:</p> <ul> <li>Container - the pipeline will be deployed in a Docker container;</li> <li>Custom - this mode allows to deploy non-container applications and customize the Init stage of CD pipeline.</li> </ul> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select the check box of the necessary application in the Applications menu.</p> </li> <li>Specify the necessary codebase Docker stream (the output for the branch and other stages from other CD pipelines) from the drop-down menu.</li> <li> <p>Select the Promote in pipeline check box in order to transfer the application from one to another stage by the specified codebase Docker stream. If the Promote in pipeline check box is not selected, the same codebase Docker stream will be deployed regardless of the stage, i.e. the codebase Docker stream input, which was selected for the pipeline, will be always used.</p> <p>Note</p> <p>The newly created CD pipeline has the following pattern combination: [pipeline name]-[branch name]. If there is another deployed CD pipeline stage with the respective codebase Docker stream (= image stream as an OpenShift term), the pattern combination will be as follows: [pipeline name]-[stage name]-[application name]-[verified].</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Click the plus sign icon in the Stages menu and fill in the necessary fields in the Adding Stage window :</p> <p> Adding stage </p> <p>a. Type the stage name;</p> <p>Note</p> <p>The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name]. Please be aware that the namespace length should not exceed 63 symbols.</p> <p>b. Enter the description for this stage;</p> <p>c. Select the quality gate type:</p> <ul> <li>Manual - means that the promoting process should be confirmed in Jenkins manually;</li> <li>Autotests - means that the promoting process should be confirmed by the successful passing of the autotests. In the additional fields, select the previously created autotest name and specify its branch for the autotest that will be launched on the current stage.</li> </ul> <p>Note</p> <p>Please be aware that autotests used in the CD pipeline cannot be removed. For the details on how to create an autotest codebase, please refer to the Add Autotest section.</p> <p>d. Type the step name, which will be displayed in Jenkins, for every quality gate type;</p> <p>e. Add an unlimited number of quality gates by clicking a corresponding plus sign icon and remove them as well by clicking the recycle bin icon;</p> <p>f. Select the trigger type. The available trigger types are manual and auto. By selecting the auto trigger type, the CD pipeline will be launched automatically after the image is built. Every trigger type has a set of default stages that differ by the input stage (auto-deploy-input or manual-deploy-input).</p> </li> </ol> <p>Note</p> <p>When changing the Trigger Type, the job-provision automatically will change the set of stages to the corresponding stages set for the CD pipeline.</p> <p>Note</p> <p>Execution sequence. The image promotion and execution of the pipelines depend on the sequence in which   the environments are added.</p> <p> Adding stage </p> <p>g. Select the groovy-pipeline library;</p> <p>h. Select the job provisioner. In case of working with non container-based applications, there is an option to use    a custom job provisioner. Please refer to the Manage Jenkins CD Job Provision    page for details.</p> <p>i. Click the Add button to display it in the Stages menu.</p> <p>Info</p> <p>Perform the same steps as described above if there is a necessity to add one more stage.</p> <p> Continuous delivery menu </p> <p>9.Edit the stage by clicking its name and applying changes, and remove the added stage by clicking the recycle bin icon next to its name.</p> <p>10.Click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new project with the stage name will be created in OpenShift.</p>"},{"location":"user-guide/add-cd-pipeline/#the-applications-menu","title":"The Applications Menu","text":"<p> CD pipeline applications </p>"},{"location":"user-guide/add-cd-pipeline/#the-stages-menu","title":"The Stages Menu","text":"<p> CD stages </p>"},{"location":"user-guide/add-cd-pipeline/#check-cd-pipeline-availability","title":"Check CD Pipeline Availability","text":"<p>As soon as the CD pipeline is provisioned and added to the CD Pipelines list, there is an ability to:</p> <p> CD page </p> <ol> <li> <p>Create another application by clicking the Create button and performing the same steps as described in the Add CD Pipeline section.</p> </li> <li> <p>Select a number of existing CD pipelines to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page.</p> </li> <li> <p>Sort the existing CD pipelines in a list by clicking the Name title. The CD pipelines will be displayed in alphabetical order.</p> </li> <li> <p>Search the necessary CD pipeline by entering the corresponding name, language or the build tool into the Search field.</p> </li> <li> <p>Navigate between pages if the number of CD pipelines exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"user-guide/add-cd-pipeline/#edit-cd-pipeline","title":"Edit CD Pipeline","text":"<ul> <li> <p>Edit the CD pipeline by clicking the pen icon next to its name in the CD Pipelines list:</p> <p> Edit CD pipeline </p> <ul> <li>apply the necessary changes (the list of applications for deploy, image streams, and promotion in the pipeline) and click the Proceed button to confirm the editions:</li> </ul> <p> Edit CD pipeline page </p> <ul> <li>add new extra stages steps by clicking the plus sign icon and filling in the necessary fields in the Adding Stage window.</li> </ul> <p> Add stages </p> <p>Note</p> <p>The added stage will appear in the Stages menu allowing to review its details or delete.</p> </li> </ul> <ul> <li> <p>Check the CD pipeline data and details by clicking the CD pipeline name in the CD Pipelines list:</p> <p> Link to Jenkins </p> <ul> <li>the main link on the top of the details page refers to Jenkins;</li> </ul> <p> Edit icon </p> <ul> <li>the pen icon refers to the same Edit CD Pipeline page as mentioned above and allows to apply the necessary changes;</li> </ul> <ul> <li>the Applications menu has the main information about the applications with the respective codebase Docker streams and links to Jenkins and Gerrit as well as the signification of the promotion in CD pipeline;</li> </ul> <ul> <li>the Stages menu includes the stages data that was previously mentioned, the direct links to the respective to every stage Kubernetes/OpenShift page, and the link to the Autotest details page in case there are added autotests. To enable or disable auto deployment of a specific stage, click the pen icon and select the necessary trigger type from the drop-down list.</li> </ul> <p> Edit trigger type </p> <p>Note</p> <p>The deletion of stages is performed sequentially, starting from the latest created stage. In order to remove a stage, click the corresponding delete icon, type the CD pipeline name and confirm the deletion by clicking the Delete button. If you remove the last stage, the whole CD pipeline will be removed as the CD pipeline does not exist without stages.</p> <ul> <li>the Deployed Version menu indicates the applications and stages with the appropriate status. The status will be changed after stage deployment.</li> </ul> <p> Deployed versions </p> <ul> <li>the Status Info menu displays all the actions that were performed during the deployment process:</li> </ul> <p> Status info </p> </li> </ul> <ul> <li> <p>Remove the added CD pipeline:</p> <p> Remove CD pipeline </p> <p>Info</p> <p>If there is a necessity to create another CD pipeline, navigate to the Continuous Delivery section, click the Create button and perform the same steps as described above.</p> <p>Info</p> <p>In OpenShift, if the deployment fails with the ImagePullBackOff error, delete the POD.</p> </li> </ul>"},{"location":"user-guide/add-cd-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add Autotest</li> <li>EDP Admin Console</li> <li>Customize CD Pipeline</li> <li>Delivery Dashboard Diagram</li> <li>Promote Application in CD Pipeline</li> </ul> <ul> <li>Manage Jenkins CD Pipeline Job Provision</li> </ul>"},{"location":"user-guide/add-custom-global-pipeline-lib/","title":"Add a Custom Global Pipeline Library","text":"<p>In order to add a new custom global pipeline library, perform the steps below:</p> <ol> <li> <p>Navigate to Jenkins and go to Manage Jenkins -&gt; Configure System -&gt; Global Pipeline Libraries.</p> <p>Note</p> <p>It is possible to configure as many libraries as necessary. Since these libraries will be globally usable, any pipeline in the system can utilize the functionality implemented in these libraries.</p> </li> <li> <p>Specify the following values:</p> <p> Add custom library </p> <p>a. Library name: The name of a custom library.</p> <p>b. Default version: The version which can be branched, tagged or hashed of a commit.</p> <p>c. Load implicitly: If checked, scripts will automatically have access to this library without needing to request it via @Library. It means that there is no need to upload the library manually because it will be downloaded automatically during the build for each job.</p> <p>d. Allow default version to be overridden: If checked, scripts may select a custom version of the library by appending @someversion in the @Library annotation. Otherwise, they are restricted to using the version selected here.</p> <p>e. Include @Library changes in job recent changes: If checked, any changes in the library will be included in the changesets of a build, and changing the library would cause new builds to run for Pipelines that include this library. This can be overridden in the jenkinsfile: @Library(value=\"name@version\", changelog=true|false).</p> <p>f. Cache fetched versions on controller for quick retrieval: If checked, versions fetched using this library will be cached on the controller. If a new library version is not downloaded during the build for some reason, remove the previous library version from cache in the Jenkins workspace.</p> <p>Note</p> <p>If the Default version check box is not defined, the pipeline must specify a version, for example, <code>@Library('my-shared-library@master')</code>. If the Allow default version to be overridden check box is enabled in the Shared Library\u2019s configuration, a @Library annotation may also override the default version defined for the library.</p> <p> Source code management </p> <p>g. Project repository: The URL of the repository</p> <p>h. Credentials: The credentials for the repository.</p> </li> <li> <p>Use the Custom Global Pipeline Libraries on the pipeline, for example:</p> </li> </ol> <p>Pipeline</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name'])_\n\nBuild()\n</code></pre> <p>Note</p> <p><code>edp-custom-shared-library-name</code> is the name of the Custom Global Pipeline Library that should be added to the Jenkins Global Settings.</p>"},{"location":"user-guide/add-custom-global-pipeline-lib/#related-articles","title":"Related Articles","text":"<ul> <li>Jenkins Official Documentation: Extending with Shared Libraries</li> </ul>"},{"location":"user-guide/add-library/","title":"Add Library","text":"<p>Admin Console helps to create, clone or import a library and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins.</p> <p>Navigate to the Libraries section on the left-side navigation bar and click the Create button.</p> <p>Once clicked, the three-step menu will appear:</p> <ul> <li>The Codebase Info Menu</li> <li>The Library Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"user-guide/add-library/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p> Create library </p> <ol> <li> <p>In the Codebase Integration Strategy field, select the necessary option that is the configuration strategy for the replication with Gerrit:</p> <ul> <li>Create \u2013 creates a project on the pattern in accordance with a code language, a build tool, and a framework.</li> </ul> <ul> <li>Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well.</li> </ul> <ul> <li>Import - allows configuring a replication from the Git server. While importing the existing repository, select the Git server and define the respective path to the repository.</li> </ul> <p>Note</p> <p>In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page.</p> </li> <li> <p>In the Git Repository URL field, specify the link to the repository that is to be cloned.</p> </li> <li> <p>With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields:</p> <ul> <li>Repository Login \u2013 enter your login data.</li> <li>Repository password (or API Token) \u2013 enter your password or indicate the API Token.</li> </ul> <p>Note</p> <p>The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Type the name of the library in the Library Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> <p>Info</p> <p>If the Import strategy is used, the Library Name field will not be displayed.</p> </li> <li> <p>Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> </li> <li> <p>To create a library with an empty repository in Gerrit, select the Empty project check box.</p> <p>Note</p> <p>The empty repository option is available only for the Create strategy.</p> </li> <li> <p>Select any of the supported code languages in the Library Code Language block:</p> <ul> <li>Java \u2013 selecting Java allows specify Java 8 or Java 11, and further usage of the Gradle or Maven tool.</li> <li>JavaScript - selecting JavaScript allows using the NPM tool.</li> <li>DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1.</li> <li>Groovy-pipeline - selecting Groovy-pipeline allows having the ability to customize a stages logic. For details, please refer to the Customize CD Pipeline page.</li> <li>Python - selecting Python allows using the Python v.3.8.</li> <li>Terraform - selecting Terraform allows using the Terraform different versions via the Terraform version manager (tfenv). EDP supports all actions available in Terraform, thus providing the ability to modify the virtual infrastructure and launch some checks with the help of linters. For details, please refer to the Use Terraform Library in EDP page.</li> <li>Rego - this option allows using Rego code language with an Open Policy Agent (OPA) Library. For details, please refer to the Use Open Policy Agent page.</li> <li>Container - this option allows using the Kaniko tool for building the container images from a Dockerfile. For details, please refer to the CI Pipeline for Container page.</li> <li>Other - selecting Other allows extending the default code languages when creating a codebase with the Clone/Import strategy. To add another code language, inspect the Add Other Code Language page.</li> </ul> <p>Note</p> <p>The Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select the CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner.</p> </li> <li> <p>Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent.</p> </li> <li> <p>Select the necessary codebase versioning type:</p> <ul> <li>default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml).</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> EDP versioning </p> <p>a. Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> </li> <li> <p>In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and     the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> <p> Integrate with Jira server </p> </li> <li> <p>Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> </li> <li> <p>As soon as the Jira server is set, select it in the Select Jira Server field.</p> </li> <li> <p>Indicate the pattern using any character, which is followed on the project, to validate a commit message.</p> </li> <li> <p>Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message.</p> </li> <li> <p>In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed.</p> <p> Advanced mapping </p> <p>a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> <p>b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value.</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira;</li> <li>For the Component/s field select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator;</li> <li>For the Labels field select the EDP_GITTAGvariable that defines a tag assigned to the commit in Git Hub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> <p>c. Click the plus icon to add more Jira field names.</p> <p>d. Click the delete icon to remove the Jira field name.</p> <p> Integrate with Perf server </p> </li> <li> <p>Select the Integrate with Perf Server check box to enable the integration with the PERF Board (Project Performance Board) for monitoring the overall team performance and setting up necessary metrics.</p> <p>Note</p> <p>If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu.</p> </li> <li> <p>In the Select Perf Server field, select the name of the Perf server with which the integration should be performed. Click the Proceed button to switch to the next menu.</p> <p> Perf integration </p> </li> <li> <p>Select the necessary DataSource (Jenkins/GitLab, Sonar) from which the data should be transferred to the Project Performance Board.</p> </li> <li> <p>Click the Create button, check the CONFIRMATION summary, and click Continue to add the library to the Libraries list.</p> <p>Note</p> <p>After the complete adding of the library, inspect the Library Overview part.</p> </li> </ol>"},{"location":"user-guide/add-library/#the-library-info-menu","title":"The Library Info Menu","text":"<p> Library info </p>"},{"location":"user-guide/add-library/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p> Advanced settings </p>"},{"location":"user-guide/add-library/#related-articles","title":"Related Articles","text":"<ul> <li>Library Overview</li> <li>Delivery Dashboard Diagram</li> </ul> <ul> <li>Add CD Pipeline</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> <li>Use Terraform Library in EDP</li> <li>Use Open Policy Agent Library in EDP</li> </ul>"},{"location":"user-guide/application/","title":"Application","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing applications.</p>"},{"location":"user-guide/application/#check-and-remove-application","title":"Check and Remove Application","text":"<p>As soon as the application is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins for this application. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added application will be listed in the Applications list allowing you to do the following:</p> <p> Applications menu </p> <ol> <li> <p>Create another application by clicking the Create button and performing the same steps as described in the Add Applications section.</p> </li> <li> <p>Open application data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the created/cloned/imported application.</li> <li>Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type).</li> <li> <p>Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields:</p> <ul> <li>Build Number - indicates the current build number;</li> <li>Last Successful Build - indicates the last successful build number.</li> </ul> </li> </ul> <ul> <li>Status Info - displays all the actions that were performed during the creation/cloning/importing process.</li> </ul> </li> <li> <p>Edit the application codebase by clicking the pencil icon. For details see the Edit Existing Codebase section.</p> </li> <li> <p>Remove application with the corresponding database and Jenkins pipelines:</p> <ul> <li>Click the delete icon next to the application name;</li> <li>Type the required application name;</li> <li>Confirm the deletion by clicking the Delete button.</li> </ul> <p>Note</p> <p>The application that is used in a CD pipeline cannot be removed.</p> <p> Applications menu </p> </li> <li> <p>Select a number of existing applications to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page.</p> </li> <li> <p>Sort the existing applications in a list by clicking the Name title. The applications will be displayed in alphabetical order.</p> </li> <li> <p>Search the necessary application by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the application name, language or a build tool.</p> </li> <li> <p>Navigate between pages if the number of applications exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"user-guide/application/#add-a-new-branch","title":"Add a New Branch","text":"<p>Note</p> <p>Pay attention when specifying the branch name: the branch name is involved in the formation of the application version, so it must comply with the versioning semantic rules for the application.</p> <p>When adding an application, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li> <p>Navigate to the Branches block and click the Create button:]</p> <p> Add branch </p> </li> <li> <p>Fill in the required fields:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch;</p> <p>b. Branch Name - type the branch name. Pay attention that this field remains static if you create a release branch.</p> <p>c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number;</p> <p>f. Click the Proceed button and wait until the new branch will be added to the list.</p> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer here.</p> </li> </ol> <p>The default application repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"user-guide/application/#edit-existing-codebase","title":"Edit Existing Codebase","text":"<p>The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for applications via the Edit Codebase page.</p> <ol> <li> <p>Perform the editing from one of the following sections on the Admin Console interface:</p> <p> Edit codebase </p> <ul> <li>Navigate to the codebase overview page and click the pencil icon, or</li> </ul> <p> Edit codebase </p> <ul> <li>Navigate to the codebase list page and click the pencil icon.</li> </ul> <p> Edit codebase </p> </li> <li> <p>To enable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>mark the Integrate with Jira server check box and fill in the necessary fields;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</li> </ul> </li> <li> <p>To disable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>unmark the Integrate with Jira server check box;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</li> </ul> </li> </ol> <p>As a result, the necessary changes will be applied.</p>"},{"location":"user-guide/application/#remove-branch","title":"Remove Branch","text":"<p>In order to remove the added branch with the corresponding record in the Admin Console database, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the application name link in the Applications list;</li> <li> <p>Click the delete icon related to the necessary branch:</p> <p> Remove branch </p> </li> <li> <p>Enter the branch name and click the Delete button;</p> </li> </ol> <p>Note</p> <p>The default master branch cannot be removed.</p>"},{"location":"user-guide/application/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Promote Application in CD Pipeline</li> </ul>"},{"location":"user-guide/autotest/","title":"Autotest","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing autotests.</p>"},{"location":"user-guide/autotest/#check-and-remove-autotest","title":"Check and Remove Autotest","text":"<p>As soon as the autotest is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins for this autotest. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added autotest will be listed in the Autotests list allowing you to do the following:</p> <p> Autotests page </p> <ol> <li> <p>Add another autotest by clicking the Create button and performing the same steps as described at the Add Autotest page.</p> </li> <li> <p>Open autotest data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the cloned/imported autotest.</li> <li>Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type).</li> <li>Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields:<ul> <li>Build Number - indicates the current build number;</li> <li>Last Successful Build - indicates the number of the last successful build.</li> </ul> </li> <li>Status Info - displays all the actions that were performed during the cloning/importing process.</li> </ul> </li> <li> <p>Edit the autotest codebase by clicking the pencil icon. For details see the Edit Existing Codebase section.</p> </li> <li> <p>Remove autotest with the corresponding database and Jenkins pipelines:</p> <ul> <li>Click the delete icon next to the autotest name;</li> <li>Type the required autotest name;</li> <li>Confirm the deletion by clicking the Delete button.</li> </ul> <p>Note</p> <p>The autotest that is used in a CD pipeline cannot be removed.</p> <p> Autotests page </p> </li> <li> <p>Select a number of existing autotests to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page.</p> </li> <li> <p>Sort the existing autotests in a list by clicking the Name title. The autotests will be displayed in alphabetical order.</p> </li> <li> <p>Search the necessary autotest by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the autotest name, language or a build tool.</p> </li> <li> <p>Navigate between pages, if the number of autotests exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"user-guide/autotest/#edit-existing-codebase","title":"Edit Existing Codebase","text":"<p>The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for autotests via the Edit Codebase page.</p> <ol> <li> <p>Perform the editing from one of the following sections on the Admin Console interface:</p> <p> Edit autotest </p> <ul> <li> <p>Navigate to the codebase overview page and click the pencil icon, or</p> <p> Edit autotest </p> </li> </ul> <ul> <li> <p>Navigate to the codebase list page and click the pencil icon.</p> <p> Edit autotest </p> </li> </ul> </li> <li> <p>To enable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>mark the Integrate with Jira server check box and fill in the necessary fields;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code-Review pipeline.</li> </ul> <p>Note</p> <p>Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration and Adjust VCS Integration With Jira pages.</p> </li> <li> <p>To disable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>unmark the Integrate with Jira server check box;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</li> </ul> </li> </ol> <p>As a result, the necessary changes will be applied.</p>"},{"location":"user-guide/autotest/#add-a-new-branch","title":"Add a New Branch","text":"<p>Note</p> <p>Pay attention when specifying the branch name: the branch name is involved in the formation of the application version, so it must comply with the versioning semantic rules for the application.</p> <p>When adding an autotest, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li> <p>Navigate to the Branches block and click the Create button:</p> <p> Add branch </p> </li> <li> <p>Fill in the required fields:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch;</p> <p>b. Branch Name - type the branch name. Pay attention that this field remains static if you create a release branch.</p> <p>c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number;</p> <p>f. Click the Proceed button and wait until the new branch will be added to the list.</p> </li> </ol> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer to the Add Autotest instruction.</p> <p>The default autotest repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"user-guide/autotest/#remove-branch","title":"Remove Branch","text":"<p>In order to remove the added branch with the corresponding  record in the Admin Console database, do the following:</p> <ol> <li> <p>Navigate to the Branches block by clicking the autotest name link in the Autotests list;</p> </li> <li> <p>Click the delete icon related to the necessary branch:</p> <p> Remove branch </p> </li> <li> <p>Enter the branch name and click the Delete button;</p> <p>Note</p> <p>The default master branch cannot be removed.</p> </li> </ol>"},{"location":"user-guide/autotest/#add-autotest-as-a-quality-gate","title":"Add Autotest as a Quality Gate","text":"<p>In order to add an autotest as a quality gate to a newly added CD pipeline, do the following:</p> <ol> <li> <p>Create a CD pipeline with the necessary parameters. Please refer to the Add CD Pipeline section for the details.</p> </li> <li> <p>In the Stages menu, select the Autotest quality gate type. It means the promoting process should be confirmed by the successful passing of the autotests.</p> </li> <li> <p>In the additional fields, select the previously created autotest name and specify its branch.</p> </li> <li> <p>After filling in all the necessary fields, click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new namespace containing the stage name will be created in Kubernetes (in OpenShift, a new project will be created) with the following name pattern: [cluster name]-[cd pipeline name]-[stage name]</p> </li> </ol>"},{"location":"user-guide/autotest/#configure-autotest-launch-at-specific-stage","title":"Configure Autotest Launch at Specific Stage","text":"<p>In order to configure the added autotest launch at the specific stage with necessary parameters, do the following:</p> <ol> <li> <p>Add the necessary stage to the CD pipeline. Please refer to the Add CD Pipeline documentation for the details.</p> </li> <li> <p>Navigate to the run.json file and add the stage name and the specific parameters.</p> </li> </ol>"},{"location":"user-guide/autotest/#launch-autotest-locally","title":"Launch Autotest Locally","text":"<p>There is an ability to run the autotests locally using the IDEA (Integrated Development Environment Application, such as IntelliJ, NetBeans etc.). To launch the autotest project for the local verification, perform the following steps:</p> <ol> <li> <p>Clone the project to the local machine.</p> </li> <li> <p>Open the project in IDEA and find the run.json file to copy out the necessary command value.</p> </li> <li> <p>Paste the copied command value into the Command line field and run it with the necessary values and namespace.</p> </li> <li> <p>As a result, all launched tests will be executed.</p> </li> </ol>"},{"location":"user-guide/autotest/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotests</li> <li>Add CD Pipeline</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> </ul>"},{"location":"user-guide/build-pipeline/","title":"Build Pipeline","text":"<p>This section provides details on the Build pipeline of the EDP CI/CD pipeline framework. Explore below the pipeline purpose, stages and possible actions to perform.</p>"},{"location":"user-guide/build-pipeline/#build-pipeline-purpose","title":"Build Pipeline Purpose","text":"<p>The purpose of the Build pipeline contains the following points:</p> <ul> <li>Check out, test, tag and build an image from the mainstream branch after a patch set is submitted in order to inspect whether the integrated with the mainstream code fits all quality gates, can be built and tested;</li> <li>Be triggered if any new patch set is submitted;</li> <li>Tag a specific commit in Gerrit in case the build is successful;</li> <li>Build a Docker image with an application that can be afterward deployed using the Jenkins Deploy pipeline.</li> </ul> <p>Find below the functional diagram of the Build pipeline with the default stages:</p> <p> build-pipeline </p>"},{"location":"user-guide/build-pipeline/#build-pipeline-for-application-and-library","title":"Build Pipeline for Application and Library","text":"<p>The Build pipeline is triggered automatically after the Code Review pipeline is completed and the changes are submitted.</p> <p>To review the Build pipeline, take the following steps:</p> <ol> <li> <p>Open Jenkins via the created link in Gerrit or via the Admin Console Overview page.</p> </li> <li> <p>Click the Build pipeline link to open its stages for the application and library codebases:</p> <ul> <li>Init - initialization of the Code Review pipeline inputs;</li> </ul> <ul> <li>Checkout - checkout of the application code;</li> </ul> <ul> <li>Get-version - get the version from the pom.XML file and add the build number;</li> </ul> <ul> <li>Compile - code compilation;</li> </ul> <ul> <li>Tests - tests execution;</li> </ul> <ul> <li>Sonar - Sonar launch that checks the whole code;</li> </ul> <ul> <li>Build - artifact building and adding to Nexus;</li> </ul> <ul> <li>Build-image - docker image building and adding to Docker Registry. The Build pipeline for the library has the same stages as the application except the Build-image stage, i.e. the Docker image is not building.</li> </ul> <ul> <li>Push - artifact docker image pushing to Nexus and Docker Registry;</li> </ul> <ul> <li>Ecr-to-docker - the docker image, after being built, is copied from the ECR project registry to DockerHub via the Crane tool. The stage is not the default and can be set for the application codebase type.   To set this stage, please refer to the EcrToDocker.groovy file and to the Promote Docker Images From ECR to Docker Hub page.</li> </ul> <ul> <li>Git-tag - adding of the corresponding Git tag of the current commit to relate with the image, artifact, and build version.</li> </ul> </li> </ol> <p>Note</p> <p>For more details on stages, please refer to the Pipeline Stages documentation.</p> <p>After the Build pipeline runs all the stages successfully, the corresponding tag numbers will be created in Kubernetes/OpenShift and Nexus.</p>"},{"location":"user-guide/build-pipeline/#check-the-tag-in-kubernetesopenshift-and-nexus","title":"Check the Tag in Kubernetes/OpenShift and Nexus","text":"<ol> <li> <p>After the Build pipeline is completed, check the tag name and the same with the commit revision. Simply navigate to Gerrit \u2192 Projects \u2192 List \u2192 select the project \u2192 Tags.</p> <p>Note</p> <p>For the Import strategy, navigate to the repository from which a codebase is imported \u2192 Tags. It is actual both for GitHub and GitLab.</p> </li> <li> <p>Open the Kubernetes/OpenShift Overview page and click the link to Nexus and check the build of a new version.</p> </li> <li> <p>Switch to Kubernetes \u2192 CodebaseImageStream (or OpenShift \u2192 Builds \u2192 Images) \u2192 click the image stream that will be used for deployment.</p> </li> <li> <p>Check the corresponding tag.</p> </li> </ol>"},{"location":"user-guide/build-pipeline/#configure-and-start-pipeline-manually","title":"Configure and Start Pipeline Manually","text":"<p>The Build pipeline can be started manually. To set the necessary stages and trigger the pipeline manually, take the following steps:</p> <ol> <li> <p>Open the Build pipeline for the created library.</p> </li> <li> <p>Click the Build with parameters option from the left-side menu. Modify the stages by removing the whole objects massive:{\"name\". \"tests\"} where name is a key and tests is a stage name that should be executed.</p> </li> <li> <p>Open Jenkins and check the successful execution of all stages.</p> </li> </ol>"},{"location":"user-guide/build-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Autotest as Quality Gate</li> <li>Pipeline Stages</li> </ul>"},{"location":"user-guide/cd-pipeline-details/","title":"CD Pipeline Details","text":"<p>CD Pipeline (Continuous Delivery Pipeline) - an EDP business entity that describes the whole delivery process of the selected application set via the respective stages. The main idea of the CD pipeline is to promote the application build version between the stages by applying the sequential verification (i.e. the second stage will be available if the verification on the first stage is successfully completed). The CD pipeline can include the essential set of applications with its specific stages as well.</p> <p>In other words, the CD pipeline allows the selected image stream (Docker container in Kubernetes terms) to pass a set of stages for the verification process (SIT - system integration testing with the automatic type of a quality gate, QA - quality assurance, UAT - user acceptance testing with the manual testing).</p> <p>Note</p> <p>It is possible to change the image stream for the application in the CD pipeline. Please refer to the Edit CD Pipeline section for the details. </p> <p>A CI/CD pipeline helps to automate steps in a software delivery process, such as the code build initialization, automated tests running, and deploying to a staging or production environment. Automated pipelines remove manual errors, provide standardized development feedback cycle, and enable the fast product iterations. To get more information on the CI pipeline, please refer to the CI Pipeline Details chapter.</p> <p>The codebase stream is used as a holder for the output of the stage, i.e. after the Docker container (or an image stream in OpenShift terms) passes the stage verification, it will be placed to the new codebase stream. Every codebase has a branch that has its own codebase stream - a Docker container that is an output of the build for the corresponding branch.</p> <p>Note</p> <p>For more information on the main terms used in EPAM Delivery Platform, please refer to the EDP Glossary</p> <p> EDP CD pipeline </p> <p>Explore the details of the CD pipeline below.</p>"},{"location":"user-guide/cd-pipeline-details/#deploy-pipeline","title":"Deploy Pipeline","text":"<p>The Deploy pipeline is used by default on any stage of the Continuous Delivery pipeline. It addresses the following concerns:</p> <ul> <li>Deploying the application(s) to the main STAGE (SIT, QA, UAT) environment in order to run autotests and to promote image build versions to the next environments afterwards.</li> <li>Deploying the application(s) to a custom STAGE environment in order to run autotests and check manually that everything is ok with the application.</li> <li>Deploying the latest or a stable and some particular numeric version of an image build that exists in Docker registry.</li> <li>Promoting the image build versions from the main STAGE (SIT, QA, UAT) environment.</li> <li>Auto deploying the application(s) version from the passed payload (using the CODEBASE_VERSION job parameter).</li> </ul> <p>Find below the functional diagram of the Deploy pipeline with the default stages:</p> <p>Note</p> <p>The input for a CD pipeline depends on the Trigger Type for a deploy stage and can be either Manual or Auto.</p> <p> Deploy pipeline stages </p>"},{"location":"user-guide/cd-pipeline-details/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add CD Pipeline</li> <li>Add Library</li> <li>CI Pipeline Details</li> <li>CI/CD Overview</li> <li>EDP Glossary</li> <li>EDP Pipeline Framework</li> <li>EDP Pipeline Stages</li> <li>Prepare for Release</li> </ul>"},{"location":"user-guide/ci-pipeline-details/","title":"CI Pipeline Details","text":"<p>CI Pipeline (Continuous Integration Pipeline) - an EDP business entity that describes the integration of changes made to a codebase into a single project. The main idea of the CI pipeline is to review the changes in the code submitted through a Version Control System (VCS) and build a new codebase version so that it can be transmitted to the Continuous Delivery Pipeline for the rest of the delivery process.</p> <p>There are three codebase types in EPAM Delivery Platform:</p> <ol> <li>Applications - a codebase that is developed in the Version Control System, has the full lifecycle starting from the Code Review stage to its deployment to the environment;</li> <li>Libraries - this codebase is similar to the Application type, but it is not deployed and stored in the Artifactory. The library can be connected to other applications/libraries;</li> <li>Autotests - a codebase that inspects the code and can be used as a quality gate for the CD pipeline stage. The autotest only has the Code Review pipeline and is launched for the stage verification.</li> </ol> <p>Note</p> <p>For more information on the above mentioned codebase types, please refer to the Add Application, Add Library, Add Autotests and Autotest as Quality Gate pages.</p> <p> EDP CI pipeline </p>"},{"location":"user-guide/ci-pipeline-details/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Autotest as Quality Gate</li> <li>Build Pipeline</li> <li>Code Review Pipeline</li> <li>Pipeline Stages</li> </ul>"},{"location":"user-guide/cicd-overview/","title":"EDP CI/CD Overview","text":"<p>This chapter provides information on CI/CD basic definitions and flow, as well as its components and process.</p>"},{"location":"user-guide/cicd-overview/#cicd-basic-definitions","title":"CI/CD Basic Definitions","text":"<p>The Continuous Integration part means the following:</p> <ul> <li>all components of the application development are in the same place and perform the same processes for running;</li> <li>the results are published in one place and replicated into EPAM GitLab or VCS (version control system);</li> <li>the repository also includes a storage tool (e.g. Nexus) for all binary artifacts that are produced by the Jenkins CI server after submitting changes from Code Review tool into VCS;</li> </ul> <p>The <code>Code Review</code> and <code>Build</code> pipelines are used before the code is delivered. An important part of both of them is the integration tests that are launched during the testing stage.</p> <p>Many applications (SonarQube, Gerrit, etc,) used by the project need databases for their performance.</p> <p>The Continuous Delivery comprises an approach allowing to produce an application in short cycles so that it can be reliably released at any time point. This part is tightly bound with the usage of the <code>Code Review</code>, <code>Build</code>, and <code>Deploy</code> pipelines.</p> <p>The <code>Deploy</code> pipelines deploy the applications configuration and their specific versions, launch automated tests and control quality gates for the specified environment. As a result of the successfully completed process, the specific versions of images are promoted to the next environment. All environments are sequential and promote the build versions of applications one-by-one. The logic of each stage is described as a code of Jenkins pipelines and stored in the VCS.</p> <p>During the CI/CD, there are several continuous processes that run in the repository, find below the list of possible actions:</p> <ul> <li>Review the code with the help of Gerrit tool;</li> <li>Run the static analysis using SonarQube to control the quality of the source code and keep the historical data which helps to understand the trend and effectivity of particular teams and members;</li> <li>Analyze application source code using SAST, byte code, and binaries for coding/design conditions that are indicative of security vulnerabilities;</li> <li>Build the code with Jenkins and run automated tests that are written to make sure the applied changes will not break any functionality.</li> </ul> <p>Note</p> <p>For the details on autotests, please refer to the Autotest, Add Autotest, and Autotest as Quality Gate pages.</p> <p>The release process is divided into cycles and provides regular delivery of completed pieces of functionality while continuing the development and integration of new functionality into the product mainline.</p> <p>Explore the main flow that is displayed on the diagram below:</p> <p> EDP CI/CD pipeline </p>"},{"location":"user-guide/cicd-overview/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Library</li> <li>Add CD Pipeline</li> <li>CI Pipeline Details</li> <li>CD Pipeline Details</li> <li>Customize CI Pipeline</li> <li>EDP Pipeline Framework</li> <li>Customize CD Pipeline</li> <li>EDP Stages</li> <li>Glossary</li> <li>Use Terraform Library in EDP</li> </ul>"},{"location":"user-guide/code-review-pipeline/","title":"Code Review Pipeline","text":"<p>This section provides details on the Code Review pipeline of the EDP CI/CD framework. Explore below the pipeline purpose, stages and possible actions to perform.</p>"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline-purpose","title":"Code Review Pipeline Purpose","text":"<p>The purpose of the Code Review pipeline contains the following points:</p> <ul> <li>Check out and test a particular developer's change (Patch Set) in order to inspect whether the code fits all the quality gates and can be built and tested;</li> <li>Be triggered if any new Patch Set appears in Gerrit;</li> <li>Send feedback about the build process in Jenkins to review the card in Gerrit;</li> <li>Send feedback about Sonar violations that have been found during the Sonar stage.</li> </ul> <p>Find below the functional diagram of the Code Review pipeline with the default stages:</p> <p> Code review pipeline stages </p>"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline-for-applications-and-libraries","title":"Code Review Pipeline for Applications and Libraries","text":"<p>Note</p> <p>Make sure the necessary applications or libraries are added to the Admin Console. For the details on how to add a codebase, please refer to the Add Application or Add Library pages accordingly.</p> <p>To discover the Code Review pipeline, apply changes that will trigger the Code Review pipeline automatically and take the following steps:</p> <ol> <li> <p>Navigate to Jenkins. In Admin Console, go to the Overview section on the left-side navigation bar and click the link to Jenkins.</p> <p> Link to Jenkins </p> <p>or</p> <p>In Gerrit, go to the Patch Set page and click the CI Jenkins link in the Change Log section</p> <p> Link from Gerrit </p> <p>Note</p> <p>The Code Review pipeline starts automatically for every codebase type (Application, Autotests, Library).</p> </li> <li> <p>Check the Code Review pipeline for the application of for the library. Click the application name in Jenkins and switch to the additional release-01 branch that is created with the respective Code Review and Build pipelines.</p> </li> <li> <p>Click the Code Review pipeline link to open the Code Review pipeline stages for the application:</p> <ul> <li>Init - initialization of the codebase information and loading of the common libraries</li> <li>gerrit-checkout / checkout - the checkout of patch sets from Gerrit. The stage is called gerrit-checkout for the Create and Clone strategies of adding a codebase and checkout for the Import strategy.</li> <li>compile - the source code compilation</li> <li>tests - the launch of the tests</li> <li>sonar - the launch of the static code analyzer that checks the whole code</li> <li>helm-lint - the launch of the linting tests for deployment charts</li> <li>dockerfile-lint - the launch of the linting tests for Dockerfile</li> <li>commit-validate - the stage is optional and appears under enabled integration with Jira. Please refer to the Adjust Jira Integration and Adjust VCS Integration With Jira sections for the details.</li> </ul> </li> </ol> <p>Note</p> <p>For more details on EDP pipeline stages, please refer to the Pipeline Stages section.</p>"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline-for-autotests","title":"Code Review Pipeline for Autotests","text":"<p>To discover the Code Review pipeline for autotests, first, apply changes to a codebase that will trigger the Code Review pipeline automatically. The flow for the autotest is similar for that for applications and libraries, however, there are some differences. Explore them below.</p> <ol> <li> <p>Open the run.json file for the created autotest.</p> <p>Note</p> <p>Please refer to the Add Autotest page for the details on how to create an autotest.</p> <p>The run.json file keeps a command that is executed on this stage.</p> </li> <li> <p>Open the Code Review pipeline in Jenkins (via the link in Gerrit or via the Admin Console Overview page) and click the Configure option from the left side. There are only four stages available: Initialization - Gerrit-checkout - tests - sonar (the launch of the static code analyzer that checks the whole code).</p> </li> <li> <p>Open the Code Review pipeline in Jenkins with the successfully passed stages.</p> </li> </ol>"},{"location":"user-guide/code-review-pipeline/#retrigger-code-review-pipeline","title":"Retrigger Code Review Pipeline","text":"<p>The Code Review pipeline can be retriggered manually, especially if the pipeline failed before. To retrigger it, take the following steps:</p> <ol> <li> <p>In Jenkins, click the Retrigger option from the drop-down menu for the specific Code Review pipeline version number. Alternatively, click the Jenkins main page and select the Query and Trigger Gerrit Patches option.</p> </li> <li> <p>Click Search and select the check box of the necessary change and patch set and then click Trigger Selected.</p> </li> </ol> <p>As a result, the Code Review pipeline will be retriggered.</p>"},{"location":"user-guide/code-review-pipeline/#configure-code-review-pipeline","title":"Configure Code Review Pipeline","text":"<p>The Configure option allows adding/removing the stage from the Code Review pipeline if needed. To configure the Code Review pipeline, take the following steps:</p> <ol> <li> <p>Being in Jenkins, click the Configure option from the left-side menu.</p> </li> <li> <p>Define the stages set that will be executed for the current pipeline.</p> <ul> <li>To remove a stage, select and remove the whole objects massive: {\"name\".\"tests\"}, where name is a key and tests is a stage name that should be executed.</li> <li>To add a stage, define the objects massive: {\"name\".\"tests\"}, where name is a key and tests is a stage name that should be added.</li> </ul> <p>Note</p> <p>All stages are launched from the shared library on GitHub. The list of libraries is located in the edp-library-stages repository.</p> </li> <li> <p>To apply the new stage process, retrigger the Code Review pipeline. For details, please refer to the Retrigger Code Review Pipeline section.</p> </li> <li> <p>Open Jenkins and check that there is no removed stage in the Code Review pipeline.</p> </li> </ol>"},{"location":"user-guide/code-review-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Autotest as Quality Gate</li> <li>Pipeline Stages</li> </ul>"},{"location":"user-guide/container-stages/","title":"CI Pipeline for Container","text":"<p>EPAM Delivery Platform ensures the implemented Container support allowing to work with Dockerfile that is processed by means of stages in the Code-Review and Build pipelines. These pipelines are expected to be created after the Container Library is added.</p>"},{"location":"user-guide/container-stages/#code-review-pipeline-stages","title":"Code Review Pipeline Stages","text":"<p>In the Code Review pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage is a standard step during which all files are checked out from a selected branch of the Git repository.</p> </li> <li> <p>dockerfile-lint stage uses the hadolint tool to perform linting tests for the Dockerfile.</p> </li> <li> <p>dockerbuild-verify stage collects artifacts and builds an image from the Dockerfile without pushing to registry. This stage is intended to check if the image is built.</p> </li> </ol>"},{"location":"user-guide/container-stages/#build-pipeline-stages","title":"Build Pipeline Stages","text":"<p>In the Build pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage is a standard step during which all files are checked out from a master branch of the Git repository.</p> </li> <li> <p>get-version stage where the library version is determined either via:</p> <p>2.1. EDP versioning functionality.</p> <p>2.2. Default versioning functionality.</p> </li> <li> <p>dockerfile-lint stage uses the hadolint tool to perform linting tests for Dockerfile.</p> </li> <li> <p>build-image-kaniko stage builds Dockerfile using the Kaniko tool.</p> </li> <li> <p>git-tag stage that is intended for tagging a repository in Git.</p> </li> </ol>"},{"location":"user-guide/container-stages/#tools-for-container-images-building","title":"Tools for Container Images Building","text":"<p>EPAM Delivery Platform ensures the implemented Kaniko tool and <code>BuildConfig</code> object support. Using Kaniko tool allows building the container images from a Dockerfile both on the Kubernetes and OpenShift platforms. The <code>BuildConfig</code> object enables the building of the container images only on the OpenShift platform.</p> <p>EDP uses the <code>BuildConfig</code> object and the Kaniko tool for creating containers from a Dockerfile and pushing them to the internal container image registry. For Kaniko, it is also possible to change the Docker config file and push the containers to different container image registries.</p>"},{"location":"user-guide/container-stages/#supported-container-image-build-tools","title":"Supported Container Image Build Tools","text":"Platform Build Tools Kubernetes Kaniko OpenShift Kaniko, BuildConfig"},{"location":"user-guide/container-stages/#change-build-tool-in-the-build-pipeline","title":"Change Build Tool in the Build Pipeline","text":"<p>By default, EPAM Delivery Platform uses the <code>build-image-kaniko</code> stage for building container images on the Kubernetes platform and the <code>build-image-from-dockerfile</code> stage for building container images on the OpenShift platform.</p> <p>In order to change a build tool for the OpenShift Platform from the default <code>buildConfig</code> object to the Kaniko tool, perform the following steps:</p> <ol> <li>Modify or update a job provisioner logic, follow the instructions on the Manage Jenkins CI Pipeline Job Provisioner page.</li> <li>Update the required parameters for a new provisioner.    For example, if it is necessary to change the build tool for Container build pipeline, update the list of stages:<pre><code>stages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-from-dockerfile\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n</code></pre> <pre><code>stages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n</code></pre> </li> </ol>"},{"location":"user-guide/container-stages/#related-articles","title":"Related Articles","text":"<ul> <li>Use Dockerfile Linters for Code Review Pipeline</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/copy-shared-secrets/","title":"Copy Shared Secrets","text":"<p>The Copy Shared Secrets stage provides the ability to copy secrets from the current Kubernetes namespace into a namespace created during CD pipeline.</p> <p> Shared secrets </p> <p>Please follow the steps described below to copy the secrets:</p> <ol> <li> <p>Create a secret in the current Kubernetes namespace that should be used in the deployment. The secret label must be <code>app.edp.epam.com/use: cicd</code>, since the pipeline script will attempt to copy the secret by its label. For example:</p> <pre><code>kind: Secret\nmetadata:\nlabels:\napp.edp.epam.com/use: cicd\n</code></pre> </li> <li> <p>Add the following step to the CD pipeline <code>{\"name\":\"copy-secrets\",\"step_name\":\"copy-secrets\"}</code>. Alternatively, it is possible to create a custom job provisioner with this step.</p> </li> <li> <p>Run the job. The pipeline script will create a secret with the same data in the namespace generated by the cd pipeline.</p> <p>Note</p> <p>Service account tokens are not supported.</p> </li> </ol>"},{"location":"user-guide/copy-shared-secrets/#related-articles","title":"Related Articles","text":"<ul> <li>Customize CD Pipeline</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/customize-cd-pipeline/","title":"Customize CD Pipeline","text":"<p>Apart from running CD pipeline stages with the default logic, there is the ability to perform the following:</p> <ul> <li>Create your own logic for stages;</li> <li>Redefine the default EDP stages of a CD pipeline.</li> </ul> <p>In order to have the ability to customize a stage logic, create a CD pipeline stage source as a Library:</p> <ol> <li> <p>Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language:</p> <p>Note</p> <p>If you clone the library, make sure that the correct source branch is selected.</p> <p> Create library </p> <p>Select the required fields to build your library:</p> <p> Advanced settings </p> </li> <li> <p>Go to the Continuous Delivery section of the Admin Console and create a CD pipeline with the library stage source and its branch:</p> <p> Library source </p> </li> </ol>"},{"location":"user-guide/customize-cd-pipeline/#add-new-stage","title":"Add New Stage","text":"<p>Follow the steps below to add a new stage:</p> <ul> <li>Clone the repository with the added library;</li> <li>Create a \"stages\" directory in the root;</li> <li>Create a Jenkinsfile with default content:<pre><code>@Library(['edp-library-stages', 'edp-library-pipelines']) _\n\nDeploy()\n</code></pre> </li> </ul> <ul> <li>Create a groovy file with a meaningful name, e.g. NotificationStage.groovy;</li> <li>Put the required construction and your own logic into the file:<pre><code>import com.epam.edp.stages.impl.cd.Stage\n\n@Stage(name = \"notify\")\nclass Notify {\n    Script script\n    void run(context) {\n    --------------- Put your own logic here ------------------\n            script.println(\"Send notification logic\")\n    --------------- Put your own logic here ------------------\n    }\n}\nreturn Notify\n</code></pre> </li> </ul> <ul> <li> <p>Add a new stage to the STAGES parameter of the Jenkins job of your CD pipeline:</p> <p> Stages parameter </p> <p>Warning</p> <p>To make this stage permanently present, please modify the job provisioner.</p> </li> </ul> <ul> <li>Run the job to check that your new stage has been run during the execution.</li> </ul>"},{"location":"user-guide/customize-cd-pipeline/#redefine-existing-stage","title":"Redefine Existing Stage","text":"<p>By default, the following stages are implemented in EDP pipeline framework:</p> <ul> <li>deploy,</li> <li>deploy-helm,</li> <li>autotests,</li> <li>manual (Manual approve),</li> <li>promote-images.</li> </ul> <p>Using one of these names for annotation in your own class will lead to redefining the default logic with your own.</p> <p>Find below a sample of the possible flow of the redefining deploy stage:</p> <ul> <li>Clone the repository with the added library;</li> <li>Create a \"stages\" directory in the root;</li> <li>Create a Jenkinsfile with default content:<pre><code>@Library(['edp-library-stages', 'edp-library-pipelines']) _\n\nDeploy()\n</code></pre> </li> </ul> <ul> <li>Create a groovy file with a meaningful name, e.g. CustomDeployStage.groovy;</li> <li>Put the required construction and your own logic into the file:<pre><code>import com.epam.edp.stages.impl.cd.Stage\n\n@Stage(name = \"deploy\")\nclass CustomDeployStage {\n    Script script\n\n    void run(context) {\n    --------------- Put your own logic here ------------------\n            script.println(\"Custom deploy stage logic\")\n    --------------- Put your own logic here ------------------\n    }\n}\nreturn CustomDeployStage\n</code></pre> </li> </ul>"},{"location":"user-guide/customize-cd-pipeline/#add-a-new-stage-using-shared-library-via-custom-global-pipeline-libraries","title":"Add a New Stage Using Shared Library via Custom Global Pipeline Libraries","text":"<p>Note</p> <p>To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page.</p> <p>To redefine any stage and add custom logic using global pipeline libraries, perform the steps below:</p> <ul> <li> <p>Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language:</p> <p> Create library </p> <p>Select the required fields to build your library:</p> <p> Advanced settings </p> </li> </ul> <ul> <li>Clone the repository with the added library;</li> <li>Create a directory with the name <code>src/com/epam/edp/customStages/impl/cd/impl/</code> in the library repository, for instance: <code>src/com/epam/edp/customStages/impl/cd/impl/EmailNotify.groovy</code>;</li> <li>Add a Groovy file with another name to the same stages catalog, for instance \u2013 <code>EmailNotify.groovy</code>:<pre><code>package com.epam.edp.customStages.impl.cd.impl\n\nimport com.epam.edp.stages.impl.cd.Stage\n\n@Stage(name = \"notify\")\nclass Notify {\n    Script script\n    void run(context) {\n    --------------- Put your own logic here ------------------\n    script.println(\"Send notification logic\")\n    --------------- Put your own logic here ------------------\n   }\n}\n</code></pre> </li> </ul> <ul> <li> <p>Create a Jenkinsfile with default content and the added custom library to Jenkins:</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name']) _\n\nDeploy()\n</code></pre> <p>Note</p> <p><code>edp-custom-shared-library-name</code> is the name of your Custom Global Pipeline Library that should be added to the Jenkins Global Settings.</p> </li> </ul> <ul> <li> <p>Add a new stage to the STAGES parameter of the Jenkins job of your CD pipeline:</p> <p> Stages parameter </p> <p>Warning</p> <p>To make this stage permanently present, please modify the job provisioner.</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> </li> </ul> <ul> <li>Run the job to check that the new stage has been running during the execution.</li> </ul>"},{"location":"user-guide/customize-cd-pipeline/#redefine-a-default-stage-logic-via-custom-global-pipeline-libraries","title":"Redefine a Default Stage Logic via Custom Global Pipeline Libraries","text":"<p>Note</p> <p>To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page.</p> <p>By default, the following stages are implemented in EDP pipeline framework:</p> <ul> <li>deploy,</li> <li>deploy-helm,</li> <li>autotests,</li> <li>manual (Manual approve),</li> <li>promote-images.</li> </ul> <p>Using one of these names for annotation in your own class will lead to redefining the default logic with your own.</p> <p>To redefine any stage and add custom logic using global pipeline libraries, perform the steps below:</p> <ul> <li> <p>Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language:</p> <p> Create library </p> <p>Select the required fields to build your library:</p> <p> Advanced settings </p> </li> </ul> <ul> <li>Clone the repository with the added library;</li> <li>Create a directory with the name <code>src/com/epam/edp/customStages/impl/cd/impl/</code> in the library repository, for instance: <code>src/com/epam/edp/customStages/impl/cd/impl/CustomDeployStage.groovy;</code>;</li> <li>Add a Groovy file with another name to the same stages catalog, for instance \u2013 <code>CustomDeployStage.groovy</code>:<pre><code>package com.epam.edp.customStages.impl.cd.impl\n\nimport com.epam.edp.stages.impl.cd.Stage\n\n@Stage(name = \"deploy\")\nclass CustomDeployStage {\n    Script script\n\n    void run(context) {\n    --------------- Put your own logic here ------------------\n            script.println(\"Custom deploy stage logic\")\n    --------------- Put your own logic here ------------------\n    }\n}\n</code></pre> </li> </ul> <ul> <li> <p>Create a Jenkinsfile with default content and the added custom library to Jenkins:</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name']) _\n\nDeploy()\n</code></pre> <p>Note</p> <p><code>edp-custom-shared-library-name</code> is the name of your Custom Global Pipeline Library that should be added to the Jenkins Global Settings.</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> </li> </ul>"},{"location":"user-guide/customize-cd-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add a New Custom Global Pipeline Library</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/customize-ci-pipeline/","title":"Customize CI Pipeline","text":"<p>This chapter describes the main steps that should be followed when customizing a CI pipeline.</p>"},{"location":"user-guide/customize-ci-pipeline/#redefine-a-default-stage-logic-for-a-particular-application","title":"Redefine a Default Stage Logic for a Particular Application","text":"<p>To redefine any stage and add custom logic, perform the steps below:</p> <ol> <li> <p>Open the GitHub repository:</p> <ul> <li>Create a directory with the name \u201cstages\u201d in the application repository;</li> <li>Create a Groovy file with a meaningful name for a custom stage description, for instance: CustomSonar.groovy.</li> </ul> </li> <li> <p>Paste the copied skeleton from the reference stage and insert the necessary logic.</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> <p>The stage logic structure is the following:</p> <p>CustomSonar.groovy</p> <pre><code>import com.epam.edp.stages.impl.ci.ProjectType\nimport com.epam.edp.stages.impl.ci.Stage\n\n@Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY])\nclass CustomSonar {\n    Script script\n    void run(context) {\n        script.sh \"echo 'Your custom logic of the stage'\"\n    }\n}\nreturn CustomSonar\n</code></pre> <p>Info</p> <p>There is the ability to redefine the predefined EDP stage as well as to create it from scratch, it depends on the name that is used in the @Stage annotation. For example, using name = \"sonar\" will redefine an existing sonar stage with the same name, but using name=\"new-sonar\" will create a new stage.</p> <p>By default, the following stages are implemented in EDP:</p> <ul> <li>build</li> <li>build-image-from-dockerfile</li> <li>build-image</li> <li>build-image-kaniko</li> <li>checkout</li> <li>compile</li> <li>create-branch</li> <li>gerrit-checkout</li> <li>get-version</li> <li>git-tag</li> <li>push</li> <li>sonar</li> <li>sonar-cleanup</li> <li>tests</li> <li>trigger-job</li> </ul> <p>Mandatory points:</p> <ul> <li>Importing classes com.epam.edp.stages.impl.ci.ProjectType and com.epam.edp.stages.impl.ci.Stage;</li> <li>Annotating \"Stage\" for class - @Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]);</li> <li>Property with the type \"Script\";</li> <li>Void the \"run\" method with the \"context input parameter\" value;</li> <li>Bring the custom class back to the end of the file: return CustomSonar.</li> </ul> </li> <li> <p>Open Jenkins and make sure that all the changes are correct after the completion of the customized pipeline.</p> </li> </ol>"},{"location":"user-guide/customize-ci-pipeline/#add-a-new-stage-for-a-particular-application","title":"Add a New Stage for a Particular Application","text":"<p>To add a new stage for a particular application, perform the steps below:</p> <ol> <li>In the GitHub repository, add a Groovy file with another name to the same stages catalog.</li> <li> <p>Copy the part of a pipeline framework logic that cannot be predefined;</p> <p>The stage logic structure is the following:</p> <p>EmailNotify.groovy</p> <pre><code>import com.epam.edp.stages.impl.ci.ProjectType\nimport com.epam.edp.stages.impl.ci.Stage\n\n@Stage(name = \"email-notify\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass EmailNotify {\n    Script script\n    void run(context) {\n        -------------------'Your custom logic here'\n    }\n}\nreturn EmailNotify\n</code></pre> </li> <li> <p>Open the default set of stages and add a new one into the Default Value field by saving the respective type {\"name\": \"email-notify\"}, save the changes:   Add stage </p> </li> <li> <p>Open Jenkins to check the pipeline; as soon as the checkout stage is passed, the new stage will appear in the pipeline:   Check stage </p> <p>Warning</p> <p>To make this stage permanently present, please modify the job provisioner.</p> </li> </ol>"},{"location":"user-guide/customize-ci-pipeline/#redefine-a-default-stage-logic-via-custom-global-pipeline-libraries","title":"Redefine a Default Stage Logic via Custom Global Pipeline Libraries","text":"<p>Note</p> <p>To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page.</p> <p>To redefine any stage and add custom logic using global pipeline libraries, perform the steps below:</p> <ol> <li> <p>Open the GitHub repository:</p> <ul> <li>Create a directory with the name <code>/src/com/epam/edp/customStages/impl/ci/impl/stageName/</code> in the library repository, for instance: <code>/src/com/epam/edp/customStages/impl/ci/impl/sonar/</code>;</li> <li>Create a Groovy file with a meaningful name for a custom stage description, for instance \u2013 <code>CustomSonar.groovy</code>.</li> </ul> </li> <li> <p>Paste the copied skeleton from the reference stage and insert the necessary logic.</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> <p>The stage logic structure is the following:</p> <p>CustomSonar.groovy</p> <pre><code>package com.epam.edp.customStages.impl.ci.impl.sonar\n\nimport com.epam.edp.stages.impl.ci.ProjectType\nimport com.epam.edp.stages.impl.ci.Stage\n\n@Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY])\nclass CustomSonar {\n    Script script\n    void run(context) {\n        script.sh \"echo 'Your custom logic of the stage'\"\n    }\n}\n</code></pre> <p>Info</p> <p>There is the ability to redefine the predefined EDP stage as well as to create it from scratch, it depends on the name that is used in the @Stage annotation. For example, using name = \"sonar\" will redefine an existing sonar stage with the same name, but using name=\"new-sonar\" will create a new stage.</p> <p>By default, the following stages are implemented in EDP:</p> <ul> <li>build</li> <li>build-image-from-dockerfile</li> <li>build-image</li> <li>build-image-kaniko</li> <li>checkout</li> <li>compile</li> <li>create-branch</li> <li>gerrit-checkout</li> <li>get-version</li> <li>git-tag</li> <li>push</li> <li>sonar</li> <li>sonar-cleanup</li> <li>tests</li> <li>trigger-job</li> </ul> <p>Mandatory points:</p> <ul> <li>Defining a package com.epam.edp.customStages.impl.ci.impl.stageName;</li> <li>Importing classes com.epam.edp.stages.impl.ci.ProjectType and com.epam.edp.stages.impl.ci.Stage;</li> <li>Annotating \"Stage\" for class - @Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]);</li> <li>Property with the type \"Script\";</li> <li>Void the \"run\" method with the \"context input parameter\" value.</li> </ul> </li> </ol> <p>3.Open Jenkins and make sure that all the changes are correct after the completion of the customized pipeline.</p>"},{"location":"user-guide/customize-ci-pipeline/#add-a-new-stage-using-shared-library-via-custom-global-pipeline-libraries","title":"Add a New Stage Using Shared Library via Custom Global Pipeline Libraries","text":"<p>Note</p> <p>To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page.</p> <p>To redefine any stage and add custom logic using global pipeline libraries, perform the steps below:</p> <ol> <li> <p>Open the GitHub repository:</p> <ul> <li>Create a directory with the name <code>/src/com/epam/edp/customStages/impl/ci/impl/stageName/</code> in the library repository, for instance: <code>/src/com/epam/edp/customStages/impl/ci/impl/emailNotify/</code>;</li> <li>Add a Groovy file with another name to the same stages catalog, for instance \u2013 <code>EmailNotify.groovy</code>.</li> </ul> </li> <li> <p>Copy the part of a pipeline framework logic that cannot be predefined;</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> <p>The stage logic structure is the following:</p> <p>EmailNotify.groovy</p> <pre><code>package com.epam.edp.customStages.impl.ci.impl.emailNotify\n\nimport com.epam.edp.stages.impl.ci.ProjectType\nimport com.epam.edp.stages.impl.ci.Stage\n\n@Stage(name = \"email-notify\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass EmailNotify {\n    Script script\n    void run(context) {\n        -------------------'Your custom logic here'\n    }\n}\n</code></pre> </li> <li> <p>Open the default set of stages and add a new one into the Default Value field by saving the respective type {\"name\": \"email-notify\"}, save the changes:   Add stage </p> </li> <li> <p>Open Jenkins to check the pipeline; as soon as the checkout stage is passed, the new stage will appear in the pipeline:   Check stage </p> <p>Warning</p> <p>To make this stage permanently present, please modify the job provisioner.</p> </li> </ol>"},{"location":"user-guide/customize-ci-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add a New Custom Global Pipeline Library</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Add Security Scanner</li> </ul>"},{"location":"user-guide/d-d-diagram/","title":"Delivery Dashboard Diagram","text":"<p>Admin Console allows getting the general visualization of all the relations between CD pipeline, stages, codebases, branches, and image streams that are elements with the specific icon. To open the current project diagram, navigate to the Delivery Dashboard Diagram section on the navigation bar:</p> <p> Delivery dashboard </p> <p>Info</p> <p>All the requested changes (deletion, creation, adding) are displayed immediately on the Delivery Dashboard Diagram.</p> <p>Possible actions when using dashboard:</p> <ul> <li>To zoom in or zoom out the diagram scale, scroll up / down.</li> <li>To move the diagram, click and drag.</li> <li>To move an element, click it and drag to the necessary place.</li> <li>To see the relations for one element, click this element.</li> <li>To see the whole diagram, click the empty space.</li> </ul>"},{"location":"user-guide/d-d-diagram/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Admin Console</li> </ul>"},{"location":"user-guide/dockerfile-stages/","title":"Use Dockerfile Linters for Code Review Pipeline","text":"<p>This section contains the description of dockerbuild-verify, dockerfile-lint stages which one can use in Code Review pipeline.</p> <p>These stages help to obtain a quick response on the validity of the code in the Code Review pipeline in Kubernetes for all types of applications supported by EDP out of the box.</p> <p> Add stages </p> <p>Inspect the functions performed by the following stages:</p> <ol> <li> <p>dockerbuild-verify stage collects artifacts and builds an image from the Dockerfile without push to registry. This stage is intended to check if the image is built.</p> </li> <li> <p>dockerfile-lint stage launches the hadolint command in order to check the Dockerfile.</p> </li> </ol>"},{"location":"user-guide/dockerfile-stages/#related-articles","title":"Related Articles","text":"<ul> <li>Use Terraform Library in EDP</li> <li>EDP Pipeline Framework</li> <li>Promote Docker Images From ECR to Docker Hub</li> <li>CI Pipeline for Container</li> </ul>"},{"location":"user-guide/ecr-to-docker-stages/","title":"Promote Docker Images From ECR to Docker Hub","text":"<p>This section contains the description of the ecr-to-docker stage, available in the Build pipeline.</p> <p>The ecr-to-docker stage is intended to perform the push of Docker images collected from the Amazon ECR cluster storage to Docker Hub repositories, where the image becomes accessible to everyone who wants to use it. This stage is optional and is designed for working with various EDP components.</p> <p>Note</p> <p>When pushing the image from ECR to Docker Hub using crane, the SHA-256 value remains unchanged.</p> <p>To run the ecr-to-docker stage just for once, navigate to the Build with Parameters option, add this stage to the stages list, and click Build.  To add the ecr-to-docker stage to the pipeline, modify the job provisioner.</p> <p>Note</p> <p>To push properly the Docker image from the ECR storage, the ecr-to-docker stage should follow the build-image-kaniko stage. Add custom lib2 </p> <p>The ecr-to-docker stage contains a specific script that launches the following actions:</p> <ol> <li>Performs authorization in AWS ECR in the EDP private storage via awsv2.</li> <li>Performs authorization in the Docker Hub.</li> <li> <p>Checks whether a similar image exists in the Docker Hub in order to avoid its overwriting.</p> <ul> <li>If a similar image exists in the Docker Hub, the script will return the message about it and stop the execution. The ecr-to-docker stage in the Build pipeline will be marked in red.</li> <li>If there is no similar image, the script will proceed to promote the image using crane.</li> </ul> </li> </ol>"},{"location":"user-guide/ecr-to-docker-stages/#create-secret-for-ecr-to-docker-stage","title":"Create Secret for ECR-to-Docker Stage","text":"<p>The ecr-to-docker stage expects the authorization credentials to be added as Kubernetes secret into EDP-installed namespace. To create the dockerhub-credentials secret, run the following command:</p> <pre><code>  kubectl -n &lt;edp-project&gt; create secret generic dockerhub-credentials \\\n  --from-literal=accesstoken=&lt;dockerhub_access_token&gt; \\\n  --from-literal=account=&lt;dockerhub_account_name&gt; \\\n  --from-literal=username=&lt;dockerhub_user_name&gt;\n</code></pre> <p>Note</p> <ul> <li>The \u2039dockerhub_access_token\u203a should be created beforehand and in accordance with the official Docker Hub instruction.</li> <li>The \u2039dockerhub_account_name\u203a and \u2039dockerhub_user_name\u203a for the organization account repository will differ and be identical for the personal account repository.</li> <li>Pay attention that the Docker Hub repository for images uploading should be created beforehand and named by the following pattern: \u2039dockerhub_account_name\u203a/\u2039Application Name\u203a, where the \u2039Application Name\u203a should match the application name in the EDP Admin Console.</li> </ul>"},{"location":"user-guide/ecr-to-docker-stages/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Pipeline Framework</li> <li>Manage Access Token</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/helm-release-deletion/","title":"Helm Release Deletion","text":"<p>The Helm release deletion stage provides the ability to remove Helm releases from the namespace.</p> <p>Note</p> <p>Pay attention that this stages will remove all Helm releases from the namespace. To avoid loss of important data, before using this stage, make the necessary backups.</p> <p>To remove Helm releases, follow the steps below:</p> <ol> <li> <p>Add the following step to the CD pipeline <code>{\"name\":\"helm-uninstall\",\"step_name\":\"helm-uninstall\"}</code>. Alternatively, with this step, it is possible to create a custom job provisioner.</p> </li> <li> <p>Run the job. The pipeline script will remove Helm releases from the namespace.</p> </li> </ol>"},{"location":"user-guide/helm-release-deletion/#related-articles","title":"Related Articles","text":"<ul> <li>Customize CD Pipeline</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/helm-stages/","title":"Helm Chart Testing and Documentation Tools","text":"<p>This section contains the description of the helm-lint and helm-docs stages that can be used in the Code Review pipeline.</p> <p>The stages help to obtain a quick response on the validity of the helm chart code and documentation in the Code Review pipeline.</p> <p>Inspect the functions performed by the following stages:</p> <ol> <li> <p>helm-lint stage launches the ct lint --charts-deploy-templates/ command in order to validate the chart.</p> <p> Helm lint </p> <ul> <li>chart_schema.yaml - this file contains some rules by which the chart validity is checked. These rules are necessary for the YAML scheme validation.</li> </ul> <p>See the current scheme:</p> View: chart_schema.yaml <pre><code>name: str()\nhome: str()\nversion: str()\ntype: str()\napiVersion: str()\nappVersion: any(str(), num())\ndescription: str()\nkeywords: list(str(), required=False)\nsources: list(str(), required=True)\nmaintainers: list(include('maintainer'), required=True)\ndependencies: list(include('dependency'), required=False)\nicon: str(required=False)\nengine: str(required=False)\ncondition: str(required=False)\ntags: str(required=False)\ndeprecated: bool(required=False)\nkubeVersion: str(required=False)\nannotations: map(str(), str(), required=False)\n---\nmaintainer:\nname: str(required=True)\nemail: str(required=False)\nurl: str(required=False)\n---\ndependency:\nname: str()\nversion: str()\nrepository: str()\ncondition: str(required=False)\ntags: list(str(), required=False)\nenabled: bool(required=False)\nimport-values: any(list(str()), list(include('import-value')), required=False)\nalias: str(required=False)\n</code></pre> <ul> <li>ct.yaml - this file contains rules that will skip the validation of certain rules.</li> </ul> <p>To get more information about the chart testing lint, please refer to the ct_lint documentation.</p> </li> <li> <p>helm-docs stage helps to validate the generated documentation for the Helm deployment templates in the Code Review pipeline for all types of applications supported by EDP. This stage launches the helm-docs command in order to validate the chart documentation file existence and verify its relevance.</p> <p>Requirements: helm-docs v1.10.0</p> <p>Note</p> <p>The helm-docs stage is optional. To extend the pipeline with an additional stage, please refer to the Configure Code Review Pipeline page.</p> <p> Helm docs </p> <p>Note</p> <p>The example of the generated documentation.</p> </li> </ol>"},{"location":"user-guide/helm-stages/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Pipeline Framework</li> </ul>"},{"location":"user-guide/library/","title":"Library","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing libraries.</p>"},{"location":"user-guide/library/#check-and-remove-library","title":"Check and Remove Library","text":"<p>As soon as the library is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins for this library. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added library will be listed in the Libraries list allowing to do the following:</p> <p> Library menu </p> <ol> <li> <p>Create another library by clicking the Create button and performing the same steps as described on the Add Library page;</p> </li> <li> <p>Open library data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the created/cloned/imported library.</li> <li>Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type).</li> <li> <p>Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields:</p> <ul> <li>Build Number - indicates the current build number;</li> <li>Last Successful Build - indicates the last successful build number.</li> </ul> </li> </ul> <ul> <li>Status Info - displays all the actions that were performed during the creation/cloning/importing process.</li> </ul> </li> <li> <p>Edit the library codebase by clicking the pencil icon. For details see the Edit Existing Codebase section.</p> </li> <li> <p>Remove library with the corresponding database and Jenkins pipelines:</p> <ul> <li>Click the delete icon next to the library name;</li> <li>Type the required library name;</li> <li>Confirm the deletion by clicking the Delete button.</li> </ul> <p>Note</p> <p>The library that is used in a CD pipeline cannot be removed.</p> <p> Library menu </p> </li> <li> <p>Select a number of existing libraries to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page.</p> </li> <li> <p>Sort the existing libraries in a list by clicking the Name title. The libraries will be displayed in an alphabetical order.</p> </li> <li> <p>Search the necessary application by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the library name, language or a build tool.</p> </li> <li> <p>Navigate between pages, if the number of libraries exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"user-guide/library/#edit-existing-codebase","title":"Edit Existing Codebase","text":"<p>The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for applications via the Edit Codebase page.</p> <ol> <li> <p>Perform the editing from one of the following sections on the Admin Console interface:</p> <p> Edit library </p> <ul> <li> <p>Navigate to the codebase overview page and click the pencil icon, or</p> <p> Edit library </p> </li> </ul> <ul> <li> <p>Navigate to the codebase list page and click the pencil icon.</p> <p> Edit library </p> </li> </ul> </li> <li> <p>To enable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>mark the Integrate with Jira server check box and fill in the necessary fields;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</li> </ul> </li> <li> <p>To disable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>unmark the Integrate with Jira server check box;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</li> </ul> </li> </ol> <p>As a result, the necessary changes will be applied.</p>"},{"location":"user-guide/library/#add-a-new-branch","title":"Add a New Branch","text":"<p>Note</p> <p>Pay attention when specifying the branch name: the branch name is involved in the formation of the application version, so it must comply with the versioning semantic rules for the application.</p> <p>When adding a library, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li> <p>Navigate to the Branches block and click the Create button:</p> <p> Add branch </p> </li> <li> <p>Fill in the required fields:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch;</p> <p>b. Branch Name - type the branch name. Pay attention that this field remain static if you create a release branch.</p> <p>c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number;</p> <p>f. Click the Proceed button and wait until the new branch will be added to the list.</p> </li> </ol> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer to Advanced Settings Menu section of the Admin Console user guide.</p> <p>The default library repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"user-guide/library/#remove-branch","title":"Remove Branch","text":"<p>In order to remove the added branch with the corresponding  record in the Admin Console database, do the following:</p> <ol> <li> <p>Navigate to the Branches block by clicking the library name link in the Libraries list;</p> </li> <li> <p>Click the delete icon related to the necessary branch:</p> <p> Remove branch </p> </li> <li> <p>Enter the branch name and click the Delete button;</p> </li> </ol> <p>Note</p> <p>The default master branch cannot be removed.</p>"},{"location":"user-guide/library/#related-articles","title":"Related Articles","text":"<ul> <li>Add Library</li> </ul>"},{"location":"user-guide/opa-stages/","title":"Use Open Policy Agent","text":"<p>Open Policy Agent (OPA) is a policy engine that provides:</p> <ul> <li>High-level declarative policy language Rego;</li> <li>API and tooling for policy execution.</li> </ul> <p>EPAM Delivery Platform ensures the implemented Open Policy Agent support allowing to work with Open Policy Agent bundles that is processed by means of stages in the Code Review and Build pipelines. These pipelines are expected to be created after the Rego OPA Library is added.</p>"},{"location":"user-guide/opa-stages/#code-review-pipeline-stages","title":"Code Review Pipeline Stages","text":"<p>In the Code Review pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository.</p> </li> <li> <p>tests stage containing a script that performs the following actions:</p> <p>2.1. Runs policy tests.</p> <p>2.2. Converts OPA test results into JUnit format.</p> <p>2.3. Publishes JUnit-formatted results to Jenkins.</p> </li> </ol>"},{"location":"user-guide/opa-stages/#build-pipeline-stages","title":"Build Pipeline Stages","text":"<p>In the Build pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository.</p> </li> <li> <p>get-version optional stage, a step where library version is determined either via:</p> <p>2.1. Standard EDP versioning functionality.</p> <p>2.2. Manually specified version. In this case .manifest file in a root directory MUST be provided. File must contain a JSON document with revision field. Minimal example: <code>{ \"revision\": \"1.0.0\" }\"</code>.</p> </li> <li> <p>tests stage containing a script that performs the following actions:   3.1. Runs policy tests.   3.2. Converts OPA test results into JUnit format.   3.3. Publishes JUnit-formatted results to Jenkins.</p> </li> <li> <p>git-tag stage, a standard step where git branch is tagged with a version.</p> </li> </ol>"},{"location":"user-guide/opa-stages/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Pipeline Framework</li> </ul>"},{"location":"user-guide/pipeline-framework/","title":"EDP Pipeline Framework","text":"<p>This chapter provides detailed information about the EDP pipeline framework concepts and parts, as well as the accurate data about the <code>Code Review</code>, <code>Build</code> and <code>Deploy</code> pipelines with the respective stages.</p>"},{"location":"user-guide/pipeline-framework/#edp-pipeline-framework-overview","title":"EDP Pipeline Framework Overview","text":"<p>Note</p> <p>The whole logic is applied to Jenkins as it is the main tool for the CI/CD processes organization.</p> <p> EDP pipeline framework basic </p> <p>The general EDP Pipeline Framework consists of several parts:</p> <ul> <li>Jenkinsfile - a text file that keeps the definition of a Jenkins Pipeline and is checked into source control. Every Job has its Jenkinsfile stored in the specific application repository and in Jenkins as the plain text. The behavior logic of the pipelines can be customized easily by modifying a source code which is always copied to the EDP repository after the EDP installation.</li> </ul> <p> Jenkinsfile example </p> <ul> <li>Loading Shared Libraries - a part where every job loads libraries with the help of the shared libraries mechanism for Jenkins that allows to create reproducible pipelines, write them uniformly, and manage the update process. There are two main libraries: EDP Pipelines with the common logic described for the main pipelines Code Review, Build, Deploy pipelines and EDP Stages library that keeps the description of the stages for every pipeline.</li> </ul> <ul> <li>Run Stages - a part where the predefined default stages are launched.</li> </ul> <p> Pipeline script </p>"},{"location":"user-guide/pipeline-framework/#cicd-jobs-comparison","title":"CI/CD Jobs Comparison","text":"<p>Explore the CI and CD job comparison. Please note that the dynamic stages order can be changed, meanwhile, the predefined stages order in the reference pipeline cannot be changed, i.e. only the predefined stages set can be run.</p> <p> CI/CD jobs comparison </p>"},{"location":"user-guide/pipeline-framework/#context","title":"Context","text":"<p>Context - a variable that stores and transfers all necessary parameters between stages that are used by pipeline during performing.</p> <ol> <li>The context type is \"Map\".</li> <li>Each stage has input and output context.</li> <li>Each stage has a mandatory input context.</li> </ol> <p>Note</p> <p>If the input context isn't transferred, the stage will be failed.</p>"},{"location":"user-guide/pipeline-framework/#annotations-for-cicd-stages","title":"Annotations for CI/CD Stages","text":"<p>Annotation for CI Stages:</p> <ul> <li>The annotation type is \"Map\";</li> <li>The annotation consists of the name, buildTool, and codebaseType.</li> </ul> <p>Annotation for CD Stages:</p> <ul> <li>The annotation type is \"Map\";</li> <li>The annotation consists of a name.</li> </ul>"},{"location":"user-guide/pipeline-framework/#code-review-pipeline","title":"Code Review Pipeline","text":"<p>CodeReview() \u2013 a function that allows using the EDP implementation for the Code Review pipeline.</p> <p>Note</p> <p>All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context.</p> <p>The Code Review pipeline consists of several steps:</p> <p>On the master:</p> <ul> <li>Initialization of all objects (Platform, Job, Gerrit, Nexus, Sonar, Application, StageFactory) and loading of the default implementations of EDP stages.</li> </ul> <p>On a particular Jenkins agent that depends on the build tool:</p> <ul> <li>Creating workdir for application sources;</li> <li>Loading build tool implementation for a particular application;</li> <li>Run in a loop all stages (From) and run them either in parallel or one by one.</li> </ul>"},{"location":"user-guide/pipeline-framework/#code-review-pipeline-overview","title":"Code Review Pipeline Overview","text":"<p>Using in pipelines - @Library(['edp-library-pipelines@version'])</p> <p>The corresponding enums, interfaces, classes, and their methods can be used separately from the EDP Pipelines library function (please refer to Table 1 and Table 2).</p> <p>Table 1.  Enums and Interfaces with the respective properties, methods, and examples.</p> <p> Enums Interfaces PlatformType:  - OPENSHIFT  - KUBERNETES  JobType:  - CODEREVIEW  - BUILD  - DEPLOY BuildToolType:  - MAVEN  - GRADLE  - NPM  - DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".  Methods: getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example: <code>context.platform.getJsonPathValue(''cm'',</code><code>''project-settings'', ''.data.username'')</code>. BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. Should be invoked on Jenkins build agents. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus. Methods: init: return parameters of buildTool that are needed for running stages. Example:  <code>context.buildTool = new BuildToolFactory().</code><code>getBuildToolImpl</code><code>(context.application.config.build_tool, this,</code><code>context.nexus) context.buildTool.init()</code>. <p></p> <p>Table 2.  Classes with the respective properties, methods, and examples.</p> Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting an implementation of CLI of the platform. At the moment OpenShift and Kubernetes are supported. Methods: <code>getPlatformImpl(PlatformType platform, Script script): return Class Platform</code>. Example:  <code>context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)</code>. Application(String name, Platform platform, Script script) - Class that describes the application object. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). String name - Name for the application for creating an object. Map config - Map of configuration settings for the particular application that is loaded from config map project-settings. String version - Application version, initially empty. Is set on the get-version step. String deployableModule - The name of the deployable module for multi-module applications, initially empty. String buildVersion - Version of the built artifact, contains build number of Job initially empty. String deployableModuleDir - The name of deployable module directory for multi-module applications, initially empty. Array imageBuildArgs - List of arguments for building an application Docker image. Methods: setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map. Example: <code>context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project)</code> Job(type: JobType.value, platform: Platform, script: Script) - Class that describes the Gerrit tool. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). JobType.value type. String deployTemplatesDirectory - The name of the directory in application repository where deploy templates are located. It can be set for a particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter. String edpName - The name of the EDP Project. Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable. String envToPromote - The name of the environment for promoting images. Boolean promoteImages - Defines whether images should be promoted or not. Methods: getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of the Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to the existing description of the Jenkins job. printDebugInfo(Map context): print context info to the log of Jenkins' job. runStage(String stage_name, Map context): run the particular stage according to its name. Example: <code>context.job = new Job(JobType.CODEREVIEW.value,</code> <code>context.platform, this)</code> <code>context.job.init()</code> <code>context.job.printDebugInfo(context)</code> <code>context.job.setDisplayName(\"test\")</code> <code>context.job.setDescription(\"Name: ${context.application.config.name}\")</code> Gerrit(Job job, Platform platform, Script script) - Class that describes the Gerrit tool. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String credentialsId - Credential Id in Jenkins for Gerrit.String autouser - Username of an auto user in Gerrit for integration with Jenkins.String host - Gerrit host.String project - the project name of the built application.String branch - branch to build the application from.String changeNumber - change number of Gerrit commit.String changeName - change name of Gerrit commit.String refspecName - refspecName of Gerrit commit.String sshPort - Gerrit ssh port number.String patchsetNumber - patchsetNumber of Gerrit commit.Methods: init(): set all the properties of Gerrit object. Example: <code>context.gerrit = new Gerrit(context.job, context.platform, this)</code> <code>context.gerrit.init()</code> Nexus(Job job, Platform platform, Script script) - Class that describes the Nexus tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String autouser - Username of an auto user in Nexus for integration with Jenkins.String credentialsId - Credential Id in Jenkins for Nexus.String host - Nexus host.String port - Nexus http(s) port.String repositoriesUrl - Base URL of repositories in Nexus.String restUrl - URL of Rest API.Methods:init(): set all the properties of Nexus objectExample: <code>context.nexus = new Nexus(context.job, context.platform, this)</code> <code>context.nexus.init()</code> Sonar(Job job, Platform platform, Script script) - Class that describes the Sonar tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String route - External route of the sonar application.Methods:init(): set all the properties of Sonar objectExample: <code>context.sonar = new Sonar(context.job, context.platform, this)</code> <code>context.sonar.init()</code>"},{"location":"user-guide/pipeline-framework/#code-review-pipeline-stages","title":"Code Review Pipeline Stages","text":"<p>Each EDP stage implementation has run method that is as input parameter required to pass the \"Map\" context with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific.</p> <p>The Code Review pipeline includes the following default stages: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Tests \u2192 Sonar.</p> <p>Info</p> <p>To get the full description of every stage, please refer to the EDP Stages Framework section.</p>"},{"location":"user-guide/pipeline-framework/#how-to-redefine-or-extend-the-edp-pipeline-stages-library","title":"How to Redefine or Extend the EDP Pipeline Stages Library","text":"<p>Inspect the points below to redefine or extend the EDP Pipeline Stages Library:</p> <ul> <li>Create \u201cstage\u201d folder in your App repository.</li> <li>Create a Groovy file with a meaningful name for the custom stage description. For instance \u2013 CustomBuildMavenApplication.groovy.</li> <li>Describe the stage logic.</li> </ul> <p>Redefinition:</p> <pre><code>import com.epam.edp.stages.ProjectType\nimport com.epam.edp.stages.Stage\n@Stage(name = \"compile\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass CustomBuildMavenApplication {\nScript script\nvoid run(context) {\nscript.sh \"echo 'Your custom logic of the stage'\"\n}\n}\nreturn CustomBuildMavenApplication\n</code></pre> <p>Extension:</p> <pre><code>import com.epam.edp.stages.ProjectType\nimport com.epam.edp.stages.Stage\n@Stage(name = \"new-stage\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass NewStageMavenApplication {\nScript script\nvoid run(context) {\nscript.sh \"echo 'Your custom logic of the stage'\"\n}\n}\nreturn NewStageMavenApplication\n</code></pre>"},{"location":"user-guide/pipeline-framework/#using-edp-stages-library-in-the-pipeline","title":"Using EDP Stages Library in the Pipeline","text":"<p>In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following:</p> <ul> <li>import library - @Library(['edp-library-stages'])</li> <li>import StageFactory class - import com.epam.edp.stages.StageFactory</li> <li>define context Map \u2013 context = [:]</li> <li>define stagesFactory instance and load EDP stages:</li> </ul> <pre><code>  context.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n</code></pre> <p>After that, there is the ability to run any EDP stage beforehand by defining a necessary context: <code>context.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)</code></p> <p>For instance, the pipeline can look like:</p> <pre><code>@Library(['edp-library-stages']) _\n\nimport com.epam.edp.stages.StageFactory\nimport org.apache.commons.lang.RandomStringUtils\n\ncontext = [:]\n\nnode('maven') {\ncontext.workDir = new File(\"/tmp/${RandomStringUtils.random(10, true, true)}\")\ncontext.workDir.deleteDir()\n\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.gerrit = [:]\ncontext.application = [:]\ncontext.application.config = [:]\ncontext.buildTool = [:]\ncontext.nexus = [:]\n\n\n\nstage(\"checkout\") {\ncontext.gerrit.branch = \"master\"\ncontext.gerrit.credentialsId = \"jenkins\"\ncontext.application.config.cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\"\ncontext.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)\n}\n\n\nstage(\"compile\") {\ncontext.buildTool.command = \"mvn\"\ncontext.nexus.credentialsId = \"nexus\"\ncontext.factory.getStage(\"compile\",\"maven\",\"application\").run(context)\n}\n}\n</code></pre> <p>Or in a declarative way:</p> <pre><code>@Library(['edp-library-stages']) _\n\nimport com.epam.edp.stages.StageFactory\nimport org.apache.commons.lang.RandomStringUtils\n\ncontext = [:]\n\npipeline {\nagent { label 'maven' }\nstages {\nstage('Init'){\nsteps {\nscript {\ncontext.workDir = new File(\"/tmp/${RandomStringUtils.random(10, true, true)}\")\ncontext.workDir.deleteDir()\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.gerrit = [:]\ncontext.application = [:]\ncontext.application.config = [:]\ncontext.buildTool = [:]\ncontext.nexus = [:]\n}\n}\n}\n\nstage(\"Checkout\") {\nsteps {\nscript {\ncontext.gerrit.branch = \"master\"\ncontext.gerrit.credentialsId = \"jenkins\"\ncontext.application.config.cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\"\ncontext.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)\n}\n}\n}\n\nstage('Compile') {\nsteps {\nscript {\ncontext.buildTool.command = \"mvn\"\ncontext.nexus.credentialsId = \"nexus\"\ncontext.factory.getStage(\"compile\",\"maven\",\"application\").run(context)\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"user-guide/pipeline-framework/#build-pipeline","title":"Build Pipeline","text":"<p>Build() \u2013 a function that allows using the EDP implementation for the Build pipeline. All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context.</p> <p>The Build pipeline consists of several steps:</p> <p>On the master:</p> <ul> <li>Initialization of all objects (Platform, Job, Gerrit, Nexus, Sonar, Application, StageFactory) and loading default implementations of EDP stages.</li> </ul> <p>On a particular Jenkins agent that depends on the build tool:</p> <ul> <li>Creating workdir for application sources;</li> <li>Loading build tool implementation for a particular application;</li> <li>Run in a loop all stages (From) and run them either in parallel or one by one.</li> </ul>"},{"location":"user-guide/pipeline-framework/#build-pipeline-overview","title":"Build Pipeline Overview","text":"<p>Using in pipelines - @Library(['edp-library-pipelines@version'])</p> <p>The corresponding enums, interfaces, classes, and their methods can be used separately from the EDP Pipelines library function (please refer to Table 3 and Table 4).</p> <p>Table 3.  Enums and Interfaces with the respective properties, methods, and examples.  Enums Interfaces PlatformType:- OPENSHIFT- KUBERNETESJobType:- CODEREVIEW- BUILD- DEPLOYBuildToolType:- MAVEN- GRADLE- NPM- DOTNET Platform() -  contains methods for working with platform CLI. At the moment only OpenShift is supported.Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Methods:getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility.Example:<code>context.platform.getJsonPathValue(\"cm\",\"project-settings\",</code><code>\".data.username\")</code>BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. Should be invoked on Jenkins build agents.Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Nexus object - Object of class Nexus. See description below:Methods:init: return parameters of buildTool that are needed for running stages.Example:<code>context.buildTool = new BuildToolFactory().getBuildToolImpl</code><code>(context.application.config.build_tool, this,</code><code>context.nexus)context.buildTool.init()</code> <p> Table 4.  Classes with the respective properties, methods, and examples.</p> Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting an implementation of CLI of the platform. At the moment OpenShift and Kubernetes are supported. Methods:getPlatformImpl(PlatformType platform, Script script): return Class PlatformExample:<code>context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)</code> Application(String name, Platform platform, Script script) - Class that describes the application object. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().String name - Name for the application for creating an object.Map config - Map of configuration settings for the particular application that is loaded from config map project-settings.String version - Application version, initially empty. Is set on the get-version step.String deployableModule - The name of the deployable module for multi-module applications, initially empty.String buildVersion - Version of the built artifact, contains build number of Job initially empty.String deployableModuleDir - The name of deployable module directory for multi-module applications, initially empty.Array imageBuildArgs - List of arguments for building the application Docker image.Methods:setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map.Example:<code>context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project)</code> Job(type: JobType.value, platform: Platform, script: Script) - Class that describes the Gerrit tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().JobType.value type.String deployTemplatesDirectory - The name of the directory in application repository, where deploy templates are located. It can be set for a particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter.String edpName - The name of the EDP Project.Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable.String envToPromote - The name of the environment for promoting images.Boolean promoteImages - Defines whether images should be promoted or not.Methods:getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job.init(): set all the properties of the Job object.setDisplayName(String displayName): set display name of the Jenkins job.setDescription(String description, Boolean addDescription = false): set new or add to the existing description of the Jenkins job.printDebugInfo(Map context): print context info to the log of Jenkins' job.runStage(String stage_name, Map context): run the particular stage according to its name.Example:<code>context.job = new Job(JobType.CODEREVIEW.value, context.platform, this) context.job.init() context.job.printDebugInfo(context) context.job.setDisplayName(\"test\") context.job.setDescription(\"Name: ${context.application.config.name}\")</code> Gerrit(Job job, Platform platform, Script script) - Class that describes the Gerrit tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String credentialsId - Credentials Id in Jenkins for Gerrit.String autouser - Username of an auto user in Gerrit for integration with Jenkins.String host - Gerrit host.String project - the project name of the built application.String branch - branch to build an application from.String changeNumber - change number of Gerrit commit.String changeName - change name of Gerrit commit.String refspecName - refspecName of Gerrit commit.String sshPort - Gerrit ssh port number.String patchsetNumber - patchsetNumber of Gerrit commit.Methods:init(): set all the properties of Gerrit objectExample: <code>context.gerrit = new Gerrit(context.job, context.platform, this) context.gerrit.init()</code> Nexus(Job job, Platform platform, Script script) - Class that describes the Nexus tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String autouser - Username of an auto user in Nexus for integration with Jenkins.String credentialsId - Credentials Id in Jenkins for Nexus.String host - Nexus host.String port - Nexus http(s) port.String repositoriesUrl - Base URL of repositories in Nexus.String restUrl - URL of Rest API.Methods:init(): set all the properties of the Nexus object.Example:<code>context.nexus = new Nexus(context.job, context.platform, this) context.nexus.init()</code> Sonar(Job job, Platform platform, Script script) - Class that describes the Sonar tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String route - External route of the sonar application.Methods:init(): set all the properties of Sonar object.Example:<code>context.sonar = new Sonar(context.job, context.platform, this) context.sonar.init()</code>"},{"location":"user-guide/pipeline-framework/#build-pipeline-stages","title":"Build Pipeline Stages","text":"<p>Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific.</p> <p>The Build pipeline includes the following default stages: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Get version \u2192 Tests \u2192 Sonar \u2192 Build \u2192 Build Docker Image \u2192 Push \u2192 Git tag.</p> <p>Info</p> <p>To get the full description of every stage, please refer to the EDP Stages Framework section.</p>"},{"location":"user-guide/pipeline-framework/#how-to-redefine-or-extend-edp-pipeline-stages-library","title":"How to Redefine or Extend EDP Pipeline Stages Library","text":"<p>Inspect the points below to redefine or extend the EDP Pipeline Stages Library:</p> <ul> <li>Create a \u201cstage\u201d folder in the App repository.</li> <li>Create a Groovy file with a meaningful name for the custom stage description. For instance \u2013 CustomBuildMavenApplication.groovy</li> <li>Describe stage logic.</li> </ul> <p>Redefinition:</p> <pre><code>import com.epam.edp.stages.ProjectType\nimport com.epam.edp.stages.Stage\n@Stage(name = \"compile\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass CustomBuildMavenApplication {\nScript script\nvoid run(context) {\nscript.sh \"echo 'Your custom logic of the stage'\"\n}\n}\nreturn CustomBuildMavenApplication\n</code></pre> <p>Extension:</p> <pre><code>import com.epam.edp.stages.ProjectType\nimport com.epam.edp.stages.Stage\n@Stage(name = \"new-stage\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass NewStageMavenApplication {\nScript script\nvoid run(context) {\nscript.sh \"echo 'Your custom logic of the stage'\"\n}\n}\nreturn NewStageMavenApplication\n</code></pre>"},{"location":"user-guide/pipeline-framework/#using-edp-stages-library-in-the-pipeline_1","title":"Using EDP Stages Library in the Pipeline","text":"<p>In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following:</p> <ul> <li>import library - @Library(['edp-library-stages'])</li> <li>import StageFactory class - import com.epam.edp.stages.StageFactory</li> <li>define context Map \u2013 context = [:]</li> <li>define stagesFactory instance and load EDP stages:</li> </ul> <pre><code>context.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n</code></pre> <p>After that, there is the ability to run any EDP stage beforehand by defining a requirement context <code>context.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)</code></p> <p>For instance, the pipeline can look like:</p> <pre><code>@Library(['edp-library-stages']) _\n\nimport com.epam.edp.stages.StageFactory\nimport org.apache.commons.lang.RandomStringUtils\n\ncontext = [:]\n\nnode('maven') {\ncontext.workDir = new File(\"/tmp/${RandomStringUtils.random(10, true, true)}\")\ncontext.workDir.deleteDir()\n\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.gerrit = [:]\ncontext.application = [:]\ncontext.application.config = [:]\ncontext.buildTool = [:]\ncontext.nexus = [:]\n\n\n\nstage(\"checkout\") {\ncontext.gerrit.branch = \"master\"\ncontext.gerrit.credentialsId = \"jenkins\"\ncontext.application.config.cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\"\ncontext.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)\n}\n\n\nstage(\"compile\") {\ncontext.buildTool.command = \"mvn\"\ncontext.nexus.credentialsId = \"nexus\"\ncontext.factory.getStage(\"compile\",\"maven\",\"application\").run(context)\n}\n}\n</code></pre> <p>Or in a declarative way:</p> <pre><code>@Library(['edp-library-stages']) _\n\nimport com.epam.edp.stages.StageFactory\nimport org.apache.commons.lang.RandomStringUtils\n\ncontext = [:]\n\npipeline {\nagent { label 'maven' }\nstages {\nstage('Init'){\nsteps {\nscript {\ncontext.workDir = new File(\"/tmp/${RandomStringUtils.random(10, true, true)}\")\ncontext.workDir.deleteDir()\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.gerrit = [:]\ncontext.application = [:]\ncontext.application.config = [:]\ncontext.buildTool = [:]\ncontext.nexus = [:]\n}\n}\n}\n\nstage(\"Checkout\") {\nsteps {\nscript {\ncontext.gerrit.branch = \"master\"\ncontext.gerrit.credentialsId = \"jenkins\"\ncontext.application.config.cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\"\ncontext.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)\n}\n}\n}\n\nstage('Compile') {\nsteps {\nscript {\ncontext.buildTool.command = \"mvn\"\ncontext.nexus.credentialsId = \"nexus\"\ncontext.factory.getStage(\"compile\",\"maven\",\"application\").run(context)\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"user-guide/pipeline-framework/#edp-library-stages-description","title":"EDP Library Stages Description","text":"<p>Using in pipelines - @Library(['edp-library-stages@version'])</p> <p>The corresponding enums, classes, interfaces and their methods can be used separately from the EDP Stages library function (please refer to Table 5).</p> <p>Table 5.  Enums and Classes with the respective properties, methods, and examples.</p> Enums Classes ProjectType: - APPLICATION  - AUTOTESTS  - LIBRARY StageFactory() - Class that contains methods getting an implementation of the particular stage either EDP from shared library or custom from application repository.Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Map stages - Map of stages implementations.Methods:loadEdpStages(): return a list of Classes that describes EDP stages implementations.loadCustomStages(String directory): return a list of Classes that describes EDP custom stages from application repository from \"directory\". The \"directory\" should have an absolute path to files with classes of custom stages implementations. Should be run from a Jenkins agent.add(Class clazz): register class for some particular stage in stages map of StageFactory class.getStage(String name, String buildTool, String type): return an object of the class for a particular stage from stages property based on stage name and buildTool, type of application.Example:<code>context.factory = new StageFactory(script: this)</code><code>context.factory.loadEdpStages().each() { context.factory.add(it) }</code><code>context.factory.loadCustomStages(\"${context.workDir}/stages\").each() { context.factory.add(it) }</code><code>context.factory.getStage(stageName.toLowerCase(),context.application.config.build_tool.toLowerCase(),</code><code>context.application.config.type).run(context)</code>"},{"location":"user-guide/pipeline-framework/#edp-stages-framework","title":"EDP Stages Framework","text":"<p>Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific.</p> <p>Inspect the Table 6 and Table 7 that contain the full description of every stage that can be included in Code Review and Build pipelines: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Get version \u2192 Tests \u2192 Sonar \u2192 Build \u2192 Build Docker Image \u2192 Push \u2192 Git tag.</p> <p>Table 6.  The Checkout, Gerrit Checkout, Compile, Get version, and Tests stages description.</p> Checkout Gerrit Checkout Compile Get version Tests name = \"checkout\",buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- StageFactory context.factory- String context.gerrit.branch- String context.gerrit.credentialsId- String context.application.config.cloneUrl name = \"gerrit-checkout\",buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"]type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]context required:- String context.workDir- StageFactory context.factory- String context.gerrit.changeName- String context.gerrit.refspecName- String context.gerrit.credentialsId- String context.application.config.cloneUrl name = \"compile\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.sln_filenameoutput:- String context.buildTool.sln_filenamebuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.command- String context.nexus.credentialsIdbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.command- String context.nexus.credentialsIdbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.groupRepository name = \"get-version\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- Map(empty) context.application- String context.gerrit.branch- Job context.joboutput:-String context.application.deplyableModule- String context.application.deplyableModuleDir- String context.application.version- String context.application.buildVersionbuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.command- Job context.job- String context.gerrit.branchoutput:- String context.application.deplyableModuleDir- String context.application.version- String context.application.buildVersionbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.command- Job context.job- String context.gerrit.branchoutput:- String context.application.deplyableModule- String context.application.deplyableModuleDir- String context.application.version- String context.application.buildVersionbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- Job context.job- String context.gerrit.branchoutput:- String context.application.deplyableModuleDir- String context.application.version- String context.application.buildVersion name = \"tests\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDirbuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.commandbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.commandtype = [ProjectType.AUTOTESTS]context required:- String context.workDir- String context.buildTool.command- String context.application.config.report_frameworkbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir <p>Table 7.  The Sonar, Build, Build Docker Image, Push, and Git tag stages description.</p> Sonar Build Build Docker Image Push Git tag name = \"sonar\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.job.type- String context.application.name- String context.buildTool.sln_filename- String context.sonar.route- String context.gerrit.changeName(Only for codereview pipeline)- String context.gerrit.branch(Only for build pipeline)buildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.job.type- String context.nexus.credentialsId- String context.buildTool.command- String context.application.name- String context.sonarRoute- String context.gerrit.changeName(Only for codereview pipeline)- String context.gerrit.branch(Only for build pipeline)buildTool = [\"maven\"]type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]context required:- String context.workDir- String context.job.type- String context.nexus.credentialsId- String context.application.name- String context.buildTool.command- String context.sonar.route- String context.gerrit.changeName(Only for codereview pipeline)- String context.gerrit.branch(Only for build pipeline)buildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.job.type- String context.sonar.route- String context.application.name- String context.gerrit.changeName(Only for codereview pipeline)- String context.gerrit.branch(Only for build pipeline) name = \"build\"buildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.command- String context.nexus.credentialsIdbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.command- String context.nexus.credentialsIdbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.groupRepository name = \"build-image\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.application.deployableModule- String context.application.deployableModuleDir- String context.application.name- String context.application.config.language- String context.application.buildVersion- Boolean context.job.promoteImages- String context.job.envToPromotebuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.application.deployableModule- String context.application.deployableModuleDir- String context.application.name- String context.application.config.language- String context.application.buildVersion- Boolean context.job.promoteImages- String context.job.envToPromotebuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.application.deployableModule- String context.application.deployableModuleDir- String context.application.name- String context.application.config.language- String context.application.buildVersion- Boolean context.job.promoteImages- String context.job.envToPromotebuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.application.deployableModule- String context.application.deployableModuleDir- String context.application.name- String context.application.config.language- String context.application.buildVersion- Boolean context.job.promoteImages- String context.job.envToPromote name = \"push\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.gerrit.project- String context.buildTool.sln_filename- String context.buildTool.snugetApiKey- String context.buildTool.hostedRepositorybuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.application.version- String context.buildTool.hostedRepository- String context. buildTool.settingsbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.application.version- String context.buildTool.hostedRepository- String context.buildTool.commandbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.hostedRepository- String context.gerrit.autouser name = \"git-tag\"buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.gerrit.credentialsId- String context.gerrit.sshPort- String context.gerrit.host- String context.gerrit.autouser- String context.application.buildVersion"},{"location":"user-guide/pipeline-framework/#deploy-pipeline","title":"Deploy Pipeline","text":"<p>Deploy() \u2013 a function that allows using the EDP implementation for the deploy pipeline. All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context.</p> <p>The deploy pipeline consists of several steps:</p> <p>On the master:</p> <ul> <li>Initialization of all objects (Platform, Job, Gerrit, Nexus, StageFactory) and loading the default implementations of EDP stages;</li> <li>Creating an environment if it doesn`t exist;</li> <li>Deploying the last versions of the applications;</li> <li>Run predefined manual gates.</li> </ul> <p>On a particular autotest Jenkins agent that depends on the build tool:</p> <ul> <li>Creating workdir for autotest sources;</li> <li>Run predefined autotests.</li> </ul>"},{"location":"user-guide/pipeline-framework/#edp-library-pipelines-description","title":"EDP Library Pipelines Description","text":"<p>_Using in pipelines - @Library(['edp-library-pipelines@version']) _</p> <p>The corresponding enums and interfaces with their methods can be used separately from the EDP Pipelines library function (please refer to Table 8 and Table 9).</p> <p>Table 8.  Enums and Interfaces with the respective properties, methods, and examples.</p> <p> Enums Interfaces PlatformType:- OPENSHIFT- KUBERNETESJobType:- CODEREVIEW- BUILD- DEPLOYBuildToolType:- MAVEN- GRADLE- NPM- DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported.Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Methods:getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example: <code>context.platform.getJsonPathValue(\"cm\",\"project-settings\",</code><code>\".data.username\")</code> BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. (Should be invoked on Jenkins build agents)Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus.Methods:init: return parameters of buildTool that are needed for running stages. Example:<code>context.buildTool = new BuildToolFactory().getBuildToolImpl</code><code>(context.application.config.build_tool, this, context.nexus)</code><code>context.buildTool.init()</code> <p> Table 9.  Classes with the respective properties, methods, and examples.</p> Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting implementation of CLI of platform. At the moment OpenShift and Kubernetes are supported. Methods:getPlatformImpl(PlatformType platform, Script script): return Class PlatformExample: <code>context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)</code> Application(String name, Platform platform, Script script) - Class that describe the application object. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform()String name - Name for the application for creating objectMap config - Map of configuration settings for particular application that is loaded from config map project-settingsString version - Application version, initially empty. Is set on get-version step.String deployableModule - The name of deployable module for multi module applications, initially empty.String buildVersion - Version of built artifact, contains build number of Job initially emptyString deployableModuleDir - The name of deployable module directory for multi module applications, initially empty.Array imageBuildArgs - List of arguments for building application Docker imageMethods: setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config mapExample: <code>context.application = new Application(context.job, context.gerrit.project, context.platform, this)</code> <code>context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project)</code> Job(type: JobType.value, platform: Platform, script: Script) - Class that describe the Gerrit tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\"Platform platform - Object of a class Platform().JobType.value type.String deployTemplatesDirectory - The name of the directory in application repository, where deploy templates are located. Can be set for particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter.String edpName - The name of the EDP Project.Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable.String envToPromote - The name of the environment for promoting images.Boolean promoteImages - Defines whether images should be promoted or not. Methods:getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to existing description of the Jenkins job. printDebugInfo(Map context): print context info to log of Jenkins job. runStage(String stage_name, Map context): run the particular stage according to its name. Example: <code>context.job = new Job(JobType.DEPLOY.value, context.platform, this)</code> <code>context.job.init()</code> <code>context.job.printDebugInfo(context)</code> <code>context.job.setDisplayName(\"test\")</code> <code>context.job.setDescription(\"Name: ${context.application.config.name}\")</code> Gerrit(Job job, Platform platform, Script script) - Class that describe the Gerrit tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform(). Job job - Object of a class Job().String credentialsId - Credential Id in Jenkins for Gerrit. String autouser - Username of autouser in Gerrit for integration with Jenkins. String host - Gerrit host. String project - project name of built application. String branch - branch to build application from. String changeNumber - change number of Gerrit commit. String changeName - change name of Gerrit commit. String refspecName - refspecName of Gerrit commit. String sshPort - gerrit ssh port number. String patchsetNumber - patchsetNumber of Gerrit commit.Methods:init(): set all the properties of Gerrit object. Example:<code>context.gerrit = new Gerrit(context.job, context.platform, this)</code><code>context.gerrit.init()</code>. Nexus(Job job, Platform platform, Script script) - Class that describe the Nexus tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String autouser - Username of autouser in Nexus for integration with Jenkins. String credentialsId - Credential Id in Jenkins for Nexus. String host - Nexus host. String port - Nexus http(s) port. String repositoriesUrl - Base URL of repositories in Nexus. String restUrl - URL of Rest API. Methods:init(): set all the properties of Nexus object. Example: <code>context.nexus = new Nexus(context.job, context.platform, this)</code> <code>context.nexus.init()</code>."},{"location":"user-guide/pipeline-framework/#edp-library-stages-description_1","title":"EDP Library Stages Description","text":"<p>Using in pipelines - @Library(['edp-library-stages@version']) _</p> <p>The corresponding classes with methods can be used separately from the EDP Pipelines library function (please refer to Table 10).</p> <p>Table 10.  Classes with the respective properties, methods, and examples.</p> Classes Description (properties, methods, and examples) StageFactory() - Class that contains methods getting implementation of particular stage either EDP from shared library or custom from application repository. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\"Map stages - Map of stages implementationsMethods:loadEdpStages(): return list of Classes that describes EDP stages implementationsloadCustomStages(String directory): return list of Classes that describes EDP custom stages from application repository from \"directory\". The \"directory\" should be absolute path to files with classes of custom stages implementations. Should be run from Jenkins agent.add(Class clazz): register class for some particular stage in stages map of StageFactory classgetStage(String name, String buildTool, String type): return object of the class for particular stage from stages property based on stage name and buildTool, type of applicationExample:<code>context.factory = new StageFactory(script: this)</code><code>context.factory.loadEdpStages().each() { context.factory.add(it) }</code><code>context.factory.loadCustomStages(\"${context.workDir}/stages\").each() { context.factory.add(it) }</code><code>context.factory.getStage(stageName.toLowerCase(),context.application.config.build_tool.toLowerCase(),</code><code>context.application.config.type).run(context)</code>."},{"location":"user-guide/pipeline-framework/#deploy-pipeline-stages","title":"Deploy Pipeline Stages","text":"<p>Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific.</p> <p>The stages for the deploy pipeline are independent of the build tool and application type. Find below (see Table 11 ) the full description of every stage: Deploy \u2192 Automated tests \u2192 Promote Images.</p> <p>Table 11.  The Deploy, Automated tests, and Promote Images stages description.</p> Deploy Automated tests Promote Images name = \"deploy\"buildTool = nulltype = nullcontext required:\u2022   String context.workDir\u2022   StageFactory context.factory\u2022 String context.gerrit.autouser\u2022   String context.gerrit.host\u2022   String context.application.config.cloneUrl\u2022   String context.jenkins.token\u2022 String context.job.edpName\u2022   String context.job.buildUrl\u2022  String context.job.jenkinsUrl\u2022    String context.job.metaProject\u2022   List context.job.applicationsList [['name':'application1_name','version':'application1_version],...]\u2022 String context.job.deployTemplatesDirectoryoutput:\u2022   List context.job.updatedApplicaions [['name':'application1_name','version':'application1_version],...]   name = \"automation-tests\", buildTool = null, type = nullcontext required:- String context.workDir- StageFactory context.factory- String context.gerrit.credentialsId- String context.autotest.config.cloneUrl- String context.autotest.name- String context.job.stageWithoutPrefixName- String context.buildTool.settings- String context.autotest.config.report_framework name = \"promote-images\"buildTool = nulltype = nullcontext required:- String context.workDir- String context.buildTool.sln_filename- List context.job.updatedApplicaions [['name':'application1_name','version':'application1_version],...]"},{"location":"user-guide/pipeline-framework/#how-to-redefine-or-extend-edp-pipeline-stages-library_1","title":"How to Redefine or Extend EDP Pipeline Stages Library","text":"<p>Info</p> <p>Currently, the redefinition of Deploy pipeline stages is prohibited.</p>"},{"location":"user-guide/pipeline-framework/#using-edp-library-stages-in-the-pipeline","title":"Using EDP Library Stages in the Pipeline","text":"<p>In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following:</p> <ul> <li>import libraries - @Library(['edp-library-stages', 'edp-library-pipelines']) _</li> <li>import reference EDP classes(See example below)</li> <li>define context Map \u2013 context = [:]</li> <li>define reference \"init\" stage</li> </ul> <p>After that, there is the ability to run any EDP stage beforehand by defining requirement context <code>context.job.runStage(\"Deploy\", context)</code>.</p> <p>For instance, the pipeline can look like:</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines']) _\n\nimport com.epam.edp.stages.StageFactory\nimport com.epam.edp.platform.PlatformFactory\nimport com.epam.edp.platform.PlatformType\nimport com.epam.edp.JobType\n\ncontext = [:]\n\nnode('master') {\nstage(\"Init\") {\ncontext.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)\ncontext.job = new com.epam.edp.Job(JobType.DEPLOY.value, context.platform, this)\ncontext.job.init()\ncontext.job.initDeployJob()\nprintln(\"[JENKINS][DEBUG] Created object job with type - ${context.job.type}\")\n\ncontext.nexus = new com.epam.edp.Nexus(context.job, context.platform, this)\ncontext.nexus.init()\n\ncontext.jenkins = new com.epam.edp.Jenkins(context.job, context.platform, this)\ncontext.jenkins.init()\n\ncontext.gerrit = new com.epam.edp.Gerrit(context.job, context.platform, this)\ncontext.gerrit.init()\n\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.environment = new com.epam.edp.Environment(context.job.deployProject, context.platform, this)\ncontext.job.printDebugInfo(context)\ncontext.job.setDisplayName(\"${currentBuild.displayName}-${context.job.deployProject}\")\n\ncontext.job.generateInputDataForDeployJob()\n}\n\nstage(\"Pre Deploy Custom stage\") {\nprintln(\"Some custom pre deploy logic\")\n}\n\ncontext.job.runStage(\"Deploy\", context)\n\nstage(\"Post Deploy Custom stage\") {\nprintln(\"Some custom post deploy logic\")\n}\n}\n</code></pre> <p>Or in a declarative way:</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines']) _\n\nimport com.epam.edp.stages.StageFactory\nimport com.epam.edp.platform.PlatformFactory\nimport com.epam.edp.platform.PlatformType\nimport com.epam.edp.JobType\n\ncontext = [:]\n\npipeline {\nagent { label 'master'}\nstages {\nstage('Init') {\nsteps {\nscript {\ncontext.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)\ncontext.job = new com.epam.edp.Job(JobType.DEPLOY.value, context.platform, this)\ncontext.job.init()\ncontext.job.initDeployJob()\nprintln(\"[JENKINS][DEBUG] Created object job with type - ${context.job.type}\")\n\ncontext.nexus = new com.epam.edp.Nexus(context.job, context.platform, this)\ncontext.nexus.init()\n\ncontext.jenkins = new com.epam.edp.Jenkins(context.job, context.platform, this)\ncontext.jenkins.init()\n\ncontext.gerrit = new com.epam.edp.Gerrit(context.job, context.platform, this)\ncontext.gerrit.init()\n\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.environment = new com.epam.edp.Environment(context.job.deployProject, context.platform, this)\ncontext.job.printDebugInfo(context)\ncontext.job.setDisplayName(\"${currentBuild.displayName}-${context.job.deployProject}\")\n\ncontext.job.generateInputDataForDeployJob()\n}\n}\n}\nstage('Deploy') {\nsteps {\nscript {\ncontext.factory.getStage(\"deploy\").run(context)\n}\n}\n}\n\nstage('Custom stage') {\nsteps {\nprintln(\"Some custom logic\")\n}\n}\n}\n}\n</code></pre>"},{"location":"user-guide/pipeline-framework/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Library</li> <li>Add CD Pipeline</li> <li>CI Pipeline Details</li> <li>CD Pipeline Details</li> <li>Customize CI Pipeline</li> <li>Customize CD Pipeline</li> <li>EDP Stages</li> <li>Glossary</li> <li>Use Terraform Library in EDP</li> </ul>"},{"location":"user-guide/pipeline-stages/","title":"Pipeline Stages","text":"<p>Get acquainted with EDP CI/CD workflow and stages description.</p>"},{"location":"user-guide/pipeline-stages/#edp-cicd-workflow","title":"EDP CI/CD Workflow","text":"<p>Within EDP, the pipeline framework comprises the following pipelines:</p> <ul> <li>Code Review;</li> <li>Build;</li> <li>Deploy.</li> </ul> <p>Note</p> <p>Please refer to the EDP Pipeline Framework page for details.</p> <p>The diagram below shows the delivery path through these pipelines and the respective stages. Please be aware that stages may differ for different codebase types.</p> <p> stages </p>"},{"location":"user-guide/pipeline-stages/#stages-description","title":"Stages Description","text":"<p>The table below provides the details on all the stages in the EDP pipeline framework:</p> Name Dependency Description Pipeline Application Library Autotest Source code Documentation init Initiates information gathering Create Release, Code Review, Build + + Build.groovy checkout Performs for all files the checkout from a selected branch of the Git repository. For the main branch - from HEAD, for code review - from the commit Create Release, Build + + Checkout.groovy sast Launches vulnerability testing via Semgrep scanner. Pushes a vulnerability report to the DefectDojo. Build + Security compile Compiles the code, includes individual groovy files for each type of app or lib (NPM, DotNet, Python, Maven, Gradle) Code Review, Build + + Compile tests Launches testing procedure, includes individual groovy files for each type of app or lib Code Review, Build + + + Tests sonar Launches testing via SonarQube scanner and includes individual groovy files for each type of app or lib Code Review, Build + + Sonar build Builds the application, includes individual groovy files for each type of app or lib (Go, Maven, Gradle, NPM) Code Review, Build + Build create-branch EDP create-release process Creates default branch in Gerrit during create and clone strategies Create Release + + + CreateBranch.groovy trigger-job EDP create-release process Triggers \"build\" job Create Release + + + TriggerJob.groovy gerrit-checkout Performs checkout to the current project branch in Gerrit Code Review + + + GerritCheckout.groovy commit-validate Optional in EDP Admin Console Takes Jira parameters, when \"Jira Integration\" is enabled for the project in the Admin Console. Code Review + + CommitValidate.groovy dockerfile-lint Launches linting tests for Dockerfile Code Review + LintDockerApplicationLibrary.groovy Use Dockerfile Linters for Code Review dockerbuild-verify \"Build\" stage (if there are no \"COPY\" layers in Dockerfile) Launches build procedure for Dockerfile without pushing an image to the repository Code Review + BuildDockerfileApplicationLibrary.groovy Use Dockerfile Linters for Code Review helm-lint Launches linting tests for deployment charts Code Review + LintHelmApplicationLibrary.groovy Use helm-lint for Code Review helm-docs Checks generated documentation for deployment charts Code Review + HelmDocsApplication.groovy Use helm-docs for Code Review helm-uninstall Helm release deletion step to clear Helm releases Deploy + HelmUninstall.groovy Helm release deletion semi-auto-deploy-input Provides auto deploy with timeout and manual deploy flow Deploy + SemiAutoDeployInput.groovy Semi Auto Deploy get-version Defines the versioning of the project depending on the versioning schema selected in Admin Console Build + + GetVersion terraform-plan AWS credentials added to Jenkins Checks Terraform version, and installs default version if necessary, and launches terraform init, returns AWS username which used for action, and terraform plan command is called with an output of results to .tfplan file Build + TerraformPlan.groovy Use Terraform library in EDP terraform-apply AWS credentials added to Jenkins, the \"Terraform-plan\" stage Checks Terraform version, and installs default version if necessary, and launches terraform init, launches terraform plan from saves before .tfplan file, asks to approve, and run terraform apply from .tfplan file Build + TerraformApply.groovy Use Terraform library in EDP build-image-from-dockerfile Platform: OpenShift Builds Dockerfile Build + + .groovy files for building Dockerfile image build-image-kaniko Platform: k8s Builds Dockerfile using the Kaniko tool Build + BuildImageKaniko.groovy push Pushes an artifact to the Nexus repository Build + + Push create-Jira-issue-metadata \"get-version\" stage Creates a temporary CR in the namespace and after that pushes Jira Integration data to Jira ticket, and delete CR Build + + JiraIssueMetadata.groovy ecr-to-docker DockerHub credentials added to Jenkins Copies the docker image from the ECR project registry to DockerHub via the Crane tool after it is built Build + EcrToDocker.groovy Promote Docker Images From ECR to Docker Hub git-tag \"Get-version\" stage Creates a tag in SCM for the current build Build + + GitTagApplicationLibrary.groovy deploy Deploys the application Deploy + Deploy.groovy manual Works with the manual approve to proceed Deploy + ManualApprove.groovy promote-images Promotes docker images to the registry Deploy + PromoteImage.groovy <p>Note</p> <p>The Create Release pipeline is an internal EDP mechanism for adding, importing or cloning a codebase. It is not a part of the pipeline framework.</p>"},{"location":"user-guide/pipeline-stages/#related-articles","title":"Related Articles","text":"<ul> <li>Manage Jenkins CI Job Provisioner</li> <li>GitLab Webhook Configuration</li> <li>GitHub Webhook Configuration</li> </ul>"},{"location":"user-guide/prepare-for-release/","title":"Prepare for Release","text":"<p>After the necessary applications are added to EDP, they can be managed via the Admin Console. To prepare for the release, create a new branch from a selected commit with a set of CI pipelines (Code Review and Build pipelines), launch the Build pipeline, and add a new CD pipeline as well.</p> <p>Note</p> <p>Please refer to the Add Application and Add CD Pipeline for the details on how to add an application or a CD pipeline.</p> <p>Become familiar with the following preparation steps for release and a CD pipeline structure:</p> <ul> <li>Create a new branch</li> <li>Launch the Build pipeline</li> <li>Add a new CD pipeline</li> <li>Check CD pipeline structure</li> </ul>"},{"location":"user-guide/prepare-for-release/#create-a-new-branch","title":"Create a New Branch","text":"<ol> <li> <p>Open Gerrit via the Admin Console Overview page to have this tab available in a web browser.</p> </li> <li> <p>Being in Admin Console, open the Applications section and click an application from the list to create a new branch.</p> </li> <li> <p>Once clicked the application name, scroll down to the Branches menu and click the Create button to open the Create New Branch dialog box, fill in the Branch Name field by typing a branch name.</p> <ul> <li>Open the Gerrit tab in the web browser, navigate to Projects \u2192 List \u2192 select the application \u2192 Branches \u2192 gitweb for a necessary branch.</li> </ul> <ul> <li>Select the commit that will be the last included to a new branch commit.</li> </ul> <ul> <li>Copy to clipboard the commit hash.</li> </ul> </li> <li> <p>Paste the copied hash to the From Commit Hash field and click Proceed.</p> </li> </ol> <p>Note</p> <p>If the commit hash is not added to the From Commit Hash field, the new branch will be created from the head of the master branch.</p>"},{"location":"user-guide/prepare-for-release/#launch-the-build-pipeline","title":"Launch the Build Pipeline","text":"<ol> <li> <p>After the new branches are added, open the details page of every application and click the CI link that refers to Jenkins.</p> <p>Note</p> <p>The adding of a new branch may take some time. As soon as the new branch is created, it will be displayed in the list of the Branches menu.</p> </li> <li> <p>To build a new version of a corresponding Docker container (an image stream in OpenShift terms) for the new branch, start the Build pipeline. Being in Jenkins, select the new branch tab and click the link to the Build pipeline.</p> </li> <li> <p>Navigate to the Build with Parameters option and click the Build button to launch the Build pipeline.</p> <p>Warning</p> <p>The predefined default parameters should not be changed when triggering the Build pipeline, otherwise, it will lead to the pipeline failure.</p> </li> </ol>"},{"location":"user-guide/prepare-for-release/#add-a-new-cd-pipeline","title":"Add a New CD Pipeline","text":"<ol> <li> <p>Add a new CD pipeline and indicate the new release branch using the Admin console tool. Pay attention to the Applications menu, the necessary application(s) should be selected there, as well as the necessary branch(es) from the drop-down list.</p> <p>Note</p> <p>For the details on how to add a CD pipeline, please refer to the Add CD Pipeline page.</p> </li> <li> <p>As soon as the Build pipelines are successfully passed in Jenkins, the Docker Registry, which is used in EDP by default, will have the new image streams (Docker container in Kubernetes terms) version that corresponds to the current branch.</p> </li> <li> <p>Open the Kubernetes/OpenShift page of the project via the Admin Console Overview page \u2192 go to CodebaseImageStream (in OpenShift, go to Builds \u2192 Images) \u2192 check whether the image streams are created under the specific name (the combination of the application and branch names) and the specific tags are added. Click every image stream link.</p> </li> </ol>"},{"location":"user-guide/prepare-for-release/#check-cd-pipeline-structure","title":"Check CD Pipeline Structure","text":"<p>When the CD pipeline is added through the Admin Console, it becomes available in the CD pipelines list. Every pipeline has the details page with the additional information. To explore the CD pipeline structure, follow the steps below:</p> <ol> <li> <p>Open Admin Console and navigate to Continuous Delivery section, click the newly created CD pipeline name.</p> </li> <li> <p>Discover the CD pipeline components:</p> <ul> <li>Applications - the list of applications with the image streams and links to Jenkins for the respective branch;</li> </ul> <ul> <li>Stages - a set of stages with the defined characteristics and links to Kubernetes/OpenShift project;</li> </ul> <p>Note</p> <p>Initially, an environment is empty and does not have any deployment unit. When deploying the subsequent stages, the artifacts of the selected versions will be deployed to the current project and the environment will display the current stage status. The project has a standard pattern: \u2039edp-name\u203a-\u2039pipeline-name\u203a-\u2039stage-name\u203a.</p> <ul> <li>Deployed Versions - the deployment status of the specific application and the predefined stage.</li> </ul> </li> </ol>"},{"location":"user-guide/prepare-for-release/#launch-cd-pipeline-manually","title":"Launch CD Pipeline Manually","text":"<p>Follow the steps below to deploy the QA and UAT application stages:</p> <ol> <li> <p>As soon as the Build pipelines for both applications are successfully passed, the new version of the Docker container will appear, thus allowing to launch the CD pipeline. Simply navigate to Continuous Delivery and click the pipeline name to open it in Jenkins.</p> </li> <li> <p>Click the QA stage link.</p> </li> <li> <p>Deploy the QA stage by clicking the Build Now option.</p> </li> <li> <p>After the initialization step starts, in case another menu is opened, the Pause for Input option will appear. Select the application version in the drop-down list and click Proceed. The pipeline passes the following stages:</p> <ul> <li>Init - initialization of the Jenkins pipeline outputs with the stages that are the Groovy scripts that execute the current code;</li> <li>Deploy - the deployment of the selected versions of the docker container and third-party services. As soon as the Deployed pipeline stage is completed, the respective environment will be deployed.</li> <li>Approve - the verification stage that enables to Proceed or Abort this stage;</li> <li>Promote-images - the creation of the new image streams for the current versions with the pattern combination: [pipeline name]-[stage name]-[application name]-[verified];</li> </ul> <p>After all the stages are passed, the new image streams will be created in the Kubernetes/OpenShift with the new names.</p> </li> <li> <p>Deploy the UAT stage, which takes the versions that were verified during the QA stage, by clicking the Build Now option, and select the necessary application versions. The launch process is the same as for all the deploy pipelines.</p> </li> <li> <p>To get the status of the pipeline deployment, open the CD pipeline details page and check the Deployed versions state.</p> </li> </ol>"},{"location":"user-guide/prepare-for-release/#cd-pipeline-as-a-team-environment","title":"CD Pipeline as a Team Environment","text":"<p>Admin Console allows creating a CD pipeline with a part of the application set as a team environment. To do this, perform the following steps;</p> <ol> <li>Open the Continuous Delivery section \u2192 click the Create button \u2192 enter the pipeline name (e.g. team-a) \u2192 select ONE application and choose the master branch for it \u2192 add one DEV stage.</li> <li>As soon as the CD pipeline is added to the CD pipelines list, its details page will display the links to Jenkins and Kubernetes/OpenShift.</li> <li>Open Jenkins and deploy the DEV stage by clicking the Build Now option.</li> <li>Kubernetes/OpenShift keeps an independent environment that allows checking the new versions, thus speeding up the developing process when working with several microservices.</li> </ol> <p>As a result, the team will have the same abilities to verify the code changes when developing and during the release.</p>"},{"location":"user-guide/prepare-for-release/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add CD Pipeline</li> <li>Autotest as Qulity Gate</li> <li>Build Pipeline</li> <li>CD Pipeline Details</li> <li>Customize CD Pipeline</li> </ul>"},{"location":"user-guide/semi-auto-deploy/","title":"Semi Auto Deploy","text":"<p>The Semi Auto Deploy stage provides the ability to deploy applications with the custom logic that comprises the following behavior:</p> <ul> <li>When the build of an application selected for deploy in the CD pipeline is completed, the Deploy pipeline is automatically triggered;</li> <li>By default, the deploy stage waits for 5 minutes, and if the user does not interfere with the process (cancels or selects certain versions of the application to deploy), then the deploy stage will deploy the latest versions of all applications;</li> <li>The stage can be used in the manual mode.</li> </ul> <p>To enable the Semi Auto Deploy stage during the deploy process, follow the steps below:</p> <ol> <li>Create or update the CD pipeline: make sure the trigger type for the stage is set to auto.</li> <li>Replace the <code>{\"name\":\"auto-deploy-input\",\"step_name\":\"auto-deploy-input\"}</code> step to the <code>{\"name\":\"semi-auto-deploy-input\",\"step_name\":\"semi-auto-deploy-input\"}</code> step in the CD pipeline. Alternatively, it is possible to create a custom job provisioner with this step.</li> <li>Run the Build pipeline for any application selected in the CD pipeline.</li> </ol>"},{"location":"user-guide/semi-auto-deploy/#exceptional-cases","title":"Exceptional Cases","text":"<p>After the timeout starts and in case the pipeline has been interrupted not from the Input requested menu, the automatic deployment will be proceeding. To resolve the issue and stop the pipeline, click the Input requested menu -&gt; Abort or being on the pipeline UI, click the Abort button.</p>"},{"location":"user-guide/semi-auto-deploy/#related-articles","title":"Related Articles","text":"<ul> <li>Add CD Pipeline</li> <li>Customize CD Pipeline</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/terraform-stages/","title":"CI Pipelines for Terraform","text":"<p>EPAM Delivery Platform ensures the implemented Terraform support by adding a separate component type called Infrastructure. The Infrastructure codebase type allows to work with Terraform code that is processed by means of stages in the Code-Review and Build pipelines.</p>"},{"location":"user-guide/terraform-stages/#pipeline-stages-for-terraform","title":"Pipeline Stages for Terraform","text":"<p>Under the hood, Infrastructure codebase type, namely Terraform, looks quite similar to other codebase types. The distinguishing characterstic of the Infrastructure codebase type is that there is a stage called terraform-check in both of Code Review and Build pipelines. This stage runs the pre-commit activities which in their turn run the following commands and tools:</p> <ol> <li> <p>Terraform fmt - the first step of the stage is basically the <code>terraform fmt</code> command. The <code>terraform fmt</code> command automatically updates the formatting of Terraform configuration files to follow the standard conventions and make the code more readable and consistent.</p> </li> <li> <p>Lock provider versions - locks the versions of the Terraform providers used in the project. This ensures that the project uses specific versions of the providers and prevents unexpected changes from impacting the infrastructure due to newer provider versions.</p> </li> <li> <p>Terraform validate - checks the syntax and validity of the Terraform configuration files. It scans the configuration files for all possible issues.</p> </li> <li> <p>Terraform docs - generates human-readable documentation for the Terraform project.</p> </li> <li> <p>Tflint - additional validation step using the <code>tflint</code> linter to provide more in-depth checks in addition to what the <code>terraform validate</code> command does.</p> </li> <li> <p>Checkov - runs the <code>checkov</code> command against the Terraform codebase to identify any security misconfigurations or compliance issues.</p> </li> <li> <p>Tfsec - another security-focused validation step using the <code>tfsec</code> command. Tfsec is a security scanner for Terraform templates that detects potential security issues and insecure configurations in the Terraform code.</p> </li> </ol> <p>Note</p> <p>The commands and their attributes are displayed in the .pre-commit-config.yaml file.</p>"},{"location":"user-guide/terraform-stages/#related-articles","title":"Related Articles","text":"<ul> <li>User Guide Overview</li> <li>Add Infrastructure</li> <li>Manage Infrastructures</li> </ul>"}]}