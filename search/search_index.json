{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-do-i-set-parallel-reconciliation-for-a-number-of-codebase-branches","title":"How Do I Set Parallel Reconciliation for a Number of Codebase Branches?","text":"<p>Set the CODEBASE_BRANCH_MAX_CONCURRENT_RECONCILES Env variable in codebase-operator by updating Deployment template. For example:</p> <pre><code>          ...\n          env:\n            - name: WATCH_NAMESPACE\n          ...\n\n            - name: CODEBASE_BRANCH_MAX_CONCURRENT_RECONCILES\n              value: 10\n...\n</code></pre> <p>It's not recommended to set the value above 10.</p>"},{"location":"faq/#how-to-change-the-lifespan-of-an-access-token-that-is-used-for-headlamp-and-oidc-login-plugin","title":"How To Change the Lifespan of an Access Token That Is Used for Headlamp and 'oidc-login' Plugin?","text":"<p>Change the Access Token Lifespan: go to your Keycloak and select Openshift realm &gt; Realm settings &gt; Tokens &gt; Access Token Lifespan &gt; set a new value to the field and save this change.</p> <p>By default, \"Access Token Lifespan\" value is 5 minutes.</p> <p> Access Token Lifespan </p>"},{"location":"features/","title":"Basic Concepts","text":"<p>Consult EDP Glossary section for definitions mentioned on this page and EDP Toolset to have a full list of tools used with the Platform. The below table contains a full list of features provided by EDP.</p> Features Description Cloud Agnostic EDP runs on Kubernetes cluster, so any Public Cloud Provider which provides Kubernetes can be used. Kubernetes clusters deployed on-premises work as well CI/CD for Microservices EDP is initially designed to support CI/CD for Microservices running as containerized applications inside Kubernetes Cluster. EDP also supports CI for:- Terraform Modules, - Open Policy Rules,- Workflows for Java11, JavaScript (React), .Net, Python, Groovy Pipelines, Go Version Control System (VCS) EDP installs Gerrit as a default Source Code Management (SCM) tool. EDP also supports GitHub and GitLab integration Branching Strategy EDP supports Trunk-based development as well as GitHub/GitLab flow. EDP creates two Pipelines per each codebase branch (see Pipeline Framework): Code Review and Build Repository Structure EDP provides separate Git repository per each Codebase and doesn't work with Monorepo. However, EDP does support customization and runs helm-lint, dockerfile-lint steps using Monorepo approach. Artifacts Versioning EDP supports two approaches for Artifacts versioning: - default (BRANCH-[TECH_STACK_VERSION]-BUILD_ID)- EDP (MAJOR.MINOR.PATCH-BUILD_ID), which is SemVer.Custom versioning can be created by implementing get-version stage Application Library EDP provides baseline codebase templates for Microservices, Libraries, within create strategy while onboarding new Codebase Stages Library Each EDP Pipeline consists of pre-defined steps (stages). Consult library documentation for more details CI Pipelines EDP provides CI Pipelines (running in Jenkins) for first-class citizens: - Applications (Microservices) based on Java8, Java11, JavaScript (React), .Net, Python, Go- Libraries based on Java8, Java11, JavaScript (React), .Net, Python, Go, Groovy Pipelines, Terraform- Autotests based on Java8, Java11 CD Pipelines EDP provides capabilities to design CD Pipelines (in Admin Console) for Microservices and defines logic for artifacts flow (promotion) from env to env. Artifacts promotion is performed automatically (Autotests), manually (User Approval) or combining both approaches Autotests EDP provides CI pipeline for autotest implemented in Java. Autotests can be used as Quality Gates in CD Pipelines Custom Pipeline Library EDP can be extended by introducing Custom Pipeline Library Dynamic Environments Each EDP CD Pipeline creates/destroys environment upon user requests"},{"location":"getting-started/","title":"Quick Start","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes cluster 1.23+, or OpenShift 4.9+</li> <li>kubectl tool</li> <li>helm 3.10.x+</li> <li>Keycloak 18.0+</li> <li>Kiosk 0.2.11</li> </ul>"},{"location":"getting-started/#hardware","title":"Hardware","text":"<p>Minimal:</p> <ul> <li>CPU: 8 Core</li> <li>Memory: 32 Gb</li> </ul>"},{"location":"getting-started/#edp-toolset","title":"EDP Toolset","text":"<p>List of Tools used on the Platform:</p> Domain Related Tools/Solutions Artefacts Management Nexus Repository, AWS ECR AWS Amazon EKS Pod Identity Webhook, AWS ECR, AWS EFS Build .NET, Go, Apache Gradle, Apache Maven, NPM Cluster Backup Velero Code Review Gerrit, GitLab, GitHub Docker Hadolint, kaniko, crane Infrastructure as Code Terraform, TFLint Kubernetes deployment kubectl, helm, ct (Chart Testing) Kubernetes Multitenancy Kiosk Logging EFK, ELK, Loki Monitoring Prometheus, Grafana Pipeline Orchestration Tekton, Jenkins Policies/Rules Open Policy Agent SSO Keycloak Static Code Analysis SonarQube, DefectDojo, semgrep Test Report Tool ReportPortal, Allure"},{"location":"getting-started/#install-prerequisites","title":"Install prerequisites","text":""},{"location":"getting-started/#install-edp","title":"Install EDP","text":"<p>Find below the example of the installation command:</p> <pre><code>    helm install edp epamedp/edp-install --wait --timeout=900s \\\n--version &lt;edp_version&gt; \\\n--set global.edpName=&lt;edp-project&gt; \\\n--set global.dnsWildCard=&lt;cluster_DNS_wilcdard&gt; \\\n--set global.webConsole.url=&lt;kubeconfig.clusters.cluster.server&gt; \\\n--set global.platform=&lt;platform_type&gt; \\\n--set awsRegion=&lt;region&gt; \\\n--set dockerRegistry.url=&lt;aws_account_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com \\\n--set keycloak-operator.keycloak.url=&lt;keycloak_endpoint&gt; \\\n--set global.gerritSSHPort=&lt;gerrit_ssh_port&gt; \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Warning</p> <p>Please be aware that the command above is an example.</p> <p>To install EDP with the necessary parameters, please refer to the Install EDP section of the Operator Guide. Mind the parameters in the EDP installation chart. For details, please refer to the values.yaml.</p>"},{"location":"glossary/","title":"Glossary","text":"<p>Get familiar with the definitions and context for the most useful EDP terms presented in table below.</p> Terms Details EDP Component - an item used in CI/CD process Admin Console - an EDP component that helps to manage, set up, and control the business entities. Artifactory - an EDP component that stores all the binary artifacts. NOTE: Nexus is used as a possible implementation of a repository. CI/CD Server - an EDP component that launches pipelines that perform the build, QA, and deployment code logic. NOTE: Jenkins is used as a possible implementation of a CI/CD server. Code Review tool - an EDP component that collaborates with the changes in the codebase. NOTE: Gerrit is used as a possible implementation of a code review tool. Identity Server - an authentication server providing a common way to verify requests to all of the applications. NOTE: Keycloak is used as a possible implementation of an identity server. Security Realm Tenant - a realm in identity server (e.g Keycloak) where all users' accounts and their access permissions are managed. The realm is unique for the identity server instance. Static Code Analyzer - an EDP component that inspects continuously a code quality before the necessary changes appear in a master branch. NOTE: SonarQube is used as a possible implementation of a static code analyzer. VCS (Version Control System) - a replication of the Gerrit repository that displays all the changes made by developers. NOTE: GitHub and GitLab are used as the possible implementation of a repository with the version control system. EDP Business Entity - a part of the CI/CD process (the integration, delivery, and deployment of any codebase changes) Application - a codebase type that is built as the binary artifact and deployable unit with the code that is stored in VCS. As a result, the application becomes a container and can be deployed in an environment. Autotests - a codebase type that inspects a product (e.g. an application set) on a stage. Autotests are not deployed to any container and launched from the respective code stage. CD Pipeline (Continuous Delivery Pipeline) - an EDP business entity that describes the whole delivery process of the selected application set via the respective stages. The main idea of the CD pipeline is to promote the application version between the stages by applying the sequential verification (i.e. the second stage will be available if the verification on the first stage is successfully completed). NOTE: The CD pipeline can include the essential set of applications with its specific stages as well. CD Pipeline Stage - an EDP business entity that is presented as the logical gate required for the application set inspection. Every stage has one OpenShift project where the selected application set is deployed. All stages are sequential and promote applications one-by-one. Codebase - an EDP business entity that possesses a code. Codebase Branch - an EDP business entity that represents a specific version in a Git branch. Every codebase branch has a Codebase Docker Stream entity. Codebase Docker Stream - a deployable component that leads to the application build and displays that the last build was verified on the specific stage. Every CD pipeline stage accepts a set of Codebase Docker Streams (CDS) that are input and output. SAMPLE: if an application1 has a master branch, the input CDS will be named as [app name]-[pipeline name]-[stage name]-[master] and the output after the passing of the DEV stage will be as follows: [app name]-[pipeline name]-[stage name]-[dev]-[verified]. Library - a codebase type that is built as the binary artifact, i.e. it`s stored in the Artifactory and can be uploaded by other applications, autotests or libraries. Quality Gate - an EDP business entity that represents the minimum acceptable results after the testing. Every stage has a quality gate that should be passed to promote the application. The stage quality gate can be a manual approve from a QA specialist OR a successful autotest launch. Quality Gate Type - this value defines trigger type that promotes artifacts (images) to the next environment in CD Pipeline. There are manual and automatic types of quality gates. The manual type means that the promoting process should be confirmed in Jenkins. The automatic type promotes the images automatically in case there are no errors in the Allure Report. NOTE: If any of the test types is not passed, the CD pipeline will fail. Trigger Type - a value that defines a trigger type used for the CD pipeline triggering. There are manual and automatic types of triggering. The manual type means that the CD pipeline should be triggered manually. The automatic type triggers the CD pipeline automatically as soon as the Codebase Docker Stream was changed. EDP CI/CD Pipelines Framework - a library that allows extending the Jenkins pipelines and stages to develop an application. Pipelines are presented as the shared library that can be connected in Jenkins. The library is connected using the Git repository link (a public repository that is supported by EDP) on the GitHub. Allure Report- a tool that represents test results in one brief report in a clear form. Automated Tests - different types of automated tests that can be run on the environment for a specific stage. Build Pipeline - a Jenkins pipeline that builds a corresponding codebase branch in the Codebase. Build Stage - a stage that takes place after the code has been submitted/merged to the repository of the main branch (the pull request from the feature branch is merged to the main one, the Patch set is submitted in Gerrit). Code Review Pipeline - a Jenkins pipeline that inspects the code candidate in the Code Review tool. Code Review Stage - a stage where code is reviewed before it goes to the main branch repository of the version control system (the commit to the feature branch is pushed, the Patch set is created in Gerrit). Deploy Pipeline - a Jenkins pipeline that is responsible for the CD Pipeline Stage deployment with the full set of applications and autotests. Deployment Stage - a part of the Continuous Delivery where artifacts are being deployed to environments. EDP CI/CD Pipelines - an orchestrator for stages that is responsible for the common technical events, e.g. initialization, in Jenkins pipeline. The set of stages for the pipeline is defined as an input JSON file for the respective Jenkins job. NOTE: There is the ability to create the necessary realization of the library pipeline on your own as well. EDP CI/CD Stages - a repository that is launched in the Jenkins pipeline. Every stage is presented as an individual Groovy file in a corresponding repository. Such single responsibility realization allows rewriting of one essential stage without changing the whole pipeline. Environment - a part of the stage where the built and packed into an image application are deployed for further testing. It`s possible to deploy several applications to several environments (Team and Integration environments) within one stage. Integration Environment - an environment type that is always deployed as soon as the new application version is built in order to launch the integration test and promote images to the next stages. The Integration Environment can be triggered manually or in case a new image appears in the Docker registry. Jenkinsfile - a text file that keeps the definition of a Jenkins Pipeline and is checked into source control. Every Job has its Jenkinsfile that is stored in the specific application repository and in Jenkins as the plain text. Jenkins Node - a machine that is a part of the Jenkins environment that is capable of executing a pipeline. Jenkins Pipeline - a user-defined model of a CD pipeline. The pipeline code defines the entire build process. Jenkins Stage - a part of the whole CI/CD process that should pass the source code in order to be released and deployed on the production. Team Environment - an environment type that can be deployed at any time by the manual trigger of the Deploy pipeline where team or developers can check out their applications. NOTE: The promotion from such kind of environment is prohibited and developed only for the local testing. OpenShift / Kubernetes (K8S) ConfigMap - a resource that stores configuration data and processes the strings that do not contain sensitive information. Docker Container - is a lightweight, standalone, and executable package. Docker Registry - a store for the Docker Container that is created for the application after the Build pipeline performance. OpenShift Web Console - a web console that enables to view, manage, and change OpenShift / K8S resources using browser. Operator Framework - a deployable unit in OpenShift that is responsible for one or a set of resources and performs its life circle (adding, displaying, and provisioning). Path - a route component that helps to find a specified path (e.g. /api) at once and skip the other. Pod - the smallest deployable unit of the large microservice application that is responsible for the application launch. The pod is presented as the one launched Docker container. When the Docker container is collected, it will be kept in Docker Registry and then saved as Pod in the OpenShift project. NOTE: The Deployment Config is responsible for the Pod push, restart, and stop processes. PV (Persistent Volume) - a cluster resource that captures the details of the storage implementation and has an independent lifecycle of any individual pod. PVC (Persistent Volume Claim) - a user request for storage that can request specific size and access mode. PV resources are consumed by PVCs. Route - a resource in OpenShift that allows getting the external access to the pushed application. Secret - an object that stores and manages all the sensitive information (e.g. passwords, tokens, and SSH keys). Service - an external connection point with Pod that is responsible for the network. A specific Service is connected to a specific Pod using labels and redirects all the requests to Pod as well. Site - a route component (link name) that is created from the indicated application name and applies automatically the project name and a wildcard DNS record."},{"location":"overview/","title":"Overview","text":"<p>EPAM Delivery Platform (EDP) is an open-source cloud-agnostic SaaS/PaaS solution for software development, licensed under Apache License 2.0. It provides a pre-defined set of CI/CD patterns and tools, which allow a user to start product development quickly with established code review, release, versioning, branching, build processes. These processes include static code analysis, security checks, linters, validators, dynamic feature environments provisioning. EDP consolidates the top Open-Source CI/CD tools by running them on Kubernetes/OpenShift, which enables web/app development either in isolated (on-prem) or cloud environments.</p> <p>EPAM Delivery Platform, which is also called \"The Rocket\", is a platform that allows shortening the time that is passed before an active development can be started from several months to several hours.</p> <p>EDP consists of the following:</p> <ul> <li>The platform based on managed infrastructure and container orchestration</li> <li>Security covering authentication, authorization, and SSO for platform services</li> <li>Development and testing toolset</li> <li>Well-established engineering process and EPAM practices (EngX) reflected in CI/CD pipelines, and delivery analytics</li> <li>Local development with debug capabilities</li> </ul>"},{"location":"overview/#features","title":"Features","text":"<ul> <li>Deployed and configured CI/CD toolset (Tekton, ArgoCD, Jenkins, Nexus, SonarQube, DefectDojo)</li> <li>Gerrit, GitLab or GitHub as a version control system for your code</li> <li>Tekton is a default pipeline orchestrator</li> <li>Jenkins is an optional pipeline orchestrator</li> <li>CI pipelines for Python, Java 8, Java 11, .Net, Go, React, Terraform, Jenkins Groovy Pipelines, Dockerfile, Helm</li> <li>Build tools: Go, Apache Maven, Apache Gradle</li> <li>Headlamp UI as a single entry point</li> <li>CD pipeline for Microservice Deployment</li> <li>Kubernetes native approach (CRD, CR) to declare CI/CD pipelines</li> </ul>"},{"location":"overview/#whats-inside","title":"What's Inside","text":"<p>EPAM Delivery Platform (EDP) is suitable for all aspects of delivery starting from development including the capability to deploy production environment. EDP architecture is represented on a diagram below.</p> <p> Architecture </p> <p>EDP consists of four cross-cutting concerns:</p> <ol> <li>Infrastructure as a Service;</li> <li>GitOps approach;</li> <li>Container orchestration and centralized services;</li> <li>Security.</li> </ol> <p>On the top of these indicated concerns, EDP adds several blocks that include:</p> <ul> <li>EDP CI/CD Components. EDP component enables a feature in CI/CD or an instance artifacts storage and distribution (Nexus or Artifactory), static code analysis (Sonar), etc.;</li> <li>EDP Artifacts. This element represents an artifact that is being delivered through EDP and presented as a code. <p>Artifact samples: frontend, backend, mobile, applications, functional and non-functional autotests, workloads for 3rd party components that can be deployed together with applications.</p> </li> </ul> <ul> <li>EDP development and production environments that share the same logic. Environments wrap a set of artifacts with a specific version, and allow performing SDLC routines in order to be sure of the artifacts quality;</li> <li>Pipelines. Pipelines cover CI/CD process, production rollout and updates. They also connect three elements indicated above via automation allowing SDLC routines to be non-human;</li> </ul>"},{"location":"overview/#technology-stack","title":"Technology Stack","text":"<p>Explore the EDP technology stack diagram</p> <p> Technology stack </p> <p>The EDP IaaS layer supports most popular public clouds AWS, Azure and GCP keeping the capability to be deployed on private/hybrid clouds based on OpenStack. EDP containers are based on Docker technology, orchestrated by Kubernetes compatible solutions.</p> <p>There are two main options for Kubernetes provided by EDP:</p> <ul> <li>Managed Kubernetes in Public Clouds to avoid installation and management of Kubernetes cluster, and get all benefits of scaling, reliability of this solution;</li> <li>OpenShift that is a Platform as a Service on the top of Kubernetes from Red Hat. OpenShift is the default option for on-premise installation and it can be considered whether the solution built on the top of EDP should be cloud-agnostic or require enterprise support;</li> </ul> <p>There is no limitation to run EDP on vanilla Kubernetes.</p>"},{"location":"roadmap/","title":"RoadMap","text":"<p>RoadMap consists of three streams:</p> <ul> <li>Community</li> <li>Architecture</li> <li>Building Blocks</li> <li>Admin Console</li> <li>Documentation</li> </ul>"},{"location":"roadmap/#i-community","title":"I. Community","text":"<p>Goals:</p> <ul> <li>Innovation Through Collaboration</li> <li>Improve OpenSource Adoption</li> <li>Build Community around technology solutions EDP is built on</li> </ul>"},{"location":"roadmap/#deliver-operators-on-operatorhub","title":"Deliver Operators on OperatorHub","text":"<p>OperatorHub is a defacto leading solution which consolidates Kubernetes Community around Operators. EDP follows the best practices of delivering Operators in a quick and reliable way. We want to improve Deployment and Management experience for our Customers by publishing all EDP operators on this HUB.</p> <p>Another artifact aggregator which is used by EDP - ArtifactHub, that holds description for both components: stable and under-development.</p> <p>OperatorHub. Keycloak Operator</p> <p>EDP Keycloak Operator is now available from OperatorHub both for Upstream (Kubernetes) and OpenShift deployments.</p>"},{"location":"roadmap/#ii-architecture","title":"II. Architecture","text":"<p>Goals:</p> <ul> <li>Improve reusability for EDP components</li> <li>Integrate Kubernetes Native Deployment solutions</li> <li>Introduce abstraction layer for CI/CD components</li> <li>Build processes around the GitOps approach</li> <li>Introduce secrets management</li> </ul>"},{"location":"roadmap/#kubernetes-multitenancy","title":"Kubernetes Multitenancy","text":"<p>Multiple instances of EDP are run in a single Kubernetes cluster. One way to achieve this is to use Multitenancy. Initially, Kiosk was selected as tools that provides this capability. An alternative option that EDP Team took into consideration is Capsule. Another tool which goes far beyond multitenancy is vcluster going a good candidate for e2e testing scenarios where one needs simple lightweight kubernetes cluster in CI pipelines.</p>"},{"location":"roadmap/#microservice-reference-architecture-framework","title":"Microservice Reference Architecture Framework","text":"<p>EDP provides basic Application Templates for a number of technology stacks (Java, .Net, NPM, Python) and Helm is used as a deployment tool. The goal is to extend this library and provide: Application Templates which are built on pre-defined architecture patterns (e.g., Microservice, API Gateway, Circuit Breaker, CQRS, Event Driven) and Deployment Approaches: Canary, Blue/Green. This requires additional tools installation on cluster as well.</p>"},{"location":"roadmap/#policy-enforcement-for-kubernetes","title":"Policy Enforcement for Kubernetes","text":"<p>Running workload in Kubernetes calls for extra effort from Cluster Administrators to ensure those workloads do follow best practices or specific requirements defined on organization level. Those requirements can be formalized in policies and integrated into: CI Pipelines and Kubernetes Cluster (through Admission Controller approach) - to guarantee proper resource management during development and runtime phases. EDP uses Open Policy Agent (from version 2.8.0), since it supports compliance check for more use-cases: Kubernetes Workloads, Terraform and Java code, HTTP APIs and many others. Kyverno is another option being checked in scope of this activity.</p>"},{"location":"roadmap/#secrets-management","title":"Secrets Management","text":"<p>EDP should provide secrets management as a part of platform. There are multiple tools providing secrets management capabilities. The aim is to be aligned with GitOps and Operator Pattern approaches so HashiCorp Vault, Banzaicloud Bank Vaults, Bitnami Sealed Secrets are currently used for internal projects and some of them should be made publicly available - as a part of EDP Deployment.</p> <p>EDP Release 2.12.x</p> <p>External Secret Operator is a recommended secret management tool for the EDP components.</p>"},{"location":"roadmap/#release-management","title":"Release Management","text":"<p>Conventional Commits and Conventional Changelog are two approaches to be used as part of release process. Today EDP provides only capabilities to manage Release Branches. This activity should address this gap by formalizing and implementing Release Process as a part of EDP. Topics to be covered: Versioning, Tagging, Artifacts Promotion.</p>"},{"location":"roadmap/#kubernetes-native-cicd-pipelines","title":"Kubernetes Native CI/CD Pipelines","text":"<p>EDP uses Jenkins as Pipeline Orchestrator. Jenkins runs workload for CI and CD parts. There is also basic support for GitLab CI, but it provides Docker image build functionality only. EDP works on providing an alternative to Jenkins and use Kubernetes Native Approach for pipeline management. There are a number of tools, which provides such capability:</p> <ul> <li>Argo CD</li> <li>Argo Workflows</li> <li>Argo Rollouts</li> <li>Tekton</li> <li>Drone</li> <li>Flux</li> </ul> <p>This list is under investigation and solution is going to be implemented in two steps:</p> <ol> <li>Introduce tool that provide Continues Delivery/Deployment approach. Argo CD is one of the best to go with.</li> <li>Integrate EDP with tool that provides Continues Integration capabilities.</li> </ol> <p>EDP Release 2.12.x</p> <p>Argo CD is suggested as a solution providing the <code>Continuous Delivery</code> capabilities.</p> <p>EDP Release 3.0</p> <p>Tekton is used as a CI/CD pipelines orchestration tool on the platform. Review edp-tekton GitHub repository that keeps all the logic behind this solution on the EDP (Pipelines, Tasks, TriggerTemplates, Interceptors, etc). Get acquainted with the series of publications on our Medium Page.</p>"},{"location":"roadmap/#advanced-edp-role-based-model","title":"Advanced EDP Role-based Model","text":"<p>EDP has a number of base roles which are used across EDP. In some cases it is necessary to provide more granular permissions for specific users. It is possible to do this using Kubernetes Native approach.</p>"},{"location":"roadmap/#notifications-framework","title":"Notifications Framework","text":"<p>EDP has a number of components which need to report their statuses: Build/Code Review/Deploy Pipelines, changes in Environments, updates with artifacts. The goal for this activity is to onboard Kubernetes Native approach which provides Notification capabilities with different sources/channels integration (e.g. Email, Slack, MS Teams). Some of these tools are Argo Events, Botkube.</p>"},{"location":"roadmap/#reconciler-component-retirement","title":"Reconciler Component Retirement","text":"<p>Persistent layer, which is based on edp-db (PostgreSQL) and reconciler component should be retired in favour of Kubernetes Custom Resource (CR). The latest features in EDP are implemented using CR approach.</p>"},{"location":"roadmap/#iii-building-blocks","title":"III. Building Blocks","text":"<p>Goals:</p> <ul> <li>Introduce best practices from Microservice Reference Architecture deployment and observability using Kubernetes Native Tools</li> <li>Enable integration with the Centralized Test Reporting Frameworks</li> <li>Onboard SAST/DAST tool as a part of CI pipelines and Non-Functional Testing activities</li> </ul> <p>EDP Release 2.12.x</p> <p>SAST is introduced as a mandatory part of the CI Pipelines. The list of currently supported SAST scanners and the instruction on how to add them are also available.</p>"},{"location":"roadmap/#infrastructure-as-code","title":"Infrastructure as Code","text":"<p>EDP Target tool for Infrastructure as Code (IaC) is Terraform. EDP sees two CI/CD scenarios while working with IaC: Module Development and Live Environment Deployment. Today, EDP provides basic capabilities (CI Pipelines) for Terraform Module Development. At the same time, currently EDP doesn't provide Deployment pipelines for Live Environments and the feature is under development. Terragrunt is an option to use in Live Environment deployment. Another Kubernetes Native approach to provision infrastructure components is Crossplane.</p>"},{"location":"roadmap/#database-schema-management","title":"Database Schema Management","text":"<p>One of the challenges for Application running in Kubernetes is to manage database schema. There are a number of tools which provides such capabilities, e.g. Liquibase, Flyway. Both tools provide versioning control for database schemas. There are different approaches on how to run migration scripts in Kubernetes: in init container, as separate Job or as a separate CD stage. Purpose of this activity is to provide database schema management solution in Kubernetes as a part of EDP. EDP Team investigates SchemaHero tool and use-cases which suits Kubernetes native approach for database schema migrations.</p>"},{"location":"roadmap/#open-policy-agent","title":"Open Policy Agent","text":"<p>Open Policy Agent is introduced in version 2.8.0. EDP now supports CI for Rego Language, so you can develop your own policies. The next goal is to provide pipeline steps for running compliance policies check for Terraform, Java, Helm Chart as a part of CI process.</p>"},{"location":"roadmap/#report-portal","title":"Report Portal","text":"<p>EDP uses Allure Framework as a Test Report tool. Another option is to integrate Report Portal into EDP ecosystem.</p> <p>EDP Release 3.0</p> <p>Use ReportPortal to consolidate and analyze your Automation tests results. Consult our pages on how to perform reporting and Keycloak integration.</p>"},{"location":"roadmap/#carrier","title":"Carrier","text":"<p>Carrier provides Non-functional testing capabilities.</p>"},{"location":"roadmap/#java-17","title":"Java 17","text":"<p>EDP supports two LTS versions of Java: 8 and 11. The goal is to provide Java 17 (LTS) support.</p>"},{"location":"roadmap/#velero","title":"Velero","text":"<p>Velero is used as a cluster backup tool and is deployed as a part of Platform. Currently, Multitenancy/On-premise support for backup capabilities is in process.</p>"},{"location":"roadmap/#istio","title":"Istio","text":"<p>Istio is to be used as a Service Mesh and to address challenges for Microservice or Distributed Architectures.</p>"},{"location":"roadmap/#kong","title":"Kong","text":"<p>Kong is one of tools which is planned to use as an API Gateway solution provider. Another possible candidate for investigation is Ambassador API Gateway</p>"},{"location":"roadmap/#openshift-4x","title":"OpenShift 4.X","text":"<p>EDP supports the OpenShift 4.9 platform.</p> <p>EDP Release 2.12.x</p> <p>EDP Platform runs on the latest OKD versions: 4.9 and 4.10. Creating the IAM Roles for Service Account is a recommended way to work with AWS Resources from the OKD cluster.</p>"},{"location":"roadmap/#iv-admin-console-ui","title":"IV. Admin Console (UI)","text":"<p>Goals:</p> <ul> <li>Improve U\u0425 for different user types to address their concerns in the delivery model</li> <li>Introduce user management capabilities</li> <li>Enrich with traceability metrics for products</li> </ul> <p>EDP Release 2.12.x</p> <p>EDP Team has introduced a new UI component called EDP Headlamp, which will replace the EDP Admin Console in future releases. EDP Headlamp is based on the Kinvolk Headlamp UI Client.</p> <p>EDP Release 3.0</p> <p>EDP Headlamp is used as a Control Plane UI on the platform.</p>"},{"location":"roadmap/#users-management","title":"Users Management","text":"<p>EDP uses Keycloak as an Identity and Access provider. EDP roles/groups are managed inside the Keycloak realm, then these changes are propagated across the EDP Tools. We plan to provide this functionality in EDP Headlamp using the Kubernetes-native approach (Custom Resources).</p>"},{"location":"roadmap/#the-delivery-pipelines-dashboard","title":"The Delivery Pipelines Dashboard","text":"<p>The CD Pipeline section in EDP Headlamp provides basic information, such as environments, artifact versions deployed per each environment, and direct links to the namespaces. One option is to enrich this panel with metrics from the Prometheus, custom resources, or events. Another option is to use the existing dashboards and expose EDP metrics to them, for example, plugin for Lens or OpenShift UI Console.</p>"},{"location":"roadmap/#split-jira-and-commit-validation-sections","title":"Split Jira and Commit Validation Sections","text":"<p>Commit Validate step was initially designed to be aligned with Jira Integration and cannot be used as single feature. Target state is to ensure features CommitMessage Validation and Jira Integration both can be used independently. We also want to add support for Conventional Commits.</p>"},{"location":"roadmap/#v-documentation-as-code","title":"V. Documentation as Code","text":"<p>Goal:</p> <ul> <li>Transparent documentation and clear development guidelines for EDP customization.</li> </ul> <p>Consolidate documentation in a single repository edp-install, use <code>mkdocs</code> tool to generate docs and GitHub Pages as a hosting solution.</p>"},{"location":"developer-guide/","title":"Overview","text":"<p>The EDP Developer guide is intended for developers and provides details on the necessary actions to extend the EDP functionality.</p>"},{"location":"developer-guide/edp-workflow/","title":"EDP Project Rules. Working Process","text":"<p>This page contains the details on the project rules and working process for EDP team and contributors. Explore the main points about working with Gerrit, following the main commit flow, as well as the details about commit types and message below.</p>"},{"location":"developer-guide/edp-workflow/#project-rules","title":"Project Rules","text":"<p>Before starting the development, please check the project rules:</p> <ol> <li> <p>It is highly recommended to become familiar with the Gerrit flow. For details, please refer to the Gerrit official documentation and pay attention to the main points:</p> <p>a. Voting in Gerrit</p> <p>b. Resolution of Merge Conflict</p> <p>c. Comments resolution</p> <p>d. One Jira task should have one Merge Request (MR). If there are many changes within one MR, add the next patch set to the open MR by selecting the Amend commit check box.</p> </li> <li> <p>Only the Assignee is responsible for the MR merge and Jira task status.</p> </li> <li> <p>Every MR should be merged in a timely manner.</p> </li> <li> <p>Log time to Jira ticket.</p> </li> </ol>"},{"location":"developer-guide/edp-workflow/#working-process","title":"Working Process","text":"<p>With EDP, the main workflow is based on the getting a Jira task and creating a Merge Request according to the rules described below.</p> <p>Workflow</p> <p>Get Jira task \u2192 implement, verify by yourself the results \u2192  create Merge Request (MR) \u2192 send for review \u2192 resolve comments/add changes, ask colleagues for the final review \u2192 track the MR merge \u2192 verify by yourself the results \u2192 change the status in the Jira ticket to CODE COMPLETE or RESOLVED \u2192 share necessary links with a QA specialist in the QA Verification channel \u2192 QA specialist closes the Jira task after his verification \u2192 Jira task should be CLOSED.</p> <p>Commit Flow</p> <ol> <li> <p>Get Jira task. Please be aware of the following points:</p> <p>a. Every task has a reporter who can provide more details in case something is not clear.</p> <p>b. The responsible person for the task and code implementation is the assignee who tracks the following:</p> <ul> <li>actual Jira task status</li> </ul> <ul> <li>time logging</li> </ul> <ul> <li>add comments, attach necessary files</li> </ul> <ul> <li>in comments, add link that refers to the merged MR (optional, if not related to many repositories)</li> </ul> <ul> <li>code review and the final merge</li> </ul> <ul> <li>MS Teams chats - ping other colleagues, answer questions, etc.</li> </ul> <ul> <li>verification by a QA specialist</li> </ul> <ul> <li>bug fixing</li> </ul> <p>c. Pay attention to the task Status that differs in different entities, the workflow will help to see the whole task processing:</p> <p> View Jira workflow </p> <p>d. There are several entities that are used on the EDP project: Story, Improvement, Task, Bug.</p> </li> <li> <p>Implement feature, improvement, fix and check the results on your own. If it is impossible to check the results of your work before the merge, verify all later.</p> </li> <li> <p>Create a Merge Request, for details, please refer to the Code Review Process.</p> </li> <li> <p>When committing, use the pattern: [EPMDEDP-JIRA Task Number]: commit type: Commit message.</p> <p>a. [EPMDEDP] - is the default part;</p> <p>b. JIRA Task Number - the number of your Jira task;</p> <p>c. commit type:</p> <p><code>feat</code>: (new feature for the user, not a new feature for build script)</p> <p><code>fix</code>: (bug fix for the user, not a fix to a build script)</p> <p><code>docs</code>: (changes to the documentation)</p> <p><code>style</code>: (formatting, missing semicolons, etc; no production code change)</p> <p><code>refactor</code>: (refactoring production code, eg. renaming a variable)</p> <p><code>test</code>: (adding missing tests, refactoring tests; no production code change)</p> <p><code>chore</code>: (updating grunt tasks etc; no production code change)</p> <p><code>!</code>: (added to other commit types to mark breaking changes) For example:</p> <pre><code>[EPMDEDP-0000]: feat!: Job provisioner is responsible for the formation of Jenkinsfile\n\nBREAKING CHANGE: Job provisioner creates Jenkinsfile and configures it in Jenkins pipeline as a pipeline script.\n</code></pre> <p>d. Commit message:</p> <ul> <li> <p>brief, for example:</p> <p><code>[EPMDEDP-0000]: fix: Fix Gerrit plugin for Jenkins provisioning</code></p> <p>or</p> </li> </ul> <ul> <li>descriptive, for example:<pre><code>[EPMDEDP-0000]: feat: Provide the ability to configure hadolint check\n\n*Add configuration files .hadolint.yaml and .hadolint.yml to stash\n</code></pre> </li> </ul> </li> </ol> <p>Note</p> <p>Make sure there is a descriptive commit message for a breaking change Merge Request. For example:</p> <p>[EPMDEDP-0000]: feat!: Job provisioner is responsible for the formation of Jenkinsfile</p> <p>BREAKING CHANGE: Job provisioner creates Jenkinsfile and configures it in Jenkins pipeline as a pipeline script.</p> <p>Note</p> <p>If a Merge Request contains both new functionality and breaking changes, make sure the functionality description is placed before the breaking changes. For example:</p> <p>[EPMDEDP-0000]: feat!: Update Gerrit to improve access</p> <ul> <li>Implement Developers group creation process</li> <li>Align group permissions</li> </ul> <p>BREAKING CHANGES: Update Gerrit config according to groups</p>"},{"location":"developer-guide/edp-workflow/#related-articles","title":"Related Articles","text":"<ul> <li>Conventional Commits</li> <li>Semantic Commit Messages</li> <li>Karma</li> </ul>"},{"location":"developer-guide/local-development/","title":"Local Development","text":""},{"location":"developer-guide/local-development/#requirements","title":"Requirements","text":"<ul> <li>GoLang version higher than 1.13;</li> </ul> <p>Note</p> <p>The GOPATH and GOROOT environment variables should be added in PATH.</p> <ul> <li>PostgreSQL client version higher than 9.5;</li> <li>Configured access to the VCS;</li> <li>GoLand Intellij IDEA or another IDE.</li> </ul>"},{"location":"developer-guide/local-development/#start-operator","title":"Start Operator","text":"<p>In order to run the operator, follow the steps below:</p> <ol> <li> <p>Clone repository;</p> </li> <li> <p>Open folder in GoLand Intellij IDEA, click the  button and select the Go Build option:</p> <p> Add configuration </p> </li> <li> <p>In Configuration tab, fill in the following:</p> <p>3.1. In the Field field, indicate the path to the main.go file;</p> <p>3.2. In the Working directory field, indicate the path to the operator;</p> <p>3.3. In the Environment field, specify the platform name (OpenShift/Kubernetes);</p> <p> Build config </p> </li> <li> <p>Create the PostgreSQL database, schema, and a user for the EDP Admin Console operator:</p> <ul> <li>Create database with a user:<pre><code>CREATE DATABASE edp-db WITH ENCODING 'UTF8';\nCREATE USER postgres WITH PASSWORD 'password';\nGRANT ALL PRIVILEGES ON DATABASE 'edp-db' to postgres;\n</code></pre> </li> </ul> <ul> <li>Create a schema:<pre><code>CREATE SCHEMA [IF NOT EXISTS] 'develop';\n</code></pre> </li> </ul> <p>EDP Admin Console operator supports two modes for running: local and prod.  For local deploy, modify <code>edp-admin-console/conf/app.conf</code> and set the following parameters:</p> <pre><code>  runmode=local\n[local]\ndbEnabled=true\npgHost=localhost\npgPort=5432\npgDatabase=edp-db\npgUser=postgres\npgPassword=password\nedpName=develop\n</code></pre> </li> <li> <p>Run <code>go build main.go</code> (Shift+F10);</p> </li> <li> <p>After the successful setup, follow the http://localhost:8080 URL address to check the result:</p> <p> Admin console UI </p> </li> </ol>"},{"location":"developer-guide/local-development/#exceptional-cases","title":"Exceptional Cases","text":"<p>After starting the Go build process, the following error will appear:</p> <pre><code>    go: finding github.com/openshift/api v3.9.0\ngo: finding github.com/openshift/client-go v3.9.0\ngo: errors parsing go.mod:\nC:\\Users\\&lt;&lt;username&gt;&gt;\\Desktop\\EDP\\edp-admin-console\\go.mod:36: require github.com/openshift/api: version \"v3.9.0\" invalid: unknown revision v3.9.0\n\nCompilation finished with exit code 1\n</code></pre> <p>To resolve the issue, update the go dependency by applying the Golang command:</p> <pre><code>    go get github.com/openshift/api@v3.9.0\n</code></pre>"},{"location":"developer-guide/mk-docs-development/","title":"Documentation Flow","text":"<p>This section defines necessary steps to start developing the EDP documentation in the MkDocs Framework. The framework presents a static site generator with documentation written in Markdown. All the docs are configured with a YAML configuration file.</p> <p>Note</p> <p>For more details on the framework, please refer to the MkDocs official website.</p> <p>There are two options for working with MkDocs:</p> <ul> <li>Work with MkDocs if Docker is installed</li> <li>Work with MkDocs if Docker is not installed</li> </ul> <p>Please see below the detailed description of each options and choose the one that suits you.</p>"},{"location":"developer-guide/mk-docs-development/#mkdocs-with-docker","title":"MkDocs With Docker","text":"<p>Prerequisites:</p> <ul> <li>Docker is installed.</li> </ul> <ul> <li><code>make</code> utility is installed.</li> </ul> <ul> <li>Git is installed. Please refer to the Git downloads.</li> </ul> <p>To work with MkDocs, take the following steps:</p> <ol> <li> <p>Clone the edp-install repository to your local folder.</p> </li> <li> <p>Run the following command:</p> <p><code>make docs</code></p> </li> <li> <p>Enter the localhost:8000 address in the browser and check that documentation pages are available.</p> </li> <li> <p>Open the file editor, navigate to edp-install-&gt;docs and make necessary changes. Check all the changes at localhost:8000.</p> </li> <li> <p>Create a merge request with changes.</p> </li> </ol>"},{"location":"developer-guide/mk-docs-development/#mkdocs-without-docker","title":"MkDocs Without Docker","text":"<p>Prerequisites:</p> <ul> <li>Git is installed. Please refer to the Git downloads.</li> </ul> <ul> <li>Python 3.9.5 is installed.</li> </ul> <p>To work with MkDocs without Docker, take the following steps:</p> <ol> <li> <p>Clone the edp-install repository to your local folder.</p> </li> <li> <p>Run the following command:</p> <pre><code>pip install -r  hack/mkdocs/requirements.txt\n</code></pre> </li> <li> <p>Run the local development command:</p> <pre><code>mkdocs serve --dev-addr 0.0.0.0:8000\n</code></pre> <p>Note</p> <p>This command may not work on Windows, so a quick solution is: <pre><code>python -m mkdocs serve --dev-addr 0.0.0.0:8000\n</code></pre></p> </li> <li> <p>Enter the localhost:8000 address in the browser and check that documentation pages are available.</p> </li> <li> <p>Open the file editor, navigate to edp-install-&gt;docs and make necessary changes. Check all the changes at localhost:8000.</p> </li> <li> <p>Create a merge request with changes.</p> </li> </ol>"},{"location":"developer-guide/rest-api/","title":"EDP API","text":""},{"location":"developer-guide/rest-api/#create-codebase-entity","title":"Create Codebase Entity","text":"<p>EDP allows you to create three codebase types: Application, Autotest and Library. There are also several strategy types for each codebase: Create, Clone and Import. Depending on the selected codebase type and the respective strategy, you should specify a different set of fields in a request.</p> <p>Note</p> <p>The Route, Database and VCS are optional fields. In accordance with the necessary deploy set, you have to add the necessary fields into request</p>"},{"location":"developer-guide/rest-api/#request","title":"Request","text":"<p><code>POST /api/v1/edp/codebase</code></p>"},{"location":"developer-guide/rest-api/#application-create","title":"Application (Create)","text":"<pre><code>{\n    \"name\": \"app01\",\n    \"type\": \"application\",\n    \"strategy\": \"create\",\n    \"lang\": \"java\",\n    \"framework\": \"springboot\",\n    \"buildTool\": \"maven\",\n    \"multiModule\": false,\n    \"route\": {\n        \"site\": \"api\",\n        \"path\": \"/\"\n    },\n    \"database\": {\n        \"kind\": \"postgresql\",\n        \"version\": \"postgres:9.6\",\n        \"capacity\": \"1Gi\",\n        \"storage\": \"efs\"\n    },\n    \"description\": \"Description\",\n    \"gitServer\": \"gerrit\",\n    \"jenkinsSlave\": \"maven\",\n    \"jobProvisioning\": \"default\",\n    \"deploymentScript\": \"openshift-template\"\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#application-clone","title":"Application (Clone)","text":"<pre><code>{\n    \"name\": \"app01\",\n    \"type\": \"application\",\n    \"strategy\": \"clone\",\n    \"lang\": \"java\",\n    \"framework\": \"springboot\",\n    \"buildTool\": \"maven\",\n    \"multiModule\": false,\n    \"repository\": {\n        \"url\": \"http(s)://git.sample.com/sample.git\",\n        // login and password are required only if repo is private\n\"login\": \"login\",\n        \"password\": \"password\"\n},\n    \"description\": \"Description\",\n    \"gitServer\": \"gerrit\",\n    \"jenkinsSlave\": \"maven\",\n    \"jobProvisioning\": \"default\",\n    \"deploymentScript\": \"openshift-template\"\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#application-import","title":"Application (Import)","text":"<pre><code>{\n    \"type\": \"application\",\n    \"strategy\": \"import\",\n    \"lang\": \"java\",\n    \"framework\": \"springboot\",\n    \"buildTool\": \"maven\",\n    \"multiModule\": false,\n    \"description\": \"Description\",\n    \"gitServer\": \"git-epam\",\n    \"gitUrlPath\": \"/relative/path/to/repo\",\n    \"jenkinsSlave\": \"maven\",\n    \"jobProvisioning\": \"default\",\n    \"deploymentScript\": \"openshift-template\"\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#autotests-clone","title":"Autotests (Clone)","text":"<pre><code>{\n    \"name\": \"aut01\",\n    \"type\": \"autotests\",\n    \"strategy\": \"clone\",\n    \"lang\": \"java\",\n    \"framework\": \"springboot\",\n    \"buildTool\": \"maven\",\n    \"testReportFramework\": \"allure\",\n    \"repository\": {\n        \"url\": \"http(s)://git.sample.com/sample.git\",\n        // login and password are required only if repo is private\n\"login\": \"login\",\n        \"password\": \"password\"\n},\n    \"description\": \"Description\",\n    \"jenkinsSlave\": \"maven\",\n    \"jobProvisioning\": \"default\"\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#autotests-import","title":"Autotests (Import)","text":"<pre><code>{\n    \"type\": \"autotests\",\n    \"strategy\": \"import\",\n    \"lang\": \"java\",\n    \"framework\": \"springboot\",\n    \"buildTool\": \"maven\",\n    \"testReportFramework\": \"allure\",\n    \"description\": \"Description\",\n    \"gitServer\": \"git-epam\",\n    \"gitRelativePath\": \"/relative/path/to/repo\",\n    \"jenkinsSlave\": \"maven\",\n    \"jobProvisioning\": \"default\"\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#library-create","title":"Library (Create)","text":"<pre><code>{\n    \"name\": \"lib01\",\n    \"type\": \"library\",\n    \"strategy\": \"create\",\n    \"lang\": \"java\",\n    \"buildTool\": \"maven\",\n    \"multiModule\": false,\n    \"jenkinsSlave\": \"maven\",\n    \"jobProvisioning\": \"default\",\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#library-clone","title":"Library (Clone)","text":"<pre><code>{\n    \"name\": \"lib01\",\n    \"type\": \"library\",\n    \"strategy\": \"clone\",\n    \"lang\": \"java\",\n    \"buildTool\": \"maven\",\n    \"multiModule\": false,\n    \"repository\": {\n    \"url\": \"http(s)://git.sample.com/sample.git\",\n    // login and password are required only if repo is private\n\"login\": \"login\",\n    \"password\": \"password\"\n},\n    \"vcs\": null,\n    \"jenkinsSlave\": \"maven\",\n    \"jobProvisioning\": \"default\",\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#library-import","title":"Library (Import)","text":"<pre><code>{\n    \"type\": \"library\",\n    \"strategy\": \"import\",\n    \"lang\": \"java\",\n    \"buildTool\": \"maven\",\n    \"multiModule\": false,\n    \"gitServer\": \"git-epam\",\n    \"gitUrlPath\": \"/relative/path/to/repo\",\n    \"jenkinsSlave\": \"maven\",\n    \"jobProvisioning\": \"default\",\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#response","title":"Response","text":"<pre><code>Status 200 OK\n</code></pre>"},{"location":"developer-guide/rest-api/#get-codebase-by-name","title":"Get Codebase by Name","text":""},{"location":"developer-guide/rest-api/#request_1","title":"Request","text":"<p><code>GET /api/v1/edp/codebase/{codebaseName}</code></p> <p>example: <code>localhost/api/v1/edp/codebase/app01</code></p>"},{"location":"developer-guide/rest-api/#response_1","title":"Response","text":"<pre><code>Status 200 OK\n{\n\"id\": 1,\n\"name\": \"app01\",\n\"language\": \"java\",\n\"build_tool\": \"maven\",\n\"framework\": \"springboot\",\n\"strategy\": \"create\",\n\"git_url\": \"\",\n\"route_site\": \"api\",\n\"route_path\": \"/\",\n\"type\": \"application\",\n\"status\": \"active\",\n\"testReportFramework\": \"\",\n\"description\": \"Description\",\n\"codebase_branch\": [\n{\n\"id\": 1,\n\"branchName\": \"master\",\n\"from_commit\": \"\",\n\"status\": \"active\",\n\"branchLink\": \"\",\n\"jenkinsLink\": \"\",\n\"appName\": \"\",\n\"codebaseDockerStream\": null\n}\n],\n\"gitServer\": \"gerrit\",\n\"gitProjectPath\": null,\n\"jenkinsSlave\": \"maven\",\n\"jobProvisioning\": \"default\",\n\"deploymentScript\": \"openshift-template\"\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#get-all-codebases","title":"Get All Codebases","text":""},{"location":"developer-guide/rest-api/#request_2","title":"Request","text":"<pre><code>GET /api/v1/edp/codebase?type={codebaseType}\n\nexample: localhost/api/v1/edp/codebase?type=application\n</code></pre>"},{"location":"developer-guide/rest-api/#response_2","title":"Response","text":"<pre><code>   Status 200 OK\n[\n{\n\"id\": 1,\n\"name\": \"app01\",\n\"language\": \"java\",\n\"build_tool\": \"maven\",\n\"framework\": \"springboot\",\n\"strategy\": \"create\",\n\"git_url\": \"\",\n\"route_site\": \"api\",\n\"route_path\": \"/\",\n\"type\": \"application\",\n\"status\": \"active\",\n\"testReportFramework\": \"\",\n\"description\": \"Description\",\n\"codebase_branch\": [\n{\n\"id\": 1,\n\"branchName\": \"master\",\n\"from_commit\": \"\",\n\"status\": \"active\",\n\"branchLink\": \"\",\n\"jenkinsLink\": \"\",\n\"appName\": \"\",\n\"codebaseDockerStream\": [\n{\n\"id\": 1,\n\"ocImageStreamName\": \"app01-master\",\n\"imageLink\": \"\",\n\"jenkinsLink\": \"\"\n}\n]\n}\n],\n\"gitServer\": \"gerrit\",\n\"gitProjectPath\": null,\n\"jenkinsSlave\": \"maven\",\n\"jobProvisioning\": \"\",\n\"deploymentScript\": \"openshift-template\"\n},\n{\n\"id\": 2,\n\"name\": \"app02\",\n\"language\": \"java\",\n\"build_tool\": \"maven\",\n\"framework\": \"springboot\",\n\"strategy\": \"create\",\n\"git_url\": \"\",\n\"route_site\": \"app\",\n\"route_path\": \"/\",\n\"type\": \"application\",\n\"status\": \"failed\",\n\"testReportFramework\": \"\",\n\"description\": \"\",\n\"codebase_branch\": [\n{\n\"id\": 2,\n\"branchName\": \"master\",\n\"from_commit\": \"\",\n\"status\": \"inactive\",\n\"branchLink\": \"\",\n\"jenkinsLink\": \"\",\n\"appName\": \"\",\n\"codebaseDockerStream\": [\n{\n\"id\": 2,\n\"ocImageStreamName\": \"app02-master\",\n\"imageLink\": \"\",\n\"jenkinsLink\": \"\"\n}\n]\n}\n],\n\"gitServer\": \"gerrit\",\n\"gitProjectPath\": null,\n\"jenkinsSlave\": \"maven\",\n\"jobProvisioning\": \"\",\n\"deploymentScript\": \"openshift-template\"\n}\n]\n</code></pre>"},{"location":"developer-guide/rest-api/#create-cd-pipeline-entity","title":"Create CD Pipeline Entity","text":""},{"location":"developer-guide/rest-api/#request_3","title":"Request","text":"<p><code>POST /api/v1/edp/cd-pipeline</code></p> <pre><code>{\n   \"name\":\"pipe1\",\n   \"applications\":[\n      {\n         \"appName\":\"app01\",\n         \"inputDockerStream\":\"app01-master\"\n      }\n   ],\n   \"stages\":[\n      {\n         \"name\":\"sit\",\n         \"description\":\"description-sit\",\n         \"qualityGateType\":\"manual\",\n         \"stepName\":\"approve\",\n         \"triggerType\":\"manual\",\n         \"order\":0,\n         \"qualityGates\": [\n             {\n             \"qualityGateType\":\"manual\",\n             \"stepName\":\"step-one-one\",\n             \"autotestName\": null,\n             \"branchName\": null\n            },\n            {\n             \"qualityGateType\":\"manual\",\n             \"stepName\":\"step-two-two\",\n             \"autotestName\": null,\n             \"branchName\": null\n            }\n         ]\n      }\n   ]\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#response_3","title":"Response","text":"<pre><code>Status 200 OK\n</code></pre>"},{"location":"developer-guide/rest-api/#get-cd-pipeline-entity-by-name","title":"Get CD Pipeline Entity by Name","text":""},{"location":"developer-guide/rest-api/#request_4","title":"Request","text":"<pre><code>GET /api/v1/edp/cd-pipeline/{cdPipelineName}\n\nexample: localhost/api/v1/edp/cd-pipeline/pipe1\n</code></pre>"},{"location":"developer-guide/rest-api/#response_4","title":"Response","text":"<pre><code>Status 200 OK\n{\n    \"id\": 1,\n    \"name\": \"pipe1\",\n    \"status\": \"active\",\n    \"jenkinsLink\": \"\",\n    \"codebaseBranches\": [\n        {\n            \"id\": 1,\n            \"branchName\": \"master\",\n            \"from_commit\": \"\",\n            \"status\": \"active\",\n            \"branchLink\": \"\",\n            \"jenkinsLink\": \"\",\n            \"appName\": \"java-springboot-helloworld\",\n            \"codebaseDockerStream\": [\n                {\n                    \"id\": 1,\n                    \"ocImageStreamName\": \"java-springboot-helloworld-master\",\n                    \"imageLink\": \"\",\n                    \"jenkinsLink\": \"\"\n                }\n            ]\n        }\n    ],\n    \"stages\": [\n        {\n            \"id\": 1,\n            \"name\": \"sit\",\n            \"description\": \"sit\",\n            \"triggerType\": \"manual\",\n            \"order\": 0,\n            \"platformProjectLink\": \"\",\n            \"platformProjectName\": env-am-test-deploy-sit\",\n            \"qualityGates\": [\n                {\n                    \"id\": 1,\n                    \"qualityGateType\": \"manual\",\n                    \"stepName\": \"manual\",\n                    \"cdStageId\": 1,\n                    \"autotest\": null,\n                    \"codebaseBranch\": null\n                }\n            ],\n            \"source\": {\n                \"type\": \"library\",\n                \"library\": {\n                    \"name\": \"lib01\",\n                    \"branch\": \"master\"\n                }\n            }\n        }\n    ],\n    \"services\": [],\n    \"applicationsToPromote\": [\n        \"java-springboot-helloworld\"\n    ]\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#get-cd-stage-entity-by-pipeline-and-stage-names","title":"Get CD Stage Entity by Pipeline and Stage Names","text":""},{"location":"developer-guide/rest-api/#request_5","title":"Request","text":"<pre><code>GET /api/v1/edp/cd-pipeline/{cdPipelineName}/stage/{stageName}\n\nexample: `localhost/api/v1/edp/cd-pipeline/pipe1/stage/sit\n</code></pre>"},{"location":"developer-guide/rest-api/#response_5","title":"Response","text":"<pre><code>{\n    \"name\": \"sit\",\n    \"cdPipeline\": \"pipe1\",\n    \"description\": \"sit\",\n    \"triggerType\": \"manual\",\n    \"order\": \"0\",\n    \"applications\": [\n        {\n            \"name\": \"java-springboot-helloworld\",\n            \"branchName\": \"master\",\n            \"inputIs\": \"java-springboot-helloworld-master\",\n            \"outputIs\": \"am-test-deploy-sit-java-springboot-helloworld-verified\"\n        }\n    ],\n    \"qualityGates\": [\n        {\n            \"id\": 1,\n            \"qualityGateType\": \"manual\",\n            \"stepName\": \"manual\",\n            \"cdStageId\": 1,\n            \"autotest\": null,\n            \"codebaseBranch\": null\n        }\n    ]\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#update-cd-pipeline-entity","title":"Update CD Pipeline Entity","text":""},{"location":"developer-guide/rest-api/#request_6","title":"Request","text":"<pre><code>PUT /api/v1/edp/cd-pipeline/{cdPipelineName}/update\n\nexample: localhost/api/v1/edp/cd-pipeline/pipe1/update\n</code></pre>"},{"location":"developer-guide/rest-api/#change-set-of-applications","title":"Change Set of Applications","text":"<pre><code>{\n    \"applications\":[\n      {\n         \"appName\":\"app01\",\n         \"inputDockerStream\":\"app01-master\"\n      },\n      {\n         \"appName\":\"app02\",\n         \"inputDockerStream\":\"app02\"\n      }\n    ]\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#response_6","title":"Response","text":"<pre><code>204 No Content\n</code></pre>"},{"location":"developer-guide/rest-api/#change-set-of-stages","title":"Change Set of Stages","text":"<pre><code>{\n    \"stages\": [\n        {\n            \"name\": \"sit\",\n            \"description\": \"sit\",\n            \"triggerType\": \"manual\",\n            \"order\": 0,\n            \"platformProjectLink\": \"\",\n            \"platformProjectName\": env-deploy-sit\",\n            \"qualityGates\": [\n                {\n                    \"id\": 1,\n                    \"qualityGateType\": \"manual\",\n                    \"stepName\": \"manual\",\n                    \"cdStageId\": 1,\n                    \"autotest\": null,\n                    \"codebaseBranch\": null\n                }\n            ],\n            \"source\": {\n                \"type\": \"library\",\n                \"library\": {\n                    \"name\": \"lib01\",\n                    \"branch\": \"master\"\n                }\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"developer-guide/rest-api/#response_7","title":"Response","text":"<pre><code>204 No Content\n</code></pre>"},{"location":"headlamp-user-guide/","title":"Overview","text":"<p>The EDP Headlamp User guide is intended for developers and provides details on working with EDP Headlamp, different codebase types, and EDP CI/CD flow.</p>"},{"location":"headlamp-user-guide/#headlamp","title":"Headlamp","text":"<p>Headlamp is a central management tool in the EDP ecosystem that provides the ability to define pipelines, project resources and new technologies in a simple way. Using Headlamp enables to manage business entities:</p> <ul> <li>Create such codebase types as Applications, Libraries and Autotests;</li> <li>Create/Update CD Pipelines;</li> </ul> <p>Note</p> <p>To interact with Headlamp via REST API, explore the Create Codebase Entity page.</p> <p> Overview page </p> <ol> <li>Navigation bar \u2013 consists of four sections: Overview, Components, CD Pipelines, and Git Servers. Click the necessary section to add an entity or open a home page.</li> <li>Login bar \u2013 contains notifications, language selection options, color scheme change, and login menu.</li> <li>Main links \u2013 displays the corresponding links to the major adjusted toolset, to the management tool and to the OpenShift cluster.</li> <li>Filter - used for searching and filtering the namespaces.</li> </ol> <p>Headlamp is a complete tool allowing to manage and control the codebases (applications, autotests, and libraries) added to the environment as well as to create a CD pipeline. Inspect the main features available in Headlamp by following the corresponding link:</p> <ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Add Git Server</li> <li>Add CD Pipeline</li> </ul>"},{"location":"headlamp-user-guide/add-application/","title":"Add Application","text":"<p>Headlamp allows to create, clone, import an application and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins/Tekton.</p> <p>To add an application, navigate to the Applications section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create Application dialog will appear. You can create an Application in YAML or via the three-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-application/#create-application-in-yaml","title":"Create Application in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create Application dialog to open the YAML editor and create the Application.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create Application dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-application/#create-application-in-the-dialog","title":"Create Application in the Dialog","text":"<p>The Create Application dialog contains the three steps:</p> <ul> <li>The Codebase Info Menu</li> <li>The Application Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"headlamp-user-guide/add-application/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p> Create application </p> <ol> <li> <p>Select the existing namespace from the drop-down list.</p> </li> <li> <p>In the Codebase Integration Strategy field, select the necessary configuration strategy:</p> <ul> <li>Create \u2013 creates a project on the pattern in accordance with an application language, a build tool, and a framework.</li> </ul> <ul> <li>Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well. Select the Codebase Authentication check box in case you clone the private repository, and fill in the repository login and password/access token.</li> </ul> <ul> <li>Import - allows configuring a replication from the Git server. While importing the existing repository, select the Git server from the drop-down list and define the relative path to the repository, such as /epmd-edp/examples/basic/edp-auto-tests-simple-example.</li> </ul> <p>Note</p> <p>In order to use the Import strategy, make sure to adjust it by the Enable VCS Import Strategy page. The Import strategy is not applicable for Gerrit.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Type the name of the application in the Application Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> </li> <li> <p>Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted. For the Clone and Import strategies: if you want to use the existing branch, enter its name into this field.</p> </li> <li> <p>To create an application with an empty repository in Gerrit, select the Empty project check box.</p> <p>Note</p> <p>The empty repository option is available only for the Create strategy.</p> </li> <li> <p>Select any of the supported application languages with its framework in the Application Code Language/framework field:</p> <ul> <li>Java \u2013 selecting Java allows using Java 8 or Java 11.</li> <li>JavaScript - selecting JavaScript allows using the React framework.</li> <li>DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1.</li> <li>Go - selecting Go allows using the Beego and Operator SDK frameworks.</li> <li>Python - selecting Python allows using the Python v.3.8.</li> <li>Other - selecting Other allows extending the default code languages when creating a codebase with the clone/import strategy. To add another code language, inspect the Add Other Code Language section.</li> </ul> <p>Note</p> <p>The Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>Choose the necessary build tool in the Select Build Tool field:</p> <ul> <li>Java - selecting Java allows using the Gradle or Maven tool.</li> <li>JavaScript - selecting JavaScript allows using the NPM tool.</li> <li>.Net - selecting .Net allows using the .Net tool.</li> </ul> <p>Note</p> <p>The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select CI pipeline provisioner that will be handling a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add another job provisioner.</p> </li> <li> <p>Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent.</p> </li> <li> <p>Select the necessary codebase versioning type:</p> <ul> <li>default - using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp - using the edp versioning type, a developer indicates the version number that will be used for all the artifacts stored in artifactory: binaries, pom.xml, metadata, etc. The version stored in repository (e.g. pom.xml) will not be affected or used. Using this versioning overrides any version stored in the repository files without changing actual file.</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> Edp versioning </p> <p>a. Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> </li> <li> <p>In the Deployment Script field, specify one of the available options: helm-chart / openshift-template that are predefined in case it is OpenShift or EKS.</p> </li> <li> <p>In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> <p> Integrate with jira server </p> </li> <li> <p>Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and setup the Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> </li> <li> <p>In the Jira Server field, select the Jira server.</p> </li> <li> <p>Specify the pattern to validate a commit message. Use regular expression to indicate the pattern that is followed on the project to validate a commit message in the code review pipeline. An example of the pattern: <code>^[PROJECT_NAME-d{4}]:.*$</code>.</p> </li> <li> <p>Specify the pattern to find a Jira ticket number in a commit message. Based on this pattern, the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value.</p> <p> Mapping field name </p> </li> <li> <p>In the Mapping field name section, specify the names of the Jira fields that should be filled in with attributes from EDP:</p> <p>a. Select the name of the field in a Jira ticket from the Mapping field name drop-down menu. The available fields are the following: Fix Version/s, Component/s and Labels.</p> <p>b. Click the plus icon to add the mapping field name.</p> <p>c. Enter Jira pattern for the field name:</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira.</li> <li>For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator.</li> <li>For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> <p>d. Click the bin icon to remove the Jira field name.</p> </li> <li> <p>Click the Apply button to add the application to the Applications list.</p> </li> </ol> <p>Note</p> <p>After the complete adding of the application, inspect the Application Overview part.</p>"},{"location":"headlamp-user-guide/add-application/#the-application-info-menu","title":"The Application Info Menu","text":"<p> Application info </p>"},{"location":"headlamp-user-guide/add-application/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p> Advanced settings </p>"},{"location":"headlamp-user-guide/add-application/#related-articles","title":"Related Articles","text":"<ul> <li>Application Overview</li> <li>Add CD Pipelines</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> <li>Promote Application in CD Pipeline</li> </ul>"},{"location":"headlamp-user-guide/add-autotest/","title":"Add Autotests","text":"<p>Headlamp enables to clone or import an autotest, add it to the environment with its subsequent deployment in Gerrit (in case the Clone strategy is used) and building of the Code Review pipeline in Jenkins/Tekton, as well as to use it for work with an application under development.  It is also possible to use autotests as quality gates in a newly created CD pipeline.</p> <p>Info</p> <p>Please refer to the Add Application section for the details on how to add an application codebase type. For the details on how to use autotests as quality gates, please refer to the Stages Menu section of the Add CD Pipeline documentation.</p> <p>To add an autotest, navigate to the Autotests section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create Autotest dialog will appear. You can create an autotest in YAML or via the three-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-autotest/#create-autotest-in-yaml","title":"Create Autotest in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create Autotest dialog to open the YAML editor and create an autotest.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create Autotest dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-autotest/#create-autotest-in-the-dialog","title":"Create Autotest in the Dialog","text":"<p>The Create Autotest dialog contains the three steps:</p> <ul> <li>The Codebase Info Menu</li> <li>The Autotest Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"headlamp-user-guide/add-autotest/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p>There are two available strategies: clone and import.</p> <ol> <li> <p>Select the existing namespace from the drop-down list.</p> </li> <li> <p>In the Codebase Integration Strategy field, select the necessary configuration strategy:</p> <ul> <li>Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well. Select the Codebase Authentication check box in case you clone the private repository, and fill in the repository login and password/access token.</li> </ul> <p> Clone autotest </p> <ul> <li>Import - allows configuring a replication from the Git server. While importing the existing repository, select the Git server from the drop-down list and define the relative path to the repository, such as /epmd-edp/examples/basic/edp-auto-tests-simple-example.</li> </ul> <p> Import autotest </p> <p>Note</p> <p>In order to use the Import strategy, make sure to adjust it by the Enable VCS Import Strategy page.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Fill in the Autotest Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> </li> <li> <p>Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> </li> <li> <p>Type the necessary description in the Description field.</p> </li> <li> <p>In the Application code language/framework field, select the Java code language (specify Java 8 or Java 11 to be used) and get the default Maven build tool OR add another code language. Selecting Other allows extending the default code languages and get the necessary build tool, for details, inspect the Add Other Code Language section.</p> <p>Note</p> <p>Using the Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>The Select Build Tool field can dispose of the default Maven tool, Gradle or other built tool in accordance with the selected code language.</p> </li> <li> <p>All the autotest reports will be created in the Allure framework that is available in the Autotest Report Framework field by default.x</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> </li> <li> <p>Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent.</p> </li> <li> <p>Select a CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add another job provisioner.</p> </li> <li> <p>Select the necessary codebase versioning type:</p> <ul> <li>default: Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp: Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml).</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> Edp versioning </p> <p>a. Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field must be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> <p> Jira integration </p> </li> <li> <p>Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> </li> <li> <p>As soon as the Jira server is set, select it in the Select Jira Server field.</p> </li> <li> <p>Specify the pattern to validate a commit message. Use regular expression to indicate the pattern that is followed on the project to validate a commit message in the code review pipeline. An example of the pattern: <code>^[PROJECT_NAME-d{4}]:.*$</code></p> </li> <li> <p>Specify the pattern to find a Jira ticket number in a commit message. Based on this pattern, the value from EDP will be displayed in Jira.</p> </li> <li> <p>In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP:</p> <p> Advance mapping </p> <p>a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> <p>b. Click the plus icon to add the mapping field name.</p> <p>c. Enter Jira pattern for the field name:</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira.</li> <li>For the Component/s field select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator.</li> <li>For the Labels field select the EDP_GITTAGvariable that defines a tag assigned to the commit in Git Hub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> <p>d. Click the bin icon to remove the Jira field name.</p> </li> <li> <p>Click the Apply button to add the autotest to the Autotests list.</p> </li> </ol> <p>Note</p> <p>After the complete adding of the autotest, inspect the Autotest Overview part.</p>"},{"location":"headlamp-user-guide/add-autotest/#the-autotest-info-menu","title":"The Autotest Info Menu","text":"<p> Autotest info </p>"},{"location":"headlamp-user-guide/add-autotest/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p> Advanced settings </p>"},{"location":"headlamp-user-guide/add-autotest/#related-articles","title":"Related Articles","text":"<ul> <li>Autotest Overview</li> <li>Add Application</li> <li>Add CD Pipelines</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> </ul>"},{"location":"headlamp-user-guide/add-cd-pipeline/","title":"Add CD Pipeline","text":"<p>Headlamp provides the ability to deploy an environment on your own and specify the essential components.</p> <p>Navigate to the CD Pipelines section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create CD Pipeline dialog will appear.</p> <p>The creation of the CD pipeline becomes available as soon as an application is created including its provisioning in a branch and the necessary entities for the environment. You can create the CD pipeline in YAML or via the three-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-cd-pipeline/#create-cd-pipeline-in-yaml","title":"Create CD Pipeline in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create CD Pipeline dialog to open the YAML editor and create the CD Pipeline.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create CD Pipeline dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-cd-pipeline/#create-cd-pipeline-in-the-dialog","title":"Create CD Pipeline in the Dialog","text":"<p>The Create CD Pipeline dialog contains the three steps:</p> <ul> <li>The Pipeline Menu</li> <li>The Applications Menu</li> <li>The Stages Menu</li> </ul>"},{"location":"headlamp-user-guide/add-cd-pipeline/#the-pipeline-menu","title":"The Pipeline Menu","text":"<p> Create CD pipeline </p> <ol> <li> <p>Select the existing namespace from the drop-down list.</p> </li> <li> <p>Type the name of the pipeline in the Pipeline Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> <p>Note</p> <p>The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name]. Please be aware that the namespace length should not exceed 63 symbols.</p> </li> <li> <p>Select the deployment type from the drop-down list:</p> <ul> <li>Container - the pipeline will be deployed in a Docker container;</li> <li>Custom - this mode allows to deploy non-container applications and customize the Init stage of CD pipeline.</li> </ul> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select the necessary application from the Mapping field name drop-down menu.</p> </li> <li>Select the plus sign icon near the selected application to specify the necessary codebase Docker branch for the application (the output for the branch and other stages from other CD pipelines).</li> <li>Select the application branch from the drop-down menu.</li> <li> <p>Select the Promote in pipeline check box in order to transfer the application from one to another stage by the specified codebase Docker branch. If the Promote in pipeline check box is not selected, the same codebase Docker stream will be deployed regardless of the stage, i.e. the codebase Docker stream input, which was selected for the pipeline, will always be used.</p> <p>Note</p> <p>The newly created CD pipeline has the following pattern combination: [pipeline name]-[branch name]. If there is another deployed CD pipeline stage with the respective codebase Docker stream (= image stream as an OpenShift term), the pattern combination will be as follows: [pipeline name]-[stage name]-[application name]-[verified].</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Click the plus sign icon in the Stages menu and fill in the necessary fields in the Adding Stage window :</p> <p> CD stages </p> <p> Adding stage </p> <p>a. Type the stage name;</p> <p>Note</p> <p>The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name]. Please be aware that the namespace length should not exceed 63 symbols.</p> <p>b. Enter the description for this stage;</p> <p>c. Select the trigger type. The available trigger types are Manual and Auto. By selecting the Auto trigger type, the CD pipeline will be launched automatically after the image is built. Every trigger type has a set of default stages that differ by the input stage (auto-deploy-input or manual-deploy-input).</p> <p>Note</p> <p>When changing the Trigger Type, the job-provision automatically will change the set of stages to the corresponding stages set for the CD pipeline.</p> <p>d. Select the job provisioner. In case of working with non container-based applications, there is an option to use a custom job provisioner. Please refer to the Manage Jenkins CD Job Provision page for details.</p> <p>e. Select the groovy-pipeline library;</p> <p>f. Select the branch;</p> <p>g. Add an unlimited number of quality gates by clicking a corresponding plus sign icon and remove them as well by clicking the recycle bin icon;</p> <p>h. Type the step name, which will be displayed in Jenkins/Tekton, for every quality gate;</p> <p>i. Select the quality gate type:</p> <ul> <li>Manual - means that the promoting process should be confirmed in Jenkins/Tekton manually;</li> <li>Autotests - means that the promoting process should be confirmed by the successful passing of the autotests.</li> </ul> <p>In the additional fields, select the previously created autotest name (j) and specify its branch for the autotest that will be launched on the current stage (k).</p> <p>Note</p> <p>Execution sequence. The image promotion and execution of the pipelines depend on the sequence in which the environments are added.</p> <p>l. Click the Apply button to display the stage in the Stages menu.</p> </li> <li> <p>Edit the stage by clicking its name and applying changes, and remove the added stage by clicking the recycle bin icon next to its name.</p> </li> </ol> <p> Continuous delivery menu </p> <ol> <li>Click the Apply button to start the provisioning of the pipeline. After the CD pipeline is added, the new project with the stage name will be created in OpenShift.</li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#the-applications-menu","title":"The Applications Menu","text":"<p> CD pipeline applications </p>"},{"location":"headlamp-user-guide/add-cd-pipeline/#the-stages-menu","title":"The Stages Menu","text":""},{"location":"headlamp-user-guide/add-cd-pipeline/#manage-cd-pipeline","title":"Manage CD Pipeline","text":"<p>As soon as the CD pipeline is provisioned and added to the CD Pipelines list, there is an ability to:</p> <p> CD pipeline page </p> <ol> <li> <p>Create another application by clicking the plus sign icon in the lower-right corner of the screen and performing the same steps as described in the Add CD Pipeline section.</p> </li> <li> <p>Open CD pipeline data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the CD pipeline, such as name and deployment type.</li> <li>Applications - displays the CD pipeline applications to promote.</li> <li>Stages - displays the CD pipeline stages and stage metadata (by selecting the information icon near the stage name); allows to add, edit and delete stages, as well as deploy or uninstall image stream versions of the related applications for a stage.</li> <li>Metadata - displays the CD pipeline name, namespace, creation date, finalizers, generation, resource version, and UID. Open this block by selecting the information icon near the options icon next to the CD pipeline name.</li> </ul> </li> <li> <p>Edit the CD pipeline by selecting the options icon next to its name in the CD Pipelines list, and then selecting Edit. For details see the Edit Existing CD Pipeline section.</p> </li> <li> <p>Delete the added CD pipeline by selecting the options icon next to its name in the CD Pipelines list, and then selecting Delete.</p> <p>Info</p> <p>In OpenShift, if the deployment fails with the ImagePullBackOff error, delete the POD.</p> </li> <li> <p>Sort the existing CD pipelines in a table by clicking the sorting icons in the table header. When sorting by name, the CD pipelines will be displayed in alphabetical order. You can also sort the CD pipelines by their status.</p> </li> <li> <p>Search the necessary CD pipeline by the namespace or by entering the corresponding name, language or the build tool into the Filter tool.</p> </li> <li> <p>Select a number of CD pipelines displayed per page (15, 25 or 50 rows) and navigate between pages if the number of CD pipelines exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#edit-existing-cd-pipeline","title":"Edit Existing CD Pipeline","text":"<p>Edit the CD pipeline directly from the CD Pipelines overview page or when viewing the CD Pipeline data:</p> <ol> <li> <p>Select Edit in the options icon menu next to the CD pipeline name:</p> <p> Edit CD pipeline on the CD Pipelines overview page </p> <p> Edit CD pipeline when viewing the CD pipeline data </p> </li> <li> <p>Apply the necessary changes (edit the list of applications for deploy, application branches, and promotion in the pipeline). Add new extra stages by clicking the plus sign icon and filling in the application branch and promotion in the pipeline.</p> <p> Edit CD pipeline dialog </p> </li> <li> <p>Select the Apply button to confirm the changes.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#add-a-new-stage","title":"Add a New Stage","text":"<p>In order to create a new stage for the existing CD pipeline, follow the steps below:</p> <ol> <li> <p>Navigate to the Stages block by clicking the CD pipeline name link in the CD Pipelines list.</p> <p> Add CD pipeline stage </p> </li> <li> <p>Select Create to open the Create stage dialog.</p> </li> <li> <p>Click Edit YAML in the upper-right corner of the Create stage dialog to open the YAML editor and add a stage. Otherwise, fill in the required fields in the dialog. Please see the Stages Menu section for details.</p> </li> <li> <p>Click the Apply button.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#edit-stage","title":"Edit Stage","text":"<p>In order to edit a stage for the existing CD pipeline, follow the steps below:</p> <ol> <li> <p>Navigate to the Stages block by clicking the CD pipeline name link in the CD Pipelines list.</p> <p> Edit CD pipeline stage </p> </li> <li> <p>Select the options icon related to the necessary stage and then select Edit.</p> <p> Edit CD pipeline stage dialog </p> </li> <li> <p>In the Edit Stage dialog, change the stage trigger type. See more about this field in the Stages Menu section.</p> </li> <li> <p>Click the Apply button.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#delete-stage","title":"Delete Stage","text":"<p>Note</p> <p>You cannot remove the last stage, as the CD pipeline does not exist without stages.</p> <p>In order to delete a stage for the existing CD pipeline, follow the steps below:</p> <ol> <li> <p>Navigate to the Stages block by clicking the CD pipeline name link in the CD Pipelines list.</p> <p> Delete CD pipeline stage </p> </li> <li> <p>Select the options icon related to the necessary stage and then select Delete. After the confirmation, the CD stage is deleted with all its components: database record, Jenkins/Tekton pipeline, and cluster namespace.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-cd-pipeline/#view-stage-data","title":"View Stage Data","text":"<p>To view the CD pipeline stage data for the existing CD pipeline, follow the steps below:</p> <ol> <li> <p>Navigate to the Stages block by clicking the CD pipeline name link in the CD Pipelines list.</p> <p> Expand CD pipeline stage </p> </li> <li> <p>Select the expand icon near the stage name. The following blocks will be displayed:</p> <p> CD pipeline stage overview </p> </li> </ol> <ul> <li>Applications - displays the status of the applications related to the stage and allows deploying the applications. Applications health and sync statuses are returned from the Argo CD tool.</li> <li>General Info - displays the stage status, CD pipeline, description, job provisioning, order, trigger type, and source.</li> <li>Quality Gates - displays the stage quality gate type, step name, autotest name, and branch name.</li> </ul>"},{"location":"headlamp-user-guide/add-cd-pipeline/#deploy-application","title":"Deploy Application","text":"<p>Navigate to the Applications block of the stage and select an application. Select the image stream version from the drop-down list and click Deploy. The application will be deployed in the Argo CD tool as well.</p> <p> Deploy the promoted application </p> <p>To update or uninstall the application, select Update or Uninstall.</p> <p> Update or uninstall the application </p> <p>After this, the application will be updated or uninstalled in the Argo CD tool as well.</p>"},{"location":"headlamp-user-guide/add-cd-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Manage Jenkins CD Pipeline Job Provision</li> </ul>"},{"location":"headlamp-user-guide/add-git-server/","title":"Add Git Server","text":"<p>Important</p> <p>This article describes how to add a Git Server when deploying EDP with Jenkins. When deploying EDP with Tekton, Git Server is created automatically.</p> <p>Add Git servers to use the Import strategy for Jenkins when creating an application, autotest or library in EDP Headlamp (Codebase Info step of the Create Application/Autotest/Library dialog). Enabling the Import strategy is a prerequisite to integrate EDP with Gitlab or GitHub.</p> <p>Note</p> <p><code>GitServer</code> Custom Resource can be also created manually. See step 3 for Jenkins import strategy in the Enable VCS Import Strategy article.</p> <p>To add a Git server, navigate to the Git servers section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create Git server dialog will appear. You can create a Git server in YAML or via the three-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-git-server/#create-git-server-in-yaml","title":"Create Git Server in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create Git server dialog to open the YAML editor and create a Git server.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create Git server dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-git-server/#create-git-server-in-the-dialog","title":"Create Git Server in the Dialog","text":"<p>Fill in the following fields:</p> <p> Create Git server </p> <ul> <li>Git provider - select Gerrit, GitLab or GitHub.</li> <li>Host - enter a Git server endpoint.</li> <li>User - enter a user for Git integration.</li> <li>SSH port - enter a Git SSH port.</li> <li>HTTPS port - enter a Git HTTPS port.</li> <li>Private SSH key - enter a private SSH key for Git integration. To generate this key, follow the instructions of the step 1 for Jenkins in the Enable VCS Import Strategy article.</li> <li>Access token - enter an access token for Git integration. To generate this token, go to GitLab/GitHub account -&gt; Settings -&gt; SSH and GPG keys -&gt; select New SSH key and add SSH key.</li> </ul> <p>Click the Apply button to add the Git server to the Git servers list. As a result, the Git Server object and the corresponding secret for further integration will be created.</p>"},{"location":"headlamp-user-guide/add-git-server/#related-articles","title":"Related Articles","text":"<ul> <li>Enable VCS Import Strategy</li> <li>GitHub Integration</li> <li>GitLab Integration</li> </ul>"},{"location":"headlamp-user-guide/add-library/","title":"Add Library","text":"<p>Headlamp helps to create, clone or import a library and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins/Tekton.</p> <p>To add a library, navigate to the Libraries section on the navigation bar and click Create (the plus sign icon in the lower-right corner of the screen). Once clicked, the Create Library dialog will appear. You can create a library in YAML or via the three-step menu in the dialog.</p>"},{"location":"headlamp-user-guide/add-library/#create-library-in-yaml","title":"Create Library in YAML","text":"<p>Click Edit YAML in the upper-right corner of the Create Library dialog to open the YAML editor and create the Library.</p> <p> Edit YAML </p> <p>To edit YAML in the minimal editor, turn on the Use minimal editor toggle in the upper-right corner of the Create Application dialog.</p> <p>To save the changes, select the Save &amp; Apply button.</p>"},{"location":"headlamp-user-guide/add-library/#create-library-in-the-dialog","title":"Create Library in the Dialog","text":"<p>The Create Library dialog contains the three steps:</p> <ul> <li>The Codebase Info Menu</li> <li>The Library Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"headlamp-user-guide/add-library/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p> Create library </p> <ol> <li> <p>Select the existing namespace from the drop-down list.</p> </li> <li> <p>In the Codebase Integration Strategy field, select the necessary configuration strategy:</p> <ul> <li>Create \u2013 creates a project on the pattern in accordance with a code language, a build tool, and a framework.</li> </ul> <ul> <li>Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well. Select the Codebase Authentication check box in case you clone the private repository, and fill in the repository login and password/access token.</li> </ul> <ul> <li>Import - allows configuring a replication from the Git server. While importing the existing repository, select the Git server from the drop-down list and define the relative path to the repository, such as /epmd-edp/examples/basic/edp-auto-tests-simple-example.</li> </ul> <p>Note</p> <p>In order to use the Import strategy, make sure to adjust it by the Enable VCS Import Strategy page.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Type the name of the library in the Library name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> </li> <li> <p>Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> </li> <li> <p>To create a library with an empty repository in Gerrit, select the Empty project check box.</p> <p>Note</p> <p>The empty repository option is available only for the Create strategy.</p> </li> <li> <p>Select any of the supported code languages with its framework in the Application code language/framework field:</p> <ul> <li>Java \u2013 selecting Java allows to specify Java 8 or Java 11, and further usage of the Gradle or Maven tool.</li> <li>JavaScript - selecting JavaScript allows using the NPM tool.</li> <li>DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1.</li> <li>Groovy-pipeline - selecting Groovy-pipeline allows having the ability to customize a stages logic. For details, please refer to the Customize CD Pipeline page.</li> <li>Python - selecting Python allows using the Python v.3.8.</li> <li>Terraform - selecting Terraform allows using the Terraform different versions via the Terraform version manager (tfenv). EDP supports all actions available in Terraform, thus providing the ability to modify the virtual infrastructure and launch some checks with the help of linters. For details, please refer to the Use Terraform Library in EDP page.</li> <li>Rego - this option allows using Rego code language with an Open Policy Agent (OPA) Library. For details, please refer to the Use Open Policy Agent page.</li> <li>Container - this option allows using the Kaniko tool for building the container images from a Dockerfile. For details, please refer to the CI Pipeline for Container page.</li> <li>Other - selecting Other allows extending the default code languages when creating a codebase with the Clone/Import strategy. To add another code language, inspect the Add Other Code Language page.</li> </ul> <p>Note</p> <p>The Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language:</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> </li> <li> <p>Select the Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent.</p> </li> <li> <p>Select the CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner.</p> </li> <li> <p>Select the necessary codebase versioning type:</p> <ul> <li>default: Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp: Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml).</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> EDP versioning </p> <p>a. Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> <p> Integrate with Jira server </p> </li> <li> <p>Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> </li> <li> <p>As soon as the Jira server is set, select it in the Select Jira Server field.</p> </li> <li> <p>Specify the pattern to validate a commit message. Use regular expression to indicate the pattern that is followed on the project to validate a commit message in the code review pipeline. An example of the pattern: <code>^[PROJECT_NAME-d{4}]:.*$</code></p> </li> <li> <p>Specify the pattern to find a Jira ticket number in a commit message. Based on this pattern, the value from EDP will be displayed in Jira.</p> </li> <li> <p>In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP:</p> <p> Mapping field name </p> <p>a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> <p>b. Click the plus icon to add the mapping field name.</p> <p>c. Enter Jira pattern for the field name:</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira.</li> <li>For the Component/s field select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator.</li> <li>For the Labels field select the EDP_GITTAGvariable that defines a tag assigned to the commit in Git Hub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> <p>d. Click the bin icon to remove the Jira field name.</p> </li> <li> <p>Click the Apply button to add the library to the Libraries list.</p> <p>Note</p> <p>After the complete adding of the library, inspect the Library Overview part.</p> </li> </ol>"},{"location":"headlamp-user-guide/add-library/#the-library-info-menu","title":"The Library Info Menu","text":"<p> Library info </p>"},{"location":"headlamp-user-guide/add-library/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p> Advanced settings </p>"},{"location":"headlamp-user-guide/add-library/#related-articles","title":"Related Articles","text":"<ul> <li>Library Overview</li> <li>Add CD Pipeline</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> </ul>"},{"location":"headlamp-user-guide/application/","title":"Application","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing applications.</p>"},{"location":"headlamp-user-guide/application/#check-and-remove-application","title":"Check and Remove Application","text":"<p>As soon as the application is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins/Tekton for this application. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins/Tekton is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins/Tekton is passed as well.</li> </ul> <p>The added application will be listed in the Applications list allowing you to do the following:</p> <p> Applications menu </p> <ol> <li> <p>Create another application by clicking the plus sign icon in the lower-right corner of the screen and performing the same steps as described in the Add Applications section.</p> </li> <li> <p>Open application data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the created/cloned/imported application, such as language, if the project is empty or not, build tool, framework, strategy, and default branch.</li> <li>Advanced Settings - displays the specified job provisioner, CI tool, deployment script, Jenkins agent, Jira server,Jira issue metadata payload, commit message pattern, and ticket name pattern.</li> <li>Branches - displays the status and name of the deployment branch.</li> <li>Metadata - displays the application name, namespace, creation date, finalizers, generation, resource version, and UID. Open this block by selecting the information icon near the options icon next to the application name.</li> </ul> </li> <li> <p>Edit the application by selecting the options icon next to its name in the Applications list, and then selecting Edit. For details see the Edit Existing Application section.</p> </li> <li> <p>Remove application by selecting the options icon next to its name in the Applications list, and then selecting Delete.</p> <p>Note</p> <p>The application that is used in a CD pipeline cannot be removed.</p> </li> <li> <p>Sort the existing applications in a table by clicking the sorting icons in the table header. Sort the applications alphabetically by their name, language, build tool, framework, and CI tool. You can also sort the applications by their status: Created, Failed, or In progress.</p> </li> <li> <p>Search the necessary application by the namespace or by entering the corresponding name, language or the build tool into the Filter tool.</p> </li> <li> <p>Select a number of applications displayed per page (15, 25 or 50 rows)  and navigate between pages if the number of applications exceeds the capacity of a single page.</p> <p> Applications menu </p> </li> </ol>"},{"location":"headlamp-user-guide/application/#edit-existing-application","title":"Edit Existing Application","text":"<p>EDP Headlamp provides the ability to enable, disable or edit the Jira Integration functionality for applications.</p> <ol> <li> <p>To edit an application directly from the Applications overview page or when viewing the application data:</p> <ul> <li>Select Edit in the options icon menu:</li> </ul> <p> Edit application on the Applications overview page </p> <p> Edit application when viewing the application data </p> <ul> <li>The Edit Application dialog opens.</li> </ul> </li> <li> <p>To enable Jira integration, in the Edit Application dialog do the following:</p> <p> Edit application </p> <p>a. Mark the Integrate with Jira server check box and fill in the necessary fields. Please see steps 15-19 on the Add Application page.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</p> </li> <li> <p>To disable Jira integration, in the Edit Application dialog do the following:</p> <p>a. Unmark the Integrate with Jira server check box.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</p> </li> </ol>"},{"location":"headlamp-user-guide/application/#add-a-new-branch","title":"Add a New Branch","text":"<p>Note</p> <p>Pay attention when specifying the branch name: the branch name is involved in the formation of the application version, so it must comply with the versioning semantic rules for the application.</p> <p>When adding an application, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li>Navigate to the Branches block by clicking the application name link in the Applications list.</li> <li> <p>Select the options icon related to the necessary branch and then select Create:</p> <p> Add branch </p> </li> <li> <p>Click Edit YAML in the upper-right corner of the Create Application dialog to open the YAML editor and add a branch. Otherwise, fill in the required fields in the dialog:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch.</p> <p>b. Branch name - type the branch name. Pay attention that this field remains static if you create a release branch. For the Clone and Import strategies: If you want to use the existing branch, enter its name into this field.</p> <p>c. From Commit Hash - paste the commit hash from which the branch will be created. For the Clone and Import strategies: Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Default branch version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number.</p> <p>f. Click the Apply button and wait until the new branch will be added to the list.</p> </li> </ol> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type.</p> <p>The default application repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"headlamp-user-guide/application/#build-branch","title":"Build Branch","text":"<p>In order to build branch from the latest commit, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the application name link in the Applications list.</li> <li> <p>Select the options icon related to the necessary branch and then select Build:</p> <p> Build branch </p> </li> </ol> <p>The pipeline run status is displayed near the branch name in the Branches block:</p> <p> Pipeline run status in Headlamp </p> <p>The corresponding item appears on the Tekton Dashboard in the PipelineRuns section:</p> <p> Pipeline run status in Tekton </p>"},{"location":"headlamp-user-guide/application/#edit-branch","title":"Edit Branch","text":"<p>In order to edit a branch with the corresponding record in the Headlamp database, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the application name link in the Applications list.</li> <li> <p>Select the options icon related to the necessary branch and then select Edit:</p> <p> Edit branch </p> </li> <li> <p>Edit the YAML file in a standard or minimal editor and select Save &amp; Apply:</p> <p> Edit branch </p> </li> </ol>"},{"location":"headlamp-user-guide/application/#delete-branch","title":"Delete Branch","text":"<p>Note</p> <p>The default master branch cannot be removed.</p> <p>In order to delete the added branch with the corresponding record in the Headlamp database, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the application name link in the Applications list.</li> <li> <p>Select the options icon related to the necessary branch and then select Delete:</p> <p> Delete branch </p> </li> </ol>"},{"location":"headlamp-user-guide/application/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Promote Application in CD Pipeline</li> </ul>"},{"location":"headlamp-user-guide/autotest/","title":"Autotest","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing autotests.</p>"},{"location":"headlamp-user-guide/autotest/#check-and-remove-autotest","title":"Check and Remove Autotest","text":"<p>As soon as the autotest is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins/Tekton for this autotest. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins/Tekton is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins/Tekton is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins/Tekton, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added autotest will be listed in the Autotests list allowing you to do the following:</p> <p> Autotests page </p> <ol> <li> <p>Create another autotest by clicking the plus sign icon in the lower-right corner of the screen and performing the same steps as described on the Add Autotest page.</p> </li> <li> <p>Open autotest data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>Branches - displays the status and name of the deployment branch.</li> <li>General Info - displays common information about the cloned/imported autotest, such as language, if the project is empty or not, build tool, framework, strategy, and default branch.</li> <li>Advanced Settings - displays the specified job provisioner, CI tool, deployment script, Jenkins agent, Jira server,Jira issue metadata payload, commit message pattern, and ticket name pattern.</li> <li>Metadata - displays the autotest name, namespace, creation date, finalizers, generation, resource version, and UID. Open this block by selecting the information icon near the options icon next to the autotest name.</li> </ul> </li> <li> <p>Edit the autotest by selecting the options icon next to its name in the Autotests list, and then selecting Edit. For details see the Edit Existing Autotest section.</p> </li> <li> <p>Remove autotest with the corresponding database and Jenkins/Tekton pipelines by selecting the options icon next to its name in the Autotests list, and then selecting Delete:</p> <p>Note</p> <p>The autotest that is used in a CD pipeline cannot be removed.</p> </li> <li> <p>Sort the existing autotests in a table by clicking the sorting icons in the table header. Sort the autotests alphabetically by their name, language, build tool, framework, and CI tool. You can also sort the autotests by their status: Created, Failed, or In progress.</p> </li> <li> <p>Search the necessary autotests by the namespace or by entering the corresponding name, language or the build tool into the Filter tool.</p> </li> <li> <p>Select a number of autotests displayed per page (15, 25 or 50 rows)  and navigate between pages if the number of autotests exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#edit-existing-autotest","title":"Edit Existing Autotest","text":"<p>EDP Headlamp provides the ability to enable, disable or edit the Jira Integration functionality for autotests.</p> <ol> <li> <p>To edit an autotest directly from the Autotests overview page or when viewing the autotest data:</p> <ul> <li> <p>Select Edit in the options icon menu:</p> <p> Edit autotest on the autotests overview page </p> <p> Edit autotest when viewing the autotest data </p> </li> </ul> <ul> <li>The Edit Autotest dialog opens.</li> </ul> </li> <li> <p>To enable Jira integration, on the Edit Autotest page do the following:</p> <p> Edit library </p> <p>a. Mark the Integrate with Jira server check box and fill in the necessary fields. Please see steps 15-19 on the Add Autotests page.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</p> <p>Note</p> <p>Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration and Adjust VCS Integration With Jira pages.</p> </li> <li> <p>To disable Jira integration, in the Edit Autotest dialog do the following:</p> <p>a. Unmark the Integrate with Jira server check box.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</p> </li> </ol> <p>As a result, the necessary changes will be applied.</p>"},{"location":"headlamp-user-guide/autotest/#add-a-new-branch","title":"Add a New Branch","text":"<p>Note</p> <p>Pay attention when specifying the branch name: the branch name is involved in the formation of the autotest version, so it must comply with the versioning semantic rules for the application.</p> <p>When adding an autotest, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li> <p>Navigate to the Branches block by clicking the autotest name link in the Autotests list.</p> </li> <li> <p>Select the options icon related to the necessary branch and then select Create:</p> <p> Add branch </p> </li> <li> <p>Click Edit YAML in the upper-right corner of the Create Autotest dialog to open the YAML editor and add a branch. Otherwise, fill in the required fields in the dialog:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch.</p> <p>b. Branch name - type the branch name. Pay attention that this field remains static if you create a release branch. If you want to use the existing branch, enter its name into this field.</p> <p>c. From Commit Hash - paste the commit hash from which the branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Default branch version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number.</p> <p>f. Click the Apply button and wait until the new branch will be added to the list.</p> </li> </ol> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type. To get more information on how to add a branch using the default versioning type, please refer to the Add Autotest instruction.</p> <p>The default autotest repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"headlamp-user-guide/autotest/#build-branch","title":"Build Branch","text":"<p>In order to build branch from the latest commit, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the autotest name link in the Autotests list.</li> <li> <p>Select the options icon related to the necessary branch and then select Build:</p> <p> Build branch </p> </li> </ol> <p>The pipeline run status is displayed near the branch name in the Branches block:</p> <p> Pipeline run status in Headlamp </p> <p>The corresponding item appears on the Tekton Dashboard in the PipelineRuns section:</p> <p> Pipeline run status in Tekton </p>"},{"location":"headlamp-user-guide/autotest/#edit-branch","title":"Edit Branch","text":"<p>In order to edit a branch with the corresponding record in the Headlamp database, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the autotest name link in the Autotests list.</li> <li> <p>Select the options icon related to the necessary branch and then select Edit:</p> <p> Edit branch </p> </li> <li> <p>Edit the YAML file in a standard or minimal editor and select Save &amp; Apply:</p> <p> Edit branch </p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#delete-branch","title":"Delete Branch","text":"<p>Note</p> <p>The default master branch cannot be removed.</p> <p>In order to delete the added branch with the corresponding record in the Headlamp database, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the library name link in the Libraries list.</li> <li> <p>Select the options icon related to the necessary branch and then select Delete:</p> <p> Delete branch </p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#add-autotest-as-a-quality-gate","title":"Add Autotest as a Quality Gate","text":"<p>In order to add an autotest as a quality gate to a newly added CD pipeline, do the following:</p> <ol> <li> <p>Create a CD pipeline with the necessary parameters. Please refer to the Add CD Pipeline section for the details.</p> </li> <li> <p>In the Stages menu, select the Autotest quality gate type. It means the promoting process should be confirmed by the successful passing of the autotests.</p> </li> <li> <p>In the additional fields, select the previously created autotest name and specify its branch.</p> </li> <li> <p>After filling in all the necessary fields, click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new namespace containing the stage name will be created in Kubernetes (in OpenShift, a new project will be created) with the following name pattern: [cluster name]-[cd pipeline name]-[stage name].</p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#configure-autotest-launch-at-specific-stage","title":"Configure Autotest Launch at Specific Stage","text":"<p>In order to configure the added autotest launch at the specific stage with necessary parameters, do the following:</p> <ol> <li> <p>Add the necessary stage to the CD pipeline. Please refer to the Add CD Pipeline documentation for the details.</p> </li> <li> <p>Navigate to the run.json file and add the stage name and the specific parameters.</p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#launch-autotest-locally","title":"Launch Autotest Locally","text":"<p>There is an ability to run the autotests locally using the IDEA (Integrated Development Environment Application, such as IntelliJ, NetBeans etc.). To launch the autotest project for the local verification, perform the following steps:</p> <ol> <li> <p>Clone the project to the local machine.</p> </li> <li> <p>Open the project in IDEA and find the run.json file to copy out the necessary command value.</p> </li> <li> <p>Paste the copied command value into the Command line field and run it with the necessary values and namespace.</p> </li> <li> <p>As a result, all launched tests will be executed.</p> </li> </ol>"},{"location":"headlamp-user-guide/autotest/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotests</li> <li>Add CD Pipeline</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> </ul>"},{"location":"headlamp-user-guide/library/","title":"Library","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing libraries.</p>"},{"location":"headlamp-user-guide/library/#check-and-remove-library","title":"Check and Remove Library","text":"<p>As soon as the library is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins/Tekton for this library. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins/Tekton is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins/Tekton is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins/Tekton, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added library will be listed in the Libraries list allowing to do the following:</p> <p> Library menu </p> <ol> <li> <p>Create another library by clicking the plus sign icon in the lower-right corner of the screen and performing the same steps as described on the Add Library page.</p> </li> <li> <p>Open library data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the created/cloned/imported library, such as language, if the project is empty or not, build tool, framework, strategy, and default branch.</li> <li>Advanced Settings - displays the specified job provisioner, CI tool, deployment script, Jenkins agent, Jira server,Jira issue metadata payload, commit message pattern, and ticket name pattern.</li> <li>Branches - displays the status and name of the deployment branch.</li> <li>Metadata - displays the library name, namespace, creation date, finalizers, generation, resource version, and UID. Open this block by selecting the information icon near the options icon next to the library name.</li> </ul> </li> <li> <p>Edit the library by selecting the options icon next to its name in the Libraries list, and then selecting Edit. For details see the Edit Existing Library section.</p> </li> <li> <p>Remove library with the corresponding database and Jenkins/Tekton pipelines by selecting the options icon next to its name in the Libraries list, and then selecting Delete:</p> <p>Note</p> <p>The library that is used in a CD pipeline cannot be removed.</p> </li> <li> <p>Sort the existing libraries in a table by clicking the sorting icons in the table header. Sort the libraries alphabetically by their name, language, build tool, framework, and CI tool. You can also sort the libraries by their status: Created, Failed, or In progress.</p> </li> <li> <p>Search the necessary libraries by the namespace or by entering the corresponding name, language or the build tool into the Filter tool.</p> </li> <li> <p>Select a number of libraries displayed per page (15, 25 or 50 rows) and navigate between pages if the number of libraries exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"headlamp-user-guide/library/#edit-existing-library","title":"Edit Existing Library","text":"<p>EDP Headlamp provides the ability to enable, disable or edit the Jira Integration functionality for libraries.</p> <ol> <li> <p>To edit a library directly from the Libraries overview page or when viewing the library data:</p> <ul> <li> <p>Select Edit in the options icon menu:</p> <p> Edit library on the libraries overview page </p> <p> Edit library when viewing the library data </p> </li> </ul> <ul> <li>The Edit Library dialog opens.</li> </ul> </li> <li> <p>To enable Jira integration, in the Edit Library dialog do the following:</p> <p> Edit library </p> <p>a. Mark the Integrate with Jira server check box and fill in the necessary fields. Please see steps 14-18 on the Add Library page.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</p> </li> <li> <p>To disable Jira integration, in the Edit Library dialog do the following:</p> <p>a. Unmark the Integrate with Jira server check box.</p> <p>b. Select the Apply button to apply the changes.</p> <p>c. Navigate to Jenkins/Tekton and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</p> </li> </ol> <p>As a result, the necessary changes will be applied.</p>"},{"location":"headlamp-user-guide/library/#add-a-new-branch","title":"Add a New Branch","text":"<p>Note</p> <p>Pay attention when specifying the branch name: the branch name is involved in the formation of the library version, so it must comply with the versioning semantic rules for the library.</p> <p>When adding a library, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li> <p>Navigate to the Branches block by clicking the library name link in the Libraries list.</p> </li> <li> <p>Select the options icon related to the necessary branch and then select Create:</p> <p> Add branch </p> </li> <li> <p>Click Edit YAML in the upper-right corner of the Create Library dialog to open the YAML editor and add a branch. Otherwise, fill in the required fields in the dialog:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch.</p> <p>b. Branch name - type the branch name. Pay attention that this field remains static if you create a release branch. For the Clone and Import strategies: If you want to use the existing branch, enter its name into this field.</p> <p>c. From Commit Hash - paste the commit hash from which the branch will be created. For the Clone and Import strategies: Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Default branch version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number.</p> <p>f. Click the Apply button and wait until the new branch will be added to the list.</p> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type.</p> </li> </ol> <p>The default application repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"headlamp-user-guide/library/#build-branch","title":"Build Branch","text":"<p>In order to build branch from the latest commit, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the library name link in the Libraries list.</li> <li> <p>Select the options icon related to the necessary branch and then select Build:</p> <p> Build branch </p> </li> </ol> <p>The pipeline run status is displayed near the branch name in the Branches block:</p> <p> Pipeline run status in Headlamp </p> <p>The corresponding item appears on the Tekton Dashboard in the PipelineRuns section:</p> <p> Pipeline run status in Tekton </p>"},{"location":"headlamp-user-guide/library/#edit-branch","title":"Edit Branch","text":"<p>In order to edit a branch with the corresponding record in the Headlamp database, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the library name link in the Libraries list.</li> <li> <p>Select the options icon related to the necessary branch and then select Edit:</p> <p> Edit branch </p> </li> <li> <p>Edit the YAML file in a standard or minimal editor and select Save &amp; Apply:</p> <p> Edit branch </p> </li> </ol>"},{"location":"headlamp-user-guide/library/#delete-branch","title":"Delete Branch","text":"<p>Note</p> <p>The default master branch cannot be removed.</p> <p>In order to delete the added branch with the corresponding record in the Headlamp database, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the library name link in the Libraries list.</li> <li> <p>Select the options icon related to the necessary branch and then select Delete:</p> <p> Delete branch </p> </li> </ol>"},{"location":"headlamp-user-guide/library/#related-articles","title":"Related Articles","text":"<ul> <li>Add Library</li> </ul>"},{"location":"operator-guide/","title":"Overview","text":"<p>The EDP Operator guide is intended for DevOps and provides information on EDP installation, configuration and customization, as well as the platform support. Inspect the documentation to adjust the EPAM Delivery Platform according to your business needs:</p> <ul> <li>The Installation section provides the prerequisites for EDP installation, including Kubernetes or OpenShift cluster setup, Keycloak, DefectDojo, Kiosk, and Ingress-nginx setup as well as the subsequent deployment of EPAM Delivery Platform.</li> </ul> <ul> <li>The Configuration section indicates the options to set the project with adding a code language, backup, VCS import strategy, managing Jenkins pipelines, and logging.</li> </ul> <ul> <li>The Integration section comprises the AWS, GitHub, GitLab, Jira, and Logsight integration options.</li> </ul> <ul> <li>The Tutorials section provides information on working with various aspects, for example, using cert-manager in OpenShift, deploying AWS EKS cluster, deploying OKD 4.9 cluster, deploying OKD 4.10 cluster, managing Jenkins agent, and upgrading Keycloak v.17.0.x-legacy to v.19.0.x on Kubernetes.</li> </ul>"},{"location":"operator-guide/add-jenkins-agent/","title":"Manage Jenkins Agent","text":"<p>Inspect the main steps to add and update Jenkins agent.</p>"},{"location":"operator-guide/add-jenkins-agent/#createupdate-jenkins-agent","title":"Create/Update Jenkins Agent","text":"<p>Every Jenkins agent is based on epamedp/edp-jenkins-base-agent. Check DockerHub for the latest version. Use it to create a new agent (or update an old one). See the example with Dockerfile of gradle-java11-agent below:</p> View: Dockerfile <pre><code>    # Copyright 2021 EPAM Systems.\n    # Licensed under the Apache License, Version 2.0 (the \"License\");\n    # you may not use this file except in compliance with the License.\n    # You may obtain a copy of the License at\n    # http://www.apache.org/licenses/LICENSE-2.0\n    # Unless required by applicable law or agreed to in writing, software\n    # distributed under the License is distributed on an \"AS IS\" BASIS,\n    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    # See the License for the specific language governing permissions and\n    # limitations under the License.\n\n    FROM epamedp/edp-jenkins-base-agent:1.0.1\n    SHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"]\n    ENV GRADLE_VERSION=7.1 \\\n        PATH=$PATH:/opt/gradle/bin\n\n    # Install Gradle\n    RUN curl -skL -o /tmp/gradle-bin.zip https://services.gradle.org/distributions/gradle-$GRADLE_VERSION-bin.zip &amp;&amp; \\\n        mkdir -p /opt/gradle &amp;&amp; \\\n        unzip -q /tmp/gradle-bin.zip -d /opt/gradle &amp;&amp; \\\n        ln -sf /opt/gradle/gradle-$GRADLE_VERSION/bin/gradle /usr/local/bin/gradle\n\n    RUN yum install java-11-openjdk-devel.x86_64 -y &amp;&amp; \\\n        rpm -V java-11-openjdk-devel.x86_64 &amp;&amp; \\\n        yum clean all -y\n\n    WORKDIR $HOME/.gradle\n\n    RUN chown -R \"1001:0\" \"$HOME\" &amp;&amp; \\\n        chmod -R \"g+rw\" \"$HOME\"\n\n    USER 1001\n</code></pre> <p>After the Docker agent update/creation, build and load the image into the project registry (e.g. DockerHub, AWS ECR, etc.).</p>"},{"location":"operator-guide/add-jenkins-agent/#add-jenkins-agent-configuration","title":"Add Jenkins Agent Configuration","text":"<p>To add a new Jenkins agent, take the steps below:</p> <ol> <li> <p>Run the following command. Please be aware that \u2039edp-project\u203a is the name of the EDP tenant.</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-project&gt;\n</code></pre> <p>Note</p> <p>On an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> <p>Add new agent template.      View: ConfigMap jenkins-slaves <pre><code>  data:\n    docker-template: |-\n     &lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;docker&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;docker&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;IMAGE_NAME:IMAGE_TAG&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n</code></pre> <p>Note</p> <p>The name and label properties should be unique(docker in the example above). Insert image name and tag instead of IMAGE_NAME:IMAGE_TAG.</p> <li> <p>Open Jenkins to ensure that everything is added correctly. Click the Manage Jenkins option, navigate to the Manage Nodes and Clouds-&gt;Configure Clouds-&gt;Kubernetes-&gt;Pod Templates..., and scroll down to find new Jenkins agent Pod Template details...:</p> <p> Jenkins pod template </p> <p>As a result, the newly added Jenkins agent will be available in the Advanced Settings block of the Admin Console tool during the codebase creation:</p> <p> Advanced settings </p> </li>"},{"location":"operator-guide/add-jenkins-agent/#modify-existing-agent-configuration","title":"Modify Existing Agent Configuration","text":"<p>If your application is integrated with EDP, take the steps below to change an existing agent configuration:</p> <ol> <li> <p>Run the following command. Please be aware that \u2039edp-project\u203a is the name of the EDP tenant.</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-project&gt;\n</code></pre> <p>Note</p> <p>On an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> </li> <li> <p>Find the agent template in use and change and change the parameters.</p> </li> <li> <p>Open Jenkins and check the correct addition. Click the Manage Jenkins option, navigate to the Manage Nodes and Clouds-&gt;Configure Clouds-&gt;Kubernetes-&gt;Pod Templates..., and scroll down to Pod Template details... with the necessary data.</p> </li> </ol>"},{"location":"operator-guide/add-other-code-language/","title":"Add Other Code Language","text":"<p>There is an ability to extend the default code languages when creating a codebase with the Clone or Import strategy.</p> <p> Other code language </p> <p>Warning</p> <p>The Create strategy does not allow to customize the default code language set.</p> <p>To customize the Build Tool list, perform the following:</p> <ul> <li> <p>Edit the edp-admin-console deployment by adding the necessary code language into the BUILD TOOLS field:</p> <pre><code> kubectl edit deployment edp-admin-console -n &lt;edp-project&gt;\n</code></pre> <p>Note</p> <p>Using an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> <p>Info</p> <p>\u2039edp-project\u203a is the name of the EDP tenant here and in all the following steps.</p> View: edp-admin-console deployment <pre><code>...\nspec:\ncontainers:\n- env:\n...\n- name: BUILD_TOOLS\nvalue: docker # List of custom build tools in Admin Console, e.g. 'docker,helm';\n...\n...\n</code></pre> </li> </ul> <ul> <li>Add the Jenkins agent by following the instruction.</li> </ul> <ul> <li>Add the Custom CI pipeline provisioner by following the instruction.</li> </ul> <ul> <li> <p>As a result, the newly added Jenkins agent will be available in the Select Jenkins Slave dropdown list of the Advanced Settings block during the codebase creation:</p> <p> Advanced settings </p> </li> </ul> <p>If it is necessary to create Code Review and Build pipelines, add corresponding entries (e.g. stages[Build-application-docker], [Code-review-application-docker]). See the example below:</p> <pre><code>...\nstages['Code-review-application-docker'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"sonar\"}]'\nstages['Build-application-docker'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build-image-kaniko\"}' + ',{\"name\": \"git-tag\"}]'\n...\n</code></pre> <p> Jenkins job provisioner </p> <p>Note</p> <p>Application is one of the available options. Another option might be to add a library. Please refer to the Add Library page for details.</p>"},{"location":"operator-guide/add-other-code-language/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Library</li> <li>Manage Jenkins Agent</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> </ul>"},{"location":"operator-guide/add-security-scanner/","title":"Add Security Scanner","text":"<p>In order to add a new security scanner, perform the steps below:</p> <ol> <li> <p>Select a pipeline customization option from the Customize CI Pipeline article. Follow the steps described in this article, to create a new repository.</p> <p>Note</p> <p>This tutorial will focus on adding a new stage using shared library via the custom global pipeline libraries.</p> </li> <li> <p>Open the new repository and create a directory with the <code>/src/com/epam/edp/customStages/impl/ci/impl/stageName/</code> name in the library repository, for example: <code>/src/com/epam/edp/customStages/impl/ci/impl/security/</code>. After that, add a Groovy file with another name to the same stages catalog, for example: <code>CustomSAST.groovy</code>.</p> </li> <li> <p>Copy the logic from <code>SASTMavenGradleGoApplication.groovy</code> stage into the new <code>CustomSAST.groovy</code> stage.</p> </li> <li> <p>Add a new <code>runGoSecScanner</code> function to the stage:</p> <pre><code>@Stage(name = \"sast-custom\", buildTool = [\"maven\",\"gradle\",\"go\"], type = [ProjectType.APPLICATION])\nclass CustomSAST {\n...\ndef runGoSecScanner(context) {\ndef edpName = context.platform.getJsonPathValue(\"cm\", \"edp-config\", \".data.edp_name\")\ndef reportData = [:]\nreportData.active = \"true\"\nreportData.verified = \"false\"\nreportData.path = \"sast-gosec-report.json\"\nreportData.type = \"Gosec Scanner\"\nreportData.productTypeName = \"Tenant\"\nreportData.productName = \"${edpName}\"\nreportData.engagementName = \"${context.codebase.name}-${context.git.branch}\"\nreportData.autoCreateContext = \"true\"\nreportData.closeOldFindings = \"true\"\nreportData.pushToJira = \"false\"\nreportData.environment = \"Development\"\nreportData.testTitle = \"SAST\"\nscript.sh(script: \"\"\"\n                set -ex\n                gosec -fmt=json -out=${reportData.path} ./...\n        \"\"\")\nreturn reportData\n}\n...\n}\n</code></pre> </li> <li> <p>Add function calls for the <code>runGoSecScanner</code> and <code>publishReport</code> functions:</p> <pre><code>...\nscript.node(\"sast\") {\nscript.dir(\"${testDir}\") {\nscript.unstash 'all-repo'\n...\ndef dataFromGoSecScanner = runGoSecScanner(context)\npublishReport(defectDojoCredentials, dataFromGoSecScanner)\n}\n}\n...\n</code></pre> </li> <li> <p>Gosec scanner will be installed on the Jenkins SAST agent. It is based on the <code>epamedp/edp-jenkins-base-agent</code>. Please check DockerHub for its latest version.</p> <p>See below an example of the <code>edp-jenkins-sast-agent</code> Dockerfile:</p> View: Default Dockerfile <pre><code> # Copyright 2022 EPAM Systems.\n\n # Licensed under the Apache License, Version 2.0 (the \"License\");\n # you may not use this file except in compliance with the License.\n # You may obtain a copy of the License at\n # http://www.apache.org/licenses/LICENSE-2.0\n\n # Unless required by applicable law or agreed to in writing, software\n # distributed under the License is distributed on an \"AS IS\" BASIS,\n # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n # See the License for the specific language governing permissions and\n # limitations under the License.\n\n FROM epamedp/edp-jenkins-base-agent:1.0.31\n\n SHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-c\"]\n\n USER root\n\n ENV SEMGREP_SCANNER_VERSION=0.106.0 \\\n     GOSEC_SCANNER_VERSION=2.12.0\n\n RUN apk --no-cache add \\\n     curl=7.79.1-r2 \\\n     build-base=0.5-r3 \\\n     python3-dev=3.9.5-r2 \\\n     py3-pip=20.3.4-r1 \\\n     go=1.16.15-r0\n\n # hadolint ignore=DL3059\n RUN pip3 install --no-cache-dir --upgrade --ignore-installed \\\n     pip==22.2.1 \\\n     ruamel.yaml==0.17.21 \\\n     semgrep==${SEMGREP_SCANNER_VERSION}\n\n # Install GOSEC\n RUN curl -Lo /tmp/gosec.tar.gz https://github.com/securego/gosec/releases/download/v${GOSEC_SCANNER_VERSION}/gosec_${GOSEC_SCANNER_VERSION}_linux_amd64.tar.gz &amp;&amp; \\\n     tar xf /tmp/gosec.tar.gz &amp;&amp; \\\n     rm -f /tmp/gosec.tar.gz &amp;&amp; \\\n     mv gosec /bin/gosec\n\n RUN chown -R \"1001:0\" \"$HOME\" &amp;&amp; \\\n     chmod -R \"g+rw\" \"$HOME\"\n\n USER 1001\n</code></pre> </li> </ol>"},{"location":"operator-guide/add-security-scanner/#related-articles","title":"Related Articles","text":"<ul> <li>Customize CI Pipeline</li> <li>Static Application Security Testing Overview</li> <li>Semgrep</li> </ul>"},{"location":"operator-guide/argocd-integration/","title":"Argo CD Integration","text":"<p>EDP uses Jenkins Pipeline as a part of the Continues Delivery/Continues Deployment implementation. Another approach is to use Argo CD tool as an alternative to Jenkins. Argo CD follows the best GitOps practices, uses Kubernetes native approach for the Deployment Management, has rich UI and required RBAC capabilities.</p>"},{"location":"operator-guide/argocd-integration/#argo-cd-deployment-approach-in-edp","title":"Argo CD Deployment Approach in EDP","text":"<p>Argo CD can be installed using two different approaches:</p> <ul> <li>Cluster-wide scope with the cluster-admin access</li> <li>Namespaced scope with the single namespace access</li> </ul> <p>Both approaches can be deployed with High Availability (HA) or Non High Availability (non HA) installation manifests.</p> <p>EDP uses the HA deployment with the cluster-admin permissions, to minimize cluster resources consumption by sharing single Argo CD instance across multiple EDP Tenants. Please follow the installation instructions, to deploy Argo CD.</p>"},{"location":"operator-guide/argocd-integration/#edp-argo-cd-integration","title":"EDP Argo CD Integration","text":"<p>See a diagram below for the details:</p> <p> Argo CD Diagram </p> <ul> <li>Argo CD is deployed in a separate <code>argocd</code> namespace.</li> <li>Argo CD uses a <code>cluster-admin</code> role for managing cluster-scope resources.</li> <li>The <code>control-plane</code> application is created using the App of Apps approach, and its code is managed by the <code>control-plane</code> members.</li> <li>The <code>control-plane</code> is used to onboard new Argo CD Tenants (Argo CD Projects - AppProject).</li> <li>The <code>EDP Tenant Member</code> manages <code>Argo CD Applications</code> using <code>kind: Application</code> in the <code>edpTenant</code> namespace.</li> </ul> <p>The App Of Apps approach is used to manage the <code>EDP Tenants</code>. Inspect the edp-grub repository structure that is used to provide the EDP Tenants for the Argo CD Projects:</p> <pre><code>edp-grub\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 apps                      ### All Argo CD Applications are stored here\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 grub-argocd.yaml      # Application that provisions Argo CD Resources - Argo Projects (EDP Tenants)\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 grub-keycloak.yaml    # Application that provisions Keycloak Resources - Argo CD Groups (EDP Tenants)\n\u251c\u2500\u2500 apps-configs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 grub\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 argocd            ### Argo CD resources definition\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 team-bar.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 team-foo.yaml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 keycloak          ### Keycloak resources definition\n\u2502\u00a0\u00a0         \u251c\u2500\u2500 team-bar.yaml\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 team-foo.yaml\n\u251c\u2500\u2500 bootstrap\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 root.yaml             ### Root application in App of Apps, which provision Applications from /apps\n\u2514\u2500\u2500 examples                  ### Examples\n\u2514\u2500\u2500 tenant\n        \u2514\u2500\u2500 foo-petclinic.yaml\n</code></pre> <p>The Root Application must be created under the <code>control-plane</code> scope.</p>"},{"location":"operator-guide/argocd-integration/#configuration","title":"Configuration","text":"<p>Note</p> <p>Make sure that both EDP and Argo CD are installed, and that SSO is enabled.</p> <p>To start using Argo CD with EDP, perform the following steps:</p> <ol> <li> <p>Create an Argo CD Project (EDP Tenant), for example, with the <code>team-foo</code> name and a Keycloak Group. Two resources must be created:</p> KeycloakRealmGroup<pre><code>apiVersion: v1.edp.epam.com/v1\nkind: KeycloakRealmGroup\nmetadata:\nname: argocd-team-foo-users\nspec:\nname: ArgoCD-team-foo-users\nrealm: main\n</code></pre> AppProject<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\nname: team-foo\nnamespace: argocd\n# Finalizer that ensures that project is not deleted until it is not referenced by any application\nfinalizers:\n- resources-finalizer.argocd.argoproj.io\nspec:\ndescription: CD pipelines for team-foo\nroles:\n- name: developer\ndescription: Users for team-foo tenant\npolicies:\n- p, proj:team-foo:developer, applications, create, team-foo/*, allow\n- p, proj:team-foo:developer, applications, delete, team-foo/*, allow\n- p, proj:team-foo:developer, applications, get, team-foo/*, allow\n- p, proj:team-foo:developer, applications, override, team-foo/*, allow\n- p, proj:team-foo:developer, applications, sync, team-foo/*, allow\n- p, proj:team-foo:developer, applications, update, team-foo/*, allow\n- p, proj:team-foo:developer, repositories, create, team-foo/*, allow\n- p, proj:team-foo:developer, repositories, delete, team-foo/*, allow\n- p, proj:team-foo:developer, repositories, update, team-foo/*, allow\n- p, proj:team-foo:developer, repositories, get, team-foo/*, allow\ngroups:\n# Keycloak Group name\n- ArgoCD-team-foo-users\ndestinations:\n# ensure we can deploy to ns with tenant prefix\n- namespace: 'team-foo-*'\n# allow to deploy to specific server (local in our case)\nserver: https://kubernetes.default.svc\n# Deny all cluster-scoped resources from being created, except for Namespace\nclusterResourceWhitelist:\n- group: ''\nkind: Namespace\n# Allow all namespaced-scoped resources to be created, except for ResourceQuota, LimitRange, NetworkPolicy\nnamespaceResourceBlacklist:\n- group: ''\nkind: ResourceQuota\n- group: ''\nkind: LimitRange\n- group: ''\nkind: NetworkPolicy\n# we are ok to create any resources inside namespace\nnamespaceResourceWhitelist:\n- group: '*'\nkind: '*'\n# enable access only for specific git server. The example below 'team-foo' - it is namespace where EDP deployed \nsourceRepos:\n- ssh://argocd@gerrit.team-foo:30007/*\n# enable capability to deploy objects from namespaces\nsourceNamespaces:\n- team-foo\n</code></pre> Get Node port of Gerrit <pre><code>EDP_NAMESPACE=&lt;EPD_NAMESPACE&gt;\nGERRIT_PORT=$(kubectl get gerrit gerrit -n ${EDP_NAMESPACE} -o jsonpath='{.spec.sshPort}')\necho \"Gerrit Node port: ${GERRIT_PORT}\"\n</code></pre> </li> <li> <p>In Keycloak, add users to the <code>ArgoCD-team-foo-users</code> Keycloak Group.</p> </li> <li> <p>Add a credential template for Gerrit integration. The credential template must be created for each EDP tenant (per Git server).</p> <pre><code>EDP_NAMESPACE=&lt;EPD_NAMESPACE&gt;\nKNOWN_HOSTS_FILE=\"/tmp/ssh_known_hosts\"\nARGOCD_KNOWN_HOSTS_NAME=\"argocd-ssh-known-hosts-cm\"\nGERRIT_PORT=$(kubectl get gerrit gerrit -n ${EDP_NAMESPACE} -o jsonpath='{.spec.sshPort}')\n\n# Add Gerrit host to ArgoCd config map with known hosts\nrm -f ${KNOWN_HOSTS_FILE}\nkubectl get cm ${ARGOCD_KNOWN_HOSTS_NAME} -n argocd -o jsonpath='{.data.ssh_known_hosts}' &gt; ${KNOWN_HOSTS_FILE}\nkubectl exec -it deployment/gerrit -n ${EDP_NAMESPACE} -- ssh-keyscan -p ${GERRIT_PORT} gerrit.${EDP_NAMESPACE} &gt;&gt; ${KNOWN_HOSTS_FILE}\nkubectl create configmap ${ARGOCD_KNOWN_HOSTS_NAME} -n argocd --from-file ${KNOWN_HOSTS_FILE} -o yaml --dry-run=client | kubectl apply -f -\n\n# Copy ssh key for Gerrit to ArgoCd namespace\nGERRIT_ARGOCD_SSH_KEY_NANE=\"gerrit-argocd-sshkey\"\nGERRIT_URL=$(echo \"ssh://argocd@gerrit.${EDP_NAMESPACE}:${GERRIT_PORT}\" | base64)\nkubectl get secret ${GERRIT_ARGOCD_SSH_KEY_NANE} -n ${EDP_NAMESPACE} -o json | jq 'del(.data.username,.metadata.annotations,.metadata.creationTimestamp,.metadata.labels,.metadata.resourceVersion,.metadata.uid,.metadata.ownerReferences)' | jq '.metadata.namespace = \"argocd\"' | jq --arg name \"${EDP_NAMESPACE}\" '.metadata.name = $name' | jq --arg url \"${GERRIT_URL}\" '.data.url = $url' | jq '.data.sshPrivateKey = .data.id_rsa' | jq 'del(.data.id_rsa,.data.\"id_rsa.pub\")' | kubectl apply -f -\nkubectl label --overwrite secret ${EDP_NAMESPACE} -n argocd \"argocd.argoproj.io/secret-type=repo-creds\"\n</code></pre> </li> <li> <p>Optional: If the Argo CD controller has not been enabled to manage the Application resources in the specific namespaces  (<code>team-foo</code>, in our case) in the Install Argo CD, modify the <code>argocd-cmd-params-cm</code> configmap in the Argo CD namespace and add the <code>application.namespaces</code> parameter to the subsection data:</p> argocd-cmd-params-cm<pre><code>data:\napplication.namespaces: team-foo\n</code></pre> values.yaml file<pre><code>configs:\nparams:\napplication.namespaces: team-foo\n</code></pre> </li> <li> <p>Deploy a test EDP Application with the <code>demo</code> name stored in a Gerrit private repository following the Headlamp Deploy-application instruction:</p> Example: ArgoCD Application  <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\nname: demo\nspec:\nproject: team-foo\ndestination:\nnamespace: team-foo-demo\nserver: https://kubernetes.default.svc\nsource:\nhelm:\nparameters:\n- name: image.tag\nvalue: master-0.1.0-1\n- name: image.repository\nvalue: image-repo\npath: deploy-templates\nrepoURL: ssh://argocd@gerrit.team-foo:30007/demo.git\ntargetRevision: master\nsyncPolicy:\nsyncOptions:\n- CreateNamespace=true\nautomated:\nselfHeal: true\nprune: true\n</code></pre> </li> <li> <p>Check that your new Repository and Application are added to the Argo CD UI under the <code>team-foo</code> Project scope.</p> </li> </ol>"},{"location":"operator-guide/argocd-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Install Argo CD</li> </ul>"},{"location":"operator-guide/configure-keycloak-oidc-eks/","title":"EKS OIDC With Keycloak","text":"<p>This article provides the instruction of configuring Keycloak as OIDC Identity Provider for EKS. The example is written on Terraform (HCL).</p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#prerequisites","title":"Prerequisites","text":"<p>To follow the instruction, check the following prerequisites:</p> <ol> <li>terraform 0.14.10</li> <li>hashicorp/aws = 4.8.0</li> <li>mrparkers/keycloak &gt;= 3.0.0</li> <li>hashicorp/kubernetes ~&gt; 2.9.0</li> <li>kubectl = 1.22</li> <li>kubelogin  &gt;= v1.25.1</li> <li>Ensure that Keycloak has network availability for AWS (not in a private network).</li> </ol> <p>Note</p> <p>To connect OIDC with a cluster, install and configure the kubelogin plugin. For Windows, it is recommended to download the kubelogin as a binary and add it to your PATH.</p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#solution-overview","title":"Solution Overview","text":"<p>The solution includes three types of the resources - AWS (EKS), Keycloak, Kubernetes. The left part of Keycloak resources remain unchanged after creation, thus allowing us to associate a claim for a user group membership. Other resources can be created, deleted or changed if needed. The most crucial from Kubernetes permissions are Kubernetes RoleBindings and ClusterRoles/Roles. Roles present a set of permissions, in turn RoleBindings map Kubernetes Role to representative Keycloak groups, so a group member can have just appropriate permissions.</p> <p> EKS Keycloak OIDC </p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#keycloak-configuration","title":"Keycloak Configuration","text":"<p>To configure Keycloak, follow the steps described below.</p> <ul> <li>Create a client:</li> </ul> <pre><code>resource \"keycloak_openid_client\" \"openid_client\" {\nrealm_id                                  = &lt;realm_id&gt;\nclient_id                                 = &lt;client_id&gt;\naccess_type                               = \"CONFIDENTIAL\"\nstandard_flow_enabled                     = true\nimplicit_flow_enabled                     = false\ndirect_access_grants_enabled              = true\nservice_accounts_enabled                  = true\noauth2_device_authorization_grant_enabled = true\nbackchannel_logout_session_required       = true\n\nroot_url    = \"http://localhost:8000/\"\nbase_url    = \"http://localhost:8000/\"\nadmin_url   = \"http://localhost:8000/\"\nweb_origins = [\"*\"]\n\nvalid_redirect_uris = [\n\"http://localhost:8000/*\"\n]\n}\n</code></pre> <ul> <li>Create the client scope:</li> </ul> <pre><code>resource \"keycloak_openid_client_scope\" \"openid_client_scope\" {\nrealm_id               = &lt;realm_id&gt;\nname                   = \"groups\"\ndescription            = \"When requested, this scope will map a user's group memberships to a claim\"\ninclude_in_token_scope = true\nconsent_screen_text    = false\n}\n</code></pre> <ul> <li>Add scope to the client by selecting all default client scope:</li> </ul> <pre><code>resource \"keycloak_openid_client_default_scopes\" \"client_default_scopes\" {\nrealm_id  = &lt;realm_id&gt;\nclient_id = keycloak_openid_client.openid_client.id\n\ndefault_scopes = [\n\"profile\",\n\"email\",\n\"roles\",\n\"web-origins\",\nkeycloak_openid_client_scope.openid_client_scope.name,\n]\n}\n</code></pre> <ul> <li>Add the following mapper to the client scope:</li> </ul> <pre><code>resource \"keycloak_openid_group_membership_protocol_mapper\" \"group_membership_mapper\" {\nrealm_id            = &lt;realm_id&gt;\nclient_scope_id     = keycloak_openid_client_scope.openid_client_scope.id\nname                = \"group-membership-mapper\"\nadd_to_id_token     = true\nadd_to_access_token = true\nadd_to_userinfo     = true\nfull_path           = false\n\nclaim_name = \"groups\"\n}\n</code></pre> <ul> <li>In the authorization token, get groups membership field with the list of group membership in the realm: <pre><code>...\n\"email_verified\": false,\n\"name\": \"An User\",\n\"groups\": [\n\"&lt;env_prefix_name&gt;-oidc-viewers\",\n\"&lt;env_prefix_name&gt;-oidc-cluster-admins\"\n],\n\"preferred_username\": \"an_user@example.com\",\n\"given_name\": \"An\",\n\"family_name\": \"User\",\n\"email\": \"an_user@example.com\"\n...\n</code></pre></li> </ul> <ul> <li>Create group/groups, e.g. admin group:</li> </ul> <pre><code>resource \"keycloak_group\" \"oidc_tenant_admin\" {\nrealm_id = &lt;realm_id&gt;\nname     = \"&lt;env_prefix_name&gt;-oidc-admins\"\n}\n</code></pre>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#eks-configuration","title":"EKS Configuration","text":"<p>To configure EKS, follow the steps described below. In AWS Console, open EKS home page -&gt; Choose a cluster -&gt; Configuration tab -&gt; Authentication tab.</p> <p>The Terraform code for association with Keycloak:</p> <ul> <li>terraform.tfvars <pre><code>...\ncluster_identity_providers = {\nkeycloak = {\nclient_id                     = &lt;keycloak_client_id&gt;\nidentity_provider_config_name = \"Keycloak\"\nissuer_url                    = \"https://&lt;keycloak_url&gt;/auth/realms/&lt;realm_name&gt;\"\ngroups_claim                  = \"groups\"\n}\n...\n</code></pre></li> <li>the resource code <pre><code>resource \"aws_eks_identity_provider_config\" \"keycloak\" {\nfor_each = { for k, v in var.cluster_identity_providers : k =&gt; v if true }\n\ncluster_name = var.platform_name\n\noidc {\nclient_id                     = each.value.client_id\ngroups_claim                  = lookup(each.value, \"groups_claim\", null)\ngroups_prefix                 = lookup(each.value, \"groups_prefix\", null)\nidentity_provider_config_name = try(each.value.identity_provider_config_name, each.key)\nissuer_url                    = each.value.issuer_url\nrequired_claims               = lookup(each.value, \"required_claims\", null)\nusername_claim                = lookup(each.value, \"username_claim\", null)\nusername_prefix               = lookup(each.value, \"username_prefix\", null)\n}\n\ntags = var.tags\n}\n</code></pre></li> </ul> <p>Note</p> <p>The resource creation takes around 20-30 minutes. The resource doesn't support updating, so each change will lead to deletion of the old instance and creation of a new instance instead.</p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#kubernetes-configuration","title":"Kubernetes Configuration","text":"<p>To connect the created Keycloak resources with permissions, it is necessary to create Kubernetes Roles and RoleBindings:</p> <ul> <li>ClusterRole <pre><code>resource \"kubernetes_cluster_role_v1\" \"oidc_tenant_admin\" {\nmetadata {\nname = \"oidc-admin\"\n}\nrule {\napi_groups = [\"*\"]\nresources  = [\"*\"]\nverbs      = [\"*\"]\n}\n}\n</code></pre></li> <li>ClusterRoleBinding <pre><code>resource \"kubernetes_cluster_role_binding_v1\" \"oidc_cluster_rb\" {\nmetadata {\nname = \"oidc-cluster-admin\"\n}\nrole_ref {\napi_group = \"rbac.authorization.k8s.io\"\nkind      = \"ClusterRole\"\nname      = kubernetes_cluster_role_v1.oidc_tenant_admin.metadata[0].name\n}\nsubject {\nkind      = \"Group\"\nname      = keycloak_group.oidc_tenant_admin.name\napi_group = \"rbac.authorization.k8s.io\"\n    # work-around due https://github.com/hashicorp/terraform-provider-kubernetes/issues/710\nnamespace = \"\"\n}\n}\n</code></pre></li> </ul> <p>Note</p> <p>When creating the Keycloak group, ClusterRole, and ClusterRoleBinding, a user receives cluster admin permissions. There is also an option to provide admin permissions just to a particular namespace or another resources set in another namespace. For details, please refer to the Mixing Kubernetes Roles page.</p>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#kubeconfig","title":"Kubeconfig","text":"<p>Template for kubeconfig:</p> <p><pre><code>apiVersion: v1\npreferences: {}\nkind: Config\n\nclusters:\n- cluster:\nserver: https://&lt;eks_url&gt;.eks.amazonaws.com\ncertificate-authority-data: &lt;certificate_authtority_data&gt;\nname: &lt;cluster_name&gt;\n\ncontexts:\n- context:\ncluster: &lt;cluster_name&gt;\nuser: &lt;keycloak_user_email&gt;\nname: &lt;cluster_name&gt;\n\ncurrent-context: &lt;cluster_name&gt;\n\nusers:\n- name: &lt;keycloak_user_email&gt;\nuser:\nexec:\napiVersion: client.authentication.k8s.io/v1beta1\ncommand: kubectl\nargs:\n- oidc-login\n- get-token\n- -v1\n- --oidc-issuer-url=https://&lt;keycloak_url&gt;/auth/realms/&lt;realm&gt;\n- --oidc-client-id=&lt;keycloak_client_id&gt;\n- --oidc-client-secret=&lt;keycloak_client_secret&gt;\n</code></pre> Flag -v1 can be used for debug, in a common case it's not needed and can be deleted.</p> <p>To find the client secret:</p> <ol> <li>Open Keycloak</li> <li>Choose realm</li> <li>Find keycloak_client_id that was previously created</li> <li>Open Credentials tab</li> <li>Copy Secret</li> </ol>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#testing","title":"Testing","text":"<p>Before testing, ensure that a user is a member of the correct Keycloak group. To add a user to a Keycloak group:</p> <ol> <li>Open Keycloak</li> <li>Choose realm</li> <li>Open user screen with search field</li> <li>Find a user and open the configuration</li> <li>Open Groups tab</li> <li>In Available Groups, choose an appropriate group</li> <li>Click the Join button</li> <li>The group should appear in the Group Membership list</li> </ol> <p>Follow the steps below to test the configuration:</p> <ul> <li>Run kubectl command, it is important to specify the correct kubeconfig: <pre><code>KUBECONFIG=&lt;path_to_oidc_kubeconfig&gt; kubectl get ingresses -n &lt;namespace_name&gt;\n</code></pre></li> <li>After the first run and redirection to the Keycloak login page, log in using credentials (login:password) or using SSO Provider. In case of the successful login, you will receive the following notification that can be closed:</li> </ul> <p> OIDC Successful Login </p> <ul> <li>As the result, a respective response from the Kubernetes will appear in the console in case a user is configured correctly and is a member of the correct group and Roles/RoleBindings.</li> </ul> <ul> <li>If something is not set up correctly, the following output error will be displayed: <pre><code>Error from server (Forbidden): ingresses.networking.k8s.io is forbidden:\nUser \"https://&lt;keycloak_url&gt;/auth/realms/&lt;realm&gt;#&lt;keycloak_user_id&gt;\"\ncannot list resource \"ingresses\" in API group \"networking.k8s.io\" in the namespace \"&lt;namespace_name&gt;\"\n</code></pre></li> </ul>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#session-update","title":"Session Update","text":"<p>To update the session, clear cache. The default location for the login cache:</p> <pre><code>rm -rf ~/.kube/cache\n</code></pre>"},{"location":"operator-guide/configure-keycloak-oidc-eks/#access-cluster-via-lens","title":"Access Cluster via Lens","text":"<p>To access the Kubernetes cluster via Lens, follow the steps below to configure it:</p> <ul> <li>Add a new kubeconfig to the location where Lens has access. The default location of the kubeconfig is ~/.kube/config but it can be changed by navigating to File -&gt; Preferences -&gt; Kubernetes -&gt; Kubeconfig Syncs;</li> <li>(Optional) Using Windows, it is recommended to reboot the system after adding a new kubeconfig.</li> <li>Authenticate on the Keycloak login page to be able to access the cluster;</li> </ul> <p>Note</p> <p>Lens does not add namespaces of the project automatically, so it is necessary to add them manually, simply go to Settings -&gt; Namespaces and add the namespaces of a project.</p>"},{"location":"operator-guide/delete-jenkins-job-provision/","title":"Delete Jenkins Job Provision","text":"<p>To delete the job provisioner, take the following steps:</p> <ol> <li> <p>Delete the job provisioner from Jenkins. Navigate to Admin Console-&gt;Jenkins-&gt;jobs-&gt;job-provisions folder, select the necessary provisioner and click the drop-down right to the provisioner name. Select Delete project.</p> <p> Delete job provisioner </p> </li> </ol>"},{"location":"operator-guide/deploy-aws-eks/","title":"Deploy AWS EKS Cluster","text":"<p>This instruction provides detailed information on the Amazon Elastic Kubernetes Service cluster deployment and contains the additional setup necessary for the managed infrastructure.</p>"},{"location":"operator-guide/deploy-aws-eks/#prerequisites","title":"Prerequisites","text":"<p>Before the EKS cluster deployment and configuration, make sure to check the prerequisites.</p>"},{"location":"operator-guide/deploy-aws-eks/#required-tools","title":"Required Tools","text":"<p>Install the required tools listed below:</p> <ul> <li>Git</li> </ul> <ul> <li>tfenv</li> </ul> <ul> <li>AWS CLI</li> </ul> <ul> <li>kubectl</li> </ul> <ul> <li>helm</li> </ul> <ul> <li>lens (optional)</li> </ul> <p>To check the correct tools installation, run the following commands:</p> <pre><code>$ git --version\n$ tfenv --version\n$ aws --version\n$ kubectl version\n$ helm version\n</code></pre>"},{"location":"operator-guide/deploy-aws-eks/#aws-account-and-iam-roles","title":"AWS Account and IAM Roles","text":"<ul> <li>Make sure the AWS account is active.</li> </ul> <ul> <li> <p>Create the AWS IAM role: EKSDeployerRole to deploy EKS cluster on the project side. The provided resources will allow to use cross-account deployment by assuming the created EKSDeployerRole from the root AWS account. Take the following steps:</p> <ol> <li> <p>Clone git repo with the edp-terraform-aws-platform.git ism-deployer project, and rename it according to the project name.</p> <p>  clone project <pre><code>$ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git\n$ mv edp-terraform-aws-platform edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;\n$ cd edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;/iam-deployer\n</code></pre> <p>where:</p> <ul> <li>\u2039PROJECT_NAME\u203a - is a project name or a unique platform identifier, for example, <code>shared</code> or <code>test-eks</code>.</li> </ul> <li> <p>Fill in the input variables for Terraform run in the \u2039iam-deployer/terraform.tfvars\u203a file. Use the iam-deployer/template.tfvars as an example. Please find the detailed description of the variables in the iam-deployer/variables.tf file.</p> <p> terraform.tfvars file example <pre><code>aws_profile = \"aws_user\"\n\nregion = \"eu-central-1\"\n\ntags = {\n\"SysName\"      = \"EKS\"\n\"SysOwner\"     = \"owner@example.com\"\n\"Environment\"  = \"EKS-TEST-CLUSTER\"\n\"CostCenter\"   = \"0000\"\n\"BusinessUnit\" = \"BU\"\n\"Department\"   = \"DEPARTMENT\"\n}\n</code></pre> <li> <p>Run the <code>terraform apply</code> command. Then initialize the backend and apply the changes.</p> <p> apply the changes <pre><code>$ terraform init\n$ terraform apply\n...\nDo you want to perform these actions?\nTerraform will perform the actions described above.\nOnly 'yes' will be accepted to approve.\n\nEnter a value: yes\n\naws_iam_role.deployer: Creating...\naws_iam_role.deployer: Creation complete after 4s [id=EKSDeployerRole]\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.\n\nOutputs:\n\ndeployer_iam_role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\"\ndeployer_iam_role_id = \"EKSDeployerRole\"\ndeployer_iam_role_name = \"EKSDeployerRole\"\n</code></pre> <li> <p>Commit the local state. At this run, Terraform will use the local backend to store the state on the local filesystem. Terraform locks that state using system APIs and performs operations locally. It is not mandatory to store the resulted state file in Git, but this option can be used since the file data is not sensitive. Optionally, commit the state of the s3-backend project.</p> <pre><code>$ git add iam-deployer/terraform.tfstate iam-deployer/terraform.tfvars\n$ git commit -m \"Terraform state for IAM deployer role\"\n</code></pre> </li> <ul> <li> <p>Create the AWS IAM role: ServiceRoleForEKSWorkerNode to connect to the EKS cluster. Take the following steps: <ol> <li> <p>Use the local state file or the AWS S3 bucket for saving the state file. The AWS S3 bucket creation is described in the Terraform Backend section.</p> </li> <li> <p>Go to the folder with the <code>iam-workernode</code> role edp-terraform-aws-platform.git, and rename it according to the project name.</p> <p>  go to the iam-workernode folder <pre><code>$ cd edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;/iam-workernode\n</code></pre> <p>where:</p> <ul> <li>\u2039PROJECT_NAME\u203a - is a project name or a unique platform identifier, for example, <code>shared</code> or <code>test-eks</code>.</li> </ul> <li> <p>Fill in the input variables for Terraform run in the \u2039iam-workernode/terraform.tfvars\u203a file, use the iam-workernode/template.tfvars as an example. Please find the detailed description of the variables in the iam-workernode/variables.tf file.</p> <p> terraform.tfvars file example <pre><code>role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\"\n\nplatform_name = \"&lt;PROJECT_NAME&gt;\"\n\niam_permissions_boundary_policy_arn = \"arn:aws:iam::012345678910:policy/some_role_boundary\"\n\nregion = \"eu-central-1\"\n\ntags = {\n\"SysName\"      = \"EKS\"\n\"SysOwner\"     = \"owner@example.com\"\n\"Environment\"  = \"EKS-TEST-CLUSTER\"\n\"CostCenter\"   = \"0000\"\n\"BusinessUnit\" = \"BU\"\n\"Department\"   = \"DEPARTMENT\"\n}\n</code></pre> <li> <p>Run the <code>terraform apply</code> command. Then initialize the backend and apply the changes.</p> <p> apply the changes <pre><code>$ terraform init\n$ terraform apply\n...\nDo you want to perform these actions?\nTerraform will perform the actions described above.\nOnly 'yes' will be accepted to approve.\n\nEnter a value: yes\n</code></pre> <ul> <li> <p>Create the AWS IAM role: ServiceRoleForEKSShared for the EKS cluster. Take the following steps:</p> <ol> <li> <p>Create the AWS IAM role: ServiceRoleForEKSShared</p> </li> <li> <p>Attach the following policies: \"AmazonEKSClusterPolicy\" and \"AmazonEKSServicePolicy\"</p> </li> </ol> </li> </ul> <ul> <li>Configure AWS profile for deployment from the local node. Please, refer to the AWS documentation for detailed guide to configure profiles.</li> </ul> <ul> <li>Create AWS Key pair for EKS cluster nodes access. Please refer to the AWS documentation for detailed guide to create a Key pair.</li> </ul> <ul> <li>Create a public Hosted Zone if there is no any to provide for EKS cluster deployment. Please, refer to the AWS documentation for detailed guide to create a Hosted zone.</li> </ul>"},{"location":"operator-guide/deploy-aws-eks/#terraform-backend","title":"Terraform Backend","text":"<p>The Terraform configuration for EKS cluster deployment has a backend block, which defines where and how the operations are performed, and where the state snapshots are stored. Currently, the best practice is to store the state as a given key in a given bucket on Amazon S3.</p> <p>This backend also supports state locking and consistency checking via Dynamo DB, which can be enabled by setting the <code>dynamodb_table</code> field to an existing DynamoDB table name.</p> <p>In the following configuration a single DynamoDB table can be used to lock multiple remote state files. Terraform generates key names that include the values of the bucket and key variables.</p> <p>In the edp-terraform-aws-platform.git repo an optional project is provided to create initial resources to start using Terraform from the scratch.</p> <p>The provided resources will allow to use the following Terraform options:</p> <ul> <li>to store Terraform states remotely in the Amazon S3 bucket;</li> </ul> <ul> <li>to manage remote state access with S3 bucket policy;</li> </ul> <ul> <li>to support state locking and consistency checking via DynamoDB.</li> </ul> <p>After Terraform run the following AWS resources will be created:</p> <ul> <li>S3 bucket: terraform-states-\u2039AWS_ACCOUNT_ID\u203a</li> </ul> <ul> <li>S3 bucket policy: terraform-states-\u2039AWS_ACCOUNT_ID\u203a</li> </ul> <ul> <li>DynamoDB lock table: terraform_locks</li> </ul> <p>Please, skip this section if you already have the listed resources for further Terraform remote backend usage.</p> <p>To create the required resources, do the following:</p> <ol> <li> <p>Clone git repo with s3-backend project edp-terraform-aws-platform.git, rename it in the correspondence with project name.</p> <p> clone project <pre><code>  $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git\n\n  $ mv edp-terraform-aws-platform tedp-terraform-aws-platform-&lt;PROJECT_NAME&gt;\n\n  $ cd edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;/s3-backend\n</code></pre> <p>where:</p> <p>\u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc.</p> <li> <p>Fill the input variables for Terraform run in the \u2039s3-backend/terraform.tfvars\u203a file, refer to the s3-backend/template.tfvars as an example.</p> <p> terraform.tfvars file example <pre><code>  region = \"eu-central-1\"\n\ns3_states_bucket_name = \"terraform-states\"\n\ntable_name = \"terraform_locks\"\n\ntags = {\n\"SysName\"      = \"EKS\"\n\"SysOwner\"     = \"owner@example.com\"\n\"Environment\"  = \"EKS-TEST-CLUSTER\"\n\"CostCenter\"   = \"0000\"\n\"BusinessUnit\" = \"BU\"\n\"Department\"   = \"DEPARTMENT\"\n}\n</code></pre> <p>Find the detailed description of the variables in the s3-backend/variables.tf file.</p> <li> <p>Run Terraform apply. Initialize the backend and apply the changes.</p> <p> apply the changes <pre><code>  $ terraform init\n$ terraform apply\n...\n  Do you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_dynamodb_table.terraform_lock_table: Creating...\n  aws_s3_bucket.terraform_states: Creating...\n  aws_dynamodb_table.terraform_lock_table: Creation complete after 27s [id=terraform-locks-test]\n  aws_s3_bucket.terraform_states: Creation complete after 1m10s [id=terraform-states-test-012345678910]\n  aws_s3_bucket_policy.terraform_states: Creating...\n  aws_s3_bucket_policy.terraform_states: Creation complete after 1s [id=terraform-states-test-012345678910]\n\n  Apply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\n  Outputs:\n\n  terraform_lock_table_dynamodb_id = \"terraform_locks\"\nterraform_states_s3_bucket_name = \"terraform-states-012345678910\"\n</code></pre> <li> <p>Commit the local state. At this run Terraform will use the local backend to store state on the local filesystem, locks that state using system APIs, and performs operations locally. There is no strong requirements to store the resulted state file in the git, but it's possible at will since there is no sensitive data. On your choice, commit the state of the s3-backend project or not.</p> <pre><code>  $ git add s3-backend/terraform.tfstate\n\n$ git commit -m \"Terraform state for s3-backend\"\n</code></pre> <p>As a result, the projects that run Terraform can use the following definition for remote state configuration:</p> providers.tf - terraform backend configuration block <pre><code>terraform {\n  backend \"s3\" {\n    bucket         = \"terraform-states-&lt;AWS_ACCOUNT_ID&gt;\"\n    key            = \"&lt;PROJECT_NAME&gt;/&lt;REGION&gt;/terraform/terraform.tfstate\"\n    region         = \"&lt;REGION&gt;\"\n    acl            = \"bucket-owner-full-control\"\n    dynamodb_table = \"terraform_locks\"\n    encrypt        = true\n  }\n}\n</code></pre> <p>where:</p> <ul> <li>AWS_ACCOUNT_ID - is AWS account id, e.g. 012345678910,</li> <li>REGION - is AWS region, e.g. eu-central-1,</li> <li>PROJECT_NAME - is a project name, a unique platform identifier, e.g. shared, test-eks etc.</li> </ul> View: providers.tf - terraform backend configuration example <pre><code>terraform {\n  backend \"s3\" {\n    bucket         = \"terraform-states-012345678910\"\n    key            = \"test-eks/eu-central-1/terraform/terraform.tfstate\"\n    region         = \"eu-central-1\"\n    acl            = \"bucket-owner-full-control\"\n    dynamodb_table = \"terraform_locks\"\n    encrypt        = true\n  }\n}\n</code></pre> </li> <p>Note</p> <p>At the moment, it is recommended to use common s3 bucket and Dynamo DB in the root EDP account both for Shared and Standalone clusters deployment.</p>"},{"location":"operator-guide/deploy-aws-eks/#deploy-eks-cluster","title":"Deploy EKS Cluster","text":"<p>To deploy the EKS cluster, make sure that all the above-mentioned Prerequisites are ready to be used.</p>"},{"location":"operator-guide/deploy-aws-eks/#eks-cluster-deployment-with-terraform","title":"EKS Cluster Deployment with Terraform","text":"<ol> <li> <p>Clone git repo with the Terraform project for EKS infrastructure edp-terraform-aws-platform.git and rename it in the correspondence with project name if not yet.</p> <p> clone project <pre><code>  $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git\n  $ mv edp-terraform-aws-platform edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;\n  $ cd edp-terraform-aws-platform-&lt;PROJECT_NAME&gt;\n</code></pre> <p>where:</p> <ul> <li>\u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc.</li> </ul> <li> <p>Configure Terraform backend according to your project needs or use instructions from the Configure Terraform backend section.</p> </li> <li> <p>Fill the input variables for Terraform run in the \u2039terraform.tfvars\u203a file, refer to the template.tfvars file and apply the changes. See details below. Be sure to put the correct values of the variables created in the Prerequisites section. Find the detailed description of the variables in the variables.tf file.</p> <p>Warning</p> <p>Please, do not use upper case in the input variables. It can lead to unexpected issues.</p> template.tfvars file template <pre><code># Check out all the inputs based on the comments below and fill the gaps instead &lt;...&gt;\n  # More details on each variable can be found in the variables.tf file\n\n  create_elb = true # set to true if you'd like to create ELB for Gerrit usage\n\n  region   = \"&lt;REGION&gt;\"\n  role_arn = \"&lt;ROLE_ARN&gt;\"\n\n  platform_name        = \"&lt;PLATFORM_NAME&gt;\"        # the name of the cluster and AWS resources\n  platform_domain_name = \"&lt;PLATFORM_DOMAIN_NAME&gt;\" # must be created as a prerequisite\n\n  # The following will be created or used existing depending on the create_vpc value\n  subnet_azs    = [\"&lt;SUBNET_AZS1&gt;\", \"&lt;SUBNET_AZS2&gt;\"]\n  platform_cidr = \"&lt;PLATFORM_CIDR&gt;\"\n  private_cidrs = [\"&lt;PRIVATE_CIDRS1&gt;\", \"&lt;PRIVATE_CIDRS2&gt;\"]\n  public_cidrs  = [\"&lt;PUBLIC_CIDRS1&gt;\", \"&lt;PUBLIC_CIDRS2&gt;\"]\n\n  infrastructure_public_security_group_ids = [\n    \"&lt;INFRASTRUCTURE_PUBLIC_SECURITY_GROUP_IDS1&gt;\",\n    \"&lt;INFRASTRUCTURE_PUBLIC_SECURITY_GROUP_IDS2&gt;\",\n  ]\n\n  ssl_policy = \"&lt;SSL_POLICY&gt;\"\n\n  # EKS cluster configuration\n  cluster_version = \"1.22\"\n  key_name        = \"&lt;AWS_KEY_PAIR_NAME&gt;\" # must be created as a prerequisite\n  enable_irsa     = true\n\n  cluster_iam_role_name            = \"&lt;SERVICE_ROLE_FOR_EKS&gt;\"\n  worker_iam_instance_profile_name = \"&lt;SERVICE_ROLE_FOR_EKS_WORKER_NODE\"\n\n  add_userdata = &lt;&lt;EOF\n  export TOKEN=$(aws ssm get-parameter --name &lt;PARAMETER_NAME&gt; --query 'Parameter.Value' --region &lt;REGION&gt; --output text)\n  cat &lt;&lt;DATA &gt; /var/lib/kubelet/config.json\n  {\n    \"auths\":{\n      \"https://index.docker.io/v1/\":{\n        \"auth\":\"$TOKEN\"\n      }\n    }\n  }\n  DATA\n  EOF\n\n  map_users = [\n    {\n      \"userarn\" : \"&lt;IAM_USER_ARN1&gt;\",\n      \"username\" : \"&lt;IAM_USER_NAME1&gt;\",\n      \"groups\" : [\"system:masters\"]\n    },\n    {\n      \"userarn\" : \"&lt;IAM_USER_ARN2&gt;\",\n      \"username\" : \"&lt;IAM_USER_NAME2&gt;\",\n      \"groups\" : [\"system:masters\"]\n    }\n  ]\n\n  map_roles = [\n    {\n      \"rolearn\" : \"&lt;IAM_ROLE_ARN1&gt;\",\n      \"username\" : \"&lt;IAM_ROLE_NAME1&gt;\",\n      \"groups\" : [\"system:masters\"]\n    },\n  ]\n\n  tags = {\n    \"SysName\"      = \"&lt;SYS_NAME&gt;\"\n    \"SysOwner\"     = \"&lt;SYSTEM_OWNER&gt;\"\n    \"Environment\"  = \"&lt;ENVIRONMENT&gt;\"\n    \"CostCenter\"   = \"&lt;COST_CENTER&gt;\"\n    \"BusinessUnit\" = \"&lt;BUSINESS_UNIT&gt;\"\n    \"Department\"   = \"&lt;DEPARTMENT&gt;\"\n    \"user:tag\"     = \"&lt;PLATFORM_NAME&gt;\"\n  }\n\n  # Variables for demand pool\n  demand_instance_types      = [\"r5.large\"]\n  demand_max_nodes_count     = 0\n  demand_min_nodes_count     = 0\n  demand_desired_nodes_count = 0\n\n  // Variables for spot pool\n  spot_instance_types      = [\"r5.xlarge\", \"r5.large\", \"r4.large\"] # need to ensure we use nodes with more memory\n  spot_max_nodes_count     = 2\n  spot_desired_nodes_count = 2\n  spot_min_nodes_count     = 2\n</code></pre> <p>Note</p> <p>The file above is an example. Please find the latest version in the project repo in the terraform.tfvars file.</p> <p>There are the following possible scenarios to deploy the EKS cluster:</p> Case 1: Create new VPC and deploy the EKS cluster, terraform.tfvars file example <pre><code>create_elb     = true # set to true if you'd like to create ELB for Gerrit usage\n\nregion   = \"eu-central-1\"\nrole_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\"\n\nplatform_name        = \"test-eks\"\nplatform_domain_name = \"example.com\" # must be created as a prerequisite\n\n# The following will be created or used existing depending on the create_vpc value\nsubnet_azs    = [\"eu-central-1a\", \"eu-central-1b\"]\nplatform_cidr = \"172.31.0.0/16\"\nprivate_cidrs = [\"172.31.0.0/20\", \"172.31.16.0/20\"]\npublic_cidrs  = [\"172.31.32.0/20\", \"172.31.48.0/20\"]\n\n# Use this parameter the second time you apply the code to specify new AWS Security Groups\ninfrastructure_public_security_group_ids = [\n  #  \"sg-00000000000000000\",\n  #  \"sg-00000000000000000\",\n]\n\n# EKS cluster configuration\ncluster_version = \"1.22\"\nkey_name        = \"test-kn\" # must be created as a prerequisite\nenable_irsa     = true\n\n# Define if IAM roles should be created during the deployment or used existing ones\ncluster_iam_role_name            = \"ServiceRoleForEKSShared\"\nworker_iam_instance_profile_name = \"ServiceRoleForEksSharedWorkerNode0000000000000000000000\"\n\nadd_userdata = &lt;&lt;EOF\nexport TOKEN=$(aws ssm get-parameter --name edprobot --query 'Parameter.Value' --region eu-central-1 --output text)\ncat &lt;&lt;DATA &gt; /var/lib/kubelet/config.json\n{\n  \"auths\":{\n    \"https://index.docker.io/v1/\":{\n      \"auth\":\"$TOKEN\"\n    }\n  }\n}\nDATA\nEOF\n\nmap_users = [\n  {\n    \"userarn\" : \"arn:aws:iam::012345678910:user/user_name1@example.com\",\n    \"username\" : \"user_name1@example.com\",\n    \"groups\" : [\"system:masters\"]\n  },\n  {\n    \"userarn\" : \"arn:aws:iam::012345678910:user/user_name2@example.com\",\n    \"username\" : \"user_name2@example.com\",\n    \"groups\" : [\"system:masters\"]\n  }\n]\n\nmap_roles = [\n  {\n    \"rolearn\" : \"arn:aws:iam::012345678910:role/EKSClusterAdminRole\",\n    \"username\" : \"eksadminrole\",\n    \"groups\" : [\"system:masters\"]\n  },\n]\n\ntags = {\n  \"SysName\"      = \"EKS\"\n  \"SysOwner\"     = \"owner@example.com\"\n  \"Environment\"  = \"EKS-TEST-CLUSTER\"\n  \"CostCenter\"   = \"2020\"\n  \"BusinessUnit\" = \"BU\"\n  \"Department\"   = \"DEPARTMENT\"\n  \"user:tag\"     = \"test-eks\"\n}\n\n# Variables for spot pool\nspot_instance_types      = [\"r5.large\", \"r4.large\"] # need to ensure we use nodes with more memory\nspot_max_nodes_count     = 1\nspot_desired_nodes_count = 1\nspot_min_nodes_count     = 1\n</code></pre> </li> <li> <p>Run Terraform apply. Initialize the backend and apply the changes.</p> apply the changes <pre><code>   $ terraform init\n   $ terraform apply\n   ...\n\n   Do you want to perform these actions?\n   Terraform will perform the actions described above.\n   Only 'yes' will be accepted to approve.\n   Enter a value: yes\n   ...\n</code></pre> </li>"},{"location":"operator-guide/deploy-aws-eks/#check-eks-cluster-deployment","title":"Check EKS cluster deployment","text":"<p>As a result, the \u2039PLATFORM_NAME\u203a EKS cluster is deployed to the specified AWS account.</p> <p>Make sure you have all required tools listed in the Install required tools section.</p> <p>To connect to the cluster find the kubeconfig_ file in the project folder which is output of the last Terraform apply run. Move it to the ~/.kube/ folder. <pre><code>    $ mv kubeconfig_&lt;PLATFORM_NAME&gt; ~/.kube/\n</code></pre> <p>Run the following commands to ensure the EKS cluster is up and has required nodes count:</p> <pre><code>    $ kubectl config get-contexts\n    $ kubectl get nodes\n</code></pre> <p>Note</p> <p>If the there are any authorisation issues, make sure the users section in the kubeconfig_ file has all required parameters based on you AWS CLI version. Find more details in the create kubeconfig AWS user guide. And pay attention on the kubeconfig_aws_authenticator terraform input variables. <p>Optionally, a Lens tool can be installed and used for further work with Kubernetes cluster. Refer to the original documentation to add and process the cluster.</p>"},{"location":"operator-guide/deploy-okd-4.10/","title":"Deploy OKD 4.10 Cluster","text":"<p>This instruction provides detailed information on the OKD 4.10 cluster deployment in the AWS Cloud and contains the additional setup necessary for the managed infrastructure.</p> <p>A full description of the cluster deployment can be found in the official documentation.</p>"},{"location":"operator-guide/deploy-okd-4.10/#prerequisites","title":"Prerequisites","text":"<p>Before the OKD cluster deployment and configuration, make sure to check the prerequisites.</p>"},{"location":"operator-guide/deploy-okd-4.10/#required-tools","title":"Required Tools","text":"<ol> <li> <p>Install the following tools listed below:</p> <ul> <li>AWS CLI</li> <li>OpenShift CLI</li> <li>Lens (optional)</li> </ul> </li> <li> <p>Create the AWS IAM user with the required permissions. Make sure the AWS account is active, and the user doesn't have a permission boundary. Remove any Service Control Policy (SCP) restrictions from the AWS account.</p> </li> <li> <p>Generate a key pair for cluster node SSH access. Please perform the steps below:</p> <ul> <li>Generate the SSH key. Specify the path and file name, such as ~/.ssh/id_ed25519, of the new SSH key. If there is an existing key pair, ensure that the public key is in the ~/.ssh directory.<pre><code>ssh-keygen -t ed25519 -N '' -f &lt;path&gt;/&lt;file_name&gt;\n</code></pre> </li> </ul> <ul> <li>Add the SSH private key identity to the SSH agent for a local user if it has not already been added.<pre><code>eval \"$(ssh-agent -s)\"\n</code></pre> </li> </ul> <ul> <li>Add the SSH private key to the ssh-agent:<pre><code>ssh-add &lt;path&gt;/&lt;file_name&gt;\n</code></pre> </li> </ul> </li> <li> <p>Build the <code>ccoctl</code> tool:</p> <ul> <li>Clone the <code>cloud-credential-operator</code> repository.<pre><code>git clone https://github.com/openshift/cloud-credential-operator.git\n</code></pre> </li> </ul> <ul> <li>Move to the <code>cloud-credential-operator</code> folder and build the <code>ccoctl</code> tool.<pre><code>cd cloud-credential-operator &amp;&amp; git checkout release-4.10\nGO_PACKAGE='github.com/openshift/cloud-credential-operator'\ngo build -ldflags \"-X $GO_PACKAGE/pkg/version.versionFromGit=$(git describe --long --tags --abbrev=7 --match 'v[0-9]*')\" ./cmd/ccoctl\n</code></pre> </li> </ul> </li> </ol>"},{"location":"operator-guide/deploy-okd-4.10/#prepare-for-the-deployment-process","title":"Prepare for the Deployment Process","text":"<p>Before deploying the OKD cluster, please perform the steps below:</p>"},{"location":"operator-guide/deploy-okd-4.10/#create-aws-resources","title":"Create AWS Resources","text":"<p>Create the AWS resources with the Cloud Credential Operator utility (the <code>ccoctl</code> tool):</p> <ol> <li> <p>Generate the public and private RSA key files that are used to set up the OpenID Connect identity provider for the cluster:</p> <pre><code>./ccoctl aws create-key-pair\n</code></pre> </li> <li> <p>Create an OpenID Connect identity provider and an S3 bucket on AWS:</p> <pre><code>./ccoctl aws create-identity-provider \\\n--name=&lt;NAME&gt; \\\n--region=&lt;AWS_REGION&gt; \\\n--public-key-file=./serviceaccount-signer.public\n</code></pre> <p>where:</p> <ul> <li>NAME - is the name used to tag any cloud resources created for tracking,</li> <li>AWS_REGION - is the AWS region in which cloud resources will be created.</li> </ul> </li> <li> <p>Create the IAM roles for each component in the cluster:</p> <ul> <li> <p>Extract the list of the <code>CredentialsRequest</code> objects from the OpenShift Container Platform release image:</p> <pre><code>oc adm release extract \\\n--credentials-requests \\\n--cloud=aws \\\n--to=./credrequests \\\n--quay.io/openshift-release-dev/ocp-release:4.10.25-x86_64\n</code></pre> <p>Note</p> <p>A version of the openshift-release-dev docker image can be found in the Quay registry.</p> </li> </ul> <ul> <li>Use the <code>ccoctl</code> tool to process all <code>CredentialsRequest</code> objects in the <code>credrequests</code> directory:<pre><code>ccoctl aws create-iam-roles \\\n--name=&lt;NAME&gt; \\\n--region=&lt;AWS_REGION&gt; \\\n--credentials-requests-dir=./credrequests\n--identity-provider-arn=arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;NAME&gt;-oidc.s3.&lt;AWS_REGION&gt;.amazonaws.com\n</code></pre> </li> </ul> </li> </ol>"},{"location":"operator-guide/deploy-okd-4.10/#create-okd-manifests","title":"Create OKD Manifests","text":"<p>Before deploying the OKD cluster, please perform the steps below:</p> <ol> <li> <p>Download the OKD installer.</p> </li> <li> <p>Extract the installation program:</p> <pre><code>tar -xvf openshift-install-linux.tar.gz\n</code></pre> </li> <li> <p>Download the installation pull secret for any private registry. This pull secret allows to authenticate with the services that are provided by the authorities, including Quay.io, serving the container images for OKD components. For example, here is a pull secret for Docker Hub:</p> The pull secret for the private registry <pre><code>{\n\"auths\":{\n\"https://index.docker.io/v1/\":{\n\"auth\":\"$TOKEN\"\n}\n}\n}\n</code></pre> </li> <li> <p>Create a deployment directory and the install-config.yaml file:</p> <pre><code>mkdir okd-deployment\ntouch okd-deployment/install-config.yaml\n</code></pre> <p>To specify more details about the OKD cluster platform or to modify the values of the required parameters, customize the install-config.yaml file for the AWS. Please see below an example of the customized file:</p> install-config.yaml - OKD cluster\u2019s platform installation configuration file <pre><code>apiVersion: v1\nbaseDomain: &lt;YOUR_DOMAIN&gt;\ncredentialsMode: Manual\ncompute:\n- architecture: amd64\nhyperthreading: Enabled\nname: worker\nplatform:\naws:\nrootVolume:\nsize: 30\nzones:\n- eu-central-1a\ntype: r5.large\nreplicas: 3\ncontrolPlane:\narchitecture: amd64\nhyperthreading: Enabled\nname: master\nplatform:\naws:\nrootVolume:\nsize: 50\nzones:\n- eu-central-1a\ntype: m5.xlarge\nreplicas: 3\nmetadata:\ncreationTimestamp: null\nname: 4-10-okd-sandbox\nnetworking:\nclusterNetwork:\n- cidr: 10.128.0.0/14\nhostPrefix: 23\nmachineNetwork:\n- cidr: 10.0.0.0/16\nnetworkType: OVNKubernetes\nserviceNetwork:\n- 172.30.0.0/16\nplatform:\naws:\nregion: eu-central-1\nuserTags:\nuser:tag: 4-10-okd-sandbox\npublish: External\npullSecret: &lt;PULL_SECRET&gt;\nsshKey: |\n&lt;SSH_KEY&gt;\n</code></pre> <p>where:</p> <ul> <li>YOUR_DOMAIN - is a base domain,</li> <li>PULL_SECRET - is a created pull secret for a private registry,</li> <li>SSH_KEY - is a created SSH key.</li> </ul> </li> <li> <p>Create the required OpenShift Container Platform installation manifests:</p> <pre><code>./openshift-install create manifests --dir okd-deployment\n</code></pre> </li> <li> <p>Copy the manifests generated by the <code>ccoctl</code> tool to the <code>manifests</code> directory created by the installation program:</p> <pre><code>cp ./manifests/* ./okd-deployment/manifests/\n</code></pre> </li> <li> <p>Copy the private key generated in the <code>tls</code> directory by the <code>ccoctl</code> tool to the installation directory:</p> <pre><code>cp -a ./tls ./okd-deployment\n</code></pre> </li> </ol>"},{"location":"operator-guide/deploy-okd-4.10/#deploy-the-cluster","title":"Deploy the Cluster","text":"<p>To initialize the cluster deployment, run the following command:</p> <pre><code>./openshift-install create cluster --dir okd-deployment --log-level=info\n</code></pre> <p>Note</p> <p>If the cloud provider account configured on the host does not have sufficient permissions to deploy the cluster, the installation process stops, and the missing permissions are displayed.</p> <p>When the cluster deployment is completed, directions for accessing the cluster are displayed in the terminal, including a link to the web console and credentials for the kubeadmin user. The <code>kubeconfig</code> for the cluster will be located in okd-deployment/auth/kubeconfig.</p> Example output <pre><code>...\nINFO Install complete!\nINFO To access the cluster as the system:admin user when using 'oc', run 'export KUBECONFIG=/home/myuser/install_dir/auth/kubeconfig'\nINFO Access the OpenShift web-console here: https://console-openshift-console.apps.mycluster.example.com\nINFO Login to the console with the user: \"kubeadmin\", and password: \"4vYBz-Ee6gm-ymBZj-Wt5AL\"\nINFO Time elapsed: 36m22s:\n</code></pre> <p>Warning</p> <p>The Ignition config files contain certificates that expire after 24 hours, which are then renewed at that time. Do not turn off the cluster for this time, or you will have to update the certificates manually. See OpenShift Container Platform documentation for more information.</p>"},{"location":"operator-guide/deploy-okd-4.10/#log-into-the-cluster","title":"Log Into the Cluster","text":"<p>To log into the cluster, export the <code>kubeconfig</code>:</p> <pre><code>  export KUBECONFIG=&lt;installation_directory&gt;/auth/kubeconfig\n</code></pre> <p>Optionally, use the Lens tool for further work with the Kubernetes cluster.</p> <p>Note</p> <p>To install and manage the cluster, refer to Lens documentation.</p>"},{"location":"operator-guide/deploy-okd-4.10/#manage-okd-cluster-without-the-inbound-rules","title":"Manage OKD Cluster Without the Inbound Rules","text":"<p>In order to manage the OKD cluster without the <code>0.0.0.0/0</code> inbound rules, please perform the steps below:</p> <ol> <li> <p>Create a Security Group with a list of your external IPs:</p> <pre><code>aws ec2 create-security-group --group-name &lt;SECURITY_GROUP_NAME&gt; --description \"&lt;DESCRIPTION_OF_SECURITY_GROUP&gt;\" --vpc-id &lt;VPC_ID&gt;\naws ec2 authorize-security-group-ingress \\\n--group-id '&lt;SECURITY_GROUP_ID&gt;' \\\n--ip-permissions 'IpProtocol=all,PrefixListIds=[{PrefixListId=&lt;PREFIX_LIST_ID&gt;}]'\n</code></pre> </li> <li> <p>Manually attach this new Security Group to all master nodes of the cluster.</p> </li> <li> <p>Create another Security Group with an Elastic IP of the Cluster VPC:</p> <pre><code>aws ec2 create-security-group --group-name custom-okd-4-10 --description \"Cluster Ip to 80, 443\" --vpc-id &lt;VPC_ID&gt;\naws ec2 authorize-security-group-ingress \\\n--group-id '&lt;SECURITY_GROUP_ID&gt;' \\\n--protocol all \\\n--port 80 \\\n--cidr &lt;ELASTIC_IP_OF_CLUSTER_VPC&gt;\naws ec2 authorize-security-group-ingress \\\n--group-id '&lt;SECURITY_GROUP_ID&gt;' \\\n--protocol all \\\n--port 443 \\\n--cidr &lt;ELASTIC_IP_OF_CLUSTER_VPC&gt;\n</code></pre> </li> <li> <p>Modify the cluster load balancer via the <code>router-default</code> svc in the <code>openshift-ingress</code> namespace, paste two Security Groups created on previous steps:</p> The pull secret for the private registry <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: router-default\n  namespace: openshift-ingress\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: \"tag_name=some_value\"\n    service.beta.kubernetes.io/aws-load-balancer-security-groups: \"&lt;SECURITY_GROUP_IDs&gt;\"\n    ...\n</code></pre> </li> </ol>"},{"location":"operator-guide/deploy-okd-4.10/#optimize-spot-instances-usage","title":"Optimize Spot Instances Usage","text":"<p>In order to optimize the usage of Spot Instances on the AWS, add the following line under the <code>providerSpec</code> field in the MachineSet of Worker Nodes:</p> <pre><code>providerSpec:\nvalue:\nspotMarketOptions: {}\n</code></pre>"},{"location":"operator-guide/deploy-okd-4.10/#related-articles","title":"Related Articles","text":"<ul> <li>Deploy AWS EKS Cluster</li> <li>Manage Jenkins Agent</li> <li>Associate IAM Roles With Service Accounts</li> <li>Deploy OKD 4.9 Cluster</li> </ul>"},{"location":"operator-guide/deploy-okd/","title":"Deploy OKD 4.9 Cluster","text":"<p>This instruction provides detailed information on the OKD 4.9 cluster deployment in the AWS Cloud and contains the additional setup necessary for the managed infrastructure.</p> <p>A full description of the cluster deployment can be found in the official documentation.</p>"},{"location":"operator-guide/deploy-okd/#prerequisites","title":"Prerequisites","text":"<p>Before the OKD cluster deployment and configuration, make sure to check the prerequisites.</p>"},{"location":"operator-guide/deploy-okd/#required-tools","title":"Required Tools","text":"<ol> <li> <p>Install the following tools listed below:</p> <ul> <li>AWS CLI</li> <li>OpenShift CLI</li> <li>Lens (optional)</li> </ul> </li> <li> <p>Create the AWS IAM user with the required permissions. Make sure the AWS account is active, and the user doesn't have a permission boundary. Remove any Service Control Policy (SCP) restrictions from the AWS account.</p> </li> <li> <p>Generate a key pair for cluster node SSH access. Please perform the steps below:</p> <ul> <li>Generate the SSH key. Specify the path and file name, such as ~/.ssh/id_ed25519, of the new SSH key. If there is an existing key pair, ensure that the public key is in the ~/.ssh directory.<pre><code> ssh-keygen -t ed25519 -N '' -f &lt;path&gt;/&lt;file_name&gt;\n</code></pre> </li> </ul> <ul> <li>Add the SSH private key identity to the SSH agent for a local user if it has not already been added.<pre><code> eval \"$(ssh-agent -s)\"\n</code></pre> </li> </ul> <ul> <li>Add the SSH private key to the ssh-agent:<pre><code> ssh-add &lt;path&gt;/&lt;file_name&gt;\n</code></pre> </li> </ul> </li> </ol>"},{"location":"operator-guide/deploy-okd/#prepare-for-the-deployment-process","title":"Prepare for the Deployment Process","text":"<p>Before deploying the OKD cluster, please perform the steps below:</p> <ol> <li> <p>Download the OKD installer.</p> </li> <li> <p>Extract the installation program:</p> <pre><code>tar -xvf openshift-install-linux.tar.gz\n</code></pre> </li> <li> <p>Download the installation pull secret for any private registry.</p> <p>This pull secret allows to authenticate with the services that are provided by the included authorities, including Quay.io serving container images for OKD components. For example, here is a pull secret for Docker Hub:</p> The pull secret for the private registry <pre><code>{\n  \"auths\":{\n    \"https://index.docker.io/v1/\":{\n      \"auth\":\"$TOKEN\"\n    }\n  }\n}\n</code></pre> </li> <li> <p>Create the deployment directory and the install-config.yaml file:</p> <pre><code>mkdir okd-deployment\ntouch okd-deployment/install-config.yaml\n</code></pre> <p>To specify more details about the OKD cluster platform or to modify the values of the required parameters, customize the install-config.yaml file for AWS. Please see an example of the customized file below:</p> install-config.yaml - OKD cluster\u2019s platform installation configuration file <pre><code>apiVersion: v1\nbaseDomain: &lt;YOUR_DOMAIN&gt;\ncompute:\n- architecture: amd64\n  hyperthreading: Enabled\n  name: worker\n  platform:\n    aws:\n      zones:\n        - eu-central-1a\n      rootVolume:\n        size: 50\n      type: r5.large\n  replicas: 3\ncontrolPlane:\n  architecture: amd64\n  hyperthreading: Enabled\n  name: master\n  platform:\n    aws:\n      rootVolume:\n        size: 50\n      zones:\n        - eu-central-1a\n      type: m5.xlarge\n  replicas: 3\nmetadata:\n  creationTimestamp: null\n  name: 4-9-okd-sandbox\nplatform:\n  aws:\n    region: eu-central-1\n    userTags:\n      user:tag: 4-9-okd-sandbox\npublish: External\npullSecret: &lt;PULL_SECRET&gt;\nsshKey: |\n  &lt;SSH_KEY&gt;\n</code></pre> <p>where:</p> <ul> <li>YOUR_DOMAIN - is a base domain,</li> <li>PULL_SECRET - is a created pull secret for a private registry,</li> <li>SSH_KEY - is a created SSH key.</li> </ul> </li> </ol>"},{"location":"operator-guide/deploy-okd/#deploy-the-cluster","title":"Deploy the Cluster","text":"<p>To initialize the cluster deployment, run the following command:</p> <pre><code>./openshift-install create cluster --dir &lt;installation_directory&gt; --log-level=info\n</code></pre> <p>Note</p> <p>If the cloud provider account configured on the host does not have sufficient permissions to deploy the cluster, the installation process stops, and the missing permissions are displayed.</p> <p>When the cluster deployment is completed, directions for accessing the cluster are displayed in the terminal, including a link to the web console and credentials for the kubeadmin user. The <code>kubeconfig</code> for the cluster will be located in okd-deployment/auth/kubeconfig.</p> Example output <pre><code>...\nINFO Install complete!\nINFO To access the cluster as the system:admin user when using 'oc', run 'export KUBECONFIG=/home/myuser/install_dir/auth/kubeconfig'\nINFO Access the OpenShift web-console here: https://console-openshift-console.apps.mycluster.example.com\nINFO Login to the console with the user: \"kubeadmin\", and password: \"4vYBz-Ee6gm-ymBZj-Wt5AL\"\nINFO Time elapsed: 36m22s:\n</code></pre> <p>Warning</p> <p>The Ignition config files contain certificates that expire after 24 hours, which are then renewed at that time. Do not turn off the cluster for this time, or you will have to update the certificates manually. See OpenShift Container Platform documentation for more information.</p>"},{"location":"operator-guide/deploy-okd/#log-into-the-cluster","title":"Log Into the Cluster","text":"<p>To log into the cluster, export the <code>kubeconfig</code>:</p> <pre><code>  export KUBECONFIG=&lt;installation_directory&gt;/auth/kubeconfig\n</code></pre> <p>Optionally, use the Lens tool for further work with the Kubernetes cluster.</p> <p>Note</p> <p>To install and manage the cluster, refer to Lens documentation.</p>"},{"location":"operator-guide/deploy-okd/#related-articles","title":"Related Articles","text":"<ul> <li>Deploy AWS EKS Cluster</li> <li>Manage Jenkins Agent</li> <li>Deploy OKD 4.10 Cluster</li> </ul>"},{"location":"operator-guide/edp-kiosk-usage/","title":"EDP Kiosk Usage","text":"<p>Explore the way Kiosk, a multi-tenancy extension for Kubernetes, is used in EDP.</p>"},{"location":"operator-guide/edp-kiosk-usage/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed Kiosk 0.2.11.</li> </ul>"},{"location":"operator-guide/edp-kiosk-usage/#diagram-of-using-kiosk-by-edp","title":"Diagram of using Kiosk by EDP","text":"<p> Kiosk usage </p> <p>Agenda</p> <ul> <li>blue - created by Helm chart;</li> <li>grey - created manually</li> </ul>"},{"location":"operator-guide/edp-kiosk-usage/#usage","title":"Usage","text":"<ul> <li>EDP installation area on a diagram is described by following link;</li> </ul> <ul> <li>Once the above step is executed, edp-cd-pipeline-operator service account will be linked to kiosk-edit ClusterRole   to get an ability for leveraging Kiosk specific resources (e.g. Space);</li> </ul> <ul> <li>Newly created stage in \u2039edp-project\u203a installation of EDP generates new Kiosk Space resource that is linked to  Kiosk Account; <ul> <li>According to Kiosk doc the Space resource creates namespace with RoleBinding that contains relation between service account   which is linked to Kiosk Account and kiosk-space-admin ClusterRole.   As cd-pipeline-operator ServiceAccount is linked to Account, it has admin permissions in all generated by him namespaces.</li> </ul>"},{"location":"operator-guide/edp-kiosk-usage/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Set Up Kiosk</li> </ul>"},{"location":"operator-guide/enable-irsa/","title":"Associate IAM Roles With Service Accounts","text":"<p>This page contains accurate information on how to associate an IAM role with the service account (IRSA) in EPAM Delivery Platform.</p> <p>Get acquainted with the AWS Official Documentation on the subject before proceeding.</p>"},{"location":"operator-guide/enable-irsa/#common-configuration-of-iam-roles-with-service-accounts","title":"Common Configuration of IAM Roles With Service Accounts","text":"<p>To successfully associate the IAM role with the service account, follow the steps below:</p> <ol> <li> <p>Create an IAM role that will further be associated with the service account. This role must have the following trust policy:</p> <p>IAM Role</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;OIDC_PROVIDER&gt;\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"&lt;OIDC_PROVIDER&gt;:sub\": \"system:serviceaccount:&lt;SERVICE_ACCOUNT_NAMESPACE&gt;:&lt;SERVICE_ACCOUNT_NAME&gt;\"\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>View cluster's \u2039OIDC_PROVIDER\u203a URL.</p> <pre><code>  aws eks describe-cluster --name &lt;CLUSTER_NAME&gt; --query \"cluster.identity.oidc.issuer\" --output text\n</code></pre> <p>Example output:</p> <pre><code>  https://oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E\n</code></pre> <p>\u2039OIDC_PROVIDER\u203a in this example will be:</p> <pre><code>  oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E\n</code></pre> </li> <li> <p>Deploy the amazon-eks-pod-identity-webhook v0.2.0.</p> <p>Note</p> <p>The amazon-eks-pod-identity-webhook functionality is provided out of the box in EKS v1.21 and higher. This does not apply if the cluster has been upgraded from older versions. Therefore, skip step 2 and continue from step 3 in this documentation.</p> <p>2.1. Provide the stable(ed8c41f) version of the Docker image in the deploy/deployment-base.yaml file.</p> <p>2.2. Provide ${CA_BUNDLE}_in the_deploy/mutatingwebhook.yaml file:</p> <pre><code>  secret_name=$(kubectl -n default get sa default -o jsonpath='{.secrets[0].name}') \\\n  CA_BUNDLE=$(kubectl -n default get secret/$secret_name -o jsonpath='{.data.ca\\.crt}' | tr -d '\\n')\n</code></pre> <p>2.3. Deploy the Webhook:</p> <pre><code>  kubectl apply -f deploy/\n</code></pre> <p>2.4. Approve the csr:</p> <pre><code>  csr_name=$(kubectl get csr -o jsonpath='{.items[?(@.spec.username==\"system:serviceaccount:default:pod-identity-webhook\")].metadata.name}')\n  kubectl certificate approve $csr_name\n</code></pre> </li> <li> <p>Annotate the created service account with the IAM role:</p> <p>Service Account</p> <pre><code>  apiVersion: v1\n  kind: ServiceAccount\n  metadata:\n    name: &lt;SERVICE_ACCOUNT_NAME&gt;\n    namespace: &lt;NAMESPACE&gt;\n    annotations:\n      eks.amazonaws.com/role-arn: \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/&lt;IAM_ROLE_NAME&gt;\"\n</code></pre> </li> <li> <p>All newly launched pods with this service account will be modified and then use the associated IAM role. Find below the pod specification template:</p> <p>Pod Template</p> <pre><code>  apiVersion: v1\n  kind: Pod\n  metadata:\n    name: irsa-test\n    namespace: &lt;POD_NAMESPACE&gt;\n  spec:\n    serviceAccountName: &lt;SERVICE_ACCOUNT_NAME&gt;\n    securityContext:\n      fsGroup: 65534\n    containers:\n    - name: terraform\n      image: epamedp/edp-jenkins-terraform-agent:2.0.4\n      command: ['sh', '-c', 'aws sts \"get-caller-identity\" &amp;&amp; sleep 3600']\n</code></pre> </li> <li> <p>Check the logs of the created pod from the template above.</p> <p>Example output:</p> <pre><code>  {\n  \"UserId\": \"XXXXXXXXXXXXXXXXXXXXX:botocore-session-XXXXXXXXXX\",\n  \"Account\": \"XXXXXXXXXXXX\",\n  \"Arn\": \"arn:aws:sts::XXXXXXXXXXXX:assumed-role/AWSIRSATestRole/botocore-session-XXXXXXXXXX\"\n  }\n</code></pre> <p>As a result, it is possible to perform actions in AWS under the AWSIRSATestRole role.</p> </li> </ol>"},{"location":"operator-guide/enable-irsa/#related-articles","title":"Related Articles","text":"<ul> <li>Use Terraform Library in EDP</li> </ul>"},{"location":"operator-guide/external-secrets-operator-integration/","title":"External Secrets Operator Integration","text":"<p>External Secrets Operator (ESO) can be integrated with EDP.</p> <p>There are multiple Secrets Providers that can be used within ESO. EDP is integrated with two major providers:</p> <ul> <li>Kubernetes Secrets</li> <li>AWS Systems Manager Parameter Store</li> </ul>"},{"location":"operator-guide/external-secrets-operator-integration/#kubernetes","title":"Kubernetes","text":"<p>All secrets are stored in Kubernetes in pre-defined namespaces. EDP suggests using the following approach for secrets management:</p> <ul> <li><code>EDP_NAMESPACE-vault</code>, where EDP_NAMESPACE is a name of the namespace where EDP is deployed, such as <code>edp-vault</code>. This namespace is used by EDP platform. Access to secrets in the <code>edp-vault</code> is permitted only for <code>EDP Administrators</code>.</li> </ul> <ul> <li><code>EDP_NAMESPACE-cicd-vault</code>, where EDP_NAMESPACE is a name of the namespace where EDP is deployed, such as <code>edp-cicd-vault</code>. Development team uses access to secrets in the <code>edp-cicd-vault</code>for microservices development.</li> </ul> <p>See a diagram below for more details:</p> <p></p>"},{"location":"operator-guide/external-secrets-operator-integration/#edp-install-scenario","title":"EDP Install Scenario","text":"<p>In order to install EDP, a list of passwords must be created: defectdojo-ciuser-token, keycloak-client-headlamp-secret and keycloak. Secrets are provided automatically when using ESO.</p> <ol> <li> <p>Create a common namespace for secrets and EDP:</p> <pre><code>kubectl create namespace edp-vault\nkubectl create namespace edp\n</code></pre> </li> <li> <p>Create secrets in the <code>edp-vault</code> namespace:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: keycloak\nnamespace: edp-vault\ndata:\npassword: cGFzcw==  # pass\nusername: dXNlcg==  # user\ntype: Opaque\n</code></pre> </li> <li> <p>In the <code>edp-vault</code> namespace, create a Role with a permission to read secrets:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\nnamespace: edp-vault\nname: external-secret-store\nrules:\n- apiGroups: [\"\"]\nresources:\n- secrets\nverbs:\n- get\n- list\n- watch\n- apiGroups:\n- authorization.k8s.io\nresources:\n- selfsubjectrulesreviews\nverbs:\n- create\n</code></pre> </li> <li> <p>In the <code>edp-vault</code> namespace, create a ServiceAccount used by <code>SecretStore</code>:</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: secret-manager\nnamespace: edp\n</code></pre> </li> <li> <p>Connect the Role from the <code>edp-vault</code> namespace with the ServiceAccount in the <code>edp</code> namespace:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: eso-from-edp\nnamespace: edp-vault\nsubjects:\n- kind: ServiceAccount\nname: secret-manager\nnamespace: edp\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: Role\nname: external-secret-store\n</code></pre> </li> <li> <p>Create a SecretStore in the <code>edp</code> namespace, and use ServiceAccount for authentication:</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\nname: edp-vault\nnamespace: edp\nspec:\nprovider:\nkubernetes:\nremoteNamespace: edp-vault  # namespace with secrets\nauth:\nserviceAccount:\nname: secret-manager\nserver:\ncaProvider:\ntype: ConfigMap\nname: kube-root-ca.crt\nkey: ca.crt\n</code></pre> </li> <li> <p>Each secret must be defined by the <code>ExternalSecret</code> object. A code example below creates the <code>keycloak</code> secret in the <code>edp</code> namespace based on a secret with the same name in the <code>edp-vault</code> namespace:</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\nname: keycloak\nnamespace: edp\nspec:\nrefreshInterval: 1h\nsecretStoreRef:\nkind: SecretStore\nname: edp-vault\n# target:\n#   name: secret-to-be-created  # name of the k8s Secret to be created. metadata.name used if not defined\ndata:\n- secretKey: username       # key to be created\nremoteRef:\nkey: keycloak           # remote secret name\nproperty: username      # value will be fetched from this field\n- secretKey: password       # key to be created\nremoteRef:\nkey: keycloak           # remote secret name\nproperty: password      # value will be fetched from this field\n</code></pre> </li> </ol> <p>Apply the same approach for enabling secrets management in the namespaces used for microservices development, such as <code>sit</code> and <code>qa</code> on the diagram above.</p>"},{"location":"operator-guide/external-secrets-operator-integration/#aws-systems-manager-parameter-store","title":"AWS Systems Manager Parameter Store","text":"<p>AWS SSM Parameter Store can be used as a Secret Provider for ESO. For EDP, it is recommended to use the IAM Roles For Service Accounts approach (see a diagram below).</p> <p></p>"},{"location":"operator-guide/external-secrets-operator-integration/#edp-install-scenario_1","title":"EDP Install Scenario","text":"<p>In order to install EDP, a list of passwords must be created: defectdojo-ciuser-token, keycloak-client-headlamp-secret and keycloak. Follow the steps below, to get secrets from the SSM:</p> <ol> <li> <p>In the AWS, create an AWS IAM policy and an IAM role used by <code>ServiceAccount</code> in <code>SecretStore</code>. The IAM role must have permissions to get values from the SSM Parameter Store.</p> <p>a. Create an IAM policy that allows to get values from the Parameter Store with the <code>edp/</code> path. Use your <code>AWS Region</code> and <code>AWS Account Id</code>:</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Sid\": \"VisualEditor0\",\n\"Effect\": \"Allow\",\n\"Action\": \"ssm:GetParameter*\",\n\"Resource\": \"arn:aws:ssm:eu-central-1:012345678910:parameter/edp/*\"\n}\n]\n}\n</code></pre> <p>b. Create an AWS IAM role with trust relationships (defined below) and attach the IAM policy. Put your string for <code>Federated</code> value (see more on IRSA enablement for EKS Cluster) and AWS region.</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Principal\": {\n\"Federated\": \"arn:aws:iam::012345678910:oidc-provider/oidc.eks.eu-central-1.amazonaws.com/id/XXXXXXXXXXXXXXXXXX\"\n},\n\"Action\": \"sts:AssumeRoleWithWebIdentity\",\n\"Condition\": {\n\"StringLike\": {\n\"oidc.eks.eu-central-1.amazonaws.com/id/XXXXXXXXXXXXXXXXXX:sub\": \"system:serviceaccount:edp:*\"\n}\n}\n}\n]\n}\n</code></pre> </li> <li> <p>In the AWS Parameter Store, create a secret with the <code>/edp/my-json-secret</code> name:</p> <pre><code>{\n\"keycloak-client-headlamp-secret\":  \"XXXXXXXXXXXX\",\n\"defectdojo-ciuser-token\": {\"token\": \"XXXXXXXXXXXX\", \"url\": \"https://defectdojo.example.com\"},\n\"keycloak\": {\"username\": \"realm-user\", \"password\": \"pass\"},\n}\n</code></pre> </li> <li> <p>In the <code>edp</code> Kubernetes namespace, create the following objects:</p> </li> </ol> <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nannotations:\neks.amazonaws.com/role-arn: arn:aws:iam::012345678910:role/ROLE_NAME\nname: secret-manager\nnamespace: edp\n---\napiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\nname: aws-parameter-store\nnamespace: edp\nspec:\nprovider:\naws:\nservice: ParameterStore\nregion: AWS_REGION\nauth:\njwt:\nserviceAccountRef:\nname: secret-manager\n---\napiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\nname: keycloak\nnamespace: edp\nspec:\nrefreshInterval: 1h\nsecretStoreRef:\nkind: SecretStore\nname: aws-parameter-store\ndata:\n- secretKey: username\nremoteRef:\nkey: /edp/my-json-secret\nproperty: keycloak.username\n- secretKey: password\nremoteRef:\nkey: /edp/my-json-secret\nproperty: keycloak.password\n</code></pre> <p>where:</p> <ul> <li><code>ROLE_NAME</code> - is a value defined on step 1.b,</li> <li><code>AWS_REGION</code> - is the AWS region, used on step 1.</li> </ul> <p>As a result, a secret with the <code>keycloak</code> name is created in the <code>edp</code> namespace with the content defined in JSON format on step 2.</p>"},{"location":"operator-guide/external-secrets-operator-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Install External Secrets Operator</li> </ul>"},{"location":"operator-guide/github-debug-webhooks/","title":"Debug GitHub Webhooks in Jenkins","text":"<p>A webhook enables third-party services like GitHub to send real-time updates to an application. Updates are triggered by an event or an action by the webhook provider (for example, a push to a repository, a Pull Request creation), and pushed to the application via HTTP requests, namely, Jenkins. The GitHub Jenkins job provisioner creates a webhook in the GitHub repository during the Create release pipeline once the VCS Import Strategy is enabled and the GitHub Integration is completed.</p> <p>The Jenkins setup in EDP uses the following plugins responsible for listening on GitHub webhooks:</p> <ul> <li>GitHub plugin is configured to listen on Push events.</li> </ul> <ul> <li>GitHub Pull Request Builder is configured to listen on Pull Request events.</li> </ul> <p>In case of any issues with webhooks, try the following solutions:</p> <ol> <li> <p>Check that the firewalls are configured to accept the incoming traffic from the IP address range that is described in the GitHub documentation.</p> </li> <li> <p>Check that GitHub Personal Access Token is correct and has sufficient scope permissions.</p> </li> <li> <p>Check that the job has run at least once before using the hook (once an application is created in EDP, the build job should be run automatically in Jenkins).</p> </li> <li> <p>Check that both Push and issue comment and Pull Request webhooks are created on the GitHub side (unlike GitLab, GitHub does not need separate webhooks for each branch):</p> <ul> <li>Go to the GitHub repository -&gt; Settings -&gt; Webhooks.</li> </ul> <p> Webhooks settings </p> </li> <li> <p>Click each webhook and check if the event delivery is successful:</p> <ul> <li>The URL payload must be <code>https://jenkins-the-host.com/github-webhook/</code> for the GitHub plugin and <code>https://jenkins-the-host.com/ghprbhook/</code> for the GitHub Pull Request Builder.</li> <li>The content type must be application/json for Push events and application/x-www-form-urlencoded for Pull Request events.</li> <li>The html_url in the Payload request must match the repository URL and be without .git at the end of the URL.</li> </ul> </li> <li> <p>Check that the X-Hub-Signature secret is verified. It is provided by the Jenkins GitHub plugin for Push events and by the GitHub Pull Request Builder plugin for Pull Request events. The Secret field is optional. Nevertheless, if incorrect, it can prevent webhook events.</p> <p>For the GitHub plugin (Push events):</p> <ul> <li>Go to Jenkins -&gt; Manage Jenkins -&gt; Configure System, and find the GitHub plugin section.</li> <li>Select Advanced -&gt; Shared secrets to add the secret via the Jenkins Credentials Provider.</li> </ul> <p>For the GitHub Pull Request Builder (Pull Request events):</p> <ul> <li>Go to Jenkins -&gt; Manage Jenkins -&gt; Configure System, and find the GitHub Pull Request Builder plugin section.</li> <li>Check Shared secret that can be added manually.</li> </ul> </li> <li> <p>Redeliver events by clicking the Redeliver button and check the Response body.</p> <p> Manage webhook </p> <p>Note</p> <p>Use Postman to debug webhooks. Add all headers to Postman from the webhook Request -&gt; Headers field and send the payload (Request body) using the appropriate content type.</p> <p>Examples for Push and Pull Request events:</p> <p> Postman push event payload headers GitHub plugin push events </p> <p>The response in the Jenkins log:</p> <pre><code>Jan 17, 2022 8:51:14 AM INFO org.jenkinsci.plugins.github.webhook.subscriber.PingGHEventSubscriber onEvent\nPING webhook received from repo &lt;https://github.com/user-profile/user-repo&gt;!\n</code></pre> <p> Postman pull request event payload headers GitHub pull request builder </p> <p>The response in the Jenkins log:</p> <pre><code>Jan 17, 2022 8:17:53 AM FINE org.jenkinsci.plugins.ghprb.GhprbRootAction\nGot payload event: ping\n</code></pre> </li> <li> <p>Check that the repo pushing to Jenkins, the GitHub project URL in the project configuration, and the repos in the pipeline Job must be lined up.</p> </li> <li> <p>Enable the GitHub hook trigger for GITScm polling for the Build job.</p> <p> GitHub hook trigger </p> </li> <li> <p>Enable the GitHub Pull Request Builder for the Code Review job.</p> <p> GitHub pull request builder </p> </li> <li> <p>Filter through Jenkins log by using Jenkins custom log recorder:</p> <ul> <li>Go to Manage Jenkins -&gt; System log -&gt; Add new log recorder.</li> <li> <p>The Push events for the GitHub:</p> Logger Log Level org.jenkinsci.plugins.github.webhook.subscriber.DefaultPushGHEventSubscriber ALL com.cloudbees.jenkins.GitHubPushTrigger ALL com.cloudbees.jenkins.GitHubWebHook ALL org.jenkinsci.plugins.github.webhook.WebhookManager ALL org.jenkinsci.plugins.github.webhook.subscriber.PingGHEventSubscriber ALL </li> </ul> <ul> <li> <p>The Pull Request events for the GitHub Pull Request Builder:</p> Logger Log Level org.jenkinsci.plugins.ghprb.GhprbRootAction ALL org.jenkinsci.plugins.ghprb.GhprbTrigger ALL org.jenkinsci.plugins.ghprb.GhprbPullRequest ALL org.jenkinsci.plugins.ghprb.GhprbRepository ALL </li> </ul> <p>Note</p> <p>Below is an example of using the Pipeline script with webhooks for the GitHub plugin implemented in the EDP pipelines:</p> <pre><code>properties([pipelineTriggers([githubPush()])])\n\nnode {\n    git credentialsId: 'github-sshkey', url: 'https://github.com/someone/something.git', branch: 'master'\n}\n</code></pre> <p>Push events may not work correctly with the Job Pipeline script from SCM option in the current version of the GitHub plugin 1.34.1.</p> </li> </ol>"},{"location":"operator-guide/github-debug-webhooks/#related-articles","title":"Related Articles","text":"<ul> <li>GitHub Webhooks</li> <li>Enable VCS Import Strategy</li> <li>GitHub Integration</li> <li>Manage Jenkins CI Pipeline Job Provision</li> <li>GitHub plugin</li> <li>GitHub Pull Request Builder</li> </ul>"},{"location":"operator-guide/github-integration/","title":"GitHub Integration","text":"<p>Follow the steps below to automatically integrate Jenkins with GitHub webhooks.</p> <p>Note</p> <p>Before applying the GitHub integration, make sure to enable VCS Import strategy. For details, please refer to the Enable VCS Import Strategy section.</p> <ol> <li> <p>Create a new job provisioner by following the instruction. The job provisioner will create a job suite for an application added to EDP. It will also create webhooks for the project in GitHub using a GitHub token.</p> </li> <li> <p>Create the classic personal access tokens for GitHub:</p> <ul> <li>Click the profile account and navigate to Settings -&gt; Developer Settings.</li> <li>Select Personal access tokens (classic) and generate a new token with the following parameters:</li> </ul> <p> Repo permission </p> <p>Note</p> <p>The access below is required for the GitHub Pull Request Builder plugin to get Pull Request commits, their status, and author info.</p> <p> Admin permission User permission </p> <p>Warning</p> <p>Make sure to save a new personal access token because it won`t be displayed later.</p> </li> <li> <p>Navigate to Jenkins -&gt; Credentials -&gt; System -&gt; Global credentials -&gt; Add credentials, and create new credentials with the Secret text kind. In the Secret field, provide the GitHub API token, fill in the ID field with the <code>github-access-token</code> value:</p> <p> Jenkins github credentials </p> </li> <li> <p>Navigate to Jenkins -&gt; Manage Jenkins -&gt; Configure system -&gt; GitHub, and configure the GitHub server:</p> <p> GitHub plugin config GitHub plugin Shared secrets config </p> <p>Note</p> <p>Keep the Manage hooks checkbox clear since the Job Provisioner automatically creates webhooks in the repository regardless of the checkbox selection. Select Advanced to see the shared secrets that can be used in a webhook Secret field to authenticate payloads from GitHub to Jenkins. The Secret field is optional.</p> </li> <li> <p>Configure the GitHub Pull Request Builder plugin. This plugin is responsible for listening on Pull Request webhook events and triggering Code Review jobs:</p> <p>Note</p> <p>The Secret field is optional and is used in a webhook Secret field to authenticate payloads from GitHub to Jenkins. For details, please refer to the official GitHub pull request builder plugin documentation.</p> <p> GitHub pull plugin config </p> </li> </ol>"},{"location":"operator-guide/github-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Enable VCS Import Strategy</li> <li>Adjust Jira Integration</li> <li>Manage Jenkins CI Pipeline Job Provision</li> </ul>"},{"location":"operator-guide/gitlab-debug-webhooks/","title":"Debug GitLab Webhooks in Jenkins","text":"<p>A webhook enables third-party services like GitLab to send real-time updates to the application. Updates are triggered by an event or action by the webhook provider (for example, a push to a repository, a Merge Request creation), and pushed to the application via the HTTP requests, namely, Jenkins. The GitLab Jenkins job provisioner creates a webhook in the GitLab repository during the Create release pipeline once the VCS Import Strategy is enabled and the GitLab Integration is completed.</p> <p>The Jenkins setup in EDP uses the GitLab plugin responsible for listening on GitLab webhook Push and Merge Request events.</p> <p>In case of any issues with webhooks, try the following solutions:</p> <ol> <li> <p>Check that the firewalls are configured to accept incoming traffic from the IP address range that is described in the GitLab documentation.</p> </li> <li> <p>Check that GitLab Personal Access Token is correct and has the api scope. If you have used the Project Access Token, make sure that the role is Owner or Maintainer, and it has the api scope.</p> </li> <li> <p>Check that the job has run at least once before using the hook (once an application is created in EDP, the build job should be run automatically in Jenkins).</p> </li> <li> <p>Check that both Push Events, Note Events and Merge Requests Events, Note Events webhooks are created on the GitLab side for each branch (unlike GitHub, GitLab must have separate webhooks for each branch).</p> <ul> <li>Go to the GitLab repository -&gt; Settings -&gt; Webhooks:</li> </ul> <p> Webhooks list </p> </li> <li> <p>Click Edit next to each webhook and check if the event delivery is successful. If the webhook is sent, the Recent Deliveries list becomes available. Click View details.</p> <p> Webhooks settings </p> <ul> <li>The URL payload must be similar to the job URL on Jenkins. For example: <code>https://jenkins-server.com/project/project-name/MAIN-Build-job</code> is for the Push events. <code>https://jenkins-server.com/project/project-name/MAIN-Code-review-job</code> is for the Merge Request events.</li> <li>The content type must be application/json for both events.</li> <li>The \"web_url\" in the Request body must match the repository URL.</li> <li>Project \"web_url\", \"path_with_namespace\", \"homepage\" links must be without .git at the end of the URL.</li> </ul> </li> <li> <p>Verify the Secret token (X-Gitlab-Token). This token comes from the Jenkins job due to the Jenkins GitLab Plugin and is created by our Job Provisioner:</p> <ul> <li>Go to the Jenkins job and select Configure.</li> <li>Select Advanced under the Build Triggers and check the Secret token.</li> </ul> <p>Secret token is optional and can be empty. Nevertheless, if incorrect, it can prevent webhook events.</p> </li> <li> <p>Redeliver events by clicking the Resend Request button and check the Response body.</p> <p>Note</p> <p>Use Postman to debug webhooks. Add all headers to Postman from the webhook Request Headers field and send the payload (Request body) using the appropriate content type.</p> <p>Examples for Push and Merge Request events:</p> <p> Postman push request payload headers Push request build pipeline </p> <p>The response in the Jenkins log:</p> <pre><code>Jan 17, 2022 11:26:34 AM INFO com.dabsquared.gitlabjenkins.webhook.GitLabWebHook getDynamic\nWebHook call ed with url: /project/project-name/MAIN-Build-job\nJan 17, 2022 11:26:34 AM INFO com.dabsquared.gitlabjenkins.trigger.handler.AbstractWebHookTriggerHandler handle\nproject-name/MAIN-Build-job triggered for push.\n</code></pre> <p> Postman merge request payload headers Merge request code review pipeline </p> <p>The response in the Jenkins log:</p> <pre><code>Jan 17, 2022 11:14:58 AM INFO com.dabsquared.gitlabjenkins.webhook.GitLabWebHook getDynamic\nWebHook called with url: /project/project-name/MAIN-Code-review-job\n</code></pre> </li> <li> <p>Check that the repository pushing to Jenkins and the repository(ies) in the pipeline Job are lined up. GitLab Connection must be defined in the job settings.</p> </li> <li> <p>Check that the settings in the Build Triggers for the Build job are as follows:</p> <p> Build triggers build pipeline </p> </li> <li> <p>Check that the settings in the Build Triggers for the Code Review job are as follows:</p> <p> Build triggers code review pipeline </p> </li> <li> <p>Filter through Jenkins log by using Jenkins custom log recorder:</p> <ul> <li>Go to Manage Jenkins -&gt; System Log -&gt; Add new log recorder.</li> <li> <p>The Push and Merge Request events for the GitLab:</p> Logger Log Level com.dabsquared.gitlabjenkins.webhook.GitLabWebHook ALL com.dabsquared.gitlabjenkins.trigger.handler.AbstractWebHookTriggerHandler ALL com.dabsquared.gitlabjenkins.trigger.handler.merge.MergeRequestHookTriggerHandlerImpl ALL com.dabsquared.gitlabjenkins.util.CommitStatusUpdater ALL </li> </ul> </li> </ol>"},{"location":"operator-guide/gitlab-debug-webhooks/#related-articles","title":"Related Articles","text":"<ul> <li>GitLab Webhooks</li> <li>Enable VCS Import Strategy</li> <li>Jenkins integration with GitLab</li> <li>GitLab Integration</li> <li>Manage Jenkins CI Pipeline Job Provision</li> <li>GitLab plugin</li> </ul>"},{"location":"operator-guide/gitlab-integration/","title":"GitLab Integration","text":"<p>Follow the steps below to automatically create and integrate Jenkins GitLab webhooks.</p> <p>Note</p> <p>Before applying the GitLab integration, make sure to enable VCS Import strategy. For details, please refer to the Enable VCS Import Strategy section.</p> <ol> <li> <p>Create a new job provisioner by following the instruction.The job provisioner will create a job suite for an application added to EDP. It will also create webhooks for the project in GitLab using a GitLab token.</p> </li> <li> <p>Create the personal access token in GitLab:</p> <ul> <li>Log in to GitLab.</li> <li>In the top-right corner, click the avatar and select Settings.</li> <li>On the User Settings menu, select Access Tokens.</li> <li>Choose a name and an optional expiry date for the token.</li> <li>In the Scopes block, select the api scope for the token.</li> </ul> <p> Personal access tokens </p> <ul> <li>Click the Create personal access token button.</li> </ul> <p>Note</p> <p>Make sure to save the access token as there will not be any ability to access it once again.</p> <p>It is also possible to create a project access token instead of a personal access token. In this case, the GitLab Jenkins plugin will be able to accept payloads from webhooks for the project only:</p> <ul> <li>Log in to GitLab and navigate to the project.</li> <li>On the User Settings menu, select Access Tokens.</li> <li>Choose a name and an optional expiry date for the token.</li> <li>Choose a role: Owner or Maintainer.</li> <li>In the Scopes block, select the api scope for the token.</li> </ul> <p> Project access tokens </p> <ul> <li>Click the Create project access token button.</li> </ul> </li> <li> <p>Create the Jenkins Credential ID by navigating to Jenkins -&gt; Credentials -&gt; System -&gt; Global Credentials -&gt; Add Credentials:</p> <ul> <li>Select the Secret text kind.</li> <li>Select the Global scope.</li> <li>Secret is the access token that was created earlier.</li> <li>ID is the gitlab-access-token ID.</li> <li>Use the description of the current Credential ID.</li> </ul> <p> Jenkins credential </p> <p>Warning</p> <p>When using the GitLab integration, a webhook is automatically created. After the removal of the application, the webhook stops working but is not deleted. If necessary, it must be deleted manually.</p> <p>Note</p> <p>The next step is necessary if it is needed to see the status of Jenkins Merge Requests builds in the GitLab CI/CD Pipelines section.</p> </li> <li> <p>In order to see the status of Jenkins Merge Requests builds in the GitLab CI/CD Pipelines section, configure the GitLab plugin by navigating to Manage Jenkins -&gt; Configure System and filling in the GitLab plugin settings:</p> <ul> <li>Connection name is gitlab.</li> <li>GitLab host URL is a host URL to GitLab.</li> <li>Use the gitlab-access-token credentials.</li> </ul> <p> GitLab plugin configuration </p> <p>Find below an example of the Merge Requests build statuses in the GitLab CI/CD Pipelines section:</p> <p> GitLab pipelines statuses </p> </li> </ol>"},{"location":"operator-guide/gitlab-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Adjust Jira Integration</li> <li>Enable VCS Import Strategy</li> <li>Jenkins integration with GitLab</li> <li>Manage Jenkins CI Pipeline Job Provision</li> </ul>"},{"location":"operator-guide/gitlabci-integration/","title":"Adjust GitLab CI Tool","text":"<p>EDP allows selecting one of two available CI (Continuous Integration) tools, namely: Jenkins or GitLab. The Jenkins tool is available by default. To use the GitLab CI tool, it is required to make it available first.</p> <p>Follow the steps below to adjust the GitLab CI tool:</p> <ol> <li> <p>In GitLab, add the environment variables to the project.</p> <ul> <li> <p>To add variables, navigate to Settings -&gt; CI/CD -&gt; Expand Variables -&gt; Add Variable:</p> <p> Gitlab ci environment variables </p> </li> </ul> <ul> <li> <p>Apply the necessary variables as they differ in accordance with the cluster OpenShift / Kubernetes, see below:</p> OpenShift Environment Variables Description DOCKER_REGISTRY_URL URL to OpenShift docker registry DOCKER_REGISTRY_PASSWORD Service Account token that has an access to registry DOCKER_REGISTRY_USER user name OPENSHIFT_SA_TOKEN token that can be used to log in to OpenShift <p>Info</p> <p>In order to get access to the Docker registry and OpenShift, use the gitlab-ci ServiceAccount; pay attention that SA description contains the credentials and secrets:</p> <p> Service account </p> Kubernetes Environment Variables Description DOCKER_REGISTRY_URL URL to Amazon ECR AWS_ACCESS_KEY_ID auto IAM user access key AWS_SECRET_ACCESS_KEY auto IAM user secret access key K8S_SA_TOKEN token that can be used to log in to Kubernetes <p>Note</p> <p>To get the access to ECR, it is required to have an auto IAM user that has rights to push/create a repository.</p> </li> </ul> </li> <li> <p>In Admin Console, select the CI tool in the Advanced Settings menu during the codebase creation:</p> <p> Advanced settings </p> <p>Note</p> <p>The selection of the CI tool is available only with the Import strategy.</p> </li> <li> <p>As soon as the codebase is provisioned, the .gitlab-ci.yml file will be created in the repository that describes the pipeline's stages and logic:</p> <p> .gitlab-ci.yml file presented in repository </p> </li> </ol>"},{"location":"operator-guide/import-strategy/","title":"Enable VCS Import Strategy","text":"<p>Note</p> <p>Enabling the VCS Import strategy is a prerequisite to integrate EDP with GitLab or GitHub.</p> Tekton CI toolJenkins CI tool <p>In order to use the Import strategy, it is required to add a Secret with SSH key, and GitServer Custom Resource by taking the steps below.</p> <ol> <li> <p>Generate an SSH key pair and add a public key to GitLab or GitHub account.</p> <pre><code>ssh-keygen -t ed25519 -C \"email@example.com\"\n</code></pre> </li> <li> <p>Generate access token for GitLab or GitHub account with read/write access to the API.</p> </li> <li> <p>Create a <code>Secret</code> in the <code>edp-project</code> namespace for the Git account with the id_rsa, username, and token fields.</p> <p>Take the following template as an example (use github instead of gitlab for GitHub):</p> <pre><code>kubectl create secret generic gitlab -n &lt;edp-project&gt; \\\n--from-file=id_rsa=id_rsa \\\n--from-literal=username=user@example.com \\\n--from-literal=token=your_gitlab_access_token\n</code></pre> </li> <li> <p>Update <code>gitProvider</code> value in <code>global</code> section of edp-install values.yaml to enable Gitlab/Github integration:</p> View: values.yaml <pre><code>global:\n# -- Can be gerrit, github or gitlab. By default: gerrit\ngitProvider: &lt;git_provider_name&gt;\n</code></pre> </li> <li> <p>Upgrade edp-install release: <code>helm upgrade edp epamedp/edp-install --values values.yaml</code>.</p> </li> </ol> <p>In order to use the Import strategy, it is required to add a Secret with SSH key, GitServer Custom Resource, and Jenkins credentials by taking the steps below.</p> <ol> <li> <p>Generate an SSH key pair and add a public key to GitLab or GitHub account.</p> <pre><code>ssh-keygen -t ed25519 -C \"email@example.com\"\n</code></pre> </li> <li> <p>Generate access token for GitLab or GitHub account with read/write access to the API.</p> </li> <li> <p>Add a Git Server via Headlamp, or create <code>GitServer</code> Custom Resource in the project namespace with the gitHost, gitUser, gitProvider, httpsPort, sshPort and nameSshKeySecret fields. The gitProvider field can be either gitlab, github, or gerrit.</p> <p>Take the following template as an example:</p> <pre><code>apiVersion: v2.edp.epam.com/v1\nkind: GitServer\nmetadata:\nname: &lt;git-server-name&gt;\nnamespace: &lt;edp-project&gt;\nspec:\ngitHost: git.sample.com\ngitUser: git\ngitProvider: gitlab\nhttpsPort: 443\nnameSshKeySecret: gitlab\nsshPort: 22\n</code></pre> <p>Note</p> <p>The value of the nameSshKeySecret property is the name of the Secret that is indicated in the first step above.</p> </li> <li> <p>Create the <code>Jenkinsserviceaccount</code> Custom Resource with the credentials field that corresponds to the nameSshKeySecret property above.</p> <pre><code>apiVersion: v2.edp.epam.com/v1\nkind: JenkinsServiceAccount\nmetadata:\nname: gitlab\nnamespace: &lt;edp-project&gt;\nspec:\ncredentials: gitlab\nownerName: ''\ntype: ssh\n</code></pre> <p>Double-check that the credentials are created in Jenkins correctly. Navigate to Jenkins -&gt; Credentials -&gt; System -&gt; Global Credentials -&gt; Add Credentials:</p> <p> Jenkins credentials </p> </li> <li> <p>The next step is to integrate Jenkins with GitHub or GitLab.</p> </li> </ol>"},{"location":"operator-guide/import-strategy/#related-articles","title":"Related Articles","text":"<ul> <li>Add Git Server</li> <li>Add Application</li> <li>GitHub Integration</li> <li>GitLab Integration</li> </ul>"},{"location":"operator-guide/install-argocd/","title":"Install Argo CD","text":"<p>Inspect the prerequisites and the main steps to perform for enabling Argo CD in EDP.</p>"},{"location":"operator-guide/install-argocd/#prerequisites","title":"Prerequisites","text":"<p>The following tools must be installed:</p> <ul> <li>Keycloak</li> <li>EDP</li> <li>Kubectl version 1.23.0</li> <li>Helm version 3.10.0</li> </ul>"},{"location":"operator-guide/install-argocd/#installation","title":"Installation","text":"<p>Argo CD enablement for EDP consists of two major steps:</p> <ul> <li>Argo CD integration with EDP (SSO enablement, codebase onboarding, etc.)</li> <li>Argo CD installation</li> </ul> <p>Info</p> <p>It is also possible to install Argo CD using the Helmfile. For details, please refer to the Install via Helmfile page.</p>"},{"location":"operator-guide/install-argocd/#integrate-with-edp","title":"Integrate With EDP","text":"<p>To enable Argo CD integration, ensure that the <code>argocd.enabled</code> flag values.yaml is set to <code>true</code></p>"},{"location":"operator-guide/install-argocd/#install-with-helm","title":"Install With Helm","text":"<p>Argo CD can be installed in several ways, please follow the official documentation for more details.</p> <p>Follow the steps below to install Argo CD using Helm:</p> <p>For the OpenShift users:</p> <p>When using the OpenShift platform, apply the <code>SecurityContextConstraints</code> resource. Change the namespace in the <code>users</code> section if required.</p> <p> View: argocd-scc.yaml <p><pre><code>allowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\napiVersion: security.openshift.io/v1\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 99\nmax: 65543\ngroups: []\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: argo-redis-ha\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nseccompProfiles:\n- '*'\nusers:\n- system:serviceaccount:argocd:argo-redis-ha\n- system:serviceaccount:argocd:argo-redis-ha-haproxy\n- system:serviceaccount:argocd:argocd-notifications-controller\n- system:serviceaccount:argocd:argo-argocd-repo-server\n- system:serviceaccount:argocd:argocd-server\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </p> <ol> <li> <p>Check out the values.yaml file sample of the Argo CD customization, which is based on the <code>HA mode without autoscaling</code>:</p> View: kubernetes-values.yaml <pre><code>redis-ha:\nenabled: true\n\ncontroller:\nenableStatefulSet: true\n\nserver:\nreplicas: 2\nextraArgs:\n- \"--insecure\"\nenv:\n- name: ARGOCD_API_SERVER_REPLICAS\nvalue: '2'\ningress:\nenabled: true\nhosts:\n- \"argocd.&lt;Values.global.dnsWildCard&gt;\"\nconfig:\n# required when SSO is enabled\nurl: \"https://argocd.&lt;.Values.global.dnsWildCard&gt;\"\napplication.instanceLabelKey: argocd.argoproj.io/instance-edp\noidc.config: |\nname: Keycloak\nissuer: https://&lt;.Values.global.keycloakEndpoint&gt;/auth/realms/&lt;.Values.global.edpName&gt;-main\nclientID: argocd\nclientSecret: $oidc.keycloak.clientSecret\nrequestedScopes:\n- openid\n- profile\n- email\n- groups\nrbacConfig:\n# users may be still be able to login,\n# but will see no apps, projects, etc...\npolicy.default: ''\nscopes: '[groups]'\npolicy.csv: |\n# default global admins\ng, ArgoCDAdmins, role:admin\n\nconfigs:\nparams:\napplication.namespaces: &lt;.Values.global.edpName&gt;\n\nrepoServer:\nreplicas: 2\n\n# we use Keycloak so no DEX is required\ndex:\nenabled: false\n\n# Disabled for multitenancy env with single instance deployment\napplicationSet:\nenabled: false\n</code></pre> View: openshift-values.yaml <pre><code>redis-ha:\nenabled: true\n\ncontroller:\nenableStatefulSet: true\n\nserver:\nreplicas: 2\nextraArgs:\n- \"--insecure\"\nenv:\n- name: ARGOCD_API_SERVER_REPLICAS\nvalue: '2'\nroute:\nenabled: true\nhostname: \"argocd.&lt;.Values.global.dnsWildCard&gt;\"\ntermination_type: edge\ntermination_policy: Redirect\nconfig:\n# required when SSO is enabled\nurl: \"https://argocd.&lt;.Values.global.dnsWildCard&gt;\"\napplication.instanceLabelKey: argocd.argoproj.io/instance-edp\noidc.config: |\nname: Keycloak\nissuer: https://&lt;.Values.global.keycloakEndpoint&gt;/auth/realms/&lt;.Values.global.edpName&gt;-main\nclientID: argocd\nclientSecret: $oidc.keycloak.clientSecret\nrequestedScopes:\n- openid\n- profile\n- email\n- groups\nrbacConfig:\n# users may be still be able to login,\n# but will see no apps, projects, etc...\npolicy.default: ''\nscopes: '[groups]'\npolicy.csv: |\n# default global admins\ng, ArgoCDAdmins, role:admin\n\nconfigs:\nparams:\napplication.namespaces: &lt;.Values.global.edpName&gt;\n\nrepoServer:\nreplicas: 2\n\n# we use Keycloak so no DEX is required\ndex:\nenabled: false\n\n# Disabled for multitenancy env with single instance deployment\napplicationSet:\nenabled: false\n</code></pre> <p>Populate Argo CD values with the values from the EDP values.yaml:</p> <ul> <li>&lt;.Values.global.dnsWildCard&gt; is the EDP DNS WildCard.</li> <li>&lt;.Values.global.keycloakEndpoint&gt; is the Keycloak Hostname.</li> <li>&lt;.Values.global.edpName&gt; is the EDP name.</li> </ul> </li> <li> <p>Run the installation:</p> <pre><code>kubectl create ns argocd\nhelm repo add argo https://argoproj.github.io/argo-helm\nhelm install argo --version 5.19.8 argo/argo-cd -f values.yaml -n argocd\n</code></pre> </li> <li> <p>Update the <code>argocd-secret</code> secret in the <code>argocd</code> namespace by providing the correct Keycloak client secret (<code>oidc.keycloak.clientSecret</code>)    with the value from the <code>keycloak-client-argocd-secret</code> secret in the EDP namespace. Then restart the deployment:</p> <pre><code>ARGOCD_CLIENT=$(kubectl -n &lt;EDP_NAMESPACE&gt; get secret keycloak-client-argocd-secret  -o jsonpath='{.data.clientSecret}')\nkubectl -n argocd patch secret argocd-secret -p=\"{\\\"data\\\":{\\\"oidc.keycloak.clientSecret\\\": \\\"${ARGOCD_CLIENT}\\\"}}\" -v=1\nkubectl -n argocd rollout restart deployment argo-argocd-server\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-argocd/#related-articles","title":"Related Articles","text":"<ul> <li>Argo CD Integration</li> <li>Install via Helmfile</li> </ul>"},{"location":"operator-guide/install-defectdojo/","title":"Install DefectDojo","text":"<p>Inspect the main steps to perform for installing DefectDojo via Helm Chart.</p> <p>Info</p> <p>It is also possible to install DefectDojo using the Helmfile. For details, please refer to the Install via Helmfile page.</p>"},{"location":"operator-guide/install-defectdojo/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.23.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.10.2 is installed. Please refer to the Helm page on GitHub for details.</li> </ul>"},{"location":"operator-guide/install-defectdojo/#installation","title":"Installation","text":"<p>Info</p> <p>Please refer to the DefectDojo Helm Chart and Deploy DefectDojo into the Kubernetes cluster sections for details.</p> <p>To install DefectDojo, follow the steps below:</p> <ol> <li> <p>Check that a security namespace is created. If not, run the following command to create it:</p> <pre><code>kubectl create namespace defectdojo\n</code></pre> <p>For the OpenShift users:</p> <p>When using the OpenShift platform, install the <code>SecurityContextConstraints</code> resource. In case of using a custom namespace for <code>defectdojo</code>, change the namespace in the <code>users</code> section.</p> <p> View: defectdojo-scc.yaml <p><pre><code>allowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\napiVersion: security.openshift.io/v1\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 999\nmax: 65543\ngroups: []\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: defectdojo\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:defectdojo:defectdojo\n- system:serviceaccount:defectdojo:defectdojo-rabbitmq\n- system:serviceaccount:defectdojo:default\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </p> <li> <p>Add a chart repository:</p> <pre><code>helm repo add defectdojo 'https://raw.githubusercontent.com/DefectDojo/django-DefectDojo/helm-charts'\nhelm repo update\n</code></pre> </li> <li> <p>Create PostgreSQL admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo-postgresql-specific \\\n--from-literal=postgresql-password=&lt;postgresql_password&gt; \\\n--from-literal=postgresql-postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> <p>Note</p> <p>The <code>postgresql_password</code> and <code>postgresql_postgres_password</code> passwords must be 16 characters long.</p> </li> <li> <p>Create Rabbitmq admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo-rabbitmq-specific \\\n--from-literal=rabbitmq-password=&lt;rabbitmq_password&gt; \\\n--from-literal=rabbitmq-erlang-cookie=&lt;rabbitmq_erlang_cookie&gt;\n</code></pre> <p>Note</p> <p>The <code>rabbitmq_password</code> password must be 10 characters long.</p> <p>The <code>rabbitmq_erlang_cookie</code> password must be 32 characters long.</p> </li> <li> <p>Create DefectDojo admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo \\\n--from-literal=DD_ADMIN_PASSWORD=&lt;dd_admin_password&gt; \\\n--from-literal=DD_SECRET_KEY=&lt;dd_secret_key&gt; \\\n--from-literal=DD_CREDENTIAL_AES_256_KEY=&lt;dd_credential_aes_256_key&gt; \\\n--from-literal=METRICS_HTTP_AUTH_PASSWORD=&lt;metric_http_auth_password&gt;\n</code></pre> <p>Note</p> <p>The <code>dd_admin_password</code> password must be 22 characters long.</p> <p>The <code>dd_secret_key</code> password must be 128 characters long.</p> <p>The <code>dd_credential_aes_256_key</code> password must be 128 characters long.</p> <p>The <code>metric_http_auth_password</code> password must be 32 characters long.</p> </li> <li> <p>Install DefectDojo v.2.17.0 using defectdojo/defectdojo Helm chart v.1.6.47:</p> <pre><code>helm upgrade --install \\\ndefectdojo \\\n--version 1.6.47 \\\ndefectdojo/defectdojo \\\n--namespace defectdojo \\\n--values values.yaml\n</code></pre> <p>Check out the values.yaml file sample of the DefectDojo customization:</p> View: values.yaml <pre><code>tag: 2.17.0\nfullnameOverride: defectdojo\nhost: defectdojo.&lt;ROOT_DOMAIN&gt;\nsite_url: https://defectdojo.&lt;ROOT_DOMAIN&gt;\nalternativeHosts:\n- defectdojo-django.defectdojo\n\ninitializer:\n# should be false after initial installation was performed\nrun: true\ndjango:\ningress:\nenabled: true # change to 'false' for OpenShift\nactivateTLS: false\nuwsgi:\nlivenessProbe:\n# Enable liveness checks on uwsgi container. Those values are use on nginx readiness checks as well.\n# default value is 120, so in our case 20 is just fine\ninitialDelaySeconds: 20\n</code></pre> </li> <li> <p>For the OpenShift platform, install a Route:</p> View: defectdojo-route.yaml <pre><code>kind: Route\napiVersion: route.openshift.io/v1\nmetadata:\nname: defectdojo\nnamespace: defectdojo\nspec:\nhost: defectdojo.&lt;ROOT_DOMAIN&gt;\npath: /\ntls:\ninsecureEdgeTerminationPolicy: Redirect\ntermination: edge\nto:\nkind: Service\nname: defectdojo-django\nport:\ntargetPort: http\nwildcardPolicy: None\n</code></pre> </li>"},{"location":"operator-guide/install-defectdojo/#configuration","title":"Configuration","text":"<p>To prepare DefectDojo for integration with EDP, follow the steps below:</p> <ol> <li> <p>Get credentials of the DefectDojo admin:</p> <pre><code>echo \"DefectDojo admin password: $(kubectl \\\nget secret defectdojo \\\n--namespace=defectdojo \\\n--output jsonpath='{.data.DD_ADMIN_PASSWORD}' \\\n| base64 --decode)\"\n</code></pre> </li> <li> <p>Get a token of the DefectDojo user:</p> <ul> <li>Login to the DefectDojo UI using the credentials.</li> </ul> <ul> <li>Go to the API v2 key (token).</li> </ul> <ul> <li>Copy the API key.</li> </ul> </li> <li> <p>Create a DefectDojo secret in your edp namespace:</p> <pre><code>kubectl -n &lt;edp_namespace&gt; create secret generic defectdojo-ciuser-token \\\n--from-literal=token=&lt;dd_token_of_dd_user&gt; \\\n--from-literal=url=\"&lt;defectdojo_url&gt;\"\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-defectdojo/#related-articles","title":"Related Articles","text":"<ul> <li>Install via Helmfile</li> </ul>"},{"location":"operator-guide/install-edp/","title":"Install EDP","text":"<p>Inspect the main steps to install EPAM Delivery Platform. Please check the Prerequisites Overview page before starting the installation. There are two ways to deploy EPAM Delivery Platform: using Helm (see below) and using Helmfile.</p> <p>Note</p> <p>The installation process below is given for a Kubernetes cluster. The steps that differ for an OpenShift cluster are indicated in the notes.</p> <p>Note</p> <p>\u2039edp-project\u203a is the name of the EDP tenant in all the following steps.</p> <ol> <li> <p>Create an \u2039edp-project\u203a namespace or a Kiosk space depending on whether Kiosk is used or not.</p> <ul> <li> <p>Without Kiosk, create a namespace:</p> <pre><code>kubectl create namespace &lt;edp-project&gt;\n</code></pre> <p>Note</p> <p>For an OpenShift cluster, run the <code>oc</code> command instead of the <code>kubectl</code> one.</p> </li> </ul> <ul> <li> <p>With Kiosk, create a relevant space:</p> <pre><code>apiVersion: tenancy.kiosk.sh/v1alpha1\nkind: Space\nmetadata:\nname: &lt;edp-project&gt;\nspec:\naccount: &lt;edp-project&gt;-admin\n</code></pre> </li> </ul> <p>Note</p> <p>Kiosk is mandatory for EDP v.2.8.x. It is not implemented for the previous versions, and is optional for EDP since v.2.9.x.</p> </li> <li> <p>For EDP, it is required to have Keycloak access to perform the integration. Create a secret with user and password provisioned in the step 2 of the Keycloak Configuration section.</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic keycloak \\\n--from-literal=username=&lt;username&gt; \\\n--from-literal=password=&lt;password&gt;\n</code></pre> </li> <li> <p>Add the Helm EPAMEDP Charts for local client.</p> <pre><code>helm repo add epamedp https://epam.github.io/edp-helm-charts/stable\n</code></pre> </li> <li> <p>Choose the required Helm chart version:</p> <pre><code>helm search repo epamedp/edp-install\nNAME                    CHART VERSION   APP VERSION     DESCRIPTION\nepamedp/edp-install     3.1.0           3.1.0           A Helm chart for EDP Install\n</code></pre> <p>Note</p> <p>It is highly recommended to use the latest released version.</p> </li> <li> <p>By default, EDP uses Tekton as a CI tool (see more in the Prerequisites Overview page). To use Jenkins instead of Tekton, redefine the following parameters in the values.yaml file:</p> View: values.yaml <pre><code>...\nedp-tekton:\nenabled: false\n...\njenkins-operator:\nenabled: true\n...\nadmin-console-operator:\nenabled: true\n...\n</code></pre> </li> <li> <p>EDP can be integrated with the following version control systems:</p> <ul> <li>Gerrit (by default)</li> <li>GitHub</li> <li>GitLab</li> </ul> <p>This integration implies in what system the development of the application will be or is already being carried out. The <code>global.gitProvider</code> flag in the edp-install controls this integration:</p> Gerrit (by default)GitHubGitLab values.yaml<pre><code>...\nglobal:\ngitProvider: gerrit\n...\n</code></pre> values.yaml<pre><code>...\nglobal:\ngitProvider: github\n...\n</code></pre> values.yaml<pre><code>...\nglobal:\ngitProvider: gitlab\n...\n</code></pre> <p>By default, the internal Gerrit server is deployed as a result of EDP deployment. For more details on how to integrate EDP with GitLab or GitHub instead of Gerrit, please refer to the Enable VCS Import Strategy article.</p> </li> <li> <p>Check the parameters in the EDP installation chart. For details, please refer to the values.yaml file.</p> </li> <li> <p>Install EDP in the \u2039edp-project\u203a namespace with the Helm tool.</p> <pre><code>helm install edp epamedp/edp-install --wait --timeout=900s \\\n--version &lt;edp_version&gt; \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>See the details on the parameters below:</p> Tekton CI toolJenkins CI tool Example values.yaml file<pre><code>global:\n# -- namespace or a project name (in case of OpenShift)\nedpName: &lt;edp-project&gt;\n# -- platform type that can be \"kubernetes\" or \"openshift\"\nplatform: \"kubernetes\"\n# DNS wildcard for routing in the Kubernetes cluster;\ndnsWildCard: &lt;DNS_wilcdard&gt;\n# -- Administrators of your tenant\nadmins:\n- \"stub_user_one@example.com\"\n# -- Developers of your tenant\ndevelopers:\n- \"stub_user_one@example.com\"\n- \"stub_user_two@example.com\"\n# Kubernetes API server;\nwebConsole:\nurl: &lt;kubeconfig.clusters.cluster.server&gt;\n# -- Can be gerrit, github or gitlab. By default: gerrit\ngitProvider: gerrit\n# -- Gerrit SSH node port\ngerritSSHPort: \"22\"\n\n# AWS Region, e.g. \"eu-central-1\"\nawsRegion:\n\nargocd:\n# -- Enable ArgoCD integration\nenabled: true\n# -- ArgoCD URL in format schema://URI\n# @default -- `\"\"` (defaults to https://argocd.{{ .Values.global.dnsWildCard }})\nurl: \"\"\n\n# Kaniko configuration section\nkaniko:\n# -- AWS IAM role to be used for kaniko pod service account (IRSA). Format: arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/&lt;AWS_IAM_ROLE_NAME&gt;\nroleArn:\n\ndockerRegistry:\n# -- Docker Registry endpoint\nurl: \"&lt;AWS_ACCOUNT_ID&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com\"\n\nkeycloak-operator:\nkeycloak:\n# URL to Keycloak;\nurl: &lt;keycloak_endpoint&gt;\n\nperf-operator:\nenabled: false\n</code></pre> Example values.yaml file<pre><code>global:\n# -- namespace or a project name (in case of OpenShift)\nedpName: &lt;edp-project&gt;\n# -- platform type that can be \"kubernetes\" or \"openshift\"\nplatform: \"kubernetes\"\n# DNS wildcard for routing in the Kubernetes cluster;\ndnsWildCard: &lt;DNS_wilcdard&gt;\n# -- Administrators of your tenant\nadmins:\n- \"stub_user_one@example.com\"\n# -- Developers of your tenant\ndevelopers:\n- \"stub_user_one@example.com\"\n- \"stub_user_two@example.com\"\n# Kubernetes API server;\nwebConsole:\nurl: &lt;kubeconfig.clusters.cluster.server&gt;\n# -- Can be gerrit, github or gitlab. By default: gerrit\ngitProvider: gerrit\n# -- Gerrit SSH node port\ngerritSSHPort: \"22\"\n\n# AWS Region, e.g. \"eu-central-1\"\nawsRegion:\n\nargocd:\n# -- Enable ArgoCD integration\nenabled: false\n\n# Kaniko configuration section\nkaniko:\n# -- AWS IAM role to be used for kaniko pod service account (IRSA). Format: arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWS_IAM_ROLE_NAME&gt;\nroleArn:\n\ndockerRegistry:\n# -- Docker Registry endpoint\nurl: \"&lt;AWS_ACCOUNT_ID&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com\"\n\nkeycloak-operator:\nkeycloak:\n# URL to Keycloak;\nurl: &lt;keycloak_endpoint&gt;\n\njenkins-operator:\nenabled: true\n\nadmin-console-operator:\nenabled: true\n\nedp-tekton:\nenabled: false\n\nperf-operator:\nenabled: false\n</code></pre> <p>Note</p> <p>Set <code>global.platform=openshift</code> while deploying EDP in OpenShift.</p> <p>Info</p> <p>The full installation with integration between tools will take at least 10 minutes.</p> </li> </ol>"},{"location":"operator-guide/install-edp/#related-articles","title":"Related Articles","text":"<ul> <li>Enable VCS Import Strategy</li> <li>GitHub Integration</li> <li>GitLab Integration</li> <li>Set Up Kubernetes</li> <li>Set Up OpenShift</li> <li>EDP Installation Prerequisites Overview</li> </ul>"},{"location":"operator-guide/install-external-secrets-operator/","title":"Install External Secrets Operator","text":"<p>Inspect the prerequisites and the main steps to perform for enabling External Secrets Operator in EDP.</p>"},{"location":"operator-guide/install-external-secrets-operator/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.23.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.10.0+ is installed. Please refer to the Helm page on GitHub for details.</li> </ul>"},{"location":"operator-guide/install-external-secrets-operator/#installation","title":"Installation","text":"<p>To install External Secrets Operator with Helm, run the following commands:</p> <pre><code>helm repo add external-secrets https://charts.external-secrets.io\n\nhelm install external-secrets \\\nexternal-secrets/external-secrets \\\n--version 0.6.1 \\\n-n external-secrets \\\n--create-namespace\n</code></pre> <p>Info</p> <p>It is also possible to install External Secrets Operator using the Helmfile or Operator Lifecycle Manager (OLM).</p>"},{"location":"operator-guide/install-external-secrets-operator/#related-articles","title":"Related Articles","text":"<ul> <li>External Secrets Operator Integration</li> </ul>"},{"location":"operator-guide/install-ingress-nginx/","title":"Install NGINX Ingress Controller","text":"<p>Inspect the prerequisites and the main steps to perform for installing Install NGINX Ingress Controller on Kubernetes.</p>"},{"location":"operator-guide/install-ingress-nginx/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.23.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.10.2 is installed. Please refer to the Helm page on GitHub for details.</li> </ul>"},{"location":"operator-guide/install-ingress-nginx/#installation","title":"Installation","text":"<p>Info</p> <p>It is also possible to install NGINX Ingress Controller using the Helmfile. For details, please refer to the Install via Helmfile page.</p> <p>To install the ingress-nginx chart, follow the steps below:</p> <ol> <li> <p>Create an ingress-nginx namespace:</p> <pre><code>kubectl create namespace ingress-nginx\n</code></pre> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo update\n</code></pre> </li> <li> <p>Install the ingress-nginx chart:</p> <pre><code>helm install ingress ingress-nginx/ingress-nginx \\\n--version 4.4.0 \\\n--values values.yaml \\\n--namespace ingress-nginx\n</code></pre> <p>Check out the values.yaml file sample of the ingress-nginx chart customization:</p> </li> </ol> View: values.yaml <pre><code>controller:\naddHeaders:\nX-Content-Type-Options: nosniff\nX-Frame-Options: SAMEORIGIN\nresources:\nlimits:\nmemory: \"256Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"128M\"\nconfig:\nssl-redirect: 'true'\nclient-header-buffer-size: '64k'\nhttp2-max-field-size: '64k'\nhttp2-max-header-size: '64k'\nlarge-client-header-buffers: '4 64k'\nupstream-keepalive-timeout: '120'\nkeep-alive: '10'\nuse-forwarded-headers: 'true'\nproxy-real-ip-cidr: '172.32.0.0/16'\nproxy-buffer-size: '8k'\n\n# To watch Ingress objects without the ingressClassName field set parameter value to true.\n# https://kubernetes.github.io/ingress-nginx/#i-have-only-one-ingress-controller-in-my-cluster-what-should-i-do\nwatchIngressWithoutClass: true\n\nservice:\ntype: NodePort\nnodePorts:\nhttp: 32080\nhttps: 32443\nupdateStrategy:\nrollingUpdate:\nmaxUnavailable: 1\ntype: RollingUpdate\nmetrics:\nenabled: true\ndefaultBackend:\nenabled: true\nserviceAccount:\ncreate: true\nname: nginx-ingress-service-account\n</code></pre> <p>Warning</p> <p>Align value controller.config.proxy-real-ip-cidr with AWS VPC CIDR.</p>"},{"location":"operator-guide/install-keycloak/","title":"Install Keycloak","text":"<p>Inspect the prerequisites and the main steps to perform for installing Keycloak.</p> <p>Info</p> <p>The installation process below is given for a Kubernetes cluster. The steps that differ for an OpenShift cluster are indicated in the warnings blocks.</p>"},{"location":"operator-guide/install-keycloak/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.23.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.10.0+ is installed. Please refer to the Helm page on GitHub for details.</li> </ul> <p>Info</p> <p>EDP team is using a Keycloakx helm chart from the codecentric repository, but other repositories can be used as well (e.g. Bitnami). Before installing Keycloak, it is necessary to install a PostgreSQL database.</p> <p>Info</p> <p>It is also possible to install Keycloak using the Helmfile. For details, please refer to the Install via Helmfile page.</p>"},{"location":"operator-guide/install-keycloak/#postgresql-installation","title":"PostgreSQL Installation","text":"<p>To install PostgreSQL, follow the steps below:</p> <ol> <li> <p>Check that a security namespace is created. If not, run the following command to create it:</p> <pre><code>kubectl create namespace security\n</code></pre> <p>Warning</p> <p>On the OpenShift platform, apply the <code>SecurityContextConstraints</code> resource. Change the namespace in the <code>users</code> section if required.</p> View: keycloak-scc.yaml <pre><code>allowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\napiVersion: security.openshift.io/v1\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 999\nmax: 65543\ngroups: []\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: keycloak\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:security:keycloakx\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> View: postgresql-keycloak-scc.yaml <pre><code>allowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\napiVersion: security.openshift.io/v1\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 999\nmax: 65543\ngroups: []\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: postgresql-keycloak\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:security:default\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </li> <li> <p>Create PostgreSQL admin secret:</p> <pre><code>kubectl -n security create secret generic keycloak-postgresql \\\n--from-literal=password=&lt;postgresql_password&gt; \\\n--from-literal=postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> </li> <li> <p>Add a helm chart repository:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Install PostgreSQL v.15.1.0 using bitnami/postgresql Helm chart v.12.1.3:</p> <p>Info</p> <p>The PostgreSQL can be deployed in production ready mode. For example, it may include multiple replicas, persistent storage, autoscaling, and monitoring. For details, please refer to the official Chart documentation.</p> <pre><code>helm install postgresql bitnami/postgresql \\\n--version 12.1.3 \\\n--values values.yaml \\\n--namespace security\n</code></pre> <p>Check out the values.yaml file sample of the PostgreSQL customization:</p> View: values.yaml <pre><code># PostgreSQL read only replica parameters\nreadReplicas:\n# Number of PostgreSQL read only replicas\nreplicaCount: 1\n\nimage:\ntag: 15.1.0-debian-11-r7\n\nglobal:\npostgresql:\nauth:\nusername: admin\nexistingSecret: keycloak-postgresql\ndatabase: keycloak\n\nprimary:\npersistence:\nenabled: true\nsize: 3Gi\n# If the StorageClass with reclaimPolicy: Retain is used, install an additional StorageClass before installing PostgreSQL\n# (the code is given below).\n# If the default StorageClass will be used - change \"gp2-retain\" to \"gp2\"\nstorageClass: \"gp2-retain\"\n</code></pre> Install an additional StorageClass (optional) <p>If the PostgreSQL installation uses a StorageClass with reclaimPolicy: Retain, install additional StorageClass storageclass.yaml.</p> gp2gp3 storageclass.yaml<pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp2-retain\nprovisioner: kubernetes.io/aws-ebs\nparameters:\nfsType: ext4\ntype: gp2\nreclaimPolicy: Retain\nvolumeBindingMode: WaitForFirstConsumer\n</code></pre> storageclass.yaml<pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp3-retain\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Retain\nvolumeBindingMode: WaitForFirstConsumer\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-keycloak/#keycloak-installation","title":"Keycloak Installation","text":"<p>To install Keycloak, follow the steps below:</p> <ol> <li> <p>Use <code>security</code> namespace from the PostgreSQL installation.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add codecentric https://codecentric.github.io/helm-charts\nhelm repo update\n</code></pre> </li> <li> <p>Create Keycloak admin secret:</p> <pre><code>kubectl -n security create secret generic keycloak-admin-creds \\\n--from-literal=username=&lt;keycloak_admin_username&gt; \\\n--from-literal=password=&lt;keycloak_admin_password&gt;\n</code></pre> </li> <li> <p>Install Keycloak 20.0.1 using codecentric/keycloakx Helm chart:</p> <p>Info</p> <p>Keycloak can be deployed in production ready mode. For example, it may include multiple replicas, persistent storage, autoscaling, and monitoring. For details, please refer to the official Chart documentation.</p> <pre><code>helm install keycloakx codecentric/keycloakx \\\n--version 1.7.0 \\\n--values values.yaml \\\n--namespace security\n</code></pre> <p>Check out the values.yaml file sample of the Keycloak customization:</p> View: values.yaml <pre><code>replicas: 1\n\n# Deploy the latest verion\nimage:\ntag: \"20.0.1\"\n\n# start: create OpenShift realm which is required by EDP\nextraInitContainers: |\n- name: realm-provider\nimage: busybox\nimagePullPolicy: IfNotPresent\ncommand:\n- sh\nargs:\n- -c\n- |\necho '{\"realm\": \"openshift\",\"enabled\": true}' &gt; /opt/keycloak/data/import/openshift.json\nvolumeMounts:\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumeMounts: |\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumes: |\n- name: realm\nemptyDir: {}\n\ncommand:\n- \"/opt/keycloak/bin/kc.sh\"\n- \"--verbose\"\n- \"start\"\n- \"--auto-build\"\n- \"--http-enabled=true\"\n- \"--http-port=8080\"\n- \"--hostname-strict=false\"\n- \"--hostname-strict-https=false\"\n- \"--spi-events-listener-jboss-logging-success-level=info\"\n- \"--spi-events-listener-jboss-logging-error-level=warn\"\n- \"--import-realm\"\n\nextraEnv: |\n- name: KC_PROXY\nvalue: \"passthrough\"\n- name: KEYCLOAK_ADMIN\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: username\n- name: KEYCLOAK_ADMIN_PASSWORD\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: password\n- name: JAVA_OPTS_APPEND\nvalue: &gt;-\n-XX:+UseContainerSupport\n-XX:MaxRAMPercentage=50.0\n-Djava.awt.headless=true\n-Djgroups.dns.query={{ include \"keycloak.fullname\" . }}-headless\n\n# This block should be uncommented if you install Keycloak on Kubernetes\ningress:\nenabled: true\nannotations:\nkubernetes.io/ingress.class: nginx\ningress.kubernetes.io/affinity: cookie\nrules:\n- host: keycloak.&lt;ROOT_DOMAIN&gt;\npaths:\n- path: '{{ tpl .Values.http.relativePath $ | trimSuffix \"/\" }}/'\npathType: Prefix\n\n# This block should be uncommented if you set Keycloak to OpenShift and change the host field\n# route:\n#   enabled: false\n#   # Path for the Route\n#   path: '/'\n#   # Host name for the Route\n#   host: \"keycloak.&lt;ROOT_DOMAIN&gt;\"\n#   # TLS configuration\n#   tls:\n#     enabled: true\n\nresources:\nlimits:\nmemory: \"2048Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"512Mi\"\n\n# Check database readiness at startup\ndbchecker:\nenabled: true\n\ndatabase:\nvendor: postgres\nexistingSecret: keycloak-postgresql\nhostname: postgresql\nport: 5432\nusername: admin\ndatabase: keycloak\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-keycloak/#configuration","title":"Configuration","text":"<p>To prepare Keycloak for integration with EDP, follow the steps below:</p> <ol> <li> <p>Ensure that the <code>openshift</code> realm is created.</p> </li> <li> <p>Create the <code>edp_&lt;EDP_PROJECT&gt;</code> user and set the password in the <code>Master</code> realm.</p> <p>Note</p> <p>This user should be used by EDP to access Keycloak. Please refer to the Install EDP and Install EDP via Helmfile sections for details.</p> </li> <li> <p>In the <code>Role Mapping</code> tab, assign the proper roles to the user:</p> <ul> <li> <p>Realm Roles:</p> <ul> <li>create-realm,</li> </ul> <ul> <li>offline_access,</li> </ul> <ul> <li>uma_authorization</li> </ul> </li> </ul> <ul> <li> <p>Client Roles <code>openshift-realm</code>:</p> <ul> <li>impersonation,</li> </ul> <ul> <li>manage-authorization,</li> </ul> <ul> <li>manage-clients,</li> </ul> <ul> <li>manage-users</li> </ul> </li> </ul> <p> Role mappings </p> </li> </ol>"},{"location":"operator-guide/install-keycloak/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP with values file</li> <li>Install EDP by one command</li> <li>Install EDP via Helmfile</li> </ul>"},{"location":"operator-guide/install-kiosk/","title":"Set Up Kiosk","text":"<p>Kiosk is a multi-tenancy extension for managing tenants and namespaces in a shared Kubernetes cluster. Within EDP, Kiosk is used to separate resources and enables the following options (see more details):</p> <ul> <li>Access to the EDP tenants in a Kubernetes cluster;</li> </ul> <ul> <li>Multi-tenancy access at the service account level for application deploy.</li> </ul> <p>Inspect the main steps to set up Kiosk for the proceeding EDP installation.</p> <p>Note</p> <p>Kiosk deploy is mandatory for EDP v.2.8.. In earlier versions, Kiosk is not implemented. Since EDP v.2.9.0, integration with Kiosk is an optional feature. You may not want to use it, so just skip those steps and disable in Helm parameters during EDP deploy.</p> <pre><code># global.kioskEnabled: &lt;true/false&gt;\n</code></pre>"},{"location":"operator-guide/install-kiosk/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.18.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.6.0 is installed. Please refer to the Helm page on GitHub for details.</li> </ul>"},{"location":"operator-guide/install-kiosk/#installation","title":"Installation","text":"<ul> <li>Deploy Kiosk version 0.2.11 in the cluster. To install it, run the following command:<pre><code>  # Install kiosk with helm v3\n\n  helm repo add kiosk https://charts.devspace.sh/\n  kubectl create namespace kiosk\n  helm install kiosk --version 0.2.11 kiosk/kiosk -n kiosk --atomic\n</code></pre> </li> </ul> <p>For more details, please refer to the Kiosk page on the GitHub.</p>"},{"location":"operator-guide/install-kiosk/#configuration","title":"Configuration","text":"<p>To provide access to the EDP tenant, follow the steps below.</p> <ul> <li>Check that a security namespace is created. If not, run the following command to create it:<pre><code>  kubectl create namespace security\n</code></pre> </li> </ul> <p>Note</p> <p>On an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> <ul> <li>Add a service account to the security namespace.<pre><code>  kubectl -n security create sa &lt;edp-project&gt;\n</code></pre> </li> </ul> <p>Info</p> <p>\u2039edp-project\u203a is the name of the EDP tenant here and in all the following steps.</p> <ul> <li>Apply the Account template to the cluster. Please check the sample below: <pre><code>apiVersion: tenancy.kiosk.sh/v1alpha1\nkind: Account\nmetadata:\nname: &lt;edp-project&gt;-admin\nspec:\nspace:\nclusterRole: kiosk-space-admin\nsubjects:\n- kind: ServiceAccount\nname: &lt;edp-project&gt;\nnamespace: security\n</code></pre></li> </ul> <ul> <li>Apply the ClusterRoleBinding to the 'kiosk-edit' cluster role (current role is added during installation of Kiosk). Please check the sample below: <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\nname: &lt;edp-project&gt;-kiosk-edit\nsubjects:\n- kind: ServiceAccount\nname: &lt;edp-project&gt;\nnamespace: security\nroleRef:\nkind: ClusterRole\nname: kiosk-edit\napiGroup: rbac.authorization.k8s.io\n</code></pre></li> <li>To provide access to the EDP tenant, generate kubeconfig with Service Account \u2039edp-project\u203a permission. The \u2039edp-project\u203a account created earlier is located in the security namespace.</li> </ul>"},{"location":"operator-guide/install-loki/","title":"Install Grafana Loki","text":"<p>EDP configures the logging with the help of Grafana Loki aggregation system.</p>"},{"location":"operator-guide/install-loki/#installation","title":"Installation","text":"<p>To install Loki, follow the steps below:</p> <ol> <li> <p>Create logging namespace:</p> <pre><code>  kubectl create namespace logging\n</code></pre> <p>Note</p> <p>On the OpenShift cluster, run the <code>oc</code> command instead of the <code>kubectl</code> command.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>  helm repo add grafana https://grafana.github.io/helm-charts\n  helm repo update\n</code></pre> <p>Note</p> <p>It is possible to use Amazon Simple Storage Service Amazon S3 as an object storage for Loki. To configure access, please refer to the IRSA for Loki documentation.</p> </li> <li> <p>Install Loki v.2.6.0:</p> <pre><code>  helm install loki grafana/loki \\\n  --version 2.6.0 \\\n  --values values.yaml \\\n  --namespace logging\n</code></pre> <p>Check out the values.yaml file sample of the Loki customization:</p> View: values.yaml <pre><code>image:\nrepository: grafana/loki\ntag: 2.3.0\nconfig:\nauth_enabled: false\nschema_config:\nconfigs:\n- from: 2021-06-01\nstore: boltdb-shipper\nobject_store: s3\nschema: v11\nindex:\nprefix: loki_index_\nperiod: 24h\nstorage_config:\naws:\ns3: s3://&lt;AWS_REGION&gt;/loki-&lt;CLUSTER_NAME&gt;\nboltdb_shipper:\nactive_index_directory: /data/loki/index\ncache_location: /data/loki/boltdb-cache\nshared_store: s3\nchunk_store_config:\nmax_look_back_period: 24h\nresources:\nlimits:\nmemory: \"128Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"128Mi\"\nserviceAccount:\ncreate: true\nname: edp-loki\nannotations:\neks.amazonaws.com/role-arn: \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\npersistence:\nenabled: false\n</code></pre> <p>Note</p> <p>In case of using cluster scheduling and amazon-eks-pod-identity-webhook, it is necessary to restart the Loki pod after the cluster is up and running. Please refer to the Schedule Pods Restart documentation.</p> </li> <li> <p>Configure custom bucket policy to delete the old data.</p> </li> </ol>"},{"location":"operator-guide/install-reportportal/","title":"Install ReportPortal","text":"<p>Inspect the prerequisites and the main steps to perform for installing ReportPortal.</p> <p>Info</p> <p>It is also possible to install ReportPortal using the Helmfile. For details, please refer to the Install via Helmfile page.</p>"},{"location":"operator-guide/install-reportportal/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.23.0 is installed. Please refer to the Kubernetes official website for details.</li> <li>Helm version 3.10.2 is installed. Please refer to the Helm page on GitHub for details.</li> </ul> <p>Info</p> <p>Please refer to the ReportPortal Helm Chart section for details.</p>"},{"location":"operator-guide/install-reportportal/#minio-installation","title":"MinIO Installation","text":"<p>To install MinIO, follow the steps below:</p> <ol> <li> <p>Check that <code>&lt;edp-project&gt;</code> namespace is created. If not, run the following command to create it:</p> <pre><code>kubectl create namespace &lt;edp-project&gt;\n</code></pre> <p>For the OpenShift users:</p> <p>When using the OpenShift platform, install the <code>SecurityContextConstraints</code> resources. In case of using a custom namespace for the <code>reportportal</code>, change the namespace in the <code>users</code> section.</p> View: report-portal-third-party-resources-scc.yaml <pre><code>apiVersion: security.openshift.io/v1\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: report-portal-minio-rabbitmq-postgresql\nallowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegeEscalation: true\nallowPrivilegedContainer: false\nallowedCapabilities: null\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- min: 999\nmax: 65543\ngroups: []\npriority: 1\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities:\n- KILL\n- MKNOD\n- SETUID\n- SETGID\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMin: 1\nuidRangeMax: 65543\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:report-portal:minio\n- system:serviceaccount:report-portal:rabbitmq\n- system:serviceaccount:report-portal:postgresql\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> View: report-portal-elasticsearch-scc.yaml <pre><code>apiVersion: security.openshift.io/v1\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: report-portal-elasticsearch\nallowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegedContainer: true\nallowedCapabilities: []\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- max: 1000\nmin: 1000\ngroups: []\npriority: 0\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities: []\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMax: 1000\nuidRangeMin: 0\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:report-portal:elasticsearch-master\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Create MinIO admin secret:</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic reportportal-minio-creds \\\n--from-literal=root-password=&lt;root_password&gt; \\\n--from-literal=root-user=&lt;root_user&gt;\n</code></pre> </li> <li> <p>Install MinIO v.11.10.3 using bitnami/minio Helm chart v.11.10.3:</p> <pre><code>helm install minio bitnami/minio \\\n--version 11.10.3 \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the MinIO customization:</p> View: values.yaml <pre><code>auth:\nexistingSecret: reportportal-minio-creds\npersistence:\nsize: 1Gi\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-reportportal/#rabbitmq-installation","title":"RabbitMQ Installation","text":"<p>To install RabbitMQ, follow the steps below:</p> <ol> <li> <p>Use <code>&lt;edp-project&gt;</code> namespace from the MinIO installation.</p> </li> <li> <p>Use <code>bitnami</code> chart repository from the MinIO installation.</p> </li> <li> <p>Create RabbitMQ admin secret:</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic reportportal-rabbitmq-creds \\\n--from-literal=rabbitmq-password=&lt;rabbitmq_password&gt; \\\n--from-literal=rabbitmq-erlang-cookie=&lt;rabbitmq_erlang_cookie&gt;\n</code></pre> <p>Warning</p> <p>The <code>rabbitmq_password</code> password must be 10 characters long. The <code>rabbitmq_erlang_cookie</code> password must be 32 characters long.</p> </li> <li> <p>Install RabbitMQ v.10.3.8 using bitnami/rabbitmq Helm chart v.10.3.8:</p> <pre><code>helm install rabbitmq bitnami/rabbitmq \\\n--version 10.3.8 \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the RabbitMQ customization:</p> View: values.yaml <pre><code>auth:\nexistingPasswordSecret: reportportal-rabbitmq-creds\nexistingErlangSecret: reportportal-rabbitmq-creds\npersistence:\nsize: 1Gi\n</code></pre> </li> <li> <p>After the rabbitmq pod gets the status Running, you need to configure the RabbitMQ memory threshold</p> <pre><code>kubectl -n &lt;edp-project&gt; exec -it rabbitmq-0 -- rabbitmqctl set_vm_memory_high_watermark 0.8\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-reportportal/#elasticsearch-installation","title":"Elasticsearch Installation","text":"<p>To install Elasticsearch, follow the steps below:</p> <ol> <li> <p>Use <code>&lt;edp-project&gt;</code> namespace from the MinIO installation.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add elastic https://helm.elastic.co\nhelm repo update\n</code></pre> </li> <li> <p>Install Elasticsearch v.7.17.3 using elastic/elasticsearch Helm chart v.7.17.3:</p> <pre><code>helm install elasticsearch elastic/elasticsearch \\\n--version 7.17.3 \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the Elasticsearch customization:</p> View: values.yaml <pre><code>replicas: 1\n\nextraEnvs:\n- name: discovery.type\nvalue: single-node\n- name: cluster.initial_master_nodes\nvalue: \"\"\n\nrbac:\ncreate: true\n\nresources:\nrequests:\ncpu: \"100m\"\nmemory: \"2Gi\"\n\nvolumeClaimTemplate:\nresources:\nrequests:\nstorage: 3Gi\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-reportportal/#postgresql-installation","title":"PostgreSQL Installation","text":"<p>To install PostgreSQL, follow the steps below:</p> <ol> <li> <p>Use <code>&lt;edp-project&gt;</code> namespace from the MinIO installation.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add bitnami-archive https://raw.githubusercontent.com/bitnami/charts/archive-full-index/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Create PostgreSQL admin secret:</p> <pre><code>kubectl -n &lt;edp-project&gt; create secret generic reportportal-postgresql-creds \\\n--from-literal=postgresql-password=&lt;postgresql_password&gt; \\\n--from-literal=postgresql-postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> <p>Warning</p> <p>The <code>postgresql_password</code> and <code>postgresql_postgres_password</code> passwords must be 16 characters long.</p> </li> <li> <p>Install PostgreSQL v.10.9.4 using Helm chart v.10.9.4:</p> <pre><code>helm install postgresql bitnami-archive/postgresql \\\n--version 10.9.4 \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the PostgreSQL customization:</p> View: values.yaml <pre><code>persistence:\nsize: 1Gi\nresources:\nrequests:\ncpu: \"100m\"\nserviceAccount:\nenabled: true\npostgresqlUsername: \"rpuser\"\npostgresqlDatabase: \"reportportal\"\nexistingSecret: \"reportportal-postgresql-creds\"\ninitdbScripts:\ninit_postgres.sh: |\n#!/bin/sh\n/opt/bitnami/postgresql/bin/psql -U postgres -d ${POSTGRES_DB} -c 'CREATE EXTENSION IF NOT EXISTS ltree; CREATE EXTENSION IF NOT EXISTS pgcrypto; CREATE EXTENSION IF NOT EXISTS pg_trgm;'\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-reportportal/#reportportal-installation","title":"ReportPortal Installation","text":"<p>To install ReportPortal, follow the steps below:</p> <ol> <li> <p>Use <code>&lt;edp-project&gt;</code> namespace from the MinIO installation.</p> <p>For the OpenShift users:</p> <p>When using the OpenShift platform, install the <code>SecurityContextConstraints</code> resource. In case of using a custom namespace for the <code>reportportal</code>, change the namespace in the <code>users</code> section.</p> View: report-portal-reportportal-scc.yaml <pre><code>apiVersion: security.openshift.io/v1\nkind: SecurityContextConstraints\nmetadata:\nannotations:\n\"helm.sh/hook\": \"pre-install\"\nname: report-portal\nallowHostDirVolumePlugin: false\nallowHostIPC: false\nallowHostNetwork: false\nallowHostPID: false\nallowHostPorts: false\nallowPrivilegedContainer: true\nallowedCapabilities: []\nallowedFlexVolumes: []\ndefaultAddCapabilities: []\nfsGroup:\ntype: MustRunAs\nranges:\n- max: 1000\nmin: 1000\ngroups: []\npriority: 0\nreadOnlyRootFilesystem: false\nrequiredDropCapabilities: []\nrunAsUser:\ntype: MustRunAsRange\nuidRangeMax: 1000\nuidRangeMin: 0\nseLinuxContext:\ntype: MustRunAs\nsupplementalGroups:\ntype: RunAsAny\nusers:\n- system:serviceaccount:report-portal:reportportal\nvolumes:\n- configMap\n- downwardAPI\n- emptyDir\n- persistentVolumeClaim\n- projected\n- secret\n</code></pre> </li> <li> <p>Add a chart repository:</p> <pre><code>helm repo add report-portal \"https://reportportal.github.io/kubernetes\"\nhelm repo update\n</code></pre> </li> <li> <p>Install ReportPortal v.5.7.2 using Helm chart v.5.7.2:</p> <pre><code>helm install report-portal report-portal/reportportal \\\n--values values.yaml \\\n--namespace &lt;edp-project&gt;\n</code></pre> <p>Check out the values.yaml file sample of the ReportPortal customization:</p> View: values.yaml <pre><code>serviceindex:\nresources:\nrequests:\ncpu: 50m\nuat:\nresources:\nrequests:\ncpu: 50m\nserviceui:\nresources:\nrequests:\ncpu: 50m\nserviceAccountName: \"reportportal\"\nsecurityContext:\nrunAsUser: 0\nserviceapi:\nresources:\nrequests:\ncpu: 50m\nserviceanalyzer:\nresources:\nrequests:\ncpu: 50m\nserviceanalyzertrain:\nresources:\nrequests:\ncpu: 50m\n\nrabbitmq:\nSecretName: \"reportportal-rabbitmq-creds\"\nendpoint:\naddress: rabbitmq.&lt;EDP_PROJECT&gt;.svc.cluster.local\nuser: user\napiuser: user\n\npostgresql:\nSecretName: \"reportportal-postgresql-creds\"\nendpoint:\naddress: postgresql.&lt;EDP_PROJECT&gt;.svc.cluster.local\n\nelasticsearch:\nendpoint: http://elasticsearch-master.&lt;EDP_PROJECT&gt;.svc.cluster.local:9200\n\nminio:\nsecretName: \"reportportal-minio-creds\"\nendpoint: http://minio.&lt;EDP_PROJECT&gt;.svc.cluster.local:9000\nendpointshort: minio.&lt;EDP_PROJECT&gt;.svc.cluster.local:9000\naccesskeyName: \"root-user\"\nsecretkeyName: \"root-password\"\n\ningress:\n# IF YOU HAVE SOME DOMAIN NAME SET INGRESS.USEDOMAINNAME to true\nusedomainname: true\nhosts:\n- report-portal-&lt;EDP_PROJECT&gt;.&lt;ROOT_DOMAIN&gt;\n</code></pre> </li> <li> <p>For the OpenShift platform, install a Gateway with Route:</p> View: gateway-config-cm.yaml <pre><code>kind: ConfigMap\nmetadata:\nname: gateway-config\nnamespace: report-portal\napiVersion: v1\ndata:\ntraefik-dynamic-config.yml: |\nhttp:\nmiddlewares:\nstrip-ui:\nstripPrefix:\nprefixes:\n- \"/ui\"\nforceSlash: false\nstrip-api:\nstripPrefix:\nprefixes:\n- \"/api\"\nforceSlash: false\nstrip-uat:\nstripPrefix:\nprefixes:\n- \"/uat\"\nforceSlash: false\n\nrouters:\nindex-router:\nrule: \"Path(`/`)\"\nservice: \"index\"\nui-router:\nrule: \"PathPrefix(`/ui`)\"\nmiddlewares:\n- strip-ui\nservice: \"ui\"\nuat-router:\nrule: \"PathPrefix(`/uat`)\"\nmiddlewares:\n- strip-uat\nservice: \"uat\"\napi-router:\nrule: \"PathPrefix(`/api`)\"\nmiddlewares:\n- strip-api\nservice: \"api\"\n\nservices:\nuat:\nloadBalancer:\nservers:\n- url: \"http://report-portal-reportportal-uat:9999/\"\n\nindex:\nloadBalancer:\nservers:\n- url: \"http://report-portal-reportportal-index:8080/\"\n\napi:\nloadBalancer:\nservers:\n- url: \"http://report-portal-reportportal-api:8585/\"\n\nui:\nloadBalancer:\nservers:\n- url: \"http://report-portal-reportportal-ui:8080/\"\ntraefik.yml: |\nentryPoints:\nhttp:\naddress: \":8081\"\nmetrics:\naddress: \":8082\"\n\nmetrics:\nprometheus:\nentryPoint: metrics\naddEntryPointsLabels: true\naddServicesLabels: true\nbuckets:\n- 0.1\n- 0.3\n- 1.2\n- 5.0\n\nproviders:\nfile:\nfilename: /etc/traefik/traefik-dynamic-config.yml\n</code></pre> View: gateway-deployment.yaml <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\nlabels:\napp: reportportal\nname: gateway\nnamespace: report-portal\nspec:\nreplicas: 1\nselector:\nmatchLabels:\ncomponent: gateway\ntemplate:\nmetadata:\nlabels:\ncomponent: gateway\nspec:\ncontainers:\n- image: quay.io/waynesun09/traefik:2.3.6\nname: traefik\nports:\n- containerPort: 8080\nprotocol: TCP\nresources: {}\nvolumeMounts:\n- mountPath: /etc/traefik/\nname: config\nreadOnly: true\nvolumes:\n- name: config\nconfigMap:\ndefaultMode: 420\nname: gateway-config\n</code></pre> View: gateway-route.yaml <pre><code>kind: Route\napiVersion: route.openshift.io/v1\nmetadata:\nlabels:\napp: reportportal\nname: reportportal\nnamespace: report-portal\nspec:\nhost: report-portal.&lt;CLUSTER_DOMAIN&gt;\nport:\ntargetPort: http\ntls:\ninsecureEdgeTerminationPolicy: Redirect\ntermination: edge\nto:\nkind: Service\nname: gateway\nweight: 100\nwildcardPolicy: None\n</code></pre> View: gateway-service.yaml <pre><code>apiVersion: v1\nkind: Service\nmetadata:\nlabels:\napp: reportportal\ncomponent: gateway\nname: gateway\nnamespace: report-portal\nspec:\nports:\n# use 8081 to allow for usage of the dashboard which is on port 8080\n- name: http\nport: 8081\nprotocol: TCP\ntargetPort: 8081\nselector:\ncomponent:  gateway\nsessionAffinity: None\ntype: ClusterIP\n</code></pre> </li> </ol> <p>Note</p> <p>For user access: default/1q2w3e For admin access: superadmin/erebus Please refer to the ReportPortal.io page for details.</p>"},{"location":"operator-guide/install-reportportal/#related-articles","title":"Related Articles","text":"<ul> <li>Install via Helmfile</li> </ul>"},{"location":"operator-guide/install-tekton/","title":"Install Tekton","text":"<p>EPAM Delivery Platform uses Tekton resources, such as Tasks, Pipelines, Triggers, and Interceptors, for running the CI/CD pipelines.</p> <p>Inspect the main steps to perform for installing the Tekton resources via the Tekton release files.</p>"},{"location":"operator-guide/install-tekton/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubectl version 1.24.0 or higher is installed. Please refer to the Kubernetes official website for details.</li> <li>For Openshift/OKD, the latest version of the <code>oc</code> utility is required. Please refer to the OKD page on GitHub for details.</li> <li>Created AWS ECR repository for Kaniko cache. By default, the Kaniko cache repository name is <code>kaniko-cache</code> and this parameter is located in our Tekton <code>common-library</code>.</li> </ul>"},{"location":"operator-guide/install-tekton/#installation-on-kubernetes-cluster","title":"Installation on Kubernetes Cluster","text":"<p>To install Tekton resources, follow the steps below:</p> <p>Info</p> <p>Please refer to the Install Tekton Pipelines and Install and set up Tekton Triggers sections for details.</p> <ol> <li> <p>Install Tekton pipelines v0.42.0 using the release file:</p> <p>Note</p> <p>Tekton Pipeline resources are used for managing and running EDP Tekton Pipelines and Tasks. Please refer to the EDP Tekton Pipelines and EDP Tekton Tasks pages for details.</p> <pre><code>kubectl apply -f https://storage.googleapis.com/tekton-releases/pipeline/previous/v0.42.0/release.yaml\n</code></pre> </li> <li> <p>Install Tekton Triggers v0.22.0 using the release file:</p> <p>Note</p> <p>Tekton Trigger resources are used for managing and running EDP Tekton EventListeners, Triggers, TriggerBindings and TriggerTemplates. Please refer to the EDP Tekton Triggers page for details.</p> <pre><code>kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/previous/v0.22.0/release.yaml\n</code></pre> </li> <li> <p>Install Tekton Interceptors v0.22.0 using the release file:</p> <p>Note</p> <p>EPAM Delivery Platform uses GitLab and GitHub ClusterInterceptors for managing requests from webhooks.</p> <pre><code>kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/previous/v0.22.0/interceptors.yaml\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-tekton/#installation-on-okd-cluster","title":"Installation on OKD cluster","text":"<p>To install Tekton resources, follow the steps below:</p> <p>Info</p> <p>Please refer to the Install Tekton Operator documentation for details.</p> <p>Note</p> <p>Tekton Operator also deploys Pipelines as Code CI that requires OpenShift v4.11 (based on Kubernetes v1.24) or higher. This feature is optional and its deployments can be scaled to zero replicas.</p> <p>Install Tekton Operator v0.64.0 using the release file:</p> <pre><code>kubectl apply -f https://github.com/tektoncd/operator/releases/download/v0.64.0/openshift-release.yaml\n</code></pre> <p>After the installation, the Tekton Operator will install the following components: Pipeline, Trigger, and Addons.</p> <p>Note</p> <p>If there is the following error in the <code>openshift-operators</code> namespace for <code>openshift-pipelines-operator</code> and <code>tekton-operator-webhook</code> deployments:</p> <pre><code>Error: container has runAsNonRoot and image will run as root\n</code></pre> <p>Patch the deployments with the following commands:</p> <pre><code>kubectl -n openshift-operators patch deployment openshift-pipelines-operator -p '{\"spec\": {\"template\": {\"spec\": {\"securityContext\": {\"runAsUser\": 1000}}}}}'\nkubectl -n openshift-operators patch deployment tekton-operator-webhook -p '{\"spec\": {\"template\": {\"spec\": {\"securityContext\": {\"runAsUser\": 1000}}}}}'\n</code></pre> <p>Grant access for Tekton Service Accounts in the <code>openshift-pipelines</code> namespace to the Privileged SCC:</p> <pre><code>oc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-operators-proxy-webhook\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-pipelines-controller\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-pipelines-resolvers\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-pipelines-webhook\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-triggers-controller\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-triggers-core-interceptors\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:tekton-triggers-webhook\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:pipelines-as-code-controller\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:pipelines-as-code-watcher\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:pipelines-as-code-webhook\noc adm policy add-scc-to-user privileged system:serviceaccount:openshift-pipelines:default\n</code></pre>"},{"location":"operator-guide/install-tekton/#related-articles","title":"Related Articles","text":"<ul> <li>Install via Helmfile</li> </ul>"},{"location":"operator-guide/install-velero/","title":"Install Velero","text":"<p>Velero is an open source tool to safely back up, recover, and migrate Kubernetes clusters and persistent volumes. It works both on premises and in a public cloud. Velero consists of a server process running as a deployment in your Kubernetes cluster and a command-line interface (CLI) with which DevOps teams and platform operators configure scheduled backups, trigger ad-hoc backups, perform restores, and more.</p>"},{"location":"operator-guide/install-velero/#installation","title":"Installation","text":"<p>To install Velero, follow the steps below:</p> <ol> <li> <p>Create velero namespace:</p> <pre><code>  kubectl create namespace velero\n</code></pre> <p>Note</p> <p>On an OpenShift cluster, run the <code>oc</code> command instead of <code>kubectl</code> one.</p> </li> <li> <p>Add a chart repository:</p> <pre><code>  helm repo add vmware-tanzu https://vmware-tanzu.github.io/helm-charts\n  helm repo update\n</code></pre> <p>Note</p> <p>Velero AWS Plugin requires access to AWS resources.  To configure access, please refer to the IRSA for Velero documentation.</p> </li> <li> <p>Install Velero v.2.14.13:</p> <pre><code>  helm install velero vmware-tanzu/velero \\\n  --version 2.14.13 \\\n  --values values.yaml \\\n  --namespace velero\n</code></pre> <p>Check out the values.yaml file sample of the Velero customization:</p> View: values.yaml <pre><code>image:\nrepository: velero/velero\ntag: v1.5.3\nsecurityContext:\nfsGroup: 65534\nrestic:\nsecurityContext:\nfsGroup: 65534\nserviceAccount:\nserver:\ncreate: true\nname: edp-velero\nannotations:\neks.amazonaws.com/role-arn: \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\"\ncredentials:\nuseSecret: false\nconfiguration:\nprovider: aws\nbackupStorageLocation:\nname: default\nbucket: velero-&lt;CLUSTER_NAME&gt;\nconfig:\nregion: eu-central-1\nvolumeSnapshotLocation:\nname: default\nconfig:\nregion: &lt;AWS_REGION&gt;\ninitContainers:\n- name: velero-plugin-for-aws\nimage: velero/velero-plugin-for-aws:v1.1.0\nvolumeMounts:\n- mountPath: /target\nname: plugins\n</code></pre> <p>Note</p> <p>In case of using cluster scheduling and amazon-eks-pod-identity-webhook, it is necessary to restart the Velero pod after the cluster is up and running. Please refer to the Schedule Pods Restart documentation.</p> </li> <li> <p>Install the client side (velero cli) according to the official documentation.</p> </li> </ol>"},{"location":"operator-guide/install-velero/#configuration","title":"Configuration","text":"<ol> <li> <p>Create backup for all components in the namespace:</p> <pre><code>  velero backup create &lt;BACKUP_NAME&gt; --include-namespaces &lt;NAMESPACE&gt;\n</code></pre> </li> <li> <p>Create a daily backup of the namespace:</p> <pre><code>  velero schedule create &lt;BACKUP_NAME&gt;  --schedule \"0 10 * * MON-FRI\" --include-namespaces &lt;NAMESPACE&gt; --ttl 120h0m0s\n</code></pre> </li> <li> <p>To restore from backup, use the following command:</p> <pre><code>  velero restore create &lt;RESTORE_NAME&gt; --from-backup &lt;BACKUP_NAME&gt;\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/","title":"Install via Helmfile","text":"<p>This article provides the instruction on how to deploy EDP and components in Kubernetes using Helmfile that is intended for deploying Helm charts. Helmfile templates are available in GitHub repository.</p>"},{"location":"operator-guide/install-via-helmfile/#prerequisites","title":"Prerequisites","text":"<p>The following tools and plugins must be installed:</p> <ul> <li>Kubectl version 1.23.0</li> <li>Helm version 3.10.0+</li> <li>Helmfile version 0.144.0</li> <li>Helm diff plugin version 3.6.0</li> </ul>"},{"location":"operator-guide/install-via-helmfile/#helmfile-structure","title":"Helmfile Structure","text":"<ul> <li>The <code>envs/common.yaml</code> file contains the specification for environments pattern, list of helm repositories from which it is necessary to fetch the helm charts and additional Helm parameters.</li> <li>The <code>envs/platform.yaml</code> file contains global parameters that are used in various Helmfiles.</li> <li>The <code>releases/envs/</code> contains symbol links to environments files.</li> <li>The <code>releases/*.yaml</code> file contains description of parameters that is used when deploying a Helm chart.</li> <li>The <code>helmfile.yaml</code> file defines components to be installed by defining a path to Helm releases files.</li> <li>The <code>envs/ci.yaml</code> file contains stub parameters for CI linter.</li> <li>The <code>test/lint-ci.sh</code> script for running CI linter with debug loglevel and stub parameters.</li> <li>The <code>resources/*.yaml</code> file contains additional resources for the OpenShift platform.</li> </ul>"},{"location":"operator-guide/install-via-helmfile/#operate-helmfile","title":"Operate Helmfile","text":"<p>Before applying the Helmfile, please fill in the global parameters in the <code>envs/platform.yaml</code> (check the examples in the <code>envs/ci.yaml</code>) and <code>releases/*.yaml</code> files for every Helm deploy.</p> <p>Pay attention to the following recommendations while working with the Helmfile:</p> <ul> <li>To launch Lint, run the <code>test/lint-ci.sh</code> script.</li> </ul> <ul> <li>Display the difference between the deployed and environment state (<code>helm diff</code>):<pre><code>helmfile --environment platform -f helmfile.yaml diff\n</code></pre> </li> </ul> <ul> <li>Apply the deployment:<pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ul> <ul> <li>Modify the deployment and apply the changes:<pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml sync\n</code></pre> </li> </ul> <ul> <li>To deploy the components according to the label, use the selector to target a subset of releases when running the Helmfile. It can be useful for large Helmfiles with the releases that are logically grouped together. For example, to display the difference only for the <code>nginx-ingress</code> file, use the following command:<pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml diff\n</code></pre> </li> </ul> <ul> <li>To destroy the release, run the following command:<pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml destroy\n</code></pre> </li> </ul>"},{"location":"operator-guide/install-via-helmfile/#deploy-components","title":"Deploy Components","text":"<p>Using the Helmfile, the following components can be installed:</p> <ul> <li>NGINX Ingress Controller</li> <li>Keycloak</li> <li>EPAM Delivery Platform</li> <li>Argo CD</li> <li>External Secrets Operator</li> <li>DefectDojo</li> <li>Moon</li> <li>ReportPortal</li> </ul>"},{"location":"operator-guide/install-via-helmfile/#deploy-nginx-ingress-controller","title":"Deploy NGINX Ingress Controller","text":"<p>Info</p> <p>Skip this step for the OpenShift platform, because it has its own Ingress Controller.</p> <p>To install NGINX Ingress controller, follow the steps below:</p> <ol> <li> <p>In the <code>releases/nginx-ingress.yaml</code> file, set the <code>proxy-real-ip-cidr</code> parameter according to the value with AWS VPC IPv4 CIDR.</p> </li> <li> <p>Install NGINX Ingress controller:</p> <pre><code>helmfile  --selector component=ingress --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-keycloak","title":"Deploy Keycloak","text":"<p>Keycloak requires a database deployment, so it has two charts: <code>releases/keycloak.yaml</code> and <code>releases/postgresql-keycloak.yaml</code>.</p> <p>To install Keycloak, follow the steps below:</p> <ol> <li> <p>Create a <code>security</code> namespace:</p> <p>Note</p> <p>For the OpenShift users: This namespace is also indicated as <code>users</code> in the following custom <code>SecurityContextConstraints</code> resources: <code>resources/keycloak-scc.yaml</code> and <code>resources/postgresql-keycloak-scc.yaml</code>. Change the namespace name when using a custom namespace.</p> <pre><code>kubectl create namespace security\n</code></pre> </li> <li> <p>Create PostgreSQL admin secret:</p> <pre><code>kubectl -n security create secret generic keycloak-postgresql \\\n--from-literal=password=&lt;postgresql_password&gt; \\\n--from-literal=postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> </li> <li> <p>In the <code>envs/platform.yaml</code> file, set the <code>dnsWildCard</code> parameter.</p> </li> <li> <p>Create Keycloak admin secret:</p> <pre><code>kubectl -n security create secret generic keycloak-admin-creds \\\n--from-literal=username=&lt;keycloak_admin_username&gt; \\\n--from-literal=password=&lt;keycloak_admin_password&gt;\n</code></pre> </li> <li> <p>Install Keycloak:</p> <pre><code>helmfile  --selector component=sso --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-epam-delivery-platform","title":"Deploy EPAM Delivery Platform","text":"<p>To install EDP, follow the steps below:</p> <ol> <li> <p>Create a <code>platform</code> namespace:</p> <pre><code>kubectl create namespace platform\n</code></pre> </li> <li> <p>For EDP, it is required to have Keycloak access to perform the integration. Create a secret with the user and password provisioned in the step 2 of the Keycloak Configuration section.</p> <pre><code>kubectl -n platform create secret generic keycloak \\\n  --from-literal=username=&lt;username&gt; \\\n  --from-literal=password=&lt;password&gt;\n</code></pre> </li> <li> <p>In the <code>envs/platform.yaml</code> file, set the <code>edpName</code> and <code>keycloakEndpoint</code> parameters.</p> </li> <li> <p>In the <code>releases/edp-install.yaml</code> file, check and fill in all values.</p> </li> <li> <p>Install EDP:</p> <pre><code>helmfile  --selector component=edp --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-argo-cd","title":"Deploy Argo CD","text":"<p>Before Argo CD deployment, install the following tools:</p> <ul> <li>Keycloak</li> <li>EDP</li> </ul> <p>To install Argo CD, follow the steps below:</p> <ol> <li> <p>Install Argo CD:</p> <p>For the OpenShift users:<p>When using a custom namespace for Argo CD, the <code>argocd</code> namespace is also indicated as <code>users</code> in the <code>resources/argocd-scc.yaml</code> custom <code>SecurityContextConstraints</code> resource. Change it there as well.</p> </p> <pre><code>helmfile --selector component=argocd --environment platform -f helmfile.yaml apply\n</code></pre> </li> <li> <p>Update the <code>argocd-secret</code> secret in the Argo CD namespace by providing the correct Keycloak client secret (<code>oidc.keycloak.clientSecret</code>) with the value from the <code>keycloak-client-argocd-secret</code> secret in EDP namespace. Then restart the deployment:</p> <pre><code>ARGOCD_CLIENT=$(kubectl -n platform get secret keycloak-client-argocd-secret  -o jsonpath='{.data.clientSecret}')\nkubectl -n argocd patch secret argocd-secret -p=\"{\\\"data\\\":{\\\"oidc.keycloak.clientSecret\\\": \\\"${ARGOCD_CLIENT}\\\"}}\" -v=1\nkubectl -n argocd rollout restart deployment argo-argocd-server\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-external-secrets-operator","title":"Deploy External Secrets Operator","text":"<p>To install External Secrets Operator, follow the steps below:</p> <pre><code>helmfile  --selector component=secrets --environment platform -f helmfile.yaml apply\n</code></pre>"},{"location":"operator-guide/install-via-helmfile/#deploy-defectdojo","title":"Deploy DefectDojo","text":"<p>Info</p> <p>It is also possible to install DefectDojo via Helm Chart. For details, please refer to the Install DefectDojo page.</p> <p>To install DefectDojo via Helmfile, follow the steps below:</p> <ol> <li> <p>Create a DefectDojo namespace:</p> <p>For the OpenShift users:</p> <p>This namespace is also indicated as <code>users</code> in the <code>resources/defectdojo-scc.yaml</code> custom <code>SecurityContextConstraints</code> resource. Change it when using a custom namespace. Also, change the namespace in the <code>resources/defectdojo-route.yaml</code> file.</p> <pre><code>kubectl create namespace defectdojo\n</code></pre> </li> <li> <p>Modify the <code>host</code> in <code>resources/defectdojo-route.yaml</code> (only for OpenShift).</p> </li> <li> <p>Create a PostgreSQL admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo-postgresql-specific \\\n--from-literal=postgresql-password=&lt;postgresql_password&gt; \\\n--from-literal=postgresql-postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> <p>Note</p> <p>The <code>postgresql_password</code> and <code>postgresql_postgres_password</code> passwords must be 16 characters long.</p> </li> <li> <p>Create a RabbitMQ admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo-rabbitmq-specific \\\n--from-literal=rabbitmq-password=&lt;rabbitmq_password&gt; \\\n--from-literal=rabbitmq-erlang-cookie=&lt;rabbitmq_erlang_cookie&gt;\n</code></pre> <p>Note</p> <p>The <code>rabbitmq_password</code> password must be 10 characters long.</p> <p>The <code>rabbitmq_erlang_cookie</code> password must be 32 characters long.</p> </li> <li> <p>Create a DefectDojo admin secret:</p> <pre><code>kubectl -n defectdojo create secret generic defectdojo \\\n--from-literal=DD_ADMIN_PASSWORD=&lt;dd_admin_password&gt; \\\n--from-literal=DD_SECRET_KEY=&lt;dd_secret_key&gt; \\\n--from-literal=DD_CREDENTIAL_AES_256_KEY=&lt;dd_credential_aes_256_key&gt; \\\n--from-literal=METRICS_HTTP_AUTH_PASSWORD=&lt;metric_http_auth_password&gt;\n</code></pre> <p>Note</p> <p>The <code>dd_admin_password</code> password must be 22 characters long.</p> <p>The <code>dd_secret_key</code> password must be 128 characters long.</p> <p>The <code>dd_credential_aes_256_key</code> password must be 128 characters long.</p> <p>The <code>metric_http_auth_password</code> password must be 32 characters long.</p> </li> <li> <p>In the <code>envs/platform.yaml</code> file, set the <code>dnsWildCard</code> parameter.</p> </li> <li> <p>Install DefectDojo:</p> <pre><code>helmfile  --selector component=defectdojo --environment platform -f helmfile.yaml apply\n</code></pre> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-reportportal","title":"Deploy ReportPortal","text":"<p>Info</p> <p>It is also possible to install ReportPortal via Helm Chart. For details, please refer to the Install ReportPortal page.</p> <p>ReportPortal requires third-party deployments: RabbitMQ, ElasticSearch, PostgreSQL, MinIO.</p> <p>To install third-party resources, follow the steps below:</p> <ol> <li> <p>Create a RabbitMQ admin secret:</p> <pre><code>kubectl -n platform create secret generic reportportal-rabbitmq-creds \\\n--from-literal=rabbitmq-password=&lt;rabbitmq_password&gt; \\\n--from-literal=rabbitmq-erlang-cookie=&lt;rabbitmq_erlang_cookie&gt;\n</code></pre> <p>Warning</p> <p>The <code>rabbitmq_password</code> password must be 10 characters long.</p> <p>The <code>rabbitmq_erlang_cookie</code> password must be 32 characters long.</p> </li> <li> <p>Create a PostgreSQL admin secret:</p> <pre><code>kubectl -n platform create secret generic reportportal-postgresql-creds \\\n--from-literal=postgresql-password=&lt;postgresql_password&gt; \\\n--from-literal=postgresql-postgres-password=&lt;postgresql_postgres_password&gt;\n</code></pre> <p>Warning</p> <p>The <code>postgresql_password</code> and <code>postgresql_postgres_password</code> passwords must be 16 characters long.</p> </li> <li> <p>Create a MinIO admin secret:</p> <pre><code>kubectl -n platform create secret generic reportportal-minio-creds \\\n--from-literal=root-password=&lt;root_password&gt; \\\n--from-literal=root-user=&lt;root_user&gt;\n</code></pre> </li> <li> <p>In the <code>envs/platform.yaml</code> file, set the <code>dnsWildCard</code> and <code>edpName</code> parameters.</p> <p>For the OpenShift users:</p> <p>The namespace is also indicated as <code>users</code> in the following custom <code>SecurityContextConstraints</code> resources: <code>resources/report-portal-elasticsearch-scc.yaml</code> and <code>resources/report-portal-third-party-resources-scc.yaml</code>. Change the namespace name when using a custom namespace.</p> </li> <li> <p>Install third-party resources:</p> <pre><code>helmfile --selector component=report-portal-third-party-resources --environment platform -f helmfile.yaml apply\n</code></pre> </li> <li> <p>After the rabbitmq pod gets the status Running, you need to configure the RabbitMQ memory threshold</p> <pre><code>kubectl -n platform exec -it rabbitmq-0 -- rabbitmqctl set_vm_memory_high_watermark 0.8\n</code></pre> </li> </ol> <p>To install ReportPortal via Helmfile, follow the steps below:</p> <p>For the OpenShift users:</p> <ol> <li>The namespace is also indicated as <code>users</code> in the <code>resources/report-portal-reportportal-scc.yaml</code> custom <code>SecurityContextConstraints</code> resource. Change it when using a custom namespace.</li> <li>Change the namespace in the following files: <code>resources/report-portal-gateway/gateway-config-cm</code>, <code>resources/report-portal-gateway/gateway-deployment</code>, <code>resources/report-portal-gateway/gateway-route</code>, and <code>resources/report-portal-gateway/gateway-service</code>.</li> <li>Modify the <code>host</code> in <code>resources/report-portal-gateway/gateway-route</code></li> </ol> <pre><code>helmfile --selector component=report-portal --environment platform -f helmfile.yaml apply\n</code></pre> <p>Note</p> <p>For user access: default/1q2w3e For admin access: superadmin/erebus Please refer to the ReportPortal.io page for details.</p>"},{"location":"operator-guide/install-via-helmfile/#deploy-moon","title":"Deploy Moon","text":"<p>Moon is a browser automation solution compatible with Selenium, Cypress, Playwright, and Puppeteer using Kubernetes or Openshift to launch browsers.</p> <p>Note</p> <p>Aerokube/Moon does not require third-party deployments.</p> <p>Follow the steps below to deploy Moon:</p> <ol> <li> <p>Use the following command to install Moon:</p> <pre><code>helmfile --selector component=moon --environment platform -f helmfile.yaml apply\n</code></pre> </li> <li> <p>After the installation, open the Ingress Dashboard and check that <code>SELENOID</code> and <code>SSE</code> have the <code>CONNECTED</code> status.</p> <p> Main board </p> </li> <li> <p>In Moon, use the following command with the Ingress rule, for example, <code>wd/hub</code>:</p> <pre><code>    curl -X POST 'http://&lt;INGRESS_LINK&gt;/wd/hub/session' -d '{\n                \"desiredCapabilities\":{\n                    \"browserName\":\"firefox\",\n                    \"version\": \"79.0\",\n                    \"platform\":\"ANY\",\n                    \"enableVNC\": true,\n                    \"name\": \"edp\",\n                    \"sessionTimeout\": \"480s\"\n                }\n            }'\n</code></pre> <p>See below the list of Moon Dashboard Ingress rules:</p> <p> Moon Dashboard Ingress rules </p> <p>After using the command above, the container will start, and the VNC viewer will be displayed on the Moon Dashboard:</p> <p> VNC viewer with the container starting </p> </li> </ol>"},{"location":"operator-guide/install-via-helmfile/#deploy-kiosk","title":"Deploy Kiosk","text":"<p>To install Kiosk, follow the steps below:</p> <pre><code>helmfile  --selector component=kiosk --environment platform -f helmfile.yaml apply\n</code></pre>"},{"location":"operator-guide/install-via-helmfile/#related-articles","title":"Related Articles","text":"<ul> <li>Install EDP</li> <li>Install NGINX Ingress Controller</li> <li>Install Keycloak</li> <li>Install DefectDojo</li> <li>Install ReportPortal</li> <li>Install Argo CD</li> </ul>"},{"location":"operator-guide/jira-gerrit-integration/","title":"Adjust VCS Integration With Jira","text":"<p>In order to adjust the Version Control System integration with Jira Server, first make sure you have the following prerequisites:</p> <ul> <li>VCS Server</li> <li>Jira</li> <li>Crucible</li> </ul> <p>When checked the prerequisites, follow the steps below to proceed with the integration:</p> <ol> <li> <p>Integrate every project in VCS Server with every project in Crucible by creating a corresponding request in EPAM Support Portal. Add the repositories links and fill in the Keep Informed field as this request must be approved.</p> <p> Request example </p> </li> <li> <p>Provide additional details to the support team. If the VCS is Gerrit, inspect the sample below of its integration:</p> <p>2.1 Create a new \"crucible-\" user in Gerrit with SSH key and add a new user to the \"Non-Interactive Users\" Gerrit group; <p>2.2 Create a new group in Gerrit \"crucible-watcher-group\" and add the \"crucible-\" user; <p>2.3 Provide access to All-Projects for the \"crucible-watcher-group\" group:</p> <p> Gerrit All-Projects configuration </p> <p> Gerrit All-Projects configuration </p> <li> <p>To link commits with Jira ticket, being in Gerrit, enter a Jira ticket ID in a commit message using the specific format:</p> <p>[PROJECT-CODE-1234]: commit message</p> <p>where PROJECT-CODE is a specific code of a project, 1234 is an ID number, and a commit message.</p> </li> <li> <p>As a result, all Gerrit commits will be displayed on Crucible:</p> <p> Crucible project </p> </li>"},{"location":"operator-guide/jira-gerrit-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Adjust Jira Integration</li> </ul>"},{"location":"operator-guide/jira-integration/","title":"Adjust Jira Integration","text":"<p>In order to adjust the Jira server integration, first add JiraServer CR by performing the following:</p> <ol> <li> <p>Create Secret in the OpenShift/Kubernetes namespace for Jira Server account with the username and password fields:</p> <pre><code>apiVersion: v1\ndata:\npassword: passwordInBase64\nusername: usernameInBase64\nkind: Secret\nmetadata:\nname: epam-jira-user\ntype: kubernetes.io/basic-auth\n</code></pre> </li> <li> <p>Create JiraServer CR in the OpenShift/Kubernetes namespace with the apiUrl, credentialName and rootUrl fields:</p> <pre><code>apiVersion: v2.edp.epam.com/v1\nkind: JiraServer\nmetadata:\nname: epam-jira\nspec:\napiUrl: 'https://jira-api.example.com'\ncredentialName: jira-user\nrootUrl: 'https://jira.example.com'\nstatus:\navailable: true\nlast_time_updated: '2021-04-05T10:51:07.042048633Z'\n</code></pre> <p>Note</p> <p>The value of the credentialName property is the name of the Secret, which is indicated in the first point above.</p> </li> <li> <p>Being in Admin Console, navigate to the Advanced Settings menu to check that the Integrate with Jira Server check box appeared:</p> <p> Advanced settings </p> </li> </ol>"},{"location":"operator-guide/kaniko-irsa/","title":"IAM Roles for Kaniko Service Accounts","text":"<p>Note</p> <p>The information below is relevant in case ECR is used as Docker container registry. Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation.</p> <p>The \"build-image-kaniko\" stage manages ECR through IRSA that should be available on the cluster. Follow the steps below to create a required role:</p> <ol> <li> <p>Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko_policy\":</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n        \"Effect\": \"Allow\",\n        \"Action\": [\n            \"ecr:*\",\n            \"cloudtrail:LookupEvents\"\n        ],\n        \"Resource\": \"arn:aws:ecr:&lt;AWS_REGION&gt;:&lt;AWS_ACCOUNT_ID&gt;:repository/&lt;EDP_NAMESPACE&gt;/*\"\n    },\n    {\n        \"Effect\": \"Allow\",\n        \"Action\": \"ecr:GetAuthorizationToken\",\n        \"Resource\": \"*\"\n    },\n    {\n        \"Effect\": \"Allow\",\n        \"Action\": [\n            \"ecr:DescribeRepositories\",\n            \"ecr:CreateRepository\"\n        ],\n        \"Resource\": \"arn:aws:ecr:&lt;AWS_REGION&gt;:&lt;AWS_ACCOUNT_ID&gt;:repository/*\"\n    }\n  ]\n}\n</code></pre> </li> <li> <p>Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\" with trust relationships:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;OIDC_PROVIDER&gt;\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"&lt;OIDC_PROVIDER&gt;:sub\": \"system:serviceaccount:&lt;EDP_NAMESPACE&gt;:edp-kaniko\"\n        }\n      }\n    }\n  ]\n}\n</code></pre> </li> <li> <p>Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\" role.</p> </li> <li> <p>Define the resulted arn role value into the kaniko.roleArn parameter in values.yaml during the EDP installation.</p> </li> </ol>"},{"location":"operator-guide/kaniko-irsa/#related-articles","title":"Related Articles","text":"<ul> <li>Associate IAM Roles With Service Accounts</li> <li>Install EDP</li> </ul>"},{"location":"operator-guide/kubernetes-cluster-settings/","title":"Set Up Kubernetes","text":"<p>Make sure the cluster meets the following conditions:</p> <ol> <li> <p>Kubernetes cluster is installed with minimum 2 worker nodes with total capacity 8 Cores and 32Gb RAM.</p> </li> <li> <p>Machine with kubectl is installed with a cluster-admin access to the Kubernetes cluster.</p> </li> <li> <p>Ingress controller is installed in a cluster, for example ingress-nginx.</p> </li> <li> <p>Ingress controller is configured with the disabled HTTP/2 protocol and header size of 64k support.</p> <p>Find below an example of the Config Map for the NGINX Ingress controller:</p> <pre><code>kind: ConfigMap\napiVersion: v1\nmetadata:\nname: nginx-configuration\nnamespace: ingress-nginx\nlabels:\napp.kubernetes.io/name: ingress-nginx\napp.kubernetes.io/part-of: ingress-nginx\ndata:\nclient-header-buffer-size: 64k\nlarge-client-header-buffers: 4 64k\nuse-http2: \"false\"\n</code></pre> </li> <li> <p>Load balancer (if any exists in front of the Ingress controller) is configured with session stickiness, disabled HTTP/2 protocol and header size of 32k support.</p> </li> <li> <p>Cluster nodes and pods have access to the cluster via external URLs. For instance, add in AWS the VPC NAT gateway elastic IP to the cluster external load balancers security group).</p> </li> <li> <p>Keycloak instance is installed. To get accurate information on how to install Keycloak, please refer to the Install Keycloak instruction.</p> </li> <li> <p>Helm 3.10 or higher is installed on the installation machine with the help of the Installing Helm instruction.</p> </li> <li> <p>Storage classes are used with the Retain Reclaim Policy and Delete Reclaim Policy.</p> <p>Info</p> <p>By default, EDP uses the default Storage Class in a cluster. The EDP development team recommends using the following Storage Classes. See an example below.</p> <p>Storage class templates with the Retain and Delete Reclaim Policies:</p> gp3gp3-retain <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp3\nannotations:\nstorageclass.kubernetes.io/is-default-class: 'true'\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Delete\nvolumeBindingMode: Immediate\nallowVolumeExpansion: true\n</code></pre> <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp3-retain\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Retain\nvolumeBindingMode: WaitForFirstConsumer\nallowVolumeExpansion: true\n</code></pre> </li> </ol>"},{"location":"operator-guide/kubernetes-cluster-settings/#related-articles","title":"Related Articles","text":"<ul> <li>Install NGINX Ingress Controller</li> <li>Install Keycloak</li> </ul>"},{"location":"operator-guide/logsight-integration/","title":"Logsight Integration","text":"<p>Logsight can be integrated with the CI/CD pipeline. It connects to log data sources, analyses collected logs, and evaluates deployment risk scores.</p>"},{"location":"operator-guide/logsight-integration/#overview","title":"Overview","text":"<p>In order to understand if a microservice or a component is ready for the deployment, EDP suggests analysing logs via Logsight to decide if the deployment is risky or not.</p> <p>Please find more about Logsight in the official documentation:</p> <ul> <li>Logsight key features and workflow</li> <li>Log analysis</li> <li>Stage verification</li> </ul>"},{"location":"operator-guide/logsight-integration/#logsight-as-a-quality-gate","title":"Logsight as a Quality Gate","text":"<p>Integration with Logsight allows enhancing and optimizing software releases by creating an additional quality gate.</p> <p>Logsight can be configured in two ways:</p> <ul> <li>SAAS - online system; for this solution a connection string is required.</li> <li>Self-deployment - local installation.</li> </ul> <p>To work with Logsight, a new Deployment Risk stage must be added to the pipeline. On this stage, the logs are analysed with the help of Logsight mechanisms.</p> <p>On the verification screen of Logsight, continuous verification of the application deployment can be monitored, and tests can be compared for detecting test flakiness.</p> <p>For example, two versions of a microservice can be compared in order to detect critical differences. Risk score will be calculated for the state reached by version A and version B. Afterwards, the deployment risk will be calculated based on individual risk scores.</p> <p>If the deployment failure risk is greater than a predefined threshold, the verification gate blocks the deployment from going to the target environment. In such case, the Deployment Risk stage of the pipeline is not passed, and additional attention is required. The exact log messages can be displayed in the Logsight verification screen, to help debug the problem.</p>"},{"location":"operator-guide/logsight-integration/#use-logsight-for-edp-development","title":"Use Logsight for EDP Development","text":"<p>Please find below the detailed description of Logsight integration with EDP.</p>"},{"location":"operator-guide/logsight-integration/#deployment-approach","title":"Deployment Approach","text":"<p>EDP uses Logsight in a self-deploying mode.</p> <p>Logsight provides a deployment approach using Helm charts. Please find below the stack of components that must be deployed:</p> <ul> <li><code>logsight</code>\u00a0- the core component.</li> <li><code>logsight-backend</code>\u00a0- the backend that provides all necessary APIs and user management.</li> <li><code>logsight-frontend</code>\u00a0- the frontend that provides the user interface.</li> <li><code>logsight-result-api</code>\u00a0- responsible for obtaining results, for example, during the verification.</li> </ul> <p>Below is a diagram of interaction when integrating the components:</p> <p> Logsight Structure </p>"},{"location":"operator-guide/logsight-integration/#configure-fluentbit-for-sending-log-data","title":"Configure FluentBit for Sending Log Data","text":"<p>Logsight is integrated with the EDP logging stack. The integration is based on top of the EFK (ElasticSearch-FluentBit-Kibana) stack. It is necessary to deploy a stack with the security support, namely, enable the certificate support.</p> <p>A FluentBit config indicates the namespace from which the logs will be received for further analysis. Below is an example of the FluentBit config for getting logs from the <code>edp-delivery-edp-delivery-sit</code> namespace:</p> View: fluent-bit.conf <pre><code>[INPUT]\nName              tail\nTag               kube.sit.*\nPath              /var/log/containers/*edp-delivery-edp-delivery-sit*.log\nParser            docker\nMem_Buf_Limit     5MB\nSkip_Long_Lines   Off\nRefresh_Interval  10\n\n[FILTER]\nName                kubernetes\nMatch               kube.sit.*\nKube_URL            https://kubernetes.default.svc:443\nKube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\nKube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token\nKube_Tag_Prefix     kube.sit.var.log.containers.\nMerge_Log           Off\nK8S-Logging.Parser  On\nK8S-Logging.Exclude On\n\n[FILTER]\nName nest\nMatch kube.sit.*\nOperation lift\nNested_under kubernetes\nAdd_prefix kubernetes.\n\n[FILTER]\nName modify\nMatch kube.sit.*\nCopy kubernetes.container_name tags.container\nCopy log message\nCopy kubernetes.container_image tags.image\nCopy kubernetes.namespace_name tags.namespace\n\n[FILTER]\nName nest\nMatch kube.sit.*\nOperation nest\nWildcard kubernetes.*\nNested_under kubernetes\nRemove_prefix kubernetes.\n\n[OUTPUT]\nName            es\nMatch           kube.sit.*\nHost            elasticsearch-master\nPort            9200\nHTTP_User elastic\nHTTP_Passwd *****\nLogstash_Format On\nLogstash_Prefix sit\nTime_Key        @timestamp\nType            flb_type\nReplace_Dots    On\nRetry_Limit     False\n\n[OUTPUT]\nMatch kube.sit.*\nName  http\nHost logsight-backend\nPort 8080\nhttp_User logsight@example.com\nhttp_Passwd *****\nuri /api/v1/logs/singles\nFormat json\njson_date_format iso8601\njson_date_key timestamp\n</code></pre>"},{"location":"operator-guide/logsight-integration/#deployment-risk-analysis","title":"Deployment Risk Analysis","text":"<p>A <code>deployment-risk</code> stage is added to the EDP CD pipeline.</p> <p> Deployment Risk </p> <p>If the deployment risk is above 70%, the red state of the pipeline is expected.</p> <p>EDP consists of a set of containerized components. For the convenience of tracking the risk deployment trend for each component, this data is stored as Jenkins artifacts.</p> <p>If the deployment risk is higher than the threshold of 70%, the EDP promotion of artifacts for the next environments does not pass. The deployment risk report can be analysed in order to avoid the potential problems with updating the components.</p> <p>To study the report in detail, use the link from the Jenkins pipeline to the Logsight verification screen:</p> <p> Logsight Insights Logsight Insights </p> <p>In this example, logs from different versions of the <code>gerrit-operator</code> were analyzed. As can be seen from the report, a large number of new messages appeared in the logs, and the output frequency of other notifications has also changed, which led to the high deployment risk.</p> <p>The environment on which the analysis is performed can exist for different time periods. Logsight only processes the minimum total number of logs since the creating of the environment.</p>"},{"location":"operator-guide/logsight-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Customize CD Pipeline</li> <li>Adjust Jira Integration</li> </ul>"},{"location":"operator-guide/loki-irsa/","title":"IAM Roles for Loki Service Accounts","text":"<p>Note</p> <p>Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation.</p> <p>It is possible to use Amazon Simple Storage Service Amazon S3 as object storage for Loki. In this case Loki requires access to AWS resources. Follow the steps below to create a required role:</p> <ol> <li> <p>Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki_policy\":</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:ListObjects\",\n                \"s3:ListBucket\",\n                \"s3:PutObject\",\n                \"s3:GetObject\",\n                \"s3:DeleteObject\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::loki-*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:ListBucket\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::loki-*\"\n            ]\n        }\n    ]\n}\n</code></pre> </li> <li> <p>Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" with trust relationships:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;OIDC_PROVIDER&gt;\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"&lt;OIDC_PROVIDER&gt;:sub\": \"system:serviceaccount:&lt;LOKI_NAMESPACE&gt;:edp-loki\"\n       }\n     }\n   }\n ]\n}\n</code></pre> </li> <li> <p>Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" role.</p> </li> <li> <p>Make sure that Amazon S3 bucket with name loki-\u2039CLUSTER_NAME\u203a exists.</p> </li> <li> <p>Provide key value eks.amazonaws.com/role-arn: \"arn:aws:iam:::role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" into the serviceAccount.annotations parameter in values.yaml during the Loki Installation."},{"location":"operator-guide/loki-irsa/#related-articles","title":"Related Articles","text":"<ul> <li>Associate IAM Roles With Service Accounts</li> <li>Install Grafana Loki</li> </ul>"},{"location":"operator-guide/manage-jenkins-cd-job-provision/","title":"Manage Jenkins CD Pipeline Job Provisioner","text":"<p>The Jenkins CD job provisioner (or seed-job) is used to create and manage the cd-pipeline folder, and its Deploy pipelines. There is a special job-provisions/cd folder in Jenkins for these provisioners. Explore the steps for managing different provisioner types below.</p>"},{"location":"operator-guide/manage-jenkins-cd-job-provision/#default","title":"Default","text":"<p>During the EDP deployment, a default provisioner is created to deploy application with container and custom deployment type.</p> <ol> <li> <p>Find the configuration in job-provisions/cd/default.</p> </li> <li> <p>Default template is presented below:</p> View: Default template <pre><code>/* Copyright 2022 EPAM Systems.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport groovy.json.*\nimport jenkins.model.Jenkins\n\nJenkins jenkins = Jenkins.instance\n\ndef pipelineName = \"${PIPELINE_NAME}-cd-pipeline\"\ndef stageName = \"${STAGE_NAME}\"\ndef qgStages = \"${QG_STAGES}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID}\"\ndef sourceType = \"${SOURCE_TYPE}\"\ndef libraryURL = \"${LIBRARY_URL}\"\ndef libraryBranch = \"${LIBRARY_BRANCH}\"\ndef isAutoDeploy = \"${AUTODEPLOY}\"\ndef scriptPath = \"Jenkinsfile\"\ndef containerDeploymentType = \"container\"\ndef deploymentType = \"${DEPLOYMENT_TYPE}\"\ndef codebaseFolder = jenkins.getItem(pipelineName)\n\ndef autoDeploy = '{\"name\":\"auto-deploy-input\",\"step_name\":\"auto-deploy-input\"}'\ndef manualDeploy = '{\"name\":\"manual-deploy-input\",\"step_name\":\"manual-deploy-input\"}'\ndef runType = isAutoDeploy.toBoolean() ? autoDeploy : manualDeploy\n\ndef stages = buildStages(deploymentType, containerDeploymentType, qgStages, runType)\n\nif (codebaseFolder == null) {\nfolder(pipelineName)\n}\n\nif (deploymentType == containerDeploymentType) {\ncreateContainerizedCdPipeline(pipelineName, stageName, stages, scriptPath, sourceType,\nlibraryURL, libraryBranch, gitCredentialsId, gitServerCrVersion,\nisAutoDeploy)\n} else {\ncreateCustomCdPipeline(pipelineName, stageName)\n}\n\ndef buildStages(deploymentType, containerDeploymentType, qgStages, runType) {\nreturn deploymentType == containerDeploymentType\n? '[{\"name\":\"init\",\"step_name\":\"init\"},' + runType + ',{\"name\":\"deploy\",\"step_name\":\"deploy\"},' + qgStages + ',{\"name\":\"promote-images\",\"step_name\":\"promote-images\"}]'\n: ''\n}\n\ndef createContainerizedCdPipeline(pipelineName, stageName, stages, pipelineScript, sourceType, libraryURL, libraryBranch, libraryCredId, gitServerCrVersion, isAutoDeploy) {\npipelineJob(\"${pipelineName}/${stageName}\") {\nif (sourceType == \"library\") {\ndefinition {\ncpsScm {\nscm {\ngit {\nremote {\nurl(libraryURL)\ncredentials(libraryCredId)\n}\nbranches(\"${libraryBranch}\")\nscriptPath(\"${pipelineScript}\")\n}\n}\n}\n}\n} else {\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nDeploy()\")\nsandbox(true)\n}\n}\n}\nproperties {\ndisableConcurrentBuilds()\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${stages}\", \"Consequence of stages in JSON format to be run during execution\")\n\nif (isAutoDeploy?.trim() &amp;&amp; isAutoDeploy.toBoolean()) {\nstringParam(\"CODEBASE_VERSION\", null, \"Codebase versions to deploy.\")\n}\n}\n}\n}\n\ndef createCustomCdPipeline(pipelineName, stageName) {\npipelineJob(\"${pipelineName}/${stageName}\") {\nproperties {\ndisableConcurrentBuilds()\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\n}\n}\n}\n</code></pre> </li> </ol>"},{"location":"operator-guide/manage-jenkins-cd-job-provision/#custom","title":"Custom","text":"<p>In some cases, it is necessary to modify or update the job provisioner logic. For example, when adding a new stage requires a custom job provisioner created on the basis of an existing one out of the box. Take the steps below to add a custom job provision.</p> <ol> <li> <p>Navigate to the Jenkins main page and open the job-provisions/cd folder, click New Item and type the name of job provisions, for example - custom.</p> <p> CD provisioner name </p> <p>Scroll down to the Copy from field, enter \"/job-provisions/cd/default\", and click OK:   Copy CD provisioner </p> </li> <li> <p>Update the required parameters in the new provisioner. For example, if it is necessary to implement a new stage clean, add the following code to the provisioner:</p> <pre><code>   def buildStages(deploymentType, containerDeploymentType, qgStages) {\n       return deploymentType == containerDeploymentType\n? '[{\"name\":\"init\",\"step_name\":\"init\"},{\"name\":\"clean\",\"step_name\":\"clean\"},{\"name\":\"deploy\",\"step_name\":\"deploy\"},' + qgStages + ',{\"name\":\"promote-images-ecr\",\"step_name\":\"promote-images\"}]'\n: ''\n}\n</code></pre> <p>Note</p> <p>Make sure the support for the above mentioned logic is implemented. Please refer to the How to Redefine or Extend the EDP Pipeline Stages Library section of the guide.</p> <p>After the steps above are performed, the new custom job-provision will be available in Adding Stage during the CD pipeline creation in Admin Console.</p> <p> Custom CD provision </p> </li> </ol>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/","title":"Manage Jenkins CI Pipeline Job Provisioner","text":"<p>The Jenkins CI job provisioner (or seed-job) is used to create and manage the application folder, and its Code Review, Build and Create Release pipelines. Depending on the version control system, different job provisioners are used. EDP supports integration with the following version control systems:</p> <ul> <li>Gerrit (default)</li> <li>GitHub (github)</li> <li>GitLab (gitlab)</li> </ul> <p>By default, the Jenkins operator creates a pipeline for several types of application and libraries. There is a special job-provisions/ci folder in Jenkins for these provisioners. During the EDP deployment, a default provisioner is created for integration with Gerrit version control system. To configure integration with other version control systems, you need to add the required job provisioners to job-provisions/ci folder in Jenkins.</p>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#custom-custom-defaultgithubgitlab","title":"Custom (custom-default/github/gitlab)","text":"<p>In some cases it is necessary to modify or update the job provisioner logic, for example when an added other code language needs to create a custom job provisioner on the basis of an existing one out of the box. Take the steps below to add a custom job provision:</p> <ol> <li> <p>Navigate to the Jenkins main page and open the job-provisions/ci folder, click New Item and type the name of job-provisions, for example - custom-github.</p> <p> CI provisioner name </p> <p>Scroll down to the Copy from field and enter \"/job-provisions/ci/github\", and click OK:   Copy ci provisioner </p> </li> <li> <p>Update the required parameters in the new provisioner. For example, if it is necessary to implement a new build tool docker, several parameters are to be updated. Add the following stages to the docker Code Review and Build pipelines for docker application:</p> <pre><code>stages['Code-review-application-docker'] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"},{\"name\": \"build\"}]'\n...\nstages['Build-application-docker'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"lint\"},{\"name\": \"build\"},{\"name\": \"push\"},{\"name\": \"git-tag\"}]'\n...\ndef getStageKeyName(buildTool) {\n    ...\n    if (buildTool.toString().equalsIgnoreCase('docker')) {\n    return \"Code-review-application-docker\"\n}\n    ...\n}\n</code></pre> <p>Note</p> <p>Make sure the support for the above mentioned logic is implemented. Please refer to the How to Redefine or Extend the EDP Pipeline Stages Library section of the guide.</p> <p>Note</p> <p>The default template should be changed if there is another creation logic for the Code Review, Build and Create Release pipelines. Furthermore, all pipeline types should have the necessary stages as well.</p> <p>After the steps above are performed, the new custom job provision will be available in Advanced Settings during the application creation in Admin Console.</p> <p> Custom ci provision </p> </li> </ol>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#gerrit-default","title":"Gerrit (default)","text":"<p>During the EDP deployment, a default provisioner is created for integration with Gerrit version control system.</p> <ol> <li> <p>Find the configuration in job-provisions/ci/default.</p> </li> <li> <p>Default template is presented below:</p> View: Default template <pre><code>/* Copyright 2022 EPAM Systems.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport groovy.json.*\nimport jenkins.model.Jenkins\n\nJenkins jenkins = Jenkins.instance\ndef stages = [:]\ndef jiraIntegrationEnabled = Boolean.parseBoolean(\"${JIRA_INTEGRATION_ENABLED}\" as String)\ndef commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : ''\ndef createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : ''\ndef platformType = \"${PLATFORM_TYPE}\"\ndef buildStage = platformType.toString() == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}'\ndef buildTool = \"${BUILD_TOOL}\"\ndef goBuildStage = buildTool.toString() == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}'\n\nstages['Code-review-application'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + goBuildStage +\n',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]'\nstages['Code-review-library'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}]'\nstages['Code-review-autotests'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + ']'\nstages['Code-review-default'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ']'\nstages['Code-review-library-terraform'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"terraform-lint\"}]'\nstages['Code-review-library-opa'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"}]'\nstages['Code-review-library-codenarc'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}]'\nstages['Code-review-library-kaniko'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"dockerbuild-verify\"}]'\n\nstages['Build-library-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-npm'] = stages['Build-library-maven']\nstages['Build-library-gradle'] = stages['Build-library-maven']\nstages['Build-library-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' +\n',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-opa'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-codenarc'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-autotests-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-autotests-gradle'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-application-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-npm'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-gradle'] = stages['Build-application-maven']\nstages['Build-application-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-go'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"tests\"}' +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"}' +\n\"${buildStage}\" + ',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Create-release'] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]'\n\ndef defaultBuild = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']'\n\ndef codebaseName = \"${NAME}\"\ndef gitServerCrName = \"${GIT_SERVER_CR_NAME}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\"\ndef repositoryPath = \"${REPOSITORY_PATH}\"\ndef defaultBranch = \"${DEFAULT_BRANCH}\"\n\ndef codebaseFolder = jenkins.getItem(codebaseName)\nif (codebaseFolder == null) {\nfolder(codebaseName)\n}\n\ncreateListView(codebaseName, \"Releases\")\ncreateReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"CreateRelease\",\nrepositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch)\n\nif (buildTool.toString().equalsIgnoreCase('none')) {\nreturn true\n}\n\nif (BRANCH) {\ndef branch = \"${BRANCH}\"\ndef formattedBranch = \"${branch.toUpperCase().replaceAll(/\\//, \"-\")}\"\ncreateListView(codebaseName, formattedBranch)\n\ndef type = \"${TYPE}\"\ndef crKey = getStageKeyName(buildTool)\ncreateCiPipeline(\"Code-review-${codebaseName}\", codebaseName, stages[crKey], \"CodeReview\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\ndef buildKey = \"Build-${type}-${buildTool.toLowerCase()}\".toString()\nif (type.equalsIgnoreCase('application') || type.equalsIgnoreCase('library') || type.equalsIgnoreCase('autotests')) {\ndef jobExists = false\nif(\"${formattedBranch}-Build-${codebaseName}\".toString() in Jenkins.instance.getAllItems().collect{it.name})\njobExists = true\n\ncreateCiPipeline(\"Build-${codebaseName}\", codebaseName, stages.get(buildKey, defaultBuild), \"Build\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\nif(!jobExists)\nqueue(\"${codebaseName}/${formattedBranch}-Build-${codebaseName}\")\n}\n}\n\ndef createCiPipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId, watchBranch, gitServerCrName, gitServerCrVersion) {\npipelineJob(\"${codebaseName}/${watchBranch.toUpperCase().replaceAll(/\\//, \"-\")}-${pipelineName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\ntriggers {\ngerrit {\nevents {\nif (pipelineName.contains(\"Build\"))\nchangeMerged()\nelse\npatchsetCreated()\n}\nproject(\"plain:${codebaseName}\", [\"plain:${watchBranch}\"])\n}\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nstringParam(\"BRANCH\", \"${watchBranch}\", \"Branch to build artifact from\")\n}\n}\n}\n}\n\ndef getStageKeyName(buildTool) {\nif (buildTool.toString().equalsIgnoreCase('terraform')) {\nreturn \"Code-review-library-terraform\"\n}\nif (buildTool.toString().equalsIgnoreCase('opa')) {\nreturn \"Code-review-library-opa\"\n}\nif (buildTool.toString().equalsIgnoreCase('codenarc')) {\nreturn \"Code-review-library-codenarc\"\n}\nif (buildTool.toString().equalsIgnoreCase('kaniko')) {\nreturn \"Code-review-library-kaniko\"\n}\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\nreturn supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\"\n}\n\ndef createReleasePipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId,\ngitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch) {\npipelineJob(\"${codebaseName}/${pipelineName}\") {\nlogRotator {\nnumToKeep(14)\ndaysToKeep(30)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"STAGES\", \"${codebaseStages}\", \"\")\nif (pipelineName.contains(\"Create-release\")) {\nstringParam(\"JIRA_INTEGRATION_ENABLED\", \"${jiraIntegrationEnabled}\", \"Is Jira integration enabled\")\nstringParam(\"PLATFORM_TYPE\", \"${platformType}\", \"Platform type\")\nstringParam(\"GERRIT_PROJECT\", \"${codebaseName}\", \"\")\nstringParam(\"RELEASE_NAME\", \"\", \"Name of the release(branch to be created)\")\nstringParam(\"COMMIT_ID\", \"\", \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\")\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"REPOSITORY_PATH\", \"${repository}\", \"Full repository path\")\nstringParam(\"DEFAULT_BRANCH\", \"${defaultBranch}\", \"Default repository branch\")\n}\n}\n}\n}\n}\n\ndef createListView(codebaseName, branchName) {\nlistView(\"${codebaseName}/${branchName}\") {\nif (branchName.toLowerCase() == \"releases\") {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^Create-release.*\")\n}\n}\n} else {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^${branchName}-(Code-review|Build).*\")\n}\n}\n}\ncolumns {\nstatus()\nweather()\nname()\nlastSuccess()\nlastFailure()\nlastDuration()\nbuildButton()\n}\n}\n}\n</code></pre> <p>Job Provision Pipeline Parameters</p> <p>The job-provisions pipeline consists of the following parameters:</p> </li> </ol> <ul> <li>NAME - the application name;</li> </ul> <ul> <li>TYPE - the codebase type (the application / library / autotest);</li> </ul> <ul> <li>BUILD_TOOL - a tool that is used to build the application;</li> </ul> <ul> <li>BRANCH - a branch name;</li> </ul> <ul> <li>GIT_SERVER_CR_NAME - the name of the application Git server custom resource;</li> </ul> <ul> <li>GIT_SERVER_CR_VERSION - the version of the application Git server custom resource;</li> </ul> <ul> <li>GIT_CREDENTIALS_ID - the secret name where Git server credentials are stored (default 'gerrit-ciuser-sshkey');</li> </ul> <ul> <li>REPOSITORY_PATH - the full repository path;</li> </ul> <ul> <li>JIRA_INTEGRATION_ENABLED - the Jira integration is enabled or not;</li> </ul> <ul> <li>PLATFORM_TYPE - the type of platform (kubernetes or openshift);</li> </ul> <ul> <li>DEFAULT_BRANCH - the default repository branch.</li> </ul>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#github-github","title":"GitHub (github)","text":"<p>To create a new job provision for work with GitHub, take the following steps:</p> <ol> <li> <p>Navigate to the Jenkins main page and open the job-provisions/ci folder.</p> </li> <li> <p>Click New Item and type the name of job-provisions - github.</p> </li> <li> <p>Select the Freestyle project option and click OK.</p> </li> <li> <p>Select the Discard old builds check box and configure a few parameters:</p> <p>Strategy: Log Rotation</p> <p>Days to keep builds: 10</p> <p>Max # of builds to keep: 10</p> </li> <li> <p>Select the This project is parameterized check box and add a few input parameters:</p> <ul> <li>NAME;</li> </ul> <ul> <li>TYPE;</li> </ul> <ul> <li>BUILD_TOOL;</li> </ul> <ul> <li>BRANCH;</li> </ul> <ul> <li>GIT_SERVER_CR_NAME;</li> </ul> <ul> <li>GIT_SERVER_CR_VERSION;</li> </ul> <ul> <li>GIT_CREDENTIALS_ID;</li> </ul> <ul> <li>REPOSITORY_PATH;</li> </ul> <ul> <li>JIRA_INTEGRATION_ENABLED;</li> </ul> <ul> <li>PLATFORM_TYPE;</li> </ul> <ul> <li>DEFAULT_BRANCH.</li> </ul> </li> <li> <p>Check the Execute concurrent builds if necessary option.</p> </li> <li> <p>Check the Restrict where this project can be run option.</p> </li> <li> <p>Fill in the Label Expression field by typing master to ensure job runs on Jenkins Master.</p> </li> <li> <p>In the Build section, perform the following:</p> <ul> <li>Select DSL Script;</li> </ul> <ul> <li>Select the Use the provided DSL script check box:</li> </ul> <p> DSL script check box </p> </li> <li> <p>As soon as all the steps above are performed, insert the code:</p> View: Template <pre><code>import groovy.json.*\nimport jenkins.model.Jenkins\nimport javaposse.jobdsl.plugin.*\nimport com.cloudbees.hudson.plugins.folder.*\n\nJenkins jenkins = Jenkins.instance\ndef stages = [:]\ndef jiraIntegrationEnabled = Boolean.parseBoolean(\"${JIRA_INTEGRATION_ENABLED}\" as String)\ndef commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : ''\ndef createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : ''\ndef platformType = \"${PLATFORM_TYPE}\"\ndef buildStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}'\ndef buildTool = \"${BUILD_TOOL}\"\ndef goBuildStage = buildTool.toString() == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}'\n\nstages['Code-review-application'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + goBuildStage +\n',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]'\nstages['Code-review-library'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"compile\"},{\"name\": \"tests\"},' +\n'{\"name\": \"sonar\"}]'\nstages['Code-review-autotests'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + ']'\nstages['Code-review-default'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ']'\nstages['Code-review-library-terraform'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"terraform-lint\"}]'\nstages['Code-review-library-opa'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"}]'\nstages['Code-review-library-codenarc'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}]'\nstages['Code-review-library-kaniko'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"dockerbuild-verify\"}]'\n\nstages['Build-library-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-npm'] = stages['Build-library-maven']\nstages['Build-library-gradle'] = stages['Build-library-maven']\nstages['Build-library-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' +\n',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-opa'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-codenarc'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-autotests-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-autotests-gradle'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-application-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-npm'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-gradle'] = stages['Build-application-maven']\nstages['Build-application-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildStage}\" +\n',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-go'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build\"}' + \"${buildStage}\" + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}' +\n\"${buildStage}\" + ',{\"name\":\"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Create-release'] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]'\n\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef defaultStages = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']'\n\ndef codebaseName = \"${NAME}\"\ndef gitServerCrName = \"${GIT_SERVER_CR_NAME}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\"\ndef repositoryPath = \"${REPOSITORY_PATH.replaceAll(~/:\\d+\\\\//,\"/\")}\"\ndef githubRepository = \"https://${repositoryPath.split(\"@\")[1]}\"\ndef defaultBranch = \"${DEFAULT_BRANCH}\"\n\ndef codebaseFolder = jenkins.getItem(codebaseName)\nif (codebaseFolder == null) {\n    folder(codebaseName)\n}\n\ncreateListView(codebaseName, \"Releases\")\ncreateReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"CreateRelease\",\n        repositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch)\n\nif (buildTool.toString().equalsIgnoreCase('none')) {\n    return true\n}\n\nif (BRANCH) {\n    def branch = \"${BRANCH}\"\n    def formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \"-\")}\"\ncreateListView(codebaseName, formattedBranch)\n\ndef type = \"${TYPE}\"\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\ndef crKey = getStageKeyName(buildTool).toString()\ncreateCodeReviewPipeline(\"Code-review-${codebaseName}\", codebaseName, stages.get(crKey, defaultStages), \"CodeReview\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion, githubRepository)\nregisterWebHook(repositoryPath)\n\n\ndef buildKey = \"Build-${type}-${buildTool.toLowerCase()}\".toString()\n\nif (type.equalsIgnoreCase('application') || type.equalsIgnoreCase('library') || type.equalsIgnoreCase('autotests')) {\ndef jobExists = false\nif(\"${formattedBranch}-Build-${codebaseName}\".toString() in Jenkins.instance.getAllItems().collect{it.name})\njobExists = true\ncreateBuildPipeline(\"Build-${codebaseName}\", codebaseName, stages.get(buildKey, defaultStages), \"Build\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion, githubRepository)\nregisterWebHook(repositoryPath, 'build')\n\nif(!jobExists)\nqueue(\"${codebaseName}/${formattedBranch}-Build-${codebaseName}\")\n}\n}\n\ndef getStageKeyName(buildTool) {\nif (buildTool.toString().equalsIgnoreCase('terraform')) {\nreturn \"Code-review-library-terraform\"\n}\nif (buildTool.toString().equalsIgnoreCase('opa')) {\nreturn \"Code-review-library-opa\"\n}\nif (buildTool.toString().equalsIgnoreCase('codenarc')) {\nreturn \"Code-review-library-codenarc\"\n}\nif (buildTool.toString().equalsIgnoreCase('kaniko')) {\nreturn \"Code-review-library-kaniko\"\n}\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\nreturn supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\"\n}\n\ndef createCodeReviewPipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId, defaultBranch, gitServerCrName, gitServerCrVersion, githubRepository) {\npipelineJob(\"${codebaseName}/${defaultBranch.toUpperCase().replaceAll(/\\\\//, \"-\")}-${pipelineName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nif (pipelineName.contains(\"Build\"))\nstringParam(\"BRANCH\", \"${defaultBranch}\", \"Branch to build artifact from\")\nelse\nstringParam(\"BRANCH\", \"\\${ghprbActualCommit}\", \"Branch to build artifact from\")\n}\n}\ntriggers {\ngithubPullRequest {\ncron('')\nonlyTriggerPhrase(false)\nuseGitHubHooks(true)\npermitAll(true)\nautoCloseFailedPullRequests(false)\ndisplayBuildErrorsOnDownstreamBuilds(false)\nwhiteListTargetBranches([defaultBranch.toString()])\nextensions {\ncommitStatus {\ncontext('Jenkins Code-Review')\ntriggeredStatus('Build is Triggered')\nstartedStatus('Build is Started')\naddTestResults(true)\ncompletedStatus('SUCCESS', 'Verified')\ncompletedStatus('FAILURE', 'Failed')\ncompletedStatus('PENDING', 'Penging')\ncompletedStatus('ERROR', 'Error')\n}\n}\n}\n}\nproperties {\ngithubProjectProperty {\nprojectUrlStr(\"${githubRepository}\")\n}\n}\n}\n}\n\ndef createBuildPipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId, defaultBranch, gitServerCrName, gitServerCrVersion, githubRepository) {\npipelineJob(\"${codebaseName}/${defaultBranch.toUpperCase().replaceAll(/\\\\//, \"-\")}-${pipelineName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nnode {\\n    git credentialsId: \\'${credId}\\', url: \\'${repository}\\', branch: \\'${BRANCH}\\'\\n}\\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nstringParam(\"BRANCH\", \"${defaultBranch}\", \"Branch to run from\")\n}\n}\ntriggers {\ngitHubPushTrigger()\n}\nproperties {\ngithubProjectProperty {\nprojectUrlStr(\"${githubRepository}\")\n}\n}\n}\n}\n\n\ndef createListView(codebaseName, branchName) {\nlistView(\"${codebaseName}/${branchName}\") {\nif (branchName.toLowerCase() == \"releases\") {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^Create-release.*\")\n}\n}\n} else {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^${branchName}-(Code-review|Build).*\")\n}\n}\n}\ncolumns {\nstatus()\nweather()\nname()\nlastSuccess()\nlastFailure()\nlastDuration()\nbuildButton()\n}\n}\n}\n\ndef createReleasePipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId,\ngitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch) {\npipelineJob(\"${codebaseName}/${pipelineName}\") {\nlogRotator {\nnumToKeep(14)\ndaysToKeep(30)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"STAGES\", \"${codebaseStages}\", \"\")\nif (pipelineName.contains(\"Create-release\")) {\nstringParam(\"JIRA_INTEGRATION_ENABLED\", \"${jiraIntegrationEnabled}\", \"Is Jira integration enabled\")\nstringParam(\"PLATFORM_TYPE\", \"${platformType}\", \"Platform type\")\nstringParam(\"GERRIT_PROJECT\", \"${codebaseName}\", \"\")\nstringParam(\"RELEASE_NAME\", \"\", \"Name of the release(branch to be created)\")\nstringParam(\"COMMIT_ID\", \"\", \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\")\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"REPOSITORY_PATH\", \"${repository}\", \"Full repository path\")\nstringParam(\"DEFAULT_BRANCH\", \"${defaultBranch}\", \"Default repository branch\")\n}\n}\n}\n}\n}\n\ndef registerWebHook(repositoryPath, type = 'code-review') {\ndef url = repositoryPath.split('@')[1].split('/')[0]\ndef owner = repositoryPath.split('@')[1].split('/')[1]\ndef repo = repositoryPath.split('@')[1].split('/')[2]\ndef apiUrl = 'https://api.' + url + '/repos/' + owner + '/' + repo + '/hooks'\ndef webhookUrl = ''\ndef webhookConfig = [:]\ndef config = [:]\ndef events = []\n\nif (type.equalsIgnoreCase('build')) {\nwebhookUrl = System.getenv('JENKINS_UI_URL') + \"/github-webhook/\"\nevents = [\"push\"]\nconfig[\"url\"] = webhookUrl\nconfig[\"content_type\"] = \"json\"\nconfig[\"insecure_ssl\"] = 0\nwebhookConfig[\"name\"] = \"web\"\nwebhookConfig[\"config\"] = config\nwebhookConfig[\"events\"] = events\nwebhookConfig[\"active\"] = true\n\n} else {\nwebhookUrl = System.getenv('JENKINS_UI_URL') + \"/ghprbhook/\"\nevents = [\"issue_comment\",\"pull_request\"]\nconfig[\"url\"] = webhookUrl\nconfig[\"content_type\"] = \"form\"\nconfig[\"insecure_ssl\"] = 0\nwebhookConfig[\"name\"] = \"web\"\nwebhookConfig[\"config\"] = config\nwebhookConfig[\"events\"] = events\nwebhookConfig[\"active\"] = true\n}\n\ndef requestBody = JsonOutput.toJson(webhookConfig)\ndef http = new URL(apiUrl).openConnection() as HttpURLConnection\nhttp.setRequestMethod('POST')\nhttp.setDoOutput(true)\nprintln(apiUrl)\nhttp.setRequestProperty(\"Accept\", 'application/json')\nhttp.setRequestProperty(\"Content-Type\", 'application/json')\nhttp.setRequestProperty(\"Authorization\", \"token ${getSecretValue('github-access-token')}\")\nhttp.outputStream.write(requestBody.getBytes(\"UTF-8\"))\nhttp.connect()\nprintln(http.responseCode)\n\nif (http.responseCode == 201) {\nresponse = new JsonSlurper().parseText(http.inputStream.getText('UTF-8'))\n} else {\nresponse = new JsonSlurper().parseText(http.errorStream.getText('UTF-8'))\n}\n\nprintln \"response: ${response}\"\n}\n\ndef getSecretValue(name) {\ndef creds = com.cloudbees.plugins.credentials.CredentialsProvider.lookupCredentials(\ncom.cloudbees.plugins.credentials.common.StandardCredentials.class,\nJenkins.instance,\nnull,\nnull\n)\n\ndef secret = creds.find { it.properties['id'] == name }\nreturn secret != null ? secret['secret'] : null\n}\n</code></pre> <p>After the steps above are performed, the new custom job-provision will be available in Advanced Settings during the application creation in Admin Console.</p> <p> Github job provision </p> </li> </ol>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#gitlab-gitlab","title":"GitLab (gitlab)","text":"<p>To create a new job provision for work with GitLab, take the following steps:</p> <ol> <li> <p>Navigate to the Jenkins main page and open the job-provisions/ci folder.</p> </li> <li> <p>Click New Item and type the name of job-provisions - gitlab.</p> </li> <li> <p>Select the Freestyle project option and click OK.</p> </li> <li> <p>Select the Discard old builds check box and configure a few parameters:</p> <p>Strategy: Log Rotation</p> <p>Days to keep builds: 10</p> <p>Max # of builds to keep: 10</p> </li> <li> <p>Select the This project is parameterized check box and add a few input parameters as the following strings:</p> <ul> <li>NAME;</li> </ul> <ul> <li>TYPE;</li> </ul> <ul> <li>BUILD_TOOL;</li> </ul> <ul> <li>BRANCH;</li> </ul> <ul> <li>GIT_SERVER_CR_NAME;</li> </ul> <ul> <li>GIT_SERVER_CR_VERSION;</li> </ul> <ul> <li>GIT_SERVER;</li> </ul> <ul> <li>GIT_SSH_PORT;</li> </ul> <ul> <li>GIT_USERNAME;</li> </ul> <ul> <li>GIT_CREDENTIALS_ID;</li> </ul> <ul> <li>REPOSITORY_PATH;</li> </ul> <ul> <li>JIRA_INTEGRATION_ENABLED;</li> </ul> <ul> <li>PLATFORM_TYPE;</li> </ul> <ul> <li>DEFAULT_BRANCH;</li> </ul> </li> <li> <p>Check the Execute concurrent builds if necessary option.</p> </li> <li> <p>Check the Restrict where this project can be run option.</p> </li> <li> <p>Fill in the Label Expression field by typing master to ensure job runs on Jenkins Master.</p> </li> <li> <p>In the Build section, perform the following:</p> <ul> <li>Select DSL Script;</li> </ul> <ul> <li>Select the Use the provided DSL script check box:</li> </ul> <p> DSL script check box </p> </li> <li> <p>As soon as all the steps above are performed, insert the code:</p> View: Template <pre><code>import groovy.json.*\nimport jenkins.model.Jenkins\n\nJenkins jenkins = Jenkins.instance\ndef stages = [:]\ndef jiraIntegrationEnabled = Boolean.parseBoolean(\"${JIRA_INTEGRATION_ENABLED}\" as String)\ndef commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : ''\ndef createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : ''\ndef platformType = \"${PLATFORM_TYPE}\"\ndef buildTool = \"${BUILD_TOOL}\"\ndef buildImageStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"},' : ',{\"name\": \"build-image-from-dockerfile\"},'\ndef goBuildImageStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}'\ndef goBuildStage = buildTool.toString() == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}'\n\nstages['Code-review-application'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + goBuildStage +\n',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]'\nstages['Code-review-library'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"compile\"},{\"name\": \"tests\"},' +\n'{\"name\": \"sonar\"}]'\nstages['Code-review-autotests'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + ']'\nstages['Code-review-default'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ']'\nstages['Code-review-library-terraform'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"terraform-lint\"}]'\nstages['Code-review-library-opa'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"}]'\nstages['Code-review-library-codenarc'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}]'\nstages['Code-review-library-kaniko'] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"dockerbuild-verify\"}]'\n\nstages['Build-library-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-npm'] = stages['Build-library-maven']\nstages['Build-library-gradle'] = stages['Build-library-maven']\nstages['Build-library-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' +\n',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-opa'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-codenarc'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-autotests-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-autotests-gradle'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\nstages['Build-application-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildImageStage}\" +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}' +\n\"${buildImageStage}\" + '{\"name\":\"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-npm'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildImageStage}\" +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-gradle'] = stages['Build-application-maven']\nstages['Build-application-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildImageStage}\" +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"tool-init\"},' +\n'{\"name\": \"lint\"},{\"name\": \"git-tag\"}]'\nstages['Build-application-helm'] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"}]'\nstages['Build-application-docker'] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"}]'\nstages['Build-application-go'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sast\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build\"}' + \"${goBuildImageStage}\" + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Create-release'] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]'\n\ndef defaultStages = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']'\n\n\ndef codebaseName = \"${NAME}\"\ndef gitServerCrName = \"${GIT_SERVER_CR_NAME}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitServer = \"${GIT_SERVER ? GIT_SERVER : 'gerrit'}\"\ndef gitSshPort = \"${GIT_SSH_PORT ? GIT_SSH_PORT : '29418'}\"\ndef gitUsername = \"${GIT_USERNAME ? GIT_USERNAME : 'jenkins'}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\"\ndef defaultRepoPath = \"ssh://${gitUsername}@${gitServer}:${gitSshPort}/${codebaseName}\"\ndef repositoryPath = \"${REPOSITORY_PATH ? REPOSITORY_PATH : defaultRepoPath}\"\ndef defaultBranch = \"${DEFAULT_BRANCH}\"\n\ndef codebaseFolder = jenkins.getItem(codebaseName)\nif (codebaseFolder == null) {\nfolder(codebaseName)\n}\n\ncreateListView(codebaseName, \"Releases\")\ncreateReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"CreateRelease\",\nrepositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch)\n\nif (BRANCH) {\ndef branch = \"${BRANCH}\"\ndef formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \"-\")}\"\ncreateListView(codebaseName, formattedBranch)\n\ndef type = \"${TYPE}\"\ndef crKey = getStageKeyName(buildTool).toString()\ncreateCiPipeline(\"Code-review-${codebaseName}\", codebaseName, stages.get(crKey, defaultStages), \"CodeReview\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\ndef buildKey = \"Build-${type}-${buildTool.toLowerCase()}\".toString()\n\nif (type.equalsIgnoreCase('application') || type.equalsIgnoreCase('library') || type.equalsIgnoreCase('autotests')) {\ndef jobExists = false\nif(\"${formattedBranch}-Build-${codebaseName}\".toString() in Jenkins.instance.getAllItems().collect{it.name}) {\njobExists = true\n}\ncreateCiPipeline(\"Build-${codebaseName}\", codebaseName, stages.get(buildKey, defaultStages), \"Build\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\nif(!jobExists) {\nqueue(\"${codebaseName}/${formattedBranch}-Build-${codebaseName}\")\n}\n}\n}\n\n\ndef createCiPipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId, defaultBranch, gitServerCrName, gitServerCrVersion) {\ndef jobName = \"${defaultBranch.toUpperCase().replaceAll(/\\\\//, \"-\")}-${pipelineName}\"\ndef existingJob = Jenkins.getInstance().getItemByFullName(\"${codebaseName}/${jobName}\")\ndef webhookToken = null\nif (existingJob) {\ndef triggersMap = existingJob.getTriggers()\ntriggersMap.each { key, value -&gt;\nwebhookToken = value.getSecretToken()\n}\n} else {\ndef random = new byte[16]\nnew java.security.SecureRandom().nextBytes(random)\nwebhookToken = random.encodeHex().toString()\n}\npipelineJob(\"${codebaseName}/${jobName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\nproperties {\ngitLabConnection {\ngitLabConnection('gitlab')\n}\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nif (pipelineName.contains(\"Build\"))\nstringParam(\"BRANCH\", \"${defaultBranch}\", \"Branch to build artifact from\")\nelse\nstringParam(\"BRANCH\", \"\\${gitlabMergeRequestLastCommit}\", \"Branch to build artifact from\")\n}\n}\ntriggers {\ngitlabPush {\nbuildOnMergeRequestEvents(pipelineName.contains(\"Build\") ? false : true)\nbuildOnPushEvents(pipelineName.contains(\"Build\") ? true : false)\nenableCiSkip(false)\nsetBuildDescription(true)\nrebuildOpenMergeRequest(pipelineName.contains(\"Build\") ? 'never' : 'source')\ncommentTrigger(\"Build it please\")\nskipWorkInProgressMergeRequest(true)\ntargetBranchRegex(\"${defaultBranch}\")\n}\n}\nconfigure {\nit / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' &lt;&lt; secretToken(webhookToken)\nit / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' &lt;&lt; triggerOnApprovedMergeRequest(pipelineName.contains(\"Build\") ? false : true)\nit / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' &lt;&lt; pendingBuildName(pipelineName.contains(\"Build\") ? \"\" : \"Jenkins\")\n}\n}\nregisterWebHook(repository, codebaseName, jobName, webhookToken)\n}\n\ndef getStageKeyName(buildTool) {\nif (buildTool.toString().equalsIgnoreCase('terraform')) {\nreturn \"Code-review-library-terraform\"\n}\nif (buildTool.toString().equalsIgnoreCase('opa')) {\nreturn \"Code-review-library-opa\"\n}\nif (buildTool.toString().equalsIgnoreCase('codenarc')) {\nreturn \"Code-review-library-codenarc\"\n}\nif (buildTool.toString().equalsIgnoreCase('kaniko')) {\nreturn \"Code-review-library-kaniko\"\n}\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\nreturn supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\"\n}\n\ndef createReleasePipeline(pipelineName, codebaseName, codebaseStages, pipelineType, repository, credId,\ngitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch) {\npipelineJob(\"${codebaseName}/${pipelineName}\") {\nlogRotator {\nnumToKeep(14)\ndaysToKeep(30)\n}\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\")\nsandbox(true)\n}\nparameters {\nstringParam(\"STAGES\", \"${codebaseStages}\", \"\")\nif (pipelineName.contains(\"Create-release\")) {\nstringParam(\"JIRA_INTEGRATION_ENABLED\", \"${jiraIntegrationEnabled}\", \"Is Jira integration enabled\")\nstringParam(\"PLATFORM_TYPE\", \"${platformType}\", \"Platform type\")\nstringParam(\"GERRIT_PROJECT\", \"${codebaseName}\", \"\")\nstringParam(\"RELEASE_NAME\", \"\", \"Name of the release(branch to be created)\")\nstringParam(\"COMMIT_ID\", \"\", \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\")\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"REPOSITORY_PATH\", \"${repository}\", \"Full repository path\")\nstringParam(\"DEFAULT_BRANCH\", \"${defaultBranch}\", \"Default repository branch\")\n}\n}\n}\n}\n}\n\ndef createListView(codebaseName, branchName) {\nlistView(\"${codebaseName}/${branchName}\") {\nif (branchName.toLowerCase() == \"releases\") {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^Create-release.*\")\n}\n}\n} else {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^${branchName}-(Code-review|Build).*\")\n}\n}\n}\ncolumns {\nstatus()\nweather()\nname()\nlastSuccess()\nlastFailure()\nlastDuration()\nbuildButton()\n}\n}\n}\n\ndef registerWebHook(repositoryPath, codebaseName, jobName, webhookToken) {\ndef apiUrl = 'https://' + repositoryPath.replaceAll(\"ssh://\", \"\").split('@')[1].replace('/', \"%2F\").replaceAll(~/:\\d+%2F/, '/api/v4/projects/') + '/hooks'\ndef jobWebhookUrl = \"${System.getenv('JENKINS_UI_URL')}/project/${codebaseName}/${jobName}\"\ndef gitlabToken = getSecretValue('gitlab-access-token')\n\nif (checkWebHookExist(apiUrl, jobWebhookUrl, gitlabToken)) {\nprintln(\"[JENKINS][DEBUG] Webhook for job ${jobName} is already exist\\r\\n\")\nreturn\n}\n\nprintln(\"[JENKINS][DEBUG] Creating webhook for job ${jobName}\")\ndef webhookConfig = [:]\nwebhookConfig[\"url\"] = jobWebhookUrl\nwebhookConfig[\"push_events\"] = jobName.contains(\"Build\") ? \"true\" : \"false\"\nwebhookConfig[\"merge_requests_events\"] = jobName.contains(\"Build\") ? \"false\" : \"true\"\nwebhookConfig[\"issues_events\"] = \"false\"\nwebhookConfig[\"confidential_issues_events\"] = \"false\"\nwebhookConfig[\"tag_push_events\"] = \"false\"\nwebhookConfig[\"note_events\"] = \"true\"\nwebhookConfig[\"job_events\"] = \"false\"\nwebhookConfig[\"pipeline_events\"] = \"false\"\nwebhookConfig[\"wiki_page_events\"] = \"false\"\nwebhookConfig[\"enable_ssl_verification\"] = \"true\"\nwebhookConfig[\"token\"] = webhookToken\ndef requestBody = JsonOutput.toJson(webhookConfig)\ndef httpConnector = new URL(apiUrl).openConnection() as HttpURLConnection\nhttpConnector.setRequestMethod('POST')\nhttpConnector.setDoOutput(true)\n\nhttpConnector.setRequestProperty(\"Accept\", 'application/json')\nhttpConnector.setRequestProperty(\"Content-Type\", 'application/json')\nhttpConnector.setRequestProperty(\"PRIVATE-TOKEN\", \"${gitlabToken}\")\nhttpConnector.outputStream.write(requestBody.getBytes(\"UTF-8\"))\nhttpConnector.connect()\n\nif (httpConnector.responseCode == 201)\nprintln(\"[JENKINS][DEBUG] Webhook for job ${jobName} has been created\\r\\n\")\nelse {\nprintln(\"[JENKINS][ERROR] Responce code - ${httpConnector.responseCode}\")\ndef response = new JsonSlurper().parseText(httpConnector.errorStream.getText('UTF-8'))\nprintln(\"[JENKINS][ERROR] Failed to create webhook for job ${jobName}. Response - ${response}\")\n}\n}\n\ndef checkWebHookExist(apiUrl, jobWebhookUrl, gitlabToken) {\nprintln(\"[JENKINS][DEBUG] Checking if webhook ${jobWebhookUrl} exists\")\ndef httpConnector = new URL(apiUrl).openConnection() as HttpURLConnection\nhttpConnector.setRequestMethod('GET')\nhttpConnector.setDoOutput(true)\n\nhttpConnector.setRequestProperty(\"Accept\", 'application/json')\nhttpConnector.setRequestProperty(\"Content-Type\", 'application/json')\nhttpConnector.setRequestProperty(\"PRIVATE-TOKEN\", \"${gitlabToken}\")\nhttpConnector.connect()\n\nif (httpConnector.responseCode == 200) {\ndef response = new JsonSlurper().parseText(httpConnector.inputStream.getText('UTF-8'))\nreturn response.find { it.url == jobWebhookUrl } ? true : false\n}\n}\n\ndef getSecretValue(name) {\ndef creds = com.cloudbees.plugins.credentials.CredentialsProvider.lookupCredentials(\ncom.cloudbees.plugins.credentials.common.StandardCredentials.class,\nJenkins.instance,\nnull,\nnull\n)\n\ndef secret = creds.find { it.properties['id'] == name }\nreturn secret != null ? secret['secret'] : null\n}\n</code></pre> </li> <li> <p>Create Secret, GitServer CR and Jenkins credentials with the \"gitlab\" ID by following the instruction: Adjust Import Strategy.</p> <p>After the steps above are performed, the new custom job-provision will be available in Advanced Settings during the application creation in Admin Console.</p> <p> Gitlab job provision </p> </li> </ol>"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#related-articles","title":"Related Articles","text":"<ul> <li>CI Pipeline for Container</li> </ul>"},{"location":"operator-guide/multitenant-logging/","title":"Multitenant Logging","text":"<p>Get acquainted with the multitenant logging components and the project logs location in the Shared cluster.</p>"},{"location":"operator-guide/multitenant-logging/#logging-components","title":"Logging Components","text":"<p>To configure the multitenant logging, it is necessary to deploy the following components:</p> <ul> <li>Grafana</li> <li>Loki</li> <li>Logging-operator</li> <li>Logging-operator stack-fluentbit</li> </ul> <p>In Grafana, every tenant represents an organization, i.e. it is necessary to create an organization for every namespace in the cluster. To get more details regarding the architecture of the Logging Operator, please review the Diagram 1.</p> <p> Logging operator scheme </p> <p>Note</p> <p>It is necessary to deploy Loki with the <code>auth_enabled: true</code> flag with the aim to ensure that the logs are separated for each tenant. For the authentication, Loki requires the HTTP header X-Scope-OrgID.</p>"},{"location":"operator-guide/multitenant-logging/#review-project-logs-in-grafana","title":"Review Project Logs in Grafana","text":"<p>To find the project logs, navigate to Grafana and follow the steps below:</p> <p>Note</p> <p>Grafana is a common service for different customers where each customer works in its own separated Grafana Organization and doesn't have any access to another project.</p> <ol> <li> <p>Choose the organization by clicking the Current Organization drop-down list. If a user is assigned to several organizations, switch easily by using the Switch button.</p> <p> Current organization </p> </li> <li> <p>Navigate to the left-side menu and click the Explore button to see the Log Browser:</p> <p> Grafana explore </p> </li> <li> <p>Click the Log Browser button to see the labels that can be used to filter logs (e.g., hostname, namespace, application name, pod, etc.):</p> <p>Note</p> <p>Enable the correct data source, select the relevant logging data from the top left-side corner, and pay attention that the data source name always follows the \u2039project_name\u203a-logging pattern.</p> <p> Log browser </p> </li> <li> <p>Filter out logs by clicking the Show logs button or write the query and click the Run query button.</p> </li> <li> <p>Review the results with the quantity of logs per time, see the example below:</p> <p> Logs example </p> <ul> <li>Expand the logs to get detailed information about the object entry:</li> </ul> <p> Expand logs </p> <ul> <li>Use the following buttons to include or remove the labels from the query:</li> </ul> <p> Addition button </p> <ul> <li>See the ad-hoc statistics for a particular label:</li> </ul> <p> Ad-hoc stat example </p> </li> </ol>"},{"location":"operator-guide/multitenant-logging/#related-articles","title":"Related Articles","text":"<ul> <li>Grafana Documentation</li> </ul>"},{"location":"operator-guide/openshift-cluster-settings/","title":"Set Up OpenShift","text":"<p>Make sure the cluster meets the following conditions:</p> <ol> <li> <p>OpenShift cluster is installed with minimum 2 worker nodes with total capacity 8 Cores and 32Gb RAM.</p> </li> <li> <p>Load balancer (if any exists in front of OpenShift router or ingress controller) is configured with session stickiness, disabled HTTP/2 protocol and header size of 64k support.</p> <p>Find below an example of the Config Map for the NGINX Ingress Controller:</p> <pre><code>kind: ConfigMap\napiVersion: v1\nmetadata:\nname: nginx-configuration\nnamespace: ingress-nginx\nlabels:\napp.kubernetes.io/name: ingress-nginx\napp.kubernetes.io/part-of: ingress-nginx\ndata:\nclient-header-buffer-size: 64k\nlarge-client-header-buffers: 4 64k\nuse-http2: \"false\"\n</code></pre> </li> <li> <p>Cluster nodes and pods have access to the cluster via external URLs. For instance, add in AWS the VPC NAT gateway elastic IP to the cluster external load balancers security group).</p> </li> <li> <p>Keycloak instance is installed. To get accurate information on how to install Keycloak, please refer to the Install Keycloak instruction.</p> </li> <li> <p>The installation machine with oc is installed with the cluster-admin access to the OpenShift cluster.</p> </li> <li> <p>Helm 3.10 is installed on the installation machine with the help of the Installing Helm instruction.</p> </li> <li> <p>Storage classes are used with the Retain Reclaim Policy and Delete Reclaim Policy.</p> <p>Info</p> <p>By default, EDP uses the default Storage Class in a cluster. The EDP development team recommends using the following Storage Classes. See an example below.</p> <p>Storage class templates with the Retain and Delete Reclaim Policies:</p> gp3gp3-retain <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp3\nannotations:\nstorageclass.kubernetes.io/is-default-class: 'true'\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Delete\nvolumeBindingMode: Immediate\nallowVolumeExpansion: true\n</code></pre> <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: gp3-retain\nallowedTopologies: []\nmountOptions: []\nprovisioner: ebs.csi.aws.com\nreclaimPolicy: Retain\nvolumeBindingMode: WaitForFirstConsumer\nallowVolumeExpansion: true\n</code></pre> </li> </ol>"},{"location":"operator-guide/openshift-cluster-settings/#related-articles","title":"Related Articles","text":"<ul> <li>Install Keycloak</li> </ul>"},{"location":"operator-guide/overview-manage-jenkins-pipelines/","title":"Overview","text":"<p>Jenkins job provisioners are responsible for creating and managing pipelines in Jenkins. In other words, provisioners configure all Jenkins pipelines and bring them to the state described in the provisioners code. Two types of provisioners are available in EDP:</p> <ul> <li>CI-provisioner - manages the application folder, and its Code Review, Build and Create Release pipelines.</li> </ul> <ul> <li>CD-provisioner - manages the Deploy pipelines.</li> </ul> <p>The subsections describe the creation/update process of provisioners and their content depending on EDP customization.</p>"},{"location":"operator-guide/overview-sast/","title":"Static Application Security Testing Overview","text":"<p>EPAM Delivery Platform provides the implemented Static Application Security Testing support allowing to work with the Semgrep security scanner and the DefectDojo vulnerability management system to check the source code for known vulnerabilities.</p>"},{"location":"operator-guide/overview-sast/#supported-languages","title":"Supported Languages","text":"<p>EDP SAST supports a number of languages and package managers.</p> Language (Package Managers) Scan Tool Build Tool Java Semgrep Maven, Gradle Go Semgrep Go React Semgrep Npm"},{"location":"operator-guide/overview-sast/#supported-vulnerability-management-system","title":"Supported Vulnerability Management System","text":"<p>To get and then manage a SAST report after scanning, it is necessary to deploy the vulnerability management system, for instance, DefectDojo.</p>"},{"location":"operator-guide/overview-sast/#defectdojo","title":"DefectDojo","text":"<p>DefectDojo is a vulnerability management and security orchestration platform that allows managing the uploaded security reports.</p> <p>Inspect the prerequisites and the main steps for installing DefectDojo on Kubernetes or OpenShift platforms.</p>"},{"location":"operator-guide/overview-sast/#related-articles","title":"Related Articles","text":"<ul> <li>Add Security Scanner</li> <li>Semgrep</li> </ul>"},{"location":"operator-guide/perf-integration/","title":"Perf Server Integration","text":"<p>Integration with Perf Server allows connecting to the PERF Board (Project Performance Board) and monitoring the overall team performance as well as setting up necessary metrics.</p> <p>Note</p> <p>To adjust the PERF Server integration, make sure that PERF Operator is deployed. To get more information about the PERF Operator installation and architecture, please refer to the PERF Operator page.</p> <p>For integration, take the following steps:</p> <ol> <li> <p>Create Secret in the OpenShift/Kubernetes namespace for Perf Server account with the username and password fields:</p> <pre><code>apiVersion: v1\ndata:\npassword: passwordInBase64\nusername: usernameInBase64\nkind: Secret\nmetadata:\nname: epam-perf-user\ntype: kubernetes.io/basic-auth\n</code></pre> </li> <li> <p>In the edp-config config map, enable the perf_integration flag and click Save:</p> <pre><code> perf_integration_enabled: 'true'\n</code></pre> </li> <li> <p>Being in Admin Console, navigate to the Advanced Settings menu to check that the Integrate with Perf Server check box appeared:</p> <p> Advanced settings </p> </li> </ol>"},{"location":"operator-guide/perf-integration/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> </ul>"},{"location":"operator-guide/prerequisites/","title":"EDP Installation Prerequisites Overview","text":"<p>Before installing EDP:</p> <ul> <li>Install and configure Kubernetes or OpenShift cluster.</li> <li>Install EDP components for the selected EDP installation scenario.</li> </ul>"},{"location":"operator-guide/prerequisites/#edp-installation-scenarios","title":"EDP Installation Scenarios","text":"<p>There are two EDP installation scenarios based on the selected CI tool: Tekton (default) or Jenkins.</p> <p>Scenario 1: Tekton CI tool. By default, EDP uses Tekton as a CI tool and EDP Headlamp as a UI tool.</p> <p>Scenario 2: Jenkins CI tool. To use Jenkins as a CI tool, it is required to install the deprecated Admin Console UI tool. Admin Console is used only as a dependency for Jenkins, and Headlamp will still be used as a UI tool.</p> <p>Find below the list of the components to be installed for each scenario:</p> Component Tekton CI tool Jenkins CI tool Tekton Mandatory - NGINX Ingress Controller Mandatory Mandatory Keycloak Mandatory Mandatory DefectDojo Mandatory Mandatory Argo CD Mandatory Optional ReportPortal Optional Optional Kiosk Optional Optional External Secrets Optional Optional <p>Note</p> <p>Alternatively, use Helmfiles to install the EDP components.</p> <p>After setting up the cluster and installing EDP components according to the selected scenario, proceed to the EDP installation.</p>"},{"location":"operator-guide/prerequisites/#related-articles","title":"Related Articles","text":"<ul> <li>Set Up Kubernetes</li> <li>Set Up OpenShift</li> <li>Install EDP</li> </ul>"},{"location":"operator-guide/report-portal-integration-tekton/","title":"Integration With Tekton","text":"<p>ReportPortal integration with Tekton allows managing all automation results and reports in one place, visualizing metrics and analytics, team collaborating to associate statistics results.</p> <p>For integration, take the following steps:</p> <ol> <li> <p>Log in to the ReportPortal console and navigate to the User Profile menu:</p> <p> ReportPortal profile </p> </li> <li> <p>Copy the Access token and use it as a value while creating a secret for the ReportPortal credentials:</p> <pre><code>apiVersion: v1\nkind: Secret\ntype: Opaque\nmetadata:\nname: rp-credentials\nstringData:\nrp_uuid: &lt;access-token&gt;\n</code></pre> </li> <li> <p>In the Configuration examples section of the ReportPortal User Profile menu, copy the following <code>REQUIRED</code> fields: <code>rp.endpoint</code>, <code>rp.launch</code> and <code>rp.project</code>. Insert these fields to the <code>pytest.ini</code> file in root directory of your project:</p> <pre><code>[pytest]\naddopts = -rsxX -l --tb=short --junitxml test-report.xml\nrp_endpoint = &lt;endpoint&gt;\nrp_launch = &lt;launch&gt;\nrp_project = &lt;project&gt;\n</code></pre> </li> <li> <p>Create a custom Tekton task:</p> View: Custom Tekton task <pre><code>apiVersion: tekton.dev/v1beta1\nkind: Task\nmetadata:\nlabels:\napp.kubernetes.io/version: '0.1'\nname: pytest-reportportal\nnamespace: &lt;namespace&gt;\nspec:\ndescription: |-\nThis task can be used to run pytest integrated with report portal.\nThis task can be used to run pytest integrated with report portal\nparams:\n- default: .\ndescription: The path where package.json of the project is defined.\nname: PATH_CONTEXT\ntype: string\n- name: EXTRA_COMMANDS\ntype: string\n- default: python:3.8-alpine3.16\ndescription: The python image you want to use.\nname: BASE_IMAGE\ntype: string\n- default: rp-credentials\ndescription: name of the secret holding the rp token\nname: rp-secret\ntype: string\nsteps:\n- env:\n- name: HOME\nvalue: $(workspaces.source.path)\n- name: RP_UUID\nvalueFrom:\nsecretKeyRef:\nkey: rp_uuid\nname: $(params.rp-secret)\nimage: $(params.BASE_IMAGE)\nname: pytest\nresources: {}\nscript: &gt;\n#!/usr/bin/env sh\nset -e\nexport PATH=$PATH:$HOME/.local/bin\n$(params.EXTRA_COMMANDS)\npytest ./tests --reportportal\nworkingDir: $(workspaces.source.path)/$(params.PATH_CONTEXT)\nworkspaces:\n- name: source\n</code></pre> </li> <li> <p>Add this task ref to your Tekton pipeline after tasks:</p> View: Tekton pipeline <pre><code>- name: pytest\nparams:\n- name: BASE_IMAGE\nvalue: $(params.python-image-version)\n- name: EXTRA_COMMANDS\nvalue: |\nset -ex\npip3 install -r requirements.txt\n[ -f run_service.py ] &amp;&amp; python run_service.py &amp;\nrunAfter:\n- compile\ntaskRef:\nkind: Task\nname: pytest-reportportal\nworkspaces:\n- name: source\nworkspace: shared-workspace\n</code></pre> </li> <li> <p>Launch your Tekton pipeline and check that the custom task has been successfully executed:</p> <p> Tekton task successfully executed </p> </li> <li> <p>Test reports will be displayed in the Launches section of the ReportPortal:</p> <p> Test report results </p> </li> </ol>"},{"location":"operator-guide/report-portal-integration-tekton/#related-articles","title":"Related Articles","text":"<ul> <li>ReportPortal Installation</li> <li>Keycloak Integration</li> <li>Pytest Integration With ReportPortal</li> </ul>"},{"location":"operator-guide/reportportal-keycloak/","title":"Keycloak Integration","text":"<p>Follow the steps below to integrate the ReportPortal with Keycloak.</p>"},{"location":"operator-guide/reportportal-keycloak/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed Keycloak. Please follow the instruction for details.</li> <li>Installed ReportPortal. Please follow the instruction to install it from Helmfile or using the Helm Chart.</li> </ul>"},{"location":"operator-guide/reportportal-keycloak/#keycloak-configuration","title":"Keycloak Configuration","text":"<ol> <li> <p>Navigate to Client Scopes &gt; Create client scope and create a new scope with the SAML protocol type.</p> </li> <li> <p>Navigate to Client Scopes &gt; your_scope_name &gt; Mappers &gt; Configure a new mapper &gt; select the User Attribute mapper type. Add three mappers for the email, first name, and last name by typing <code>lastName</code>, <code>firstName</code>, and <code>email</code> in the User Attribute field:</p> <ul> <li>Name is a display name in Keycloak.</li> <li>User Attribute is a user property for mapping.</li> <li>SAML Attribute Name is an attribute used for requesting information in the ReportPortal configuration.</li> <li>SAML Attribute NameFormat: <code>Basic</code>.</li> <li>Aggregate attribute values: <code>Off</code>.</li> </ul> <p> User mapper sample Scope mappers </p> </li> <li> <p>Navigate to Clients &gt; Create client and fill in the following fields:</p> <ul> <li>Client type: <code>SAML</code>.</li> <li>Client ID: <code>report.portal.sp.id</code>.</li> </ul> <p>Warning</p> <p>The <code>report.portal.sp.id</code> Client ID is a constant value.</p> </li> <li> <p>Navigate to Client &gt; your_client &gt; Settings and add <code>https://&lt;report-portal-url\\&gt;/*</code> to the Valid redirect URIs.</p> </li> <li> <p>Navigate to Client &gt; your_client &gt; Keys and disable Client signature required.</p> <p> Client keys </p> </li> <li> <p>Navigate to Client &gt; your_client &gt; Client scopes and add the scope created on step 3 with the default Assigned type.</p> <p> Client scopes </p> </li> </ol>"},{"location":"operator-guide/reportportal-keycloak/#reportportal-configuration","title":"ReportPortal Configuration","text":"<ol> <li> <p>Log in to the ReportPortal with the admin permissions.</p> </li> <li> <p>Navigate to Client &gt; Administrate &gt; Plugins and select the SAML plugin.</p> <p> Plugins menu </p> </li> <li> <p>To add a new integration, fill in the following fields:</p> <p> Add SAML configuration </p> <ul> <li>Provider name is the display name in the ReportPortal login page.</li> <li>Metadata URL: <code>https://&lt;keycloak_url\\&gt;/auth/realms/&lt;realm\\&gt;/protocol/saml/descriptor</code>.</li> <li>Email is the value from the SAML Attribute Name field in the Keycloak mapper.</li> <li>RP callback URL: <code>https://&lt;report_portal_url\\&gt;/uat</code>.</li> <li>Name attributes mode is the first &amp; last name (type based on your mapper).</li> <li>First name is the value from the SAML Attribute Name field in the Keycloak mapper.</li> <li>Last name is the value from the SAML Attribute Name field in the Keycloak mapper.</li> </ul> </li> <li> <p>Log in to the ReportPortal.</p> <p>Note</p> <p>By default, after the first login, ReportPortal creates the &lt;your_email&gt;_personal project and adds an account with the <code>Project manager</code> role.</p> <p> Report portal login page </p> </li> </ol>"},{"location":"operator-guide/reportportal-keycloak/#related-articles","title":"Related Articles","text":"<ul> <li>ReportPortal Installation</li> <li>Integration With Tekton</li> </ul>"},{"location":"operator-guide/restore-edp-with-velero/","title":"Restore EDP Tenant With Velero","text":"<p>You can use the Velero tool to restore a EDP tenant. Explore the main steps for backup and restoring below.</p> <ol> <li> <p>Delete all related entities in Keycloak: realm and clients from master/openshift realms. Navigate to the entitities list in the Keycloak, select the necessary ones, and click the deletion icon on the entitiy overview page.    If there are customized configs in Keycloak, save them before making backup.</p> <p> Remove keycloak realm </p> </li> <li> <p>To restore EDP, install and configure the Velero tool. Please refer to the Install Velero documentation for details.</p> </li> <li> <p>Remove all locks for operators. Delete all config maps that have \u2039OPERATOR_NAME\u203a-operator-lock names. Then restart all pods with operators, or simply run the following command:</p> <pre><code>     kubectl -n &lt;EDP_NAMESPACE&gt; delete cm $(kubectl -n &lt;EDP_NAMESPACE&gt; get cm | grep 'operator-lock' | awk '{print $1}')\n</code></pre> </li> <li> <p>Recreate the admin password and delete the Jenkins pod. Or change the script to update the admin password in Jenkins every time when the pod is updated.</p> </li> </ol>"},{"location":"operator-guide/sast-scaner-semgrep/","title":"Semgrep","text":"<p>Semgrep is an open-source static source code analyzer for finding bugs and enforcing code standards.</p> <p>Semgrep scanner is installed on the EDP Jenkins SAST agent and runs on the <code>sast</code> pipeline stage. For details, please refer to the edp-library-stages repository.</p>"},{"location":"operator-guide/sast-scaner-semgrep/#supported-languages","title":"Supported Languages","text":"<p>Semgrep supports more than 20 languages, see the full list in the official documentation. EDP uses Semgrep to scan Java, JavaScript and Go languages.</p>"},{"location":"operator-guide/sast-scaner-semgrep/#related-articles","title":"Related Articles","text":"<ul> <li>Add Security Scanner</li> </ul>"},{"location":"operator-guide/schedule-pods-restart/","title":"Schedule Pods Restart","text":"<p>In case it is necessary to restart pods, use a CronJob according to the following template:</p> View: template <pre><code>---\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\nnamespace: &lt;NAMESPACE&gt;\nname: apps-restart\nrules:\n- apiGroups: [\"apps\"]\nresources:\n- deployments\n- statefulsets\nverbs:\n- 'get'\n- 'list'\n- 'patch'\n---\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\nname: apps-restart\nnamespace: &lt;NAMESPACE&gt;\nsubjects:\n- kind: ServiceAccount\nname: apps-restart-sa\nnamespace: &lt;NAMESPACE&gt;\nroleRef:\nkind: Role\nname: apps-restart\napiGroup: \"\"\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\nname: apps-restart-sa\nnamespace: &lt;NAMESPACE&gt;\n---\napiVersion: batch/v1beta1\nkind: CronJob\nmetadata:\nname: apps-rollout-restart\nnamespace: &lt;NAMESPACE&gt;\nspec:\nschedule: \"0 9 * * MON-FRI\"\njobTemplate:\nspec:\ntemplate:\nspec:\nserviceAccountName: apps-restart-sa\ncontainers:\n- name: kubectl-runner\nimage: bitnami/kubectl\ncommand:\n- /bin/sh\n- -c\n- kubectl get -n &lt;NAMESPACE&gt; -o name deployment,statefulset | grep &lt;NAME_PATTERN&gt;| xargs kubectl -n &lt;NAMESPACE&gt; rollout restart\nrestartPolicy: Never\n</code></pre> <p>Modify the Cron expression in the CronJob manifest if needed.</p>"},{"location":"operator-guide/ssl-automation-okd/","title":"Use Cert-Manager in OpenShift","text":"<p>The following material covers Let's Encrypt certificate automation with cert-manager using AWS Route53.</p> <p>The cert-manager is a Kubernetes/OpenShift operator that allows to issue and automatically renew SSL certificates. In this tutorial, the steps to secure DNS Name will be demonstrated.</p> <p>Below is an instruction on how to automatically issue and install wildcard certificates on OpenShift Ingress Controller and API Server covering all cluster Routes. To secure separate OpenShift Routes, please refer to the OpenShift Route Support project for <code>cert-manager</code>.</p>"},{"location":"operator-guide/ssl-automation-okd/#prerequisites","title":"Prerequisites","text":"<ul> <li>The cert-manager;</li> <li>OpenShift v4.7 - v4.11;</li> <li>Connection to the OpenShift Cluster;</li> <li>Enabled AWS IRSA;</li> <li>The latest <code>oc</code> utility. The <code>kubectl</code> tool can also be used for most of the commands.</li> </ul>"},{"location":"operator-guide/ssl-automation-okd/#install-cert-manager-operator","title":"Install Cert-Manager Operator","text":"<p>Install the <code>cert-manager</code> operator via OpenShift OperatorHub that uses Operator Lifecycle Manager (OLM):</p> <ol> <li> <p>Go to the OpenShift Admin Console \u2192 OperatorHub, search for the <code>cert-manager</code>, and click Install:</p> <p> Cert-Manager Installation </p> </li> <li> <p>Modify the <code>ClusterServiceVersion</code> OLM resource, by selecting the Update approval \u2192 Manual. If selecting Update approval \u2192 Automatic after the automatic operator update, the parameters in the <code>ClusterServiceVersion</code> will be reset to default.</p> <p>Note</p> <p>Installing an operator with Manual approval causes all operators installed in namespace <code>openshift-operators</code> to function as manual approval strategy. In case the Manual approval is chosen, review the manual installation plan and approve it.</p> <p> Cert-Manager Installation </p> </li> <li> <p>Navigate to Operators \u2192 Installed Operators and check the operator status to be Succeeded:</p> <p> Cert-Manager Installation </p> </li> <li> <p>In case of errors, troubleshoot the Operator issues:</p> <pre><code>oc describe operator cert-manager -n openshift-operators\noc describe sub cert-manager -n openshift-operators\n</code></pre> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#create-aws-role-for-route53","title":"Create AWS Role for Route53","text":"<p>The <code>cert-manager</code> should be configured to validate Wildcard certificates using the DNS-based method.</p> <ol> <li> <p>Check the DNS Hosted zone ID in AWS Route53 for your domain.</p> <p> Hosted Zone ID </p> </li> <li> <p>Create Route53 Permissions policy in AWS for <code>cert-manager</code> to be able to create DNS TXT records for the certificate validation. In this example, <code>cert-manager</code> permissions are given for a particular DNS zone only. Replace Hosted zone ID XXXXXXXX in the \"Resource\": \"arn:aws:route53:::hostedzone/XXXXXXXXXXXX\".</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": \"route53:GetChange\",\n\"Resource\": \"arn:aws:route53:::change/*\"\n},\n{\n\"Effect\": \"Allow\",\n\"Action\": [\n\"route53:ChangeResourceRecordSets\",\n\"route53:ListResourceRecordSets\"\n],\n\"Resource\": \"arn:aws:route53:::hostedzone/XXXXXXXXXXXX\"\n}\n]\n}\n</code></pre> </li> <li> <p>Create an AWS Role with Custom trust policy for the <code>cert-manager</code> service account to use the AWS IRSA feature and then attach the created policy. Replace the following:</p> <ul> <li><code>${aws-account-id}</code> with the AWS account ID of the EKS cluster.</li> <li><code>${aws-region}</code> with the region where the EKS cluster is located.</li> <li><code>${eks-hash}</code> with the hash in the EKS API URL; this will be a random 32 character hex string, for example, 45DABD88EEE3A227AF0FA468BE4EF0B5.</li> <li><code>${namespace}</code> with the namespace where cert-manager is running.</li> <li><code>${service-account-name}</code> with the name of the ServiceAccount object created by cert-manager.</li> <li>By default, it is \"system:serviceaccount:openshift-operators:cert-manager\" if <code>cert-manager</code> is installed via OperatorHub.</li> <li>Attach the created Permission policy for Route53 to the Role.</li> <li> <p>Optionally, add Permissions boundary to the Role.</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": \"sts:AssumeRoleWithWebIdentity\",\n\"Principal\": {\n\"Federated\": \"arn:aws:iam::* ${aws-account-id}:oidc-provider/oidc.eks.${aws-region}.amazonaws.com/id/${eks-hash}\"\n},\n\"Condition\": {\n\"StringEquals\": {\n\"oidc.eks.${aws-region}.amazonaws.com/id/${eks-hash}:sub\": \"system:serviceaccount:${namespace}:${service-account-name}\"\n}\n}\n}\n]\n}\n</code></pre> </li> </ul> </li> <li> <p>Copy the created Role ARN.</p> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#configure-cert-manager-integration-with-aws-route53","title":"Configure Cert-Manager Integration With AWS Route53","text":"<ol> <li> <p>Annotate the <code>ServiceAccount</code> created by <code>cert-manager</code> (required for AWS IRSA), and restart the <code>cert-manager</code> pod.</p> </li> <li> <p>Replace the <code>eks.amazonaws.com/role-arn</code> annotation value with your own Role ARN.</p> <pre><code>oc edit sa cert-manager -n openshift-operators\n</code></pre> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\nannotations:\neks.amazonaws.com/role-arn: arn:aws:iam::XXXXXXXXXXXX:role/cert-manager\n</code></pre> </li> <li> <p>Modify the <code>cert-manager</code> <code>Deployment</code> with the correct file system permissions <code>fsGroup: 1001</code>, so that the <code>ServiceAccount</code> token can be read.</p> <p>Note</p> <p>In case the <code>ServiceAccount</code> token cannot be read and the operator is installed using the OperatorHub, add <code>fsGroup: 1001</code> via OpenShift ClusterServiceVersion OLM resource. It should be a <code>cert-manager</code> controller spec. These actions are not required for OpenShift v4.10.</p> <pre><code>oc get csv\noc edit csv cert-manager.${VERSION}\n</code></pre> <pre><code>spec:\ntemplate:\nspec:\nsecurityContext:\nfsGroup: 1001\nserviceAccountName: cert-manager\n</code></pre> <p> Cert-Manager System Permissions </p> <p>Info</p> <p>A mutating admission controller will automatically modify all pods running with the service account:</p> <p> cert-manager controller pod <pre><code>apiVersion: apps/v1\nkind: Pod\n# ...\nspec:\n# ...\nserviceAccountName: cert-manager\nserviceAccount: cert-manager\ncontainers:\n- name: ...\n# ...\nenv:\n- name: AWS_ROLE_ARN\nvalue: &gt;-\narn:aws:iam::XXXXXXXXXXX:role/cert-manager\n- name: AWS_WEB_IDENTITY_TOKEN_FILE\nvalue: /var/run/secrets/eks.amazonaws.com/serviceaccount/token\nvolumeMounts:\n- name: aws-iam-token\nreadOnly: true\nmountPath: /var/run/secrets/eks.amazonaws.com/serviceaccount\nvolumes:\n- name: aws-iam-token\nprojected:\nsources:\n- serviceAccountToken:\naudience: sts.amazonaws.com\nexpirationSeconds: 86400\npath: token\ndefaultMode: 420\n</code></pre> </p> </li> <li> <p>If you have separate public and private DNS zones for the same domain (split-horizon DNS), modify the <code>cert-manager</code> <code>Deployment</code> in order to validate DNS TXT records via public recursive nameservers.</p> <p>Note</p> <p>Otherwise, you will be getting an error during a record validation:</p> <p><pre><code>Waiting for DNS-01 challenge propagation: NS ns-123.awsdns-00.net.:53 returned REFUSED for _acme-challenge.\n</code></pre> To avoid the error, add <code>--dns01-recursive-nameservers-only --dns01-recursive-nameservers=8.8.8.8:53,1.1.1.1:53</code> as ARGs to the <code>cert-manager</code> controller <code>Deployment</code>.</p> <pre><code>oc get csv\noc edit csv cert-manager.${VERSION}\n</code></pre> <pre><code>  labels:\napp: cert-manager\napp.kubernetes.io/component: controller\napp.kubernetes.io/instance: cert-manager\napp.kubernetes.io/name: cert-manager\napp.kubernetes.io/version: v1.9.1\nspec:\ncontainers:\n- args:\n- '--v=2'\n- '--cluster-resource-namespace=$(POD_NAMESPACE)'\n- '--leader-election-namespace=kube-system'\n- '--dns01-recursive-nameservers-only'\n- '--dns01-recursive-nameservers=8.8.8.8:53,1.1.1.1:53'\n</code></pre> <p>Note</p> <p>The <code>Deployment</code> must be modified via OpenShift ClusterServiceVersion OLM resource if the operator was installed using the OperatorHub. The OpenShift <code>ClusterServiceVersion</code> OLM resource includes several Deployments, and the ARGs must be modified only for the <code>cert-manager</code> controller.</p> <ul> <li>Save the resource. After that, OLM will try to reload the resource automatically and save it to the YAML file. If OLM resets the config file, double-check the entered values.</li> </ul> <p> Cert-Manager Nameservers </p> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#configure-clusterissuers","title":"Configure ClusterIssuers","text":"<p><code>ClusterIssuer</code> is available on the whole cluster.</p> <ol> <li> <p>Create the ClusterIssuer resource for Let's Encrypt Staging and Prod environments that signs a Certificate using <code>cert-manager</code>.</p> <p>Note</p> <p>Let's Encrypt has a limit of duplicate certificates in the Prod environment. Therefore, a <code>ClusterIssuer</code> has been created for Let's Encrypt Staging environment. By default, Let's Encrypt Staging certificates will not be trusted in your browser. The certificate validation cannot be tested in the Let's Encrypt Staging environment.</p> <ul> <li>Change <code>user@example.com</code> with your contact email.</li> <li>Replace <code>hostedZoneID</code> XXXXXXXXXXX with the DNS Hosted zone ID in AWS for your domain.</li> <li>Replace the region value <code>${region}</code>.</li> <li>The secret under <code>privateKeySecretRef</code> will be created automatically by the <code>cert-manager</code> operator.</li> </ul> <pre><code>apiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\nname: letsencrypt-staging\nspec:\nacme:\nemail: user@example.com\nserver: https://acme-staging-v02.api.letsencrypt.org/directory\nprivateKeySecretRef:\nname: letsencrypt-staging-issuer-account-key\nsolvers:\n- dns01:\nroute53:\nregion: ${region}\nhostedZoneID: XXXXXXXXXXX\n</code></pre> <pre><code>apiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\nname: letsencrypt-prod\nspec:\nacme:\nemail: user@example.com\nserver: https://acme-v02.api.letsencrypt.org/directory\nprivateKeySecretRef:\nname: letsencrypt-prod-issuer-account-key\nsolvers:\n- dns01:\nroute53:\nregion: ${region}\nhostedZoneID: XXXXXXXXXXX\n</code></pre> <p> Cert-Manager ClusterIssuer </p> </li> <li> <p>Check the <code>ClusterIssuer</code> status:</p> <p> Cert-Manager ClusterIssuer </p> <pre><code>oc describe clusterissuer letsencrypt-prod\noc describe clusterissuer letsencrypt-staging\n</code></pre> </li> <li> <p>If the <code>ClusterIssuer</code> state is not ready, investigate <code>cert-manager</code> controller pod logs:</p> <pre><code>oc get pod -n openshift-operators | grep 'cert-manager'\noc logs -f cert-manager-${replica_set}-${random_string} -n openshift-operators\n</code></pre> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#configure-certificates","title":"Configure Certificates","text":"<ol> <li> <p>In two different namespaces, create a Certificate resource for the OpenShift Router (Ingress controller for OpenShift) and for the OpenShift APIServer.</p> <ul> <li>OpenShift Router supports a single wildcard certificate for Ingress/Route resources in different namespaces (so called, default SSL certificate). The Ingress controller expects the certificates in a <code>Secret</code> to be created in the <code>openshift-ingress</code> namespace; the API Server, in the <code>openshift-config</code> namespace. The <code>cert-manager</code> operator will automatically create these secrets from the <code>Certificate</code> resource.</li> <li>Replace <code>${DOMAIN}</code> with your domain name. It can be checked with <code>oc whoami --show-server</code>. Put domain names in quotes.</li> </ul> The certificate for OpenShift Router in the `openshift-ingress` namespace <pre><code>apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\nname: router-certs\nnamespace: openshift-ingress\nlabels:\napp: cert-manager\nspec:\nsecretName: router-certs\nsecretTemplate:\nlabels:\napp: cert-manager\nduration: 2160h # 90d\nrenewBefore: 360h # 15d\nsubject:\norganizations:\n- Org Name\ncommonName: '*.${DOMAIN}'\nprivateKey:\nalgorithm: RSA\nencoding: PKCS1\nsize: 2048\nrotationPolicy: Always\nusages:\n- server auth\n- client auth\ndnsNames:\n- '*.${DOMAIN}'\n- '*.apps.${DOMAIN}'\nissuerRef:\nname: letsencrypt-staging\nkind: ClusterIssuer\n</code></pre> The certificate for OpenShift APIServer in the `openshift-config` namespace <pre><code>apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\nname: api-certs\nnamespace: openshift-config\nlabels:\napp: cert-manager\nspec:\nsecretName: api-certs\nsecretTemplate:\nlabels:\napp: cert-manager\nduration: 2160h # 90d\nrenewBefore: 360h # 15d\nsubject:\norganizations:\n- Org Name\ncommonName: '*.${DOMAIN}'\nprivateKey:\nalgorithm: RSA\nencoding: PKCS1\nsize: 2048\nrotationPolicy: Always\nusages:\n- server auth\n- client auth\ndnsNames:\n- '*.${DOMAIN}'\n- '*.apps.${DOMAIN}'\nissuerRef:\nname: letsencrypt-staging\nkind: ClusterIssuer\n</code></pre> <p>Info</p> <ul> <li> <p><code>cert-manager</code> supports ECDSA key pairs in the <code>Certificate</code> resource. To use it, change RSA <code>privateKey</code> to ECDSA:</p> <pre><code>privateKey:\nalgorithm: ECDSA\nencoding: PKCS1\nsize: 256\nrotationPolicy: Always\n</code></pre> </li> </ul> <ul> <li><code>rotationPolicy: Always</code> is highly recommended since <code>cert-manager</code> does not rotate private keys by default.</li> <li>Full <code>Certificate</code> spec is described in the <code>cert-manager</code> API documentation.</li> </ul> </li> <li> <p>Check that the certificates in the namespaces are ready:</p> <p> Cert-Manager Certificate Status </p> <p> Cert-Manager Certificate Status </p> </li> <li> <p>Check the details of the certificates via CLI:</p> <pre><code>oc describe certificate api-certs -n openshift-config\noc describe certificate router-certs -n openshift-ingress\n</code></pre> </li> <li> <p>Check the cert-manager controller pod logs if the Staging Certificate condition is not ready for more than 7 minutes:</p> <pre><code>oc get pod -n openshift-operators | grep 'cert-manager'\noc logs -f cert-manager-${replica_set}-${random_string} -n openshift-operators\n</code></pre> </li> <li> <p>When the certificate is ready, its private key will be put into the OpenShift <code>Secret</code> in the namespace indicated in the <code>Certificate</code> resource:</p> <pre><code>oc describe secret api-certs -n openshift-config\noc describe secret router-certs -n openshift-ingress\n</code></pre> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#modify-openshift-router-and-api-server-custom-resources","title":"Modify OpenShift Router and API Server Custom Resources","text":"<ol> <li> <p>Update the Custom Resource of your Router (Ingress controller). Patch the <code>defaultCertificate</code> object value with <code>{ \"name\": \"router-certs\" }</code>:</p> <pre><code>oc patch ingresscontroller default -n openshift-ingress-operator --type=merge --patch='{\"spec\": { \"defaultCertificate\": { \"name\": \"router-certs\" }}}' --insecure-skip-tls-verify\n</code></pre> <p>Info</p> <p>After updating the <code>IngressController</code> object, the OpenShift Ingress operator redeploys the router.</p> </li> <li> <p>Update the Custom Resource for the OpenShift API Server:</p> <ul> <li> <p>Export the name of <code>APIServer</code>:</p> <pre><code>export OKD_API=$(oc whoami --show-server --insecure-skip-tls-verify | cut -f 2 -d ':' | cut -f 3 -d '/' | sed 's/-api././')\n</code></pre> </li> </ul> <ul> <li> <p>Patch the <code>servingCertificate</code> object value with <code>{ \"name\": \"api-certs\" }</code>:</p> <pre><code>oc patch apiserver cluster --type merge --patch=\"{\\\"spec\\\": {\\\"servingCerts\\\": {\\\"namedCertificates\\\": [ { \\\"names\\\": [  \\\"$OKD_API\\\"  ], \\\"servingCertificate\\\": {\\\"name\\\": \\\"api-certs\\\" }}]}}}\" --insecure-skip-tls-verify\n</code></pre> </li> </ul> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#move-from-lets-encrypt-staging-environment-to-prod","title":"Move From Let's Encrypt Staging Environment to Prod","text":"<ol> <li> <p>Test the Staging certificate on the OpenShift Admin Console. The <code>--insecure</code> flag is used because Let's Encrypt Staging certificates are not trusted in browsers by default:</p> <pre><code>curl -v --insecure https://console-openshift-console.apps.${DOMAIN}\n</code></pre> </li> <li> <p>Change <code>issuerRef</code> to <code>letsencrypt-prod</code> in both <code>Certificate</code> resources:</p> <pre><code>oc edit certificate api-certs -n openshift-config\noc edit certificate router-certs -n openshift-ingress\n</code></pre> <pre><code>issuerRef:\nname: letsencrypt-prod\nkind: ClusterIssuer\n</code></pre> <p>Note</p> <p>In case the certificate reissue is not triggered after that, try to force the certificate renewal with cmctl:</p> <pre><code>cmctl renew router-certs -n openshift-ingress\ncmctl renew api-certs -n openshift-config\n</code></pre> <p>If this won't work, delete the <code>api-certs</code> and <code>router-certs</code> secrets. It should trigger the Prod certificates issuance:</p> <pre><code>oc delete secret router-certs -n openshift-ingress\noc delete secret api-certs -n openshift-config\n</code></pre> <p>Please note that these actions will lead to logging your account out of the OpenShift Admin Console, since certificates will be deleted. Accept the certificate warning in the browser and log in again after that.</p> </li> <li> <p>Check the status of the Prod certificates:</p> <pre><code>oc describe certificate api-certs -n openshift-config\noc describe certificate router-certs -n openshift-ingress\n</code></pre> <pre><code>cmctl status certificate api-certs -n openshift-config\ncmctl status certificate router-certs -n openshift-ingress\n</code></pre> </li> <li> <p>Check the web console and make sure it has secure connection:</p> <pre><code>curl -v https://console-openshift-console.apps.${DOMAIN}\n</code></pre> </li> </ol>"},{"location":"operator-guide/ssl-automation-okd/#troubleshoot-certificates","title":"Troubleshoot Certificates","text":"<p>Below is an example of the DNS TXT <code>challenge</code> record created by the <code>cert-manager</code> operator:</p> <p> DNS Validation </p> <p>Use <code>nslookup</code> or <code>dig</code> tools to check if the DNS propagation for the TXT record is complete:</p> <pre><code>nslookup -type=txt _acme-challenge.${DOMAIN}\ndig txt _acme-challenge.${DOMAIN}\n</code></pre> <p>Otherwise, use web tools like Google Admin Toolbox:</p> <p> DNS Validation </p> <p>If the correct TXT value is shown (the value corresponds to the current TXT value in the DNS zone), it means that the DNS propagation is complete and Let's Encrypt is able to access the record in order to validate it and issue a trusted certificate.</p> <p>Note</p> <p>If the DNS validation challenge self check fails, <code>cert-manager</code> will retry the self check with a fixed 10-second retry interval. Challenges that do not ever complete the self check will continue retrying until the user intervenes by either retrying the <code>Order</code> (by deleting the <code>Order</code> resource) or amending the associated <code>Certificate</code> resource to resolve any configuration errors.</p> <p>As soon as the domain ownership has been verified, any <code>cert-manager</code> affected validation TXT records in the AWS Route53 DNS zone will be cleaned up.</p> <p>Please find below the issues that may occur and their troubleshooting:</p> <ul> <li>When certificates are not issued for a long time, or a <code>cert-manager</code> resource is not in a Ready state, describing a resource may show the reason for the error.</li> </ul> <ul> <li>Basically, the <code>cert-manager</code> creates the following resources during a <code>Certificate</code> issuance: <code>CertificateRequest</code>, <code>Order</code>, and <code>Challenge</code>. Investigate each of them in case of errors.</li> </ul> <ul> <li>Use the cmctl tool to show the state of a <code>Certificate</code> and its associated resources.</li> </ul> <ul> <li> <p>Check the <code>cert-manager</code> controller pod logs:</p> <pre><code>oc get pod -n openshift-operators | grep 'cert-manager'\noc logs -f cert-manager-${replica_set}-${random_string} -n openshift-operators\n</code></pre> </li> </ul> <ul> <li> <p>Certificate error debugging:   a. Decode certificate chain located in the secrets:</p> <pre><code>oc get secret router-certs -n openshift-ingress -o 'go-template={{index .data \"tls.crt\"}}' | base64 -d | while openssl x509 -noout -text; do :; done 2&gt;/dev/null\noc get secret api-certs -n openshift-config -o 'go-template={{index .data \"tls.crt\"}}' | base64 -d | while openssl x509 -noout -text; do :; done 2&gt;/dev/null\n</code></pre> <pre><code>cmctl inspect secret router-certs -n openshift-ingress\ncmctl inspect secret api-certs -n openshift-config\n</code></pre> <p>b. Check the SSL RSA private key consistency:</p> <pre><code>oc get secret router-certs -n openshift-ingress -o 'go-template={{index .data \"tls.key\"}}' | base64 -d | openssl rsa -check -noout\noc get secret api-certs -n openshift-config -o 'go-template={{index .data \"tls.key\"}}' | base64 -d | openssl rsa -check -noout\n</code></pre> <p>c. Match the SSL certificate public key against its RSA private key. Their modulus must be identical:</p> <pre><code>diff &lt;(oc get secret api-certs -n openshift-config -o 'go-template={{index .data \"tls.crt\"}}' | base64 -d | openssl x509 -noout -modulus | openssl md5) &lt;(oc get secret api-certs -n openshift-config -o 'go-template={{index .data \"tls.key\"}}' | base64 -d | openssl rsa -noout -modulus | openssl md5)\ndiff &lt;(oc get secret router-certs -n openshift-ingress -o 'go-template={{index .data \"tls.crt\"}}' | base64 -d | openssl x509 -noout -modulus | openssl md5) &lt;(oc get secret router-certs -n openshift-ingress -o 'go-template={{index .data \"tls.key\"}}' | base64 -d | openssl rsa -noout -modulus | openssl md5)\n</code></pre> </li> </ul>"},{"location":"operator-guide/ssl-automation-okd/#remove-obsolete-certificate-authority-data-from-kubeconfig","title":"Remove Obsolete Certificate Authority Data From Kubeconfig","text":"<p>After updating the certificates, the access to the cluster via Lens or CLI will be denied because of the untrusted certificate errors:</p> <pre><code>$ oc whoami\nUnable to connect to the server: x509: certificate signed by unknown authority\n</code></pre> <p>Such behavior appears because the <code>oc</code> tool references an old CA data in the kubeconfig file.</p> <p>Note</p> <p>Examine the Certificate Authority data using the following command:</p> <pre><code>oc config view --minify --raw -o jsonpath='{.clusters[].cluster.certificate-authority-data}' | base64 -d | openssl x509 -text\n</code></pre> <p>This certificate has the <code>CA:TRUE</code> parameter, which means that this is a self-signed root CA certificate.</p> <p>To fix the error, remove the old CA data from your OpenShift kubeconfig file:</p> <pre><code>sed -i \"/certificate-authority-data/d\" $KUBECONFIG\n</code></pre> <p>Since this field will be absent in the kubeconfig file, system root SSL certificate will be used to validate the cluster certificate trust chain. On Ubuntu, Let's Encrypt OpenShift cluster certificates will be validated against <code>Internet Security Research Group</code> root in <code>/etc/ssl/certs/ca-certificates.crt</code>.</p>"},{"location":"operator-guide/ssl-automation-okd/#certificate-renewals","title":"Certificate Renewals","text":"<p>The <code>cert-manager</code> automatically renews the certificates based on the X.509 certificate's duration and the <code>renewBefore</code> value. The minimum value for the <code>spec.duration</code> is 1 hour; for <code>spec.renewBefore</code>, 5 minutes. It is also required that <code>spec.duration</code> &gt; <code>spec.renewBefore</code>.</p> <p>Use the cmctl tool to manually trigger a single instant certificate renewal:</p> <pre><code>cmctl renew router-certs -n openshift-ingress\ncmctl renew api-certs -n openshift-config\n</code></pre> <p>Otherwise, manually renew all certificates in all namespaces with the <code>app=cert-manager</code> label:</p> <pre><code>cmctl renew --all-namespaces -l app=cert-manager\n</code></pre> <p>Run the <code>cmctl renew --help</code> command to get more details.</p>"},{"location":"operator-guide/ssl-automation-okd/#related-articles","title":"Related Articles","text":"<ul> <li>Cert-Manager Official Documentation</li> <li>Installing the Cert-Manager Operator for Red Hat OpenShift</li> <li>Checking Issued Certificate Details</li> </ul>"},{"location":"operator-guide/upgrade-edp-2.10.x-to-2.11.x/","title":"Upgrade EDP v.2.10.x to v.2.11.x","text":"<p>This section provides the details on the EDP upgrade from the v.2.10.x to the v.2.11.x. Explore the actions and requirements below.</p> <ol> <li> <p>Update Custom Resource Definitions. Run the following command to apply all the necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.12/deploy-templates/crds/edp_v1alpha1_cd_stage_deploy_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.11/deploy-templates/crds/v2_v1alpha1_merge_request_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.11/deploy-templates/crds/edp_v1alpha1_user_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.11/deploy-templates/crds/edp_v1alpha1_cdpipeline_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.11/deploy-templates/crds/v2_v1alpha1_jenkinssharedlibrary_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.11/deploy-templates/crds/v2_v1alpha1_cdstagejenkinsdeployment_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.11/deploy-templates/crds/v1_v1alpha1_keycloakauthflow_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.11/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.12/deploy-templates/crds/edp_v1alpha1_codebaseimagestream_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.12/deploy-templates/crds/edp_v1alpha1_codebase_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.11/deploy-templates/crds/edp_v1alpha1_sonar_group_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.11/deploy-templates/crds/edp_v1alpha1_permission_template_crd.yaml\n</code></pre> </li> <li> <p>Backup kaniko-template config-map and then remove it. This component will be delivered during upgrade.</p> </li> <li> <p>Set required awsRegion parameter. Pay attention that the nesting of the kanikoRoleArn parameter has been changed to the kaniko.roleArn parameter. Check the parameters in the EDP installation chart. For details, please refer to the values.yaml file. To upgrade EDP to the v.2.11.x, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.11.x\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.11.x  --dry-run</code></p> </li> <li> <p>Update Sonar Project Key:</p> <p>Note</p> <p>Avoid using special characters when creating projects in SonarQube. Allowed characters are: <code>letters</code>, <code>numbers</code>, <code>-</code>, <code>_</code>, <code>.</code> and <code>:</code>, with at least one non-digit. For details, please refer to the SonarQube documentation. As the result, the project name will be: <code>project-name-release-0.0</code> or <code>project-name-branchName</code>.</p> <p>Such actions are required to be followed with the aim to store the SonarQube statistics from the previous EDP version:</p> <p>Warning</p> <p>Do not run any pipeline with the updated sonar stage on any existing application before the completion of the first step.</p> <p>4.1. Update the project key in SonarQube from old to new format by adding the default branch name.</p> <p>- Navigate to Project Settings -&gt; Update Key:   Update SonarQube project key    - Enter the default branch name and click Update:   Update SonarQube project key </p> <p>4.2. As the result, after the first run, the project name will be changed to a new format containing all previous statistics:</p> <p> SonarQube project history activity </p> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images should be:<pre><code>epamedp/edp-jenkins-codenarc-agent:3.0.4\nepamedp/edp-jenkins-dotnet-21-agent:3.0.4\nepamedp/edp-jenkins-dotnet-31-agent:3.0.3\nepamedp/edp-jenkins-go-agent:3.0.5\nepamedp/edp-jenkins-gradle-java11-agent:3.0.2\nepamedp/edp-jenkins-gradle-java8-agent:3.0.2\nepamedp/edp-jenkins-helm-agent:3.0.3\nepamedp/edp-jenkins-maven-java11-agent:3.0.3\nepamedp/edp-jenkins-maven-java8-agent:3.0.3\nepamedp/edp-jenkins-npm-agent:3.0.4\nepamedp/edp-jenkins-opa-agent:3.0.2\nepamedp/edp-jenkins-python-38-agent:3.0.2\nepamedp/edp-jenkins-terraform-agent:3.0.3\n</code></pre> </li> </ul> <ul> <li> <p>Add Jenkins agent by following the template:</p> <p> View: values.yaml <pre><code>kaniko-docker-template: |-\n&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;kaniko-docker&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;kaniko-docker&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;epamedp/edp-jenkins-kaniko-docker-agent:1.0.4&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n</code></pre> <ul> <li>Restart the Jenkins pod.</li> </ul> <li> <p>Update the Jenkins plugins with the 'pipeline' name and 'HTTP Request Plugin'.</p> </li> <li> <p>Update Jenkins provisioners according to the Manage Jenkins CI Pipeline Job Provisioner and Manage Jenkins CD Pipeline Job Provisioner documentation.</p> </li> <li> <p>Restart the codebase-operator to recreate the Code-review and Build pipelines for codebases.</p> </li> <li>Run the CD job-provisioners for every CD pipeline to align the CD stages.</li>"},{"location":"operator-guide/upgrade-edp-2.11.x-to-2.12.x/","title":"Upgrade EDP v.2.11.x to v.2.12.x","text":"<p>Important</p> <p>We suggest making a backup of the EDP environment before starting the upgrade procedure.</p> <p>This section provides the details on the EDP upgrade from the v.2.11.x to the v.2.12.x. Explore the actions and requirements below.</p> <p>Notes</p> <ul> <li>EDP now supports Kubernetes 1.22: Ingress Resources use <code>networking.k8s.io/v1</code>, and Ingress Operators use CustomResourceDefinition <code>apiextensions.k8s.io/v1</code>.</li> <li>EDP Team now delivers its own Gerrit Docker image: epamedp/edp-gerrit. It is based on the openfrontier Gerrit Docker image.</li> </ul> <ol> <li> <p>EDP now uses DefectDojo as a SAST tool. It is mandatory to deploy DefectDojo before updating EDP to v.2.12.x.</p> </li> <li> <p>Update Custom Resource Definitions (CRDs). Run the following command to apply all necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-admin-console-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_adminconsoles.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_cdpipelines.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_cdstagedeployments.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_cdstagejenkinsdeployments.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_codebasebranches.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_codebaseimagestreams.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_codebases.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-component-operator/release/0.12/deploy-templates/crds/v1.edp.epam.com_edpcomponents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritgroupmembers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritgroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritmergerequests.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritprojectaccesses.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritprojects.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerritreplicationconfigs.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_gerrits.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_gitservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_gittags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_imagestreamtags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkins.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsagents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsauthorizationrolemappings.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsauthorizationroles.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsfolders.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsjobbuildruns.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsjobs.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsscripts.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinsserviceaccounts.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_jenkinssharedlibraries.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_jiraissuemetadatas.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.13/deploy-templates/crds/v2.edp.epam.com_jiraservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakauthflows.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakclients.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakclientscopes.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmcomponents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmgroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmidentityproviders.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmrolebatches.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmroles.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealms.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloakrealmusers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.12/deploy-templates/crds/v1.edp.epam.com_keycloaks.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_nexuses.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_nexususers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_perfdatasourcegitlabs.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_perfdatasourcejenkinses.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_perfdatasourcesonars.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-perf-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_perfservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_sonargroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_sonarpermissiontemplates.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-sonar-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_sonars.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.12/deploy-templates/crds/v2.edp.epam.com_stages.yaml\n</code></pre> </li> <li> <p>Set the required parameters. For details, please refer to the values.yaml file.</p> <ul> <li>In version v.2.12.x, EDP contains Gerrit <code>v3.6.1</code>. According to the Official Gerrit Upgrade flow, a user must initially upgrade to Gerrit <code>v3.5.2</code>, and then upgrade to <code>v3.6.1</code>. Therefore, define the <code>gerrit-operator.gerrit.version=3.5.2</code> value in the edp-install <code>values.yaml</code> file.</li> </ul> <ul> <li> <p>Two more components are available with the new functionality:</p> <ul> <li><code>edp-argocd-operator</code></li> <li><code>external-secrets</code></li> </ul> </li> </ul> <ul> <li>If there is no need to use these new operators, define <code>false</code> values for them in the existing <code>value.yaml</code> file:<p> View: values.yaml <pre><code>gerrit-operator:\ngerrit:\nversion: \"3.5.2\"\nexternalSecrets:\nenabled: false\nargocd:\nenabled: false\n</code></pre> <li> <p>The <code>edp-jenkins-role</code> is renamed to the <code>jenkins-resources-role</code>. Delete the <code>edp-jenkins-role</code> with the following command:</p> <pre><code>  kubectl delete role edp-jenkins-role -n &lt;edp-namespace&gt;\n</code></pre> <p>The <code>jenkins-resources-role</code> role will be created automatically while EDP upgrade.</p> </li> <li> <p>Recreate the <code>edp-jenkins-resources-permissions</code> RoleBinding according to the following template:</p> <p> View: jenkins-resources-role <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\nname: edp-jenkins-resources-permissions\nnamespace: &lt;edp-namespace&gt;\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: Role\nname: jenkins-resources-role\n</code></pre> <li> <p>To upgrade EDP to the v.2.12.x, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.x\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the following command: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.x  --dry-run</code></p> </li> <li> <p>After the update, please remove the <code>gerrit-operator.gerrit.version</code> value. In this case, the default value will be used, and Gerrit will be updated to the <code>v3.6.1</code> version. Run the following command:</p> <pre><code>  helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.x\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the following command: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.12.x  --dry-run</code></p> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images must be the following:<pre><code>epamedp/edp-jenkins-codenarc-agent:3.0.8\nepamedp/edp-jenkins-dotnet-21-agent:3.0.7\nepamedp/edp-jenkins-dotnet-31-agent:3.0.7\nepamedp/edp-jenkins-go-agent:3.0.11\nepamedp/edp-jenkins-gradle-java11-agent:3.0.5\nepamedp/edp-jenkins-gradle-java8-agent:3.0.7\nepamedp/edp-jenkins-helm-agent:3.0.8\nepamedp/edp-jenkins-maven-java11-agent:3.0.6\nepamedp/edp-jenkins-maven-java8-agent:3.0.8\nepamedp/edp-jenkins-npm-agent:3.0.7\nepamedp/edp-jenkins-opa-agent:3.0.5\nepamedp/edp-jenkins-python-38-agent:3.0.5\nepamedp/edp-jenkins-terraform-agent:3.0.6\n</code></pre> </li> </ul> <ul> <li> <p>Add Jenkins agents by following the template:</p> <p> View: jenkins-slaves <pre><code>  sast-template: |\n&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;sast&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;sast&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;epamedp/edp-jenkins-sast-agent:0.1.3&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n</code></pre> <ul> <li> <p>If required, update the requests and limits for the following Jenkins agents:</p> <ul> <li><code>edp-jenkins-codenarc-agent</code></li> <li><code>edp-jenkins-go-agent</code></li> <li><code>edp-jenkins-gradle-java11-agent</code></li> <li><code>edp-jenkins-gradle-java8-agent</code></li> <li><code>edp-jenkins-maven-java11-agent</code></li> <li><code>edp-jenkins-maven-java8-agent</code></li> <li><code>edp-jenkins-npm-agent</code></li> <li><code>edp-jenkins-dotnet-21-agent</code></li> <li><code>edp-jenkins-dotnet-31-agent</code></li> </ul> <p>EDP requires to start with the following values:</p> <p> View: jenkins-slaves <pre><code>  &lt;resourceRequestCpu&gt;500m&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;1Gi&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;2&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;5Gi&lt;/resourceLimitMemory&gt;\n</code></pre> <ul> <li>Restart the Jenkins pod.</li> </ul> <li> <p>Update Jenkins provisioners according to the Manage Jenkins CI Pipeline Job Provisioner instruction.</p> </li> <li> <p>Restart the <code>codebase-operator</code>, to recreate the Code Review and Build pipelines for the codebases.</p> </li> <p>Warning</p> <p>In case there are different EDP versions on one cluster, the following error may occur on the <code>init</code> stage of Jenkins Groovy pipeline: <code>java.lang.NumberFormatException: For input string: \"\"</code>. To fix this issue, please run the following command using <code>kubectl</code> v1.24.4+:</p> <pre><code>kubectl patch codebasebranches.v2.edp.epam.com &lt;codebase-branch-name&gt;  -n &lt;edp-namespace&gt;  '--subresource=status' '--type=merge' -p '{\"status\": {\"build\": \"0\"}}'\n</code></pre>"},{"location":"operator-guide/upgrade-edp-2.12.x-to-3.0.x/","title":"Upgrade EDP v.2.12.x to v.3.0.x","text":"<p>Important</p> <p>We suggest making a backup of the EDP environment before starting the upgrade procedure.</p> <p>This section provides the details on upgrading EDP from the v.2.12.x to the v.3.0.x. Explore the actions and requirements below.</p> <ol> <li> <p>Update Custom Resource Definitions (CRDs). Run the following command to apply all necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/d9a4d15244c527ef6d1d029af27574282a281b98/deploy-templates/crds/v2.edp.epam.com_gerrits.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_cdstagedeployments.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_codebasebranches.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_codebaseimagestreams.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_codebases.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_gitservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_gittags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_imagestreamtags.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_jiraissuemetadatas.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.14/deploy-templates/crds/v2.edp.epam.com_jiraservers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakauthflows.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakclients.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakclientscopes.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmcomponents.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmgroups.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmidentityproviders.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmrolebatches.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmroles.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealms.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloakrealmusers.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.14/deploy-templates/crds/v1.edp.epam.com_keycloaks.yaml\n</code></pre> </li> <li> <p>Set the required parameters. For more details, please refer to the values.yaml file.</p> View: values.yaml <pre><code>edp-tekton:\nenabled: false\nadmin-console-operator:\nenabled: true\njenkins-operator:\nenabled: true\n</code></pre> </li> <li> <p>Add labels and annotations to Custom Resources:       <pre><code>  kubectl label EDPComponent main-keycloak app.kubernetes.io/managed-by=Helm -n &lt;keycloak-namespace&gt;\n  kubectl annotate EDPComponent main-keycloak meta.helm.sh/release-name=&lt;edp-project&gt; -n &lt;keycloak-namespace&gt;\n  kubectl annotate EDPComponent main-keycloak meta.helm.sh/release-namespace=&lt;edp-namespace&gt; -n &lt;keycloak-namespace&gt;\n  kubectl label KeycloakRealm main app.kubernetes.io/managed-by=Helm -n &lt;keycloak-namespace&gt;\n  kubectl annotate KeycloakRealm main meta.helm.sh/release-name=&lt;edp-project&gt; -n &lt;keycloak-namespace&gt;\n  kubectl annotate KeycloakRealm main meta.helm.sh/release-namespace=&lt;edp-namespace&gt; -n &lt;keycloak-namespace&gt;\n</code></pre></p> </li> <li> <p>To upgrade EDP to the v.3.0.x, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.0.x\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with the following command: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=3.0.x  --dry-run</code></p> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>  kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images must be the following:<pre><code>epamedp/edp-jenkins-codenarc-agent:3.0.10\nepamedp/edp-jenkins-dotnet-31-agent:3.0.9\nepamedp/edp-jenkins-go-agent:3.0.17\nepamedp/edp-jenkins-gradle-java11-agent:3.0.7\nepamedp/edp-jenkins-gradle-java8-agent:3.0.10\nepamedp/edp-jenkins-helm-agent:3.0.11\nepamedp/edp-jenkins-kaniko-docker-agent:1.0.9\nepamedp/edp-jenkins-maven-java11-agent:3.0.7\nepamedp/edp-jenkins-maven-java8-agent:3.0.10\nepamedp/edp-jenkins-npm-agent:3.0.9\nepamedp/edp-jenkins-opa-agent:3.0.7\nepamedp/edp-jenkins-python-38-agent:3.0.8\nepamedp/edp-jenkins-sast-agent:0.1.5\nepamedp/edp-jenkins-terraform-agent:3.0.9\n</code></pre> </li> </ul> <ul> <li>Remove the <code>edp-jenkins-dotnet-21-agent</code> agent manifest.</li> </ul> <ul> <li>Restart the Jenkins pod.</li> </ul> </li> <li> <p>Attach the <code>id_rsa.pub</code> SSH public key from the <code>gerrit-ciuser-sshkey</code> secret to the <code>edp-ci</code> Gerrit user in the <code>gerrit</code> pod:</p> <pre><code>ssh -p &lt;gerrit_ssh_port&gt; &lt;host&gt; gerrit set-account --add-ssh-key ~/id_rsa.pub\n</code></pre> <p>Notes</p> <ul> <li>For this operation, use the <code>gerrit-admin</code> SSH key from secrets.</li> <li><code>&lt;host&gt;</code> is admin@localhost or any other user with permissions.</li> </ul> </li> <li> <p>Change the username from <code>jenkins</code> to <code>edp-ci</code> in the <code>gerrit-ciuser-sshkey</code> secret:</p> <pre><code>kubectl -n &lt;edp-namespace&gt; patch secret gerrit-ciuser-sshkey\\\n --patch=\"{\\\"data\\\": { \\\"username\\\": \\\"$(echo -n edp-ci |base64 -w0)\\\" }}\" -oyaml\n</code></pre> </li> </ol> <p>Warning</p> <p>In EDP v.3.0.x, Admin Console is deprecated, and EDP interface is available only via Headlamp.</p>"},{"location":"operator-guide/upgrade-edp-2.7.8-to-2.8.4/","title":"Upgrade EDP v.2.7.8 to v.2.8.4","text":"<p>This section provides the details on the EDP upgrade from the v.2.7.8 to the v.2.8.4. Explore the actions and requirements below.</p> <p>Note</p> <p>Kiosk is implemented and mandatory for EDP v.2.8.4 and is optional for EDP v.2.9.0 and higher.</p> <p>To upgrade EDP v.2.7.8 to the v.2.8.4, take the following steps:</p> <ol> <li> <p>Deploy and configure Kiosk (create a Service Account, Account, and ClusterRoleBinging) according to the Set Up Kiosk documentation.</p> <ul> <li>Update the spec field in the Kiosk space:<pre><code>apiVersion: tenancy.kiosk.sh/v1alpha1\nkind: Space\nmetadata:\nname: &lt;edp-project&gt;\nspec:\naccount: &lt;edp-project&gt;-admin\n</code></pre> </li> </ul> <ul> <li> <p>Create RoleBinding (required for namespaces created before using Kiosk):</p> <p>Note</p> <p>In the uid field under the ownerReferences in the Kubernetes manifest, indicate the Account Custom Resource ID from accounts.config.kiosk.sh <code>kubectl get account &lt;edp-project&gt;-admin -o=custom-columns=NAME:.metadata.uid --no-headers=true</code></p> <p> View: rolebinding-kiosk.yaml <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\ngenerateName: &lt;edp-project&gt;-admin-\nnamespace: &lt;edp-project&gt;\nownerReferences:\n- apiVersion: config.kiosk.sh/v1alpha1\nblockOwnerDeletion: true\ncontroller: true\nkind: Account\nname: &lt;edp-project&gt;-admin\nuid: ''\nroleRef:\napiGroup: rbac.authorization.k8s.io\nkind: ClusterRole\nname: kiosk-space-admin\nsubjects:\n- kind: ServiceAccount\nname: &lt;edp-project&gt;\nnamespace: security\n</code></pre> <pre><code>kubectl create -f rolebinding-kiosk.yaml\n</code></pre> <li> <p>With Amazon Elastic Container Registry to store the images, there are two options:</p> <ul> <li>Enable IRSA and create AWS IAM Role for Kaniko image builder. Please refer to the IAM Roles for Kaniko Service Accounts section for the details.</li> <li>The Amazon Elastic Container Registry Roles can be stored in an instance profile.</li> </ul> </li> <li> <p>Update Custom Resource Definitions by applying all the necessary CRD to the cluster with the command below:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_cdpipeline_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_codebase_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_cd_stage_deploy_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_jenkinsjobbuildrun_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_cdstagejenkinsdeployment_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_jenkinsjob_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.8/deploy-templates/crds/v1_v1alpha1_keycloakauthflow_crd.yaml\n</code></pre> </li> <li> <p>With Amazon Elastic Container Registry to store and Kaniko to build the images, add the kanikoRoleArn parameter to the values before starting the update process. This parameter is indicated in AWS Roles once IRSA is enabled and AWS IAM Role is created for Kaniko. The value should look as follows:</p> <pre><code>kanikoRoleArn: arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\n</code></pre> </li> <li> <p>To upgrade EDP to the v.2.8.4, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.8.4\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.8.4  --dry-run</code></p> </li> <li> <p>Remove the following Kubernetes resources left from the previous EDP installation (it is optional):</p> <pre><code>kubectl delete cm luminatesec-conf -n &lt;edp-namespace&gt;\nkubectl delete sa edp edp-perf-operator -n &lt;edp-namespace&gt;\nkubectl delete deployment perf-operator -n &lt;edp-namespace&gt;\nkubectl delete clusterrole edp-&lt;edp-namespace&gt; edp-perf-operator-&lt;edp-namespace&gt;\nkubectl delete clusterrolebinding edp-&lt;edp-namespace&gt; edp-perf-operator-&lt;edp-namespace&gt;\nkubectl delete rolebinding edp-&lt;edp-namespace&gt; edp-perf-operator-&lt;edp-namespace&gt;-admin -n &lt;edp-namespace&gt;\nkubectl delete perfserver epam-perf -n &lt;edp-namespace&gt;\nkubectl delete services.v2.edp.epam.com postgres rabbit-mq -n &lt;edp-namespace&gt;\n</code></pre> </li> <li> <p>Update the CI and CD Jenkins job provisioners:</p> <p>Note</p> <p>Please refer to the Manage Jenkins CI Pipeline Job Provisioner section for the details.</p> View: Default CI provisioner template for EDP 2.8.4 <pre><code>/* Copyright 2021 EPAM Systems.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport groovy.json.*\nimport jenkins.model.Jenkins\nimport hudson.model.*\n\nJenkins jenkins = Jenkins.instance\ndef stages = [:]\ndef jiraIntegrationEnabled = Boolean.parseBoolean(\"${JIRA_INTEGRATION_ENABLED}\" as String)\ndef commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : ''\ndef createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : ''\ndef buildTool = \"${BUILD_TOOL}\"\ndef goBuildStage = buildTool.toString() == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}'\n\nstages['Code-review-application'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + goBuildStage +\n',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]'\nstages['Code-review-library'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"compile\"},{\"name\": \"tests\"},' +\n'{\"name\": \"sonar\"}]'\nstages['Code-review-autotests'] = '[{\"name\": \"gerrit-checkout\"},{\"name\": \"get-version\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${createJIMStage}\" + ']'\nstages['Code-review-default'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ']'\nstages['Code-review-library-terraform'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"terraform-lint\"}]'\nstages['Code-review-library-opa'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"tests\"}]'\nstages['Code-review-library-codenarc'] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" +\n',{\"name\": \"sonar\"},{\"name\": \"build\"}]'\n\nstages['Build-library-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-npm'] = stages['Build-library-maven']\nstages['Build-library-gradle'] = stages['Build-library-maven']\nstages['Build-library-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-terraform'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' +\n',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-opa'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-library-codenarc'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n\n\nstages['Build-application-maven'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},[{\"name\": \"sonar\"}],{\"name\": \"build\"},{\"name\": \"build-image-kaniko\"},' +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-npm'] = stages['Build-application-maven']\nstages['Build-application-gradle'] = stages['Build-application-maven']\nstages['Build-application-dotnet'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},[{\"name\": \"sonar\"}],{\"name\": \"build-image-kaniko\"},' +\n'{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-go'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build\"},{\"name\": \"build-image-kaniko\"}' +\n\"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\nstages['Build-application-python'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' +\n'{\"name\": \"tests\"},{\"name\": \"sonar\"},' +\n'{\"name\": \"build-image-kaniko\"},{\"name\": \"push\"}' + \"${createJIMStage}\" +\n',{\"name\": \"git-tag\"}]'\n\nstages['Create-release'] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]'\n\ndef defaultBuild = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']'\n\ndef codebaseName = \"${NAME}\"\ndef gitServerCrName = \"${GIT_SERVER_CR_NAME}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\"\ndef repositoryPath = \"${REPOSITORY_PATH}\"\ndef defaultBranch = \"${DEFAULT_BRANCH}\"\n\ndef codebaseFolder = jenkins.getItem(codebaseName)\nif (codebaseFolder == null) {\nfolder(codebaseName)\n}\n\ncreateListView(codebaseName, \"Releases\")\ncreateReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"create-release.groovy\",\nrepositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, defaultBranch)\n\nif (buildTool.toString().equalsIgnoreCase('none')) {\nreturn true\n}\n\nif (BRANCH) {\ndef branch = \"${BRANCH}\"\ndef formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \"-\")}\"\ncreateListView(codebaseName, formattedBranch)\n\ndef type = \"${TYPE}\"\ndef crKey = getStageKeyName(buildTool)\ncreateCiPipeline(\"Code-review-${codebaseName}\", codebaseName, stages[crKey], \"code-review.groovy\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\ndef buildKey = \"Build-${type}-${buildTool.toLowerCase()}\".toString()\nif (type.equalsIgnoreCase('application') || type.equalsIgnoreCase('library')) {\ndef jobExists = false\nif(\"${formattedBranch}-Build-${codebaseName}\".toString() in Jenkins.instance.getAllItems().collect{it.name})\njobExists = true\n\ncreateCiPipeline(\"Build-${codebaseName}\", codebaseName, stages.get(buildKey, defaultBuild), \"build.groovy\",\nrepositoryPath, gitCredentialsId, branch, gitServerCrName, gitServerCrVersion)\n\nif(!jobExists)\nqueue(\"${codebaseName}/${formattedBranch}-Build-${codebaseName}\")\n}\n}\n\ndef createCiPipeline(pipelineName, codebaseName, codebaseStages, pipelineScript, repository, credId, watchBranch, gitServerCrName, gitServerCrVersion) {\npipelineJob(\"${codebaseName}/${watchBranch.toUpperCase().replaceAll(/\\\\//, \"-\")}-${pipelineName}\") {\nlogRotator {\nnumToKeep(10)\ndaysToKeep(7)\n}\ntriggers {\ngerrit {\nevents {\nif (pipelineName.contains(\"Build\"))\nchangeMerged()\nelse\npatchsetCreated()\n}\nproject(\"plain:${codebaseName}\", [\"plain:${watchBranch}\"])\n}\n}\ndefinition {\ncpsScm {\nscm {\ngit {\nremote {\nurl(repository)\ncredentials(credId)\n}\nbranches(\"${watchBranch}\")\nscriptPath(\"${pipelineScript}\")\n}\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${codebaseStages}\", \"Consequence of stages in JSON format to be run during execution\")\nstringParam(\"GERRIT_PROJECT_NAME\", \"${codebaseName}\", \"Gerrit project name(Codebase name) to be build\")\nstringParam(\"BRANCH\", \"${watchBranch}\", \"Branch to build artifact from\")\n}\n}\n}\n}\n}\n\ndef getStageKeyName(buildTool) {\nif (buildTool.toString().equalsIgnoreCase('terraform')) {\nreturn \"Code-review-library-terraform\"\n}\nif (buildTool.toString().equalsIgnoreCase('opa')) {\nreturn \"Code-review-library-opa\"\n}\nif (buildTool.toString().equalsIgnoreCase('codenarc')) {\nreturn \"Code-review-library-codenarc\"\n}\ndef buildToolsOutOfTheBox = [\"maven\",\"npm\",\"gradle\",\"dotnet\",\"none\",\"go\",\"python\"]\ndef supBuildTool = buildToolsOutOfTheBox.contains(buildTool.toString())\nreturn supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\"\n}\n\ndef createReleasePipeline(pipelineName, codebaseName, codebaseStages, pipelineScript, repository, credId,\ngitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, defaultBranch) {\npipelineJob(\"${codebaseName}/${pipelineName}\") {\nlogRotator {\nnumToKeep(14)\ndaysToKeep(30)\n}\ndefinition {\ncpsScm {\nscm {\ngit {\nremote {\nurl(repository)\ncredentials(credId)\n}\nbranches(\"${defaultBranch}\")\nscriptPath(\"${pipelineScript}\")\n}\n}\nparameters {\nstringParam(\"STAGES\", \"${codebaseStages}\", \"\")\nif (pipelineName.contains(\"Create-release\")) {\nstringParam(\"JIRA_INTEGRATION_ENABLED\", \"${jiraIntegrationEnabled}\", \"Is Jira integration enabled\")\nstringParam(\"GERRIT_PROJECT\", \"${codebaseName}\", \"\")\nstringParam(\"RELEASE_NAME\", \"\", \"Name of the release(branch to be created)\")\nstringParam(\"COMMIT_ID\", \"\", \"Commit ID that will be used to create branch from for new release. If empty, HEAD of master will be used\")\nstringParam(\"GIT_SERVER_CR_NAME\", \"${gitServerCrName}\", \"Name of Git Server CR to generate link to Git server\")\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"REPOSITORY_PATH\", \"${repository}\", \"Full repository path\")\nstringParam(\"DEFAULT_BRANCH\", \"${defaultBranch}\", \"Default repository branch\")\n}\n}\n}\n}\n}\n}\n\ndef createListView(codebaseName, branchName) {\nlistView(\"${codebaseName}/${branchName}\") {\nif (branchName.toLowerCase() == \"releases\") {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^Create-release.*\")\n}\n}\n} else {\njobFilters {\nregex {\nmatchType(MatchType.INCLUDE_MATCHED)\nmatchValue(RegexMatchValue.NAME)\nregex(\"^${branchName}-(Code-review|Build).*\")\n}\n}\n}\ncolumns {\nstatus()\nweather()\nname()\nlastSuccess()\nlastFailure()\nlastDuration()\nbuildButton()\n}\n}\n}\n</code></pre> <p>Note</p> <p>Please refer to the Manage Jenkins CD Pipeline Job Provisioner page for the details.</p> View: Default CD provisioner template for EDP 2.8.4 <pre><code>/* Copyright 2021 EPAM Systems.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\nSee the License for the specific language governing permissions and\nlimitations under the License. */\n\nimport groovy.json.*\nimport jenkins.model.Jenkins\n\nJenkins jenkins = Jenkins.instance\n\ndef pipelineName = \"${PIPELINE_NAME}-cd-pipeline\"\ndef stageName = \"${STAGE_NAME}\"\ndef qgStages = \"${QG_STAGES}\"\ndef gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\"\ndef gitCredentialsId = \"${GIT_CREDENTIALS_ID}\"\ndef sourceType = \"${SOURCE_TYPE}\"\ndef libraryURL = \"${LIBRARY_URL}\"\ndef libraryBranch = \"${LIBRARY_BRANCH}\"\ndef autodeploy = \"${AUTODEPLOY}\"\ndef scriptPath = \"Jenkinsfile\"\ndef containerDeploymentType = \"container\"\ndef deploymentType = \"${DEPLOYMENT_TYPE}\"\n\ndef stages = buildStages(deploymentType, containerDeploymentType, qgStages)\n\ndef codebaseFolder = jenkins.getItem(pipelineName)\nif (codebaseFolder == null) {\nfolder(pipelineName)\n}\n\nif (deploymentType == containerDeploymentType) {\ncreateContainerizedCdPipeline(pipelineName, stageName, stages, scriptPath, sourceType,\nlibraryURL, libraryBranch, gitCredentialsId, gitServerCrVersion,\nautodeploy)\n} else {\ncreateCustomCdPipeline(pipelineName, stageName)\n}\n\ndef buildStages(deploymentType, containerDeploymentType, qgStages) {\nreturn deploymentType == containerDeploymentType\n? '[{\"name\":\"init\",\"step_name\":\"init\"},{\"name\":\"deploy\",\"step_name\":\"deploy\"},' + qgStages + ',{\"name\":\"promote-images-ecr\",\"step_name\":\"promote-images\"}]'\n: ''\n}\n\ndef createContainerizedCdPipeline(pipelineName, stageName, stages, pipelineScript, sourceType, libraryURL, libraryBranch, libraryCredId, gitServerCrVersion, autodeploy) {\npipelineJob(\"${pipelineName}/${stageName}\") {\nif (sourceType == \"library\") {\ndefinition {\ncpsScm {\nscm {\ngit {\nremote {\nurl(libraryURL)\ncredentials(libraryCredId)\n}\nbranches(\"${libraryBranch}\")\nscriptPath(\"${pipelineScript}\")\n}\n}\n}\n}\n} else {\ndefinition {\ncps {\nscript(\"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nDeploy()\")\nsandbox(true)\n}\n}\n}\nproperties {\ndisableConcurrentBuilds()\n}\nparameters {\nstringParam(\"GIT_SERVER_CR_VERSION\", \"${gitServerCrVersion}\", \"Version of GitServer CR Resource\")\nstringParam(\"STAGES\", \"${stages}\", \"Consequence of stages in JSON format to be run during execution\")\n\nif (autodeploy?.trim() &amp;&amp; autodeploy.toBoolean()) {\nstringParam(\"AUTODEPLOY\", \"${autodeploy}\", \"Is autodeploy enabled?\")\nstringParam(\"CODEBASE_VERSION\", null, \"Codebase versions to deploy.\")\n}\n}\n}\n}\n\ndef createCustomCdPipeline(pipelineName, stageName) {\npipelineJob(\"${pipelineName}/${stageName}\") {\nproperties {\ndisableConcurrentBuilds()\n}\n}\n}\n</code></pre> <ul> <li>It is also necessary to add the string parameter DEPLOYMENT_TYPE to the CD provisioner:<ul> <li>Go to job-provisions - &gt; cd -&gt; default -&gt; configure;</li> <li>Add Parameter - &gt; String parameter;</li> <li>Name -&gt; DEPLOYMENT_TYPE</li> </ul> </li> </ul> </li> <li> <p>Update Jenkins pipelines and stages to the new release tag:</p> <ul> <li>In Jenkins, go to Manage Jenkins -&gt; Configure system -&gt; Find the Global Pipeline Libraries menu.</li> <li>Change the Default version for edp-library-stages from build/2.8.0-RC.6 to build/2.9.0-RC.5</li> <li>Change the Default version for edp-library-pipelines from build/2.8.0-RC.4 to build/2.9.0-RC.3</li> </ul> </li> <li> <p>Update the edp-admin-console Custom Resource in the KeycloakClient Custom Resource Definition:</p> View: keycloakclient.yaml <pre><code>kind: KeycloakClient\napiVersion: v1.edp.epam.com/v1alpha1\nmetadata:\nname: edp-admin-console\nnamespace: &lt;edp-namespace&gt;\nspec:\nadvancedProtocolMappers: false\nattributes: null\naudRequired: true\nclientId: admin-console-client\ndirectAccess: true\npublic: false\nsecret: admin-console-client\nserviceAccount:\nenabled: true\nrealmRoles:\n- developer\ntargetRealm: &lt;keycloak-edp-realm&gt;\nwebUrl: &gt;-\nhttps://edp-admin-console-example.com\n</code></pre> <pre><code>kubectl apply -f keycloakclient.yaml\n</code></pre> </li> <li> <p>Remove the admin-console-client client ID in the edp-namespace-main realm in Keycloak, restart the keycloak-operator pod and check that the new KeycloakClient is created with the confidential access type.</p> <p>Note</p> <p>If \"Internal error\" occurs, regenerate the admin-console-client secret in the Credentials tab in Keycloak and update the admin-console-client secret key \"clientSecret\" and \"password\".</p> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images should be:<pre><code>epamedp/edp-jenkins-dotnet-21-agent:1.0.2\nepamedp/edp-jenkins-dotnet-31-agent:1.0.2\nepamedp/edp-jenkins-go-agent:1.0.3\nepamedp/edp-jenkins-gradle-java11-agent:2.0.2\nepamedp/edp-jenkins-gradle-java8-agent:1.0.2\nepamedp/edp-jenkins-helm-agent:1.0.6\nepamedp/edp-jenkins-maven-java11-agent:2.0.3\nepamedp/edp-jenkins-maven-java8-agent:1.0.2\nepamedp/edp-jenkins-npm-agent:2.0.2\nepamedp/edp-jenkins-python-38-agent:2.0.3\nepamedp/edp-jenkins-terraform-agent:2.0.4\n</code></pre> </li> </ul> <ul> <li>Add new Jenkins agents under the data field:</li> </ul> View <pre><code>data:\ncodenarc-template: |-\n&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;codenarc&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;codenarc&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;epamedp/edp-jenkins-codenarc-agent:1.0.0&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\nopa-template: |-\n&lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n&lt;inheritFrom&gt;&lt;/inheritFrom&gt;\n&lt;name&gt;opa&lt;/name&gt;\n&lt;namespace&gt;&lt;/namespace&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;\n&lt;slaveConnectTimeout&gt;100&lt;/slaveConnectTimeout&gt;\n&lt;idleMinutes&gt;5&lt;/idleMinutes&gt;\n&lt;activeDeadlineSeconds&gt;0&lt;/activeDeadlineSeconds&gt;\n&lt;label&gt;opa&lt;/label&gt;\n&lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;\n&lt;nodeSelector&gt;beta.kubernetes.io/os=linux&lt;/nodeSelector&gt;\n&lt;nodeUsageMode&gt;NORMAL&lt;/nodeUsageMode&gt;\n&lt;workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"&gt;\n&lt;memory&gt;false&lt;/memory&gt;\n&lt;/workspaceVolume&gt;\n&lt;volumes/&gt;\n&lt;containers&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;name&gt;jnlp&lt;/name&gt;\n&lt;image&gt;epamedp/edp-jenkins-opa-agent:1.0.1&lt;/image&gt;\n&lt;privileged&gt;false&lt;/privileged&gt;\n&lt;alwaysPullImage&gt;false&lt;/alwaysPullImage&gt;\n&lt;workingDir&gt;/tmp&lt;/workingDir&gt;\n&lt;command&gt;&lt;/command&gt;\n&lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;\n&lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;\n&lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;\n&lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;\n&lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;\n&lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;\n&lt;envVars&gt;\n&lt;org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;key&gt;JAVA_TOOL_OPTIONS&lt;/key&gt;\n&lt;value&gt;-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true&lt;/value&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar&gt;\n&lt;/envVars&gt;\n&lt;ports/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;\n&lt;/containers&gt;\n&lt;envVars/&gt;\n&lt;annotations/&gt;\n&lt;imagePullSecrets/&gt;\n&lt;podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/&gt;\n&lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;\n</code></pre> <ul> <li>Restart the Jenkins pod.</li> </ul> </li> <li> <p>Update compatible plugins in Jenkins and install additional plugins:</p> <ul> <li>Go to Manage Jenkins -&gt; Manage Plugins -&gt; Select Compatible -&gt; Click Download now and install after restart</li> <li>Install the following additional plugins (click the Available plugins tab in Jenkins):<ul> <li>Groovy Postbuild</li> <li>CloudBees AWS Credentials</li> <li>Badge</li> <li>Timestamper</li> </ul> </li> </ul> </li> <li> <p>Add the annotation <code>deploy.edp.epam.com/previous-stage-name: ''</code> (it should be empty if the CD pipeline contains one stage) to each Custom Resource in the Custom Resource Definition Stage, for example:</p> <ul> <li>List all Custom Resources in Stage: <code>kubectl get stages.v2.edp.epam.com -n &lt;edp-namespace&gt;</code></li> </ul> <ul> <li>Edit resources: <code>kubectl edit stages.v2.edp.epam.com &lt;cd-stage-name&gt; -n &lt;edp-namespace&gt;</code><pre><code>apiVersion: v2.edp.epam.com/v1alpha1\nkind: Stage\nmetadata:\nannotations:\ndeploy.edp.epam.com/previous-stage-name: ''\n</code></pre> </li> </ul> <p>Note</p> <p>If a pipeline contains several stages, add a previous stage name indicated in the EDP Admin Console to the annotation, for example: <code>deploy.edp.epam.com/previous-stage-name: 'dev'</code>.</p> </li> <li> <p>Execute script to align CDPipeline resources to the new API (jq command-line JSON processor is required):</p> <pre><code>pipelines=$( kubectl get cdpipelines -n &lt;edp-namespace&gt; -ojson | jq -c '.items[]' )\nfor p in $pipelines; do\necho \"$p\" | \\\n    jq '. | .spec.inputDockerStreams = .spec.input_docker_streams | del(.spec.input_docker_streams) | .spec += { \"deploymentType\": \"container\" } ' | \\\n    kubectl apply -f -\ndone\n</code></pre> </li> <li> <p>Update the database in the edp-db pod in the edp-namespace:</p> <ul> <li>Log in to the pod:<pre><code>kubectl exec -i -t -n &lt;edp-namespace&gt; edp-db-&lt;pod&gt; -c edp-db \"--\" sh -c \"(bash || ash || sh)\"\n</code></pre> </li> </ul> <ul> <li>Log in to the Postgress DB (where \"admin\" is the user the secret was created for):<pre><code>psql edp-db &lt;admin&gt;;\nSET search_path to '&lt;edp-namespace&gt;';\nUPDATE cd_pipeline SET deployment_type = 'container';\n</code></pre> </li> </ul> </li> <li> <p>Add <code>\"AUTODEPLOY\":\"true/false\",\"DEPLOYMENT_TYPE\":\"container\"</code> to every Custom Resource in <code>jenkinsjobs.v2.edp.epam.com</code>:</p> <ul> <li>Edit Kubernetes resources:<pre><code>kubectl get jenkinsjobs.v2.edp.epam.com -n &lt;edp-namespace&gt;\n\nkubectl edit jenkinsjobs.v2.edp.epam.com &lt;cd-pipeline-name&gt; -n &lt;edp-namespace&gt;\n</code></pre> </li> </ul> <ul> <li>Alternatively, use this script to update all the necessary jenkinsjobs Custom Resources:<pre><code>edp_namespace=&lt;epd_namespace&gt;\nfor stages in $(kubectl get jenkinsjobs -o=name -n $edp_namespace); do kubectl get $stages -n $edp_namespace -o yaml | grep -q \"container\" &amp;&amp; echo -e \"\\n$stages is already updated\" || kubectl get $stages -n $edp_namespace -o yaml | sed 's/\"GIT_SERVER_CR_VERSION\"/\"AUTODEPLOY\":\"false\",\"DEPLOYMENT_TYPE\":\"container\",\"GIT_SERVER_CR_VERSION\"/g' | kubectl apply -f -; done\n</code></pre> </li> </ul> <ul> <li>Make sure the edited resource looks as follows:<pre><code>job:\nconfig: '{\"AUTODEPLOY\":\"false\",\"DEPLOYMENT_TYPE\":\"container\",\"GIT_SERVER_CR_VERSION\":\"v2\",\"PIPELINE_NAME\":\"your-pipeline-name\",\"QG_STAGES\":\"{\\\"name\\\":\\\"manual\\\",\\\"step_name\\\":\\\"your-step-name\\\"}\",\"SOURCE_TYPE\":\"default\",\"STAGE_NAME\":\"your-stage-name\"}'\nname: job-provisions/job/cd/job/default\n</code></pre> </li> </ul> <ul> <li>Restart the Jenkins operator pod and wait until the CD job provisioner in Jenkins creates the updated pipelines.</li> </ul> </li>"},{"location":"operator-guide/upgrade-edp-2.7.8-to-2.8.4/#possible-issues","title":"Possible Issues","text":"<ol> <li> <p>SonarQube fails during the CI pipeline run. The previous builds of SonarQube used the latest version of the OpenID Connect Authentication for SonarQube plugin. Version 2.1.0 of this plugin may have issues with the connection, so it is necessary to downgrade it in order to get rid of errors in the pipeline. Take the following steps:</p> <ul> <li>Log in to the Sonar pod:<pre><code>kubectl exec -i -t -n &lt;edp-namespace&gt; sonar-&lt;pod&gt; -c sonar \"--\" sh -c \"(bash || ash || sh)\"\n</code></pre> </li> </ul> <ul> <li>Run the command in the Sonar container:<pre><code>rm extensions/plugins/sonar-auth-oidc-plugin*\n</code></pre> </li> </ul> <ul> <li>Install the OpenID Connect Authentication for SonarQube plugin v2.0.0:<pre><code>curl -L  https://github.com/vaulttec/sonar-auth-oidc/releases/download/v2.0.0/sonar-auth-oidc-plugin-2.0.0.jar --output extensions/plugins/sonar-auth-oidc-plugin-2.0.0.jar\n</code></pre> </li> </ul> <ul> <li>Restart the SonarQube pod;</li> </ul> </li> <li> <p>The Helm lint checker in EDP 2.8.4 has some additional rules. There can be issues with it during the Code Review pipeline in Jenkins for applications that were transferred from previous EDP versions to EDP 2.8.4. To fix this, add the following annotation to the <code>Chart.yaml</code> file:</p> <ul> <li>Go to the Git repository -&gt; Choose the application -&gt; Edit the <code>deploy-templates/Chart.yaml</code> file.</li> <li>It is necessary to add the following lines to the bottom of the <code>Chart.yaml</code> file:<pre><code>home: https://github.com/your-repo.git\nsources:\n- https://github.com/your-repo.git\nmaintainers:\n- name: DEV Team\n</code></pre> </li> </ul> <ul> <li>Add a new line character at the end of the last line. Please be aware it is important.</li> </ul> </li> </ol>"},{"location":"operator-guide/upgrade-edp-2.7.8-to-2.8.4/#related-articles","title":"Related Articles","text":"<ul> <li>Set Up Kiosk</li> <li>IAM Roles for Kaniko Service Accounts</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"operator-guide/upgrade-edp-2.8.4-to-2.9.0/","title":"Upgrade EDP v.2.8.4 to v.2.9.0","text":"<p>This section provides the details on the EDP upgrade from the v.2.8.4 to the v.2.9.0. Explore the actions and requirements below.</p> <p>Note</p> <p>Kiosk is optional for EDP v.2.9.0 and higher, and enabled by default. To disable it, add the following parameter to the <code>values.yaml</code> file: <code>kioskEnabled: false</code>. Please refer to the Set Up Kiosk documentation for the details.</p> <ol> <li> <p>With Amazon Elastic Container Registry to store the images, there are two options:</p> <ul> <li>Enable IRSA and create AWS IAM Role for Kaniko image builder. Please refer to the IAM Roles for Kaniko Service Accounts section for the details.</li> <li>The Amazon Elastic Container Registry Roles can be stored in an instance profile.</li> </ul> </li> <li> <p>Before updating EDP from v.2.8.4 to v.2.9.0, update the <code>gerrit-is-credentials</code> secret by adding the new <code>clientSecret</code> key with the value from <code>gerrit-is-credentials.client_secret</code>:</p> <pre><code>kubectl edit secret gerrit-is-credentials -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>Make sure it looks as follows (replace with the necessary key value):<pre><code>data:\nclient_secret: example\nclientSecret: example\n</code></pre> </li> </ul> </li> <li> <p>Update Custom Resource Definitions. This command will apply all the necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritgroupmember_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritgroup_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritprojectaccess_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritproject_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkins_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsagent_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsauthorizationrolemapping_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsauthorizationrole_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.9/deploy-templates/crds/v1_v1alpha1_keycloakclientscope_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.9/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.9/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml\n</code></pre> </li> <li> <p>With Amazon Elastic Container Registry to store and Kaniko to build the images, add the kanikoRoleArn parameter to the values before starting the update process. This parameter is indicated in AWS Roles once IRSA is enabled and AWS IAM Role is created for Kaniko.The value should look as follows:</p> <pre><code>kanikoRoleArn: arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\n</code></pre> </li> <li> <p>To upgrade EDP to the v.2.9.0, run the following command:</p> <pre><code>helm upgrade --install edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.9.0\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with: <code>helm upgrade --install edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.9.0  --dry-run</code></p> </li> <li> <p>Remove the following Kubernetes resources left from the previous EDP installation (it is optional):</p> <pre><code>kubectl delete rolebinding edp-cd-pipeline-operator-&lt;edp-namespace&gt;-admin -n &lt;edp-namespace&gt;\n</code></pre> </li> <li> <p>After EDP update, please restart the 'sonar-operator' pod to address the proper Sonar plugin versioning. After 'sonar-operator' is restarted, check the list of installed plugins in the corresponding SonarQube menu.</p> </li> <li> <p>Update Jenkins pipelines and stages to the new release tag:</p> <ul> <li>Restart the Jenkins pod</li> <li>In Jenkins, go to Manage Jenkins -&gt; Configure system -&gt; Find the Global Pipeline Libraries menu</li> <li>Make sure that the Default version for edp-library-stages is build/2.10.0-RC.1</li> <li>Make sure that the Default version for edp-library-pipelines is build/2.10.0-RC.1</li> </ul> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images should be:<pre><code>epamedp/edp-jenkins-codenarc-agent:1.0.1\nepamedp/edp-jenkins-dotnet-21-agent:1.0.3\nepamedp/edp-jenkins-dotnet-31-agent:1.0.3\nepamedp/edp-jenkins-go-agent:1.0.4\nepamedp/edp-jenkins-gradle-java8-agent:1.0.3\nepamedp/edp-jenkins-gradle-java11-agent:2.0.3\nepamedp/edp-jenkins-helm-agent:1.0.7\nepamedp/edp-jenkins-maven-java8-agent:1.0.3\nepamedp/edp-jenkins-maven-java11-agent:2.0.4\nepamedp/edp-jenkins-npm-agent:2.0.3\nepamedp/edp-jenkins-opa-agent:1.0.2\nepamedp/edp-jenkins-python-38-agent:2.0.4\nepamedp/edp-jenkins-terraform-agent:2.0.5\n</code></pre> </li> </ul> <ul> <li>Restart the Jenkins pod.</li> </ul> </li> <li> <p>Update the compatible plugins in Jenkins:</p> <ul> <li>Go to Manage Jenkins -&gt; Manage Plugins -&gt; Select Compatible -&gt; Click Download now and install after restart</li> </ul> </li> </ol>"},{"location":"operator-guide/upgrade-edp-2.8.4-to-2.9.0/#related-articles","title":"Related Articles","text":"<ul> <li>Set Up Kiosk</li> <li>IAM Roles for Kaniko Service Accounts</li> </ul>"},{"location":"operator-guide/upgrade-edp-2.9.0-to-2.10.2/","title":"Upgrade EDP v.2.9.0 to v.2.10.2","text":"<p>This section provides the details on the EDP upgrade from the v.2.9.0 to the v.2.10.2. Explore the actions and requirements below.</p> <p>Note</p> <p>Kiosk is optional for EDP v.2.9.0 and higher, and is enabled by default. To disable it, add the following parameter to the <code>values.yaml</code> file: <code>global.kioskEnabled: false</code>. Please refer to the Set Up Kiosk documentation for the details.</p> <p>Note</p> <p>In the process of updating the EDP, it is necessary to migrate the database for SonarQube, before performing the update procedure, please carefully read section 4 of this guide.</p> <ol> <li> <p>Before updating EDP from v.2.9.0 to v.2.10.2, delete SonarQube plugins by executing the following command in SonarQube pod:</p> <pre><code>rm -r /opt/sonarqube/extensions/plugins/*\n</code></pre> </li> <li> <p>Update Custom Resource Definitions. Run the following command to apply all the necessary CRDs to the cluster:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.10/deploy-templates/crds/v2_v1alpha1_jenkins_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakclient_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmcomponent_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmidentityprovider_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmrole_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloak_crd.yaml\nkubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.10/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml\n</code></pre> </li> <li> <p>To upgrade EDP to the v.2.10.2, run the following command:</p> <pre><code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.10.2\n</code></pre> <p>Note</p> <p>To verify the installation, it is possible to test the deployment before applying it to the cluster with: <code>helm upgrade edp epamedp/edp-install -n &lt;edp-namespace&gt; --values values.yaml --version=2.10.2  --dry-run</code></p> </li> <li> <p>Migrate the database for SonarQube according to the official documentation.</p> <p>Note</p> <p>Please be aware of possible tables duplication for speeding up the migration process during the upgrade. Due to the duplication, the database disk usage can be temporarily increased to twice as the normal usage. Therefore, the recommended database disk usage is below 50% before the migration start.</p> <ul> <li> <p>Navigate to the project http://SonarQubeServerURL/setup link and follow the setup instructions:</p> <p> Migrate SonarQube database </p> </li> </ul> <ul> <li>Click the Upgrade button and wait for the end of the migration process.</li> </ul> </li> <li> <p>Remove the resources related to the deprecated Sonar Gerrit Plugin that is deleted in EDP 2.10.2:</p> <ul> <li>Remove Sonar Gerrit Plugin from Jenkins (go to Manage Jenkins -&gt; Manage Plugins -&gt; Installed -&gt; Uninstall Sonar Gerrit Plugin).</li> <li>In Gerrit, clone the All-Projects repository.</li> <li>Edit the project.config file in the All-Projects repository and remove the Sonar-Verified label declaration:<pre><code>[label \"Sonar-Verified\"]\nfunction = MaxWithBlock\nvalue = -1 Issues found\nvalue = 0 No score\nvalue = +1 Verified\ndefaultValue = 0\n</code></pre> </li> </ul> <ul> <li>Also, remove the following permissions for the Sonar-Verified label in the project.config file:<pre><code>label-Sonar-Verified = -1..+1 group Administrators\nlabel-Sonar-Verified = -1..+1 group Project Owners\nlabel-Sonar-Verified = -1..+1 group Service Users\n</code></pre> </li> </ul> <ul> <li>Save the changes, and commit and push the repository to HEAD:refs/meta/config bypassing the Gerrit code review:<pre><code>git push origin HEAD:refs/meta/config\n</code></pre> </li> </ul> </li> <li> <p>Update image versions for the Jenkins agents in the ConfigMap:</p> <pre><code>kubectl edit configmap jenkins-slaves -n &lt;edp-namespace&gt;\n</code></pre> <ul> <li>The versions of the images should be:<pre><code>epamedp/edp-jenkins-codenarc-agent:1.0.1\nepamedp/edp-jenkins-dotnet-21-agent:1.0.5\nepamedp/edp-jenkins-dotnet-31-agent:1.0.4\nepamedp/edp-jenkins-go-agent:1.0.6\nepamedp/edp-jenkins-gradle-java8-agent:1.0.3\nepamedp/edp-jenkins-gradle-java11-agent:2.0.3\nepamedp/edp-jenkins-helm-agent:1.0.10\nepamedp/edp-jenkins-maven-java8-agent:1.0.3\nepamedp/edp-jenkins-maven-java11-agent:2.0.4\nepamedp/edp-jenkins-npm-agent:2.0.3\nepamedp/edp-jenkins-opa-agent:1.0.2\nepamedp/edp-jenkins-python-38-agent:2.0.4\nepamedp/edp-jenkins-terraform-agent:2.0.5\n</code></pre> </li> </ul> <ul> <li>Restart the Jenkins pod.</li> </ul> </li> <li> <p>Since EDP version v.2.10.x, the create-release.groovy, code-review.groovy, and build.groovy files are deprecated (<code>pipeline script from SCM</code> is replaced with <code>pipeline script</code>, see below).</p> <ul> <li>Pipeline script from SCM:    Pipeline script from scm example </li> </ul> <ul> <li>Pipeline script:     Pipeline script example </li> </ul> <ul> <li>Update the job-provisioner code and restart the codebase-operator pod. Consult the default job-provisioners code section.</li> </ul> </li> </ol>"},{"location":"operator-guide/upgrade-edp-2.9.0-to-2.10.2/#related-articles","title":"Related Articles","text":"<ul> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Set Up Kiosk</li> <li>SonarQube Upgrade Guide</li> </ul>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/","title":"Upgrade Keycloak v.17.0.x-Legacy to v.19.0.x","text":"<p>Starting from Keycloak v.18.x.x, the Keycloak server has been moved from the Wildfly (JBoss) Application Server to Quarkus framework and is called Keycloak.X.</p> <p>There are two ways to upgrade Keycloak v.17.0.x-legacy to v.19.0.x on Kubernetes, please perform the steps described in the Prerequisites section of this tutorial, and then select a suitable upgrade strategy for your environment:</p> <ul> <li>Upgrade Postgres database to a minor release v.11.17</li> <li>Migrate Postgres database from Postgres v.11.x to v.14.5</li> </ul>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#prerequisites","title":"Prerequisites","text":"<p>Before upgrading Keycloak, please perform the steps below:</p> <ol> <li> <p>Create a backup/snapshot of the Keycloak database volume. Locate the AWS <code>volumeID</code> and then create its snapshot on AWS:</p> <ul> <li> <p>Find the <code>PVC</code> name attached to the Postgres pod. It can be similar to <code>data-keycloak-postgresql-0</code> if the Postgres <code>StatefulSet</code> name is <code>keycloak-postgresql</code>:</p> <pre><code>kubectl get pods keycloak-postgresql-0 -n security -o jsonpath='{.spec.volumes[*].persistentVolumeClaim.claimName}{\"\\n\"}'\n</code></pre> </li> </ul> <ul> <li> <p>Locate the <code>PV</code> <code>volumeName</code> in the <code>data-keycloak-postgresql-0</code> Persistent Volume Claim:</p> <pre><code>kubectl get pvc data-keycloak-postgresql-0 -n security -o jsonpath='{.spec.volumeName}{\"\\n\"}'\n</code></pre> </li> </ul> <ul> <li> <p>Get <code>volumeID</code> in the Persistent Volume:</p> <pre><code>kubectl get pv ${pv_name} -n security -o jsonpath='{.spec.awsElasticBlockStore.volumeID}{\"\\n\"}'\n</code></pre> </li> </ul> </li> <li> <p>Add two additional keys: <code>password</code> and <code>postgres-password</code>, to the <code>keycloak-postgresql</code> secret in the Keycloak namespace.</p> <p>Note</p> <ul> <li>The <code>password</code> key must have the same value as the <code>postgresql-password</code> key.</li> <li>The <code>postgres-password</code> key must have the same value as the <code>postgresql-postgres-password</code> key.</li> </ul> <p>The latest chart for Keycloak.X does not have an option to override Postgres password and admin password keys in the secret, and it uses the Postgres defaults, therefore, a new secret scheme must be implemented:</p> <pre><code>kubectl -n security edit secret keycloak-postgresql\n</code></pre> <pre><code>data:\npostgresql-password: XXXXXX\npostgresql-postgres-password: YYYYYY\npassword: XXXXXX\npostgres-password: YYYYYY\n</code></pre> </li> <li> <p>Save Keycloak <code>StatefulSet</code> names, for example, <code>keycloak</code> and <code>keycloak-postgresql</code>. These names will be used in the new Helm deployments:</p> <pre><code>$ kubectl get statefulset -n security\nNAME                  READY   AGE\nkeycloak              1/1     18h\nkeycloak-postgresql   1/1     18h\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#upgrade-postgres-database-to-a-minor-release-v1117","title":"Upgrade Postgres Database to a Minor Release v.11.17","text":"<p>To upgrade Keycloak by upgrading Postgres Database to a minor release v.11.17, perform the steps described in the Prerequisites section of this tutorial, and then perform the following steps:</p>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#delete-keycloak-resources","title":"Delete Keycloak Resources","text":"<ol> <li> <p>Delete <code>Keycloak</code> and <code>Prostgres</code> <code>StatefulSets</code>:</p> <pre><code>kubectl delete statefulset keycloak keycloak-postgresql -n security\n</code></pre> </li> <li> <p>Delete the Keycloak <code>Ingress</code>object, to prevent hostname duplication issues:</p> <pre><code>kubectl delete ingress keycloak -n security\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#upgrade-keycloak","title":"Upgrade Keycloak","text":"<ol> <li> <p>Make sure the Keycloak chart repository is added:</p> <pre><code>helm repo add codecentric https://codecentric.github.io/helm-charts\nhelm repo update\n</code></pre> </li> <li> <p>Create values for Keycloak:</p> <p>Note</p> <p>Since the Keycloak.X release, Keycloak  and Postgres database charts are separated. Upgrade Keycloak, and then install the Postgres database.</p> <p>Note</p> <ul> <li><code>nameOverride: \"keycloak\"</code> sets the name of the Keycloak pod. It must be the same Keycloak name as in the previous <code>StatefulSet</code>.</li> <li>Change Ingress host name to the Keycloak host name.</li> <li><code>hostname: keycloak-postgresql</code> is the hostname of the pod with the Postgres database that is the same as Postgres StatefulSet name, for example, <code>keycloak-postgresql</code>.</li> <li><code>\"/opt/keycloak/bin/kc.sh start --auto-build\"</code> was used in the legacy Keycloak version. However, it is no longer required in the new Keycloak version since it is deprecated and used by default.</li> <li> <p>Optionally, use the following command for applying the old Keycloak theme:</p> <p><pre><code>bin/kc.sh start --features-disabled=admin2\n</code></pre> </p> </li> </ul> View: keycloak-values.yaml <pre><code>nameOverride: \"keycloak\"\n\nreplicas: 1\n\n# Deploy the latest verion\nimage:\ntag: \"19.0.1\"\n\n# start: create OpenShift realm which is required by EDP\nextraInitContainers: |\n- name: realm-provider\nimage: busybox\nimagePullPolicy: IfNotPresent\ncommand:\n- sh\nargs:\n- -c\n- |\necho '{\"realm\": \"openshift\",\"enabled\": true}' &gt; /opt/keycloak/data/import/openshift.json\nvolumeMounts:\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumeMounts: |\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumes: |\n- name: realm\nemptyDir: {}\n\ncommand:\n- \"/opt/keycloak/bin/kc.sh\"\n- \"--verbose\"\n- \"start\"\n- \"--http-enabled=true\"\n- \"--http-port=8080\"\n- \"--hostname-strict=false\"\n- \"--hostname-strict-https=false\"\n- \"--spi-events-listener-jboss-logging-success-level=info\"\n- \"--spi-events-listener-jboss-logging-error-level=warn\"\n- \"--import-realm\"\n\nextraEnv: |\n- name: KC_PROXY\nvalue: \"passthrough\"\n- name: KEYCLOAK_ADMIN\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: username\n- name: KEYCLOAK_ADMIN_PASSWORD\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: password\n- name: JAVA_OPTS_APPEND\nvalue: &gt;-\n-XX:+UseContainerSupport\n-XX:MaxRAMPercentage=50.0\n-Djava.awt.headless=true\n-Djgroups.dns.query={{ include \"keycloak.fullname\" . }}-headless\n\n# This block should be uncommented if you install Keycloak on Kubernetes\ningress:\nenabled: true\nannotations:\nkubernetes.io/ingress.class: nginx\ningress.kubernetes.io/affinity: cookie\nrules:\n- host: keycloak.&lt;ROOT_DOMAIN&gt;\npaths:\n- path: '{{ tpl .Values.http.relativePath $ | trimSuffix \"/\" }}/'\npathType: Prefix\n\n# This block should be uncommented if you set Keycloak to OpenShift and change the host field\n# route:\n#   enabled: false\n#   # Path for the Route\n#   path: '/'\n#   # Host name for the Route\n#   host: \"keycloak.&lt;ROOT_DOMAIN&gt;\"\n#   # TLS configuration\n#   tls:\n#     enabled: true\n\nresources:\nlimits:\nmemory: \"2048Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"512Mi\"\n\n# Check database readiness at startup\ndbchecker:\nenabled: true\n\ndatabase:\nvendor: postgres\nexistingSecret: keycloak-postgresql\nhostname: keycloak-postgresql\nport: 5432\nusername: admin\ndatabase: keycloak\n</code></pre> </li> <li> <p>Upgrade the Keycloak Helm chart:</p> <p>Note</p> <ul> <li>The Helm chart is substituted with the new Keyacloak.X instance.</li> <li>Change the namespace and the values file name if required.</li> </ul> <pre><code>helm upgrade keycloak codecentric/keycloakx --version 1.6.0 --values keycloak-values.yaml -n security\n</code></pre> <p>Note</p> <p>If there are error messages when upgrading via Helm, make sure that <code>StatefulSets</code> are removed. If they are removed and the error still persists, try to add the <code>--force</code> flag to the Helm command:</p> <pre><code>helm upgrade keycloak codecentric/keycloakx --version 1.6.0 --values keycloak-values.yaml -n security --force\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#install-postgres","title":"Install Postgres","text":"<ol> <li> <p>Add Bitnami chart repository and update Helm repos:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Create values for Postgres:</p> <p>Note</p> <ul> <li>Postgres v.11 and Postgres v.14.5 are not compatible.</li> <li>Postgres image will be upgraded to a minor release v.11.17.</li> <li><code>fullnameOverride: \"keycloak-postgresql\"</code> sets the name of the Postgres StatefulSet. It must be the same as in the previous <code>StatefulSet</code>.</li> </ul> View: postgres-values.yaml <pre><code>fullnameOverride: \"keycloak-postgresql\"\n\n# PostgreSQL read only replica parameters\nreadReplicas:\n# Number of PostgreSQL read only replicas\nreplicaCount: 1\n\nglobal:\npostgresql:\nauth:\nusername: admin\nexistingSecret: keycloak-postgresql\nsecretKeys:\nadminPasswordKey: postgres-password\nuserPasswordKey: password\ndatabase: keycloak\n\nimage:\nregistry: docker.io\nrepository: bitnami/postgresql\ntag: 11.17.0-debian-11-r3\n\nauth:\nexistingSecret: keycloak-postgresql\nsecretKeys:\nadminPasswordKey: postgres-password\nuserPasswordKey: password\n\nprimary:\npersistence:\nenabled: true\nsize: 3Gi\n# If the StorageClass with reclaimPolicy: Retain is used, install an additional StorageClass before installing PostgreSQL\n# (the code is given below).\n# If the default StorageClass will be used - change \"gp2-retain\" to \"gp2\"\nstorageClass: \"gp2-retain\"\n</code></pre> </li> <li> <p>Install the Postgres database chart:</p> <p>Note</p> <p>Change the namespace and the values file name if required.</p> <pre><code>helm install postgresql bitnami/postgresql \\\n--version 11.7.6 \\\n--values postgres-values.yaml \\\n--namespace security\n</code></pre> </li> <li> <p>Log in to Keycloak and check that everything works as expected.</p> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#clean-and-analyze-database","title":"Clean and Analyze Database","text":"<p>Optionally, run the vacuumdb application on the database, to recover space occupied by \"dead tuples\" in the tables, analyze the contents of database tables, and collect statistics for PostgreSQL query engine to improve performance:</p> <p><pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" vacuumdb --analyze --verbose -d keycloak -U postgres\n</code></pre> For all databases, run the following command:</p> <pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" vacuumdb --analyze --verbose --all -U postgres\n</code></pre>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#migrate-postgres-database-from-postgres-v11x-to-v145","title":"Migrate Postgres Database From Postgres v.11.x to v.14.5","text":"<p>Info</p> <p>There is a Postgres database migration script at the end of this tutorial. Please read the section below before using the script.</p> <p>To upgrade Keycloak by migrating Postgres database from Postgres v.11.x to v.14.5, perform the steps described in the Prerequisites section of this tutorial, and then perform the following steps:</p>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#export-postgres-databases","title":"Export Postgres Databases","text":"<ol> <li> <p>Log in to the current Keycloak Postgres pod and create a logical backup of all roles and databases using the pg_dumpall application. If there is no access to the Postgres Superuser, backup the Keycloak database with the pg_dump application:</p> <p>Note</p> <ul> <li>The secret key <code>postgresql-postgres-password</code> is for the <code>postgres</code> Superuser and <code>postgresql-password</code> is for <code>admin</code> user. The <code>admin</code> user is indicated by default in the Postgres Helm chart. The <code>admin</code> user may not have enough permissions to dump all Postgres databases and roles, so the preferred option for exporting all objects is using the <code>pg_dumpall</code> tool with the <code>postgres</code> Superuser.</li> <li>If the <code>PGPASSWORD</code> variable is not specified before using the <code>pg_dumpall</code> tool, you will be prompted to enter a password for each database during the export.</li> <li>If the <code>-l keycloak</code> parameter is specified, <code>pg_dumpall</code> will connect to the <code>keycloak</code> database for dumping global objects and discovering what other databases should be dumped. By default, <code>pg_dumpall</code> will try to connect to <code>postgres</code> or <code>template1</code> databases. This parameter is optional.</li> <li>The <code>pg_dumpall --clean</code> option adds SQL commands to the dumped file for dropping databases before recreating them during import, as well as <code>DROP</code> commands for roles and tablespaces (<code>pg_dump</code> also has this option). If the <code>--clean</code> parameter is specified, connect to the <code>postgres</code> database initially during import via <code>psql</code>. The <code>psql</code> script will attempt to drop other databases immediately, and that will fail for the database you are connected to. This flag is optional, and it is not included into this tutorial.</li> </ul> <pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" pg_dumpall -h localhost -p 5432 -U postgres -l keycloak &gt; /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> <p>Note</p> <p>If there is no working password for the <code>postgres</code> Superuser, try the <code>admin</code> user using the pg_dump tool to export the <code>keycloak</code> database without global roles:</p> <pre><code>PGPASSWORD=\"${postgresql_password}\" pg_dump -h localhost -p 5432 -U admin -d keycloak &gt; /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> <p>Info</p> <p>Double-check that the contents of the dumped file is not empty. It usually contains more than 4000 lines.</p> </li> <li> <p>Copy the file with the database dump to a local machine. Since <code>tar</code> may not be present in the pod and <code>kubectl cp</code> will not work without <code>tar</code>, use the following command:</p> <pre><code>kubectl exec -n security ${postgresql_pod} -- cat /tmp/keycloak_wildfly_db_dump.sql  &gt; keycloak_wildfly_db_dump.sql\n</code></pre> <p>Note</p> <p>Please find below the alternative commands for exporting the database to the local machine without copying the file to a pod for Postgres and admin users:</p> <pre><code>kubectl exec -n security ${postgresql_pod} \"--\" sh -c \"PGPASSWORD='\"${postgresql_postgres-password}\"' pg_dumpall -h localhost -p 5432 -U postgres\" &gt; keycloak_wildfly_db_dump.sql\nkubectl exec -n security ${postgresql_pod} \"--\" sh -c \"PGPASSWORD='\"${postgresql_password}\"' pg_dump -h localhost -p 5432 -U admin -d keycloak\" &gt; keycloak_wildfly_db_dump.sql\n</code></pre> </li> <li> <p>Delete the dumped file from the pod for security reasons:</p> <pre><code>kubectl exec -n security ${postgresql_pod} \"--\" sh -c \"rm /tmp/keycloak_wildfly_db_dump.sql\"\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#delete-keycloak-resources_1","title":"Delete Keycloak Resources","text":"<ol> <li> <p>Delete all previous Keycloak resources along with the Postgres database and keycloak <code>StatefulSets</code>, <code>Ingress</code>, and custom resources via Helm, or via the tool used for their deployment.</p> <pre><code>helm list -n security\nhelm delete keycloak -n security\n</code></pre> <p>Warning</p> <p>Don't delete the whole namespace. Keep the <code>keycloak-postgresql</code> and <code>keycloak-admin-creds</code> secrets.</p> </li> <li> <p>Delete the volume in AWS, from which a snapshot has been created. Then delete the PVC:</p> <pre><code>kubectl delete pvc data-keycloak-postgresql-0 -n security\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#install-postgres_1","title":"Install Postgres","text":"<ol> <li> <p>Add Bitnami chart repository and update Helm repos:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\n</code></pre> </li> <li> <p>Create Postgres values:</p> <p>Note</p> <p><code>fullnameOverride: \"keycloak-postgresql\"</code> sets the name of the Postgres StatefulSet. It must be same as in the previous <code>StatefulSet</code>.</p> View: postgres-values.yaml <pre><code>nameOverride: \"keycloak-postgresql\"\n\n# PostgreSQL read only replica parameters\nreadReplicas:\n# Number of PostgreSQL read only replicas\nreplicaCount: 1\n\nglobal:\npostgresql:\nauth:\nusername: admin\nexistingSecret: keycloak-postgresql\nsecretKeys:\nadminPasswordKey: postgres-password\nuserPasswordKey: password\ndatabase: keycloak\n\nauth:\nexistingSecret: keycloak-postgresql\nsecretKeys:\nadminPasswordKey: postgres-password\nuserPasswordKey: password\n\nprimary:\npersistence:\nenabled: true\nsize: 3Gi\n# If the StorageClass with reclaimPolicy: Retain is used, install an additional StorageClass before installing PostgreSQL\n# (the code is given below).\n# If the default StorageClass will be used - change \"gp2-retain\" to \"gp2\"\nstorageClass: \"gp2-retain\"\n</code></pre> </li> <li> <p>Install the Postgres database:</p> <p>Note</p> <p>Change the namespace and the values file name if required.</p> <pre><code>helm install postgresql bitnami/postgresql \\\n--version 11.7.6 \\\n--values postgres-values.yaml \\\n--namespace security\n</code></pre> </li> <li> <p>Wait for the database to be ready.</p> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#import-postgres-databases","title":"Import Postgres Databases","text":"<ol> <li> <p>Upload the database dump to the new Keycloak Postgres pod:</p> <pre><code>cat keycloak_wildfly_db_dump.sql | kubectl exec -i -n security ${postgresql_pod} \"--\" sh -c \"cat &gt; /tmp/keycloak_wildfly_db_dump.sql\"\n</code></pre> <p>Warning</p> <p>Database import must be done before deploying Keycloak, because Keycloak will write its own data to the database during the start, and the import will partially fail. If that happened, scale down the keycloak <code>StatefulSet</code>, and try to drop the Keycloak database in the Postgres pod:</p> <pre><code>dropdb -i -e keycloak -p 5432 -h localhost -U postgres\n</code></pre> <p>If there still are some conflicting objects like roles, drop them via the DROP ROLE command.</p> <p>If the previous steps do not help, downscale the Keycloak and Postgres <code>StatefulSets</code> and delete the attached <code>PVC</code> (save the <code>volumeID</code> before removing), and delete the volume on AWS if using <code>gp2-retain</code>. In case of using <code>gp2</code>, the volume will be deleted automatically after removing PVC. After that, redeploy the Postgres database, so that the new <code>PVC</code> is automatically created.</p> </li> <li> <p>Import the SQL dump file to the Postgres database cluster:</p> <p>Info</p> <p>Since the databases were exported in the <code>sql</code> format, the psql tool will be used to restore (reload) them. pg_restore does not support this plain-text format.</p> <ul> <li> <p>If the entire Postgres database cluster was migrated with the <code>postgres</code> Superuser using <code>pg_dumpall</code>, use the import command without indicating the database:</p> <pre><code>psql -U postgres -f /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> </li> </ul> <ul> <li> <p>If the database was migrated with the <code>admin</code> user using <code>pg_dump</code>, the <code>postgres</code> Superuser still can be used to restore it, but, in this case, a database must be indicated:</p> <p>Warning</p> <p>If the database name was not indicated during the import for the file dumped with <code>pg_dump</code>, the <code>psql</code> tool will import this database to a default Postgres database called <code>postgres</code>.</p> <pre><code>psql -U postgres -d keycloak -f /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> </li> </ul> <ul> <li> <p>If the <code>postgres</code> Superuser is not accessible in the Postgres pod, run the command under the <code>admin</code> or any other user that has the database permissions. In this case, indicate the database as well:</p> <pre><code>psql -U admin -d keycloak -f /tmp/keycloak_wildfly_db_dump.sql\n</code></pre> </li> </ul> </li> <li> <p>After a successful import, delete the dump file from the pod for security reasons:</p> <pre><code>kubectl exec -n security ${postgresql_pod} \"--\" sh -c \"rm /tmp/keycloak_wildfly_db_dump.sql\"\n</code></pre> <p>Note</p> <p>Please find below the alternative commands for importing the database from the local machine to the pod without storing the backup on a pod for <code>postgres</code> or <code>admin</code> users:</p> <pre><code>cat \"keycloak_wildfly_db_dump.sql\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" sh -c \"cat | PGPASSWORD='\"${postgresql_superuser_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\"\"\ncat \"keycloak_wildfly_db_dump.sql\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" sh -c \"cat | PGPASSWORD='\"${postgresql_superuser_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\ncat \"keycloak_wildfly_db_dump.sql\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" sh -c \"cat | PGPASSWORD='\"${postgresql_admin_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\n</code></pre> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#install-keycloak","title":"Install Keycloak","text":"<ol> <li> <p>Make sure the Keycloak chart repository is added:</p> <pre><code>helm repo add codecentric https://codecentric.github.io/helm-charts\nhelm repo update\n</code></pre> </li> <li> <p>Create Keycloak values:</p> <p>Note</p> <ul> <li><code>nameOverride: \"keycloak\"</code> sets the name of the Keycloak pod. It must be the same Keycloak name as in the previous <code>StatefulSet</code>.</li> <li>Change Ingress host name to the Keycloak host name.</li> <li><code>hostname: keycloak-postgresql</code> is the hostname of the pod with the Postgres database that is the same as Postgres StatefulSet name, for example, <code>keycloak-postgresql</code>.</li> <li><code>\"/opt/keycloak/bin/kc.sh start --auto-build\"</code> was used in the legacy Keycloak version. However, it is no longer required in the new Keycloak version since it is deprecated and used by default.</li> <li> <p>Optionally, use the following command for applying the old Keycloak theme:</p> <pre><code>bin/kc.sh start --features-disabled=admin2\n</code></pre> </li> </ul> <p>Info</p> <p>Automatic database migration will start after the Keycloak installation.</p> View: keycloak-values.yaml <pre><code>nameOverride: \"keycloak\"\n\nreplicas: 1\n\n# Deploy the latest verion\nimage:\ntag: \"19.0.1\"\n\n# start: create OpenShift realm which is required by EDP\nextraInitContainers: |\n- name: realm-provider\nimage: busybox\nimagePullPolicy: IfNotPresent\ncommand:\n- sh\nargs:\n- -c\n- |\necho '{\"realm\": \"openshift\",\"enabled\": true}' &gt; /opt/keycloak/data/import/openshift.json\nvolumeMounts:\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumeMounts: |\n- name: realm\nmountPath: /opt/keycloak/data/import\n\nextraVolumes: |\n- name: realm\nemptyDir: {}\n\ncommand:\n- \"/opt/keycloak/bin/kc.sh\"\n- \"--verbose\"\n- \"start\"\n- \"--http-enabled=true\"\n- \"--http-port=8080\"\n- \"--hostname-strict=false\"\n- \"--hostname-strict-https=false\"\n- \"--spi-events-listener-jboss-logging-success-level=info\"\n- \"--spi-events-listener-jboss-logging-error-level=warn\"\n- \"--import-realm\"\n\nextraEnv: |\n- name: KC_PROXY\nvalue: \"passthrough\"\n- name: KEYCLOAK_ADMIN\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: username\n- name: KEYCLOAK_ADMIN_PASSWORD\nvalueFrom:\nsecretKeyRef:\nname: keycloak-admin-creds\nkey: password\n- name: JAVA_OPTS_APPEND\nvalue: &gt;-\n-XX:+UseContainerSupport\n-XX:MaxRAMPercentage=50.0\n-Djava.awt.headless=true\n-Djgroups.dns.query={{ include \"keycloak.fullname\" . }}-headless\n\n# This block should be uncommented if you install Keycloak on Kubernetes\ningress:\nenabled: true\nannotations:\nkubernetes.io/ingress.class: nginx\ningress.kubernetes.io/affinity: cookie\nrules:\n- host: keycloak.&lt;ROOT_DOMAIN&gt;\npaths:\n- path: '{{ tpl .Values.http.relativePath $ | trimSuffix \"/\" }}/'\npathType: Prefix\n\n# This block should be uncommented if you set Keycloak to OpenShift and change the host field\n# route:\n#   enabled: false\n#   # Path for the Route\n#   path: '/'\n#   # Host name for the Route\n#   host: \"keycloak.&lt;ROOT_DOMAIN&gt;\"\n#   # TLS configuration\n#   tls:\n#     enabled: true\n\nresources:\nlimits:\nmemory: \"2048Mi\"\nrequests:\ncpu: \"50m\"\nmemory: \"512Mi\"\n\n# Check database readiness at startup\ndbchecker:\nenabled: true\n\ndatabase:\nvendor: postgres\nexistingSecret: keycloak-postgresql\nhostname: keycloak-postgresql\nport: 5432\nusername: admin\ndatabase: keycloak\n</code></pre> </li> <li> <p>Deploy Keycloak:</p> <p>Note</p> <p>Change the namespace and the values file name if required.</p> <pre><code>helm install keycloak codecentric/keycloakx --version 1.6.0 --values keycloak-values.yaml -n security\n</code></pre> </li> <li> <p>Log in to Keycloak and check if everything has been imported correctly.</p> </li> </ol>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#clean-and-analyze-database_1","title":"Clean and Analyze Database","text":"<p>Optionally, run the vacuumdb application on the database, to analyze the contents of database tables and collect statistics for the Postgres query optimizer:</p> <p><pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" vacuumdb --analyze --verbose -d keycloak -U postgres\n</code></pre> For all databases, run the following command:</p> <pre><code>PGPASSWORD=\"${postgresql_postgres-password}\" vacuumdb --analyze --verbose --all -U postgres\n</code></pre>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#postgres-database-migration-script","title":"Postgres Database Migration Script","text":"<p>Info</p> <p>Please read the Migrate Postgres Database From Postgres v.11.x to v.14.5 section of this tutorial before using the script.</p> <p>Note</p> <ul> <li>The <code>kubectl</code> tool is required for using this script.</li> <li>This script will likely work for any other Postgres database besides Keycloak after some adjustments. It queries the <code>pg_dump</code>, <code>pg_dumpall</code>, <code>psql</code>, and <code>vacuumdb</code> commands under the hood.</li> </ul> <p>The following script can be used for exporting and importing Postgres databases as well as optimizing them with the vacuumdb application. Please examine the code and make the adjustments if required.</p> <ul> <li> <p>By default, the following command exports Keycloak Postgres databases from a Kubernetes pod to a local machine:</p> <pre><code>./script.sh\n</code></pre> <p>After running the command, please follow the prompt.</p> </li> </ul> <ul> <li>To import a database backup to a newly created Postgres Kubernetes pod, pass a database dump sql file to the script:<pre><code>./script.sh path-to/db_dump.sql\n</code></pre> </li> </ul> <ul> <li>The <code>-h</code> flag prints help, and <code>-c|-v</code> runs the <code>vacuumdb</code> garbage collector and analyzer.</li> </ul> View: keycloak_db_migration.sh <pre><code>#!/bin/bash\n\n# set -x\n\ndb_migration_help(){\necho \"Keycloak Postgres database migration\"\necho\necho \"Usage:\"\necho \"------------------------------------------\"\necho \"Export Keycloak Postgres database from pod\"\necho \"Run without parameters:\"\necho \"      $0\"\necho \"------------------------------------------\"\necho \"Import Keycloak Postgres database to pod\"\necho \"Pass filename to script:\"\necho \"      $0 path/to/db_dump.sql\"\necho \"------------------------------------------\"\necho \"Additional options: \"\necho \"      $0 [OPTIONS...]\"\necho \"Options:\"\necho \"h     Print Help.\"\necho \"c|v   Run garbage collector and analyzer.\"\n}\n\nkeycloak_ns(){\nprintf '%s\\n' 'Enter keycloak namespace: '\nread -r keycloak_namespace\n\n    if [ -z \"${keycloak_namespace}\" ]; then\necho \"Don't skip namespace\"\nexit 1\nfi\n}\n\npostgres_pod(){\nprintf '%s\\n' 'Enter postgres pod name: '\nread -r postgres_pod_name\n\n    if [ -z \"${postgres_pod_name}\" ]; then\necho \"Don't skip pod name\"\nexit 1\nfi\n}\n\npostgres_user(){\nprintf '%s\\n' 'Enter postgres username: '\nprintf '%s' \"Skip to use [postgres] superuser: \"\nread -r postgres_username\n\n    if [ -z \"${postgres_username}\" ]; then\npostgres_username='postgres'\nfi\n}\n\npgdb_host_info(){\ndatabase_name='keycloak'\ndb_host='localhost'\ndb_port='5432'\n}\n\npostgresql_admin_pass(){\npostgresql_password='POSTGRES_PASSWORD'\npostgresql_admin_password=\"$(kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"printenv ${postgresql_password}\")\"\n}\n\npostgresql_su_pass(){\npostgresql_postgres_password='POSTGRES_POSTGRES_PASSWORD'\npostgresql_superuser_password=\"$(kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"printenv ${postgresql_postgres_password}\")\"\n\nif [ -z \"${postgresql_superuser_password}\" ]; then\necho \"SuperUser password variable does not exist. Using user password instead...\"\npostgresql_admin_pass\n        postgresql_superuser_password=\"${postgresql_admin_password}\"\nfi\n}\n\nkeycloak_pgdb_export(){\ncurrent_cluster=\"$(kubectl config current-context)\"\nexported_db_name=\"keycloak_db_dump_${current_cluster}_${keycloak_namespace}_${postgres_username}_$(date +\"%Y%m%d%H%M\").sql\"\n\nif [ \"${postgres_username}\" == 'postgres' ]; then\n# call a function to get a pass for postgres user\npostgresql_su_pass\n        kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"PGPASSWORD='\"${postgresql_superuser_password}\"' pg_dumpall -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\"\" &gt; \"${exported_db_name}\"\nelse\n# call a function to get a pass for admin user\npostgresql_admin_pass\n        kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"PGPASSWORD='\"${postgresql_admin_password}\"' pg_dump -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\" &gt; \"${exported_db_name}\"\nfi\n\nseparate_lines=\"---------------\"\n\nif [ ! -s \"${exported_db_name}\" ]; then\nrm -f \"${exported_db_name}\"\necho \"${separate_lines}\"\necho \"Something went wrong. The database dump file is empty and was not saved.\"\nelse\necho \"${separate_lines}\"\ngrep 'Dumped' \"${exported_db_name}\" | sort -u\n        echo \"Database has been exported to $(pwd)/${exported_db_name}\"\nfi\n}\n\nkeycloak_pgdb_import(){\necho \"Preparing Import\"\necho \"----------------\"\n\nif [ ! -f \"$1\" ]; then\necho \"The file $1 does not exist.\"\nexit 1\nfi\n\nkeycloak_ns\n    postgres_pod\n    postgres_user\n    pgdb_host_info\n\n    if [ \"${postgres_username}\" == 'postgres' ]; then\n# restore full backup with all databases and roles as superuser or a single database\npostgresql_su_pass\n        if [ -n \"$(cat \"$1\" | grep 'CREATE ROLE')\" ]; then\ncat \"$1\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"cat | PGPASSWORD='\"${postgresql_superuser_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\"\"\nelse\ncat \"$1\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"cat | PGPASSWORD='\"${postgresql_superuser_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\nfi\nelse\n# restore a single database\npostgresql_admin_pass\n        cat \"$1\" | kubectl exec -i -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"cat | PGPASSWORD='\"${postgresql_admin_password}\"' psql -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\nfi\n}\n\nvacuum_pgdb(){\necho \"Preparing garbage collector and analyzer\"\necho \"----------------------------------------\"\n\nkeycloak_ns\n    postgres_pod\n    postgres_user\n    pgdb_host_info\n\n    if [ \"${postgres_username}\" == 'postgres' ]; then\npostgresql_su_pass\n        kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"PGPASSWORD='\"${postgresql_superuser_password}\"' vacuumdb --analyze --all -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\"\"\nelse\npostgresql_admin_pass\n        kubectl exec -n \"${keycloak_namespace}\" \"${postgres_pod_name}\" \"--\" \\\nsh -c \"PGPASSWORD='\"${postgresql_admin_password}\"' vacuumdb --analyze -h \"${db_host}\" -p \"${db_port}\" -U \"${postgres_username}\" -d \"${database_name}\"\"\nfi\n}\n\nwhile [ \"$#\" -eq 1 ]; do\ncase \"$1\" in\n-h | --help)\ndb_migration_help\n            exit 0\n;;\n-c | --clean | -v | --vacuum)\nvacuum_pgdb\n            exit 0\n;;\n--)\nbreak\n;;\n-*)\necho \"Invalid option '$1'. Use -h|--help to see the valid options\" &gt;&amp;2\nexit 1\n;;\n*)\nkeycloak_pgdb_import \"$1\"\nexit 0\n;;\nesac\nshift\ndone\n\nif [ \"$#\" -gt 1 ]; then\necho \"Please pass a single file to the script\"\nexit 1\nfi\n\necho \"Preparing Export\"\necho \"----------------\"\nkeycloak_ns\npostgres_pod\npostgres_user\npgdb_host_info\nkeycloak_pgdb_export\n</code></pre>"},{"location":"operator-guide/upgrade-keycloak-17.0.x-legacy-to-19.0.x/#related-articles","title":"Related Articles","text":"<ul> <li>Deploy OKD 4.10 Cluster</li> </ul>"},{"location":"operator-guide/velero-irsa/","title":"IAM Roles for Velero Service Accounts","text":"<p>Note</p> <p>Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation.</p> <p>Velero AWS plugin requires access to AWS resources. Follow the steps below to create a required role:</p> <ol> <li> <p>Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero_policy\":</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": [\n\"ec2:DescribeVolumes\",\n\"ec2:DescribeSnapshots\",\n\"ec2:CreateTags\",\n\"ec2:CreateVolume\",\n\"ec2:CreateSnapshot\",\n\"ec2:DeleteSnapshot\"\n],\n\"Resource\": \"*\"\n},\n{\n\"Effect\": \"Allow\",\n\"Action\": [\n\"s3:GetObject\",\n\"s3:DeleteObject\",\n\"s3:PutObject\",\n\"s3:AbortMultipartUpload\",\n\"s3:ListMultipartUploadParts\"\n],\n\"Resource\": [\n\"arn:aws:s3:::velero-*/*\"\n]\n},\n{\n\"Effect\": \"Allow\",\n\"Action\": [\n\"s3:ListBucket\"\n],\n\"Resource\": [\n\"arn:aws:s3:::velero-*\"\n]\n}\n]\n}\n</code></pre> </li> <li> <p>Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" with trust relationships:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:oidc-provider/&lt;OIDC_PROVIDER&gt;\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"&lt;OIDC_PROVIDER&gt;:sub\": \"system:serviceaccount:&lt;VELERO_NAMESPACE&gt;:edp-velero\"\n       }\n     }\n   }\n ]\n}\n</code></pre> </li> <li> <p>Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" role.</p> </li> <li> <p>Make sure that Amazon S3 bucket with name velero-\u2039CLUSTER_NAME\u203a exists.</p> </li> <li> <p>Provide key value eks.amazonaws.com/role-arn: \"arn:aws:iam:::role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" into the serviceAccount.server.annotations parameter in values.yaml during the Velero Installation."},{"location":"operator-guide/velero-irsa/#related-articles","title":"Related Articles","text":"<ul> <li>Associate IAM Roles With Service Accounts</li> <li>Install Velero</li> </ul>"},{"location":"operator-guide/waf-tf-configuration/","title":"Configure AWS WAF With Terraform","text":"<p>This page contains accurate information on how to configure AWS WAF using Terraform with the aim to have a secured traffic exposure and to prevent the Host Header vulnerabilities.</p>"},{"location":"operator-guide/waf-tf-configuration/#prerequisites","title":"Prerequisites","text":"<p>To follow the instruction, check the following prerequisites:</p> <ol> <li>Deployed infrastructure includes Nginx Ingress Controller</li> <li>Deployed services for testing</li> <li>Separate and exposed AWS ALB</li> <li>terraform 0.14.10</li> <li>hishicorp/aws = 4.8.0</li> </ol>"},{"location":"operator-guide/waf-tf-configuration/#solution-overview","title":"Solution Overview","text":"<p>The solution includes two parts:</p> <ol> <li>Prerequisites (mostly the left part of the scheme) - AWS ALB, Compute Resources (EC2, EKS, etc.).</li> <li>WAF configuration (the right part of the scheme).</li> </ol> <p>The WAF ACL resource is the main resource used for the configuration; The default web ACL option is Block.</p> <p> Overview WAF Solution </p> <p>The ACL includes three managed AWS rules that secure the exposed traffic:</p> <ul> <li>AWS-AWSManagedRulesCommonRuleSet</li> <li>AWS-AWSManagedRulesLinuxRuleSet</li> <li>AWS-AWSManagedRulesKnownBadInputsRuleSet</li> </ul> <p>AWS provides a lot of rules such as baseline and use-case specific rules, for details, please refer to the Baseline rule groups.</p> <p>There is the PreventHostInjections rule that prevents the Host Header vulnerabilities. This rule includes one statement that declares that the Host Header should match Regex Pattern Set, thus only in this case it will be passed.</p> <p>The Regex Pattern Set is another resource that helps to organize regexes, in fact, is a set of regexes. All regexes added to the single set are matched by the OR statement, i.e. when exposing several URLs, it is necessary to add this statement to the set and refer to it in the rule.</p>"},{"location":"operator-guide/waf-tf-configuration/#waf-acl-configuration","title":"WAF ACL Configuration","text":"<p>To create the Regex Pattern Set, inspect the following code:</p> <pre><code>resource \"aws_wafv2_regex_pattern_set\" \"common\" {\nname  = \"Common\"\nscope = \"REGIONAL\"\n\nregular_expression {\nregex_string = \"^.*(some-url).*((.edp-epam)+)\\\\.com$\"\n}\n\n  #  Add here additional regular expressions for other endpoints, they are merging with OR operator, e.g.\n\n  /*\n   regular_expression {\n      regex_string = \"^.*(jenkins).*((.edp-epam)+)\\\\.com$\"\n   }\n   */\n\ntags = var.tags\n}\n</code></pre> <p>It includes 'regex_string', for example: url - some-url.edp-epam.com, In addition, it is possible to add other links to the same resource using the regular_expression element.</p> <p>There is the Terraform code for the aws_wafv2_web_acl resource:</p> <pre><code>resource \"aws_wafv2_web_acl\" \"external\" {\nname  = \"ExternalACL\"\nscope = \"REGIONAL\"\n\ndefault_action {\nblock {}\n}\n\nrule {\nname     = \"AWS-AWSManagedRulesCommonRuleSet\"\npriority = 1\n\noverride_action {\nnone {}\n}\n\nstatement {\nmanaged_rule_group_statement {\nname        = \"AWSManagedRulesCommonRuleSet\"\nvendor_name = \"AWS\"\n}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"AWS-AWSManagedRulesCommonRuleSet\"\nsampled_requests_enabled   = true\n}\n}\n\nrule {\nname     = \"AWS-AWSManagedRulesLinuxRuleSet\"\npriority = 2\n\nstatement {\nmanaged_rule_group_statement {\nname        = \"AWSManagedRulesLinuxRuleSet\"\nvendor_name = \"AWS\"\n}\n}\n\noverride_action {\nnone {}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"AWS-AWSManagedRulesLinuxRuleSet\"\nsampled_requests_enabled   = true\n}\n}\n\nrule {\nname     = \"AWS-AWSManagedRulesKnownBadInputsRuleSet\"\npriority = 3\n\noverride_action {\nnone {}\n}\n\nstatement {\nmanaged_rule_group_statement {\nname        = \"AWSManagedRulesKnownBadInputsRuleSet\"\nvendor_name = \"AWS\"\n}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"AWS-AWSManagedRulesKnownBadInputsRuleSet\"\nsampled_requests_enabled   = true\n}\n}\n\nrule {\nname     = \"PreventHostInjections\"\npriority = 0\n\nstatement {\nregex_pattern_set_reference_statement {\narn = aws_wafv2_regex_pattern_set.common.arn\n\nfield_to_match {\nsingle_header {\nname = \"host\"\n}\n}\n\ntext_transformation {\npriority = 0\ntype     = \"NONE\"\n}\n}\n}\n\naction {\nallow {}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"PreventHostInjections\"\nsampled_requests_enabled   = true\n}\n}\n\nvisibility_config {\ncloudwatch_metrics_enabled = true\nmetric_name                = \"ExternalACL\"\nsampled_requests_enabled   = true\n}\n\ntags = var.tags\n}\n</code></pre> <p>As mentioned previously, ACL includes three managed AWS rules (group rules), for visibility, enabling sampling, and CloudWatch in the config. The 'PreventHostInjections' custom rule refers to the created pattern set and declares the Host Header, as well as sets the 'Action' if matched to 'Allow'.</p>"},{"location":"operator-guide/waf-tf-configuration/#associate-aws-resource","title":"Associate AWS Resource","text":"<p>To have the created ACL working, it is necessary to associate an AWS resource with it, in this case, it is AWS ALB:</p> <pre><code>resource \"aws_wafv2_web_acl_association\" \"waf_alb\" {\nresource_arn = aws_lb.&lt;aws_alb_for_waf&gt;.arn\nweb_acl_arn  = aws_wafv2_web_acl.external.arn\n}\n</code></pre> <p>Note</p> <p>AWS ALB can be created in the scope of this Terraform code or created previously. When creating ALB to expose links, the ALB should have a security group that allows some external traffic.</p> <p>When ALB is associated with the WAF ACL, direct the traffic to the ALB by the Route53 CNAME record:</p> <pre><code>module \"some_url_exposure\" {\nsource  = \"terraform-aws-modules/route53/aws//modules/records\"\nversion = \"2.0.0\"\n\nzone_name = \"edp-epam.com\"\n\nrecords = [\n{\nname    = \"some-url\"\ntype    = \"CNAME\"\nttl     = 300\nrecords = [aws_lb.&lt;aws_alb_for_waf&gt;.dns_name]\n}\n]\n}\n</code></pre> <p>In the sample above, the module is used, but it is also possible to use a Terraform resource.</p>"},{"location":"use-cases/","title":"Overview","text":"<p>The Use Cases section provides useful recommendations of how to operate with the EPAM Delivery Platform tools and manage the custom resources. Get acquainted with the description of technical scenarios and solutions.</p> <ul> <li>Autotest as Quality Gate</li> <li>Promote Application in CD Pipeline</li> </ul>"},{"location":"use-cases/autotest-as-quality-gate/","title":"Autotest as a Quality Gate","text":"<p>This use case describes the flow of adding an autotest as a quality gate to a newly created CD pipeline with a selected build version of an application to be promoted.</p> <ol> <li> <p>Make sure an application is created. Please refer to the Add Application section for details.</p> <p> Applications </p> </li> <li> <p>Create an autotest with the necessary parameters. Please refer to the Add Autotest section for details.</p> <p> Autotests </p> </li> <li> <p>Create a CD pipeline where the necessary application build version will be promoted and the autotest will be used as a quality gate. Please refer to the Add CD Pipeline section for details.</p> <p> Continuous delivery </p> </li> <li> <p>In the Application menu, select the application to be promoted in the CD pipeline.</p> <p> Application to promote </p> </li> <li> <p>In the Stages menu, add the necessary stage and indicate the Autotests quality gate.</p> <p> Quality gate type </p> <p>Note</p> <p>Please be aware that once created, the CD pipeline remains with the chosen quality gate type without possibility to edit it.</p> <p>Info</p> <p>To trigger the CD pipeline, first, make sure that all applications have passed the Build pipelines and autotests have passed the single Code Review pipelines.</p> </li> <li> <p>Navigate to Jenkins to see the autotest logs and Allure report.</p> </li> </ol>"},{"location":"use-cases/autotest-as-quality-gate/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add CD Pipeline</li> </ul>"},{"location":"use-cases/promotion-procedure/","title":"Promote Application in CD Pipeline","text":"<p>This use case describes the promotion of the selected build versions of an application in the CD pipeline.</p> <ol> <li> <p>Before the promotion, make sure the necessary applications are added to the Admin Console. Please refer to the Add Application section for the details.</p> </li> <li> <p>Navigate to the Continuous Delivery section on the left-side navigation bar and click the Create button. Please refer to the Add CD Pipeline section for the details.</p> <p> Create cd pipeline </p> </li> <li> <p>In the Application menu, select the applications to be deployed and promoted in the pipeline.</p> <ul> <li>If the application is selected without the promotion option, a new build version will be available for deploy at all the stages of the CD pipeline;</li> </ul> <p> Select application to deploy </p> <ul> <li>If the promotion is selected, the build version will pass through the environments one by one through the quality gates.</li> </ul> <p> Select application to promote </p> <p>Info</p> <p>If there are several applications to be promoted, and some changes are made to one of them, only the application with the changes will be promoted to the next environments.</p> </li> <li> <p>In the Stages menu, set the manual trigger type to select an application for promotion.</p> <p> Select trigger type </p> </li> <li> <p>Navigate to Jenkins and start the CD pipeline.</p> </li> <li> <p>With the manual quality gate, click the OK button at the quality gate stage to promote the build to the next stage.</p> </li> </ol>"},{"location":"use-cases/promotion-procedure/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add CD Pipeline</li> <li>Autotest as a Quality Gate</li> </ul>"},{"location":"user-guide/","title":"Overview","text":"<p>Important</p> <p>Admin Console is deprecated and replaced by the Headlamp tool. Please see the Headlamp User guide.</p> <p>The EDP User guide is intended for developers and provides details on working with EDP Admin Console, different codebase types and EDP CI/CD flow.</p>"},{"location":"user-guide/#admin-console","title":"Admin Console","text":"<p>Admin Console is a central management tool in the EDP ecosystem that provides the ability to define pipelines, project resources and new technologies in a simple way. Using Admin Console enables to manage business entities:</p> <ul> <li>Create such codebase types as Applications, Libraries and Autotests;</li> <li>Create/Update CD Pipelines;</li> </ul> <p>Note</p> <p>To interact with Admin Console via REST API, explore the Create Codebase Entity page.</p> <p> Overview page </p> <ul> <li>Navigation bar \u2013 consists of six sections: Overview, Continuous Delivery, Applications, Autotests, Libraries, and Delivery Dashboard Diagram. Click the necessary section to add an entity, open a home page or check the diagram.</li> <li>User name \u2013 displays the registered user name.</li> <li>Main links \u2013 displays the corresponding links to the major adjusted toolset, to the management tool and to the OpenShift cluster.</li> </ul> <p>Admin Console is a complete tool allowing to manage and control added to the environment codebases (applications, autotests, libraries) as well as to create a CD pipeline and check the visualization diagram. Inspect the main features available in Admin Console by following the corresponding link:</p> <ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Add CD Pipeline</li> <li>Delivery Dashboard Diagram</li> </ul>"},{"location":"user-guide/add-application/","title":"Add Application","text":"<p>Admin Console allows to create, clone, import an application and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins.</p> <p>To add an application, navigate to the Applications section on the left-side navigation bar and click the Create button.</p> <p>Once clicked, the three-step menu will appear:</p> <ul> <li>The Codebase Info Menu</li> <li>The Application Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"user-guide/add-application/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p> Create application </p> <ol> <li> <p>In the Codebase Integration Strategy field, select the necessary configuration strategy:</p> <ul> <li>Create \u2013 creates a project on the pattern in accordance with an application language, a build tool, and a framework.</li> </ul> <ul> <li>Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well.</li> </ul> <ul> <li>Import - allows configuring a replication from the Git server. While importing the existing repository, you have to select the Git server and define the respective path to the repository.</li> </ul> <p>Note</p> <p>In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page. The Import strategy is not applicable for Gerrit.</p> </li> <li> <p>In the Git Repository URL field, specify the link to the repository that is to be cloned.   If the Import strategy is selected, specify the following fields:</p> <p> Select import strategy </p> <p>a. Git Server where the repository is located.</p> <p>b. Relative path to the repository on the server.</p> </li> <li> <p>With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields:</p> <ul> <li>Repository Login \u2013 enter your login data.</li> </ul> <ul> <li>Repository password (or API Token) \u2013 enter your password or indicate the API Token.</li> </ul> <p>Note</p> <p>The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Type the name of the application in the Application Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> </li> <li> <p>Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> </li> <li> <p>To create an application with an empty repository in Gerrit, select the Empty project check box.</p> <p>Note</p> <p>The empty repository option is available only for the Create strategy.</p> </li> <li> <p>Select any of the supported application languages with its framework in the Application Code Language/framework field:</p> <ul> <li>Java \u2013 selecting Java allows using Java 8 or Java 11.</li> <li>JavaScript - selecting JavaScript allows using the React framework.</li> <li>DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1.</li> <li>Go - selecting Go allows using the Beego and Operator SDK frameworks.</li> <li>Python - selecting Python allows using the Python v.3.8.</li> <li>Other - selecting Other allows extending the default code languages when creating a codebase with the clone/import strategy. To add another code language, inspect the Add Other Code Language section.</li> </ul> <p>Note</p> <p>The Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>Choose the necessary build tool in the Select Build Tool field:</p> <ul> <li>Java - selecting Java allows using the Gradle or Maven tool.</li> <li>JavaScript - selecting JavaScript allows using the NPM tool.</li> <li>.Net - selecting .Net allows using the .Net tool.</li> </ul> <p>Note</p> <p>The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language.</p> </li> <li> <p>Select the Multi-Module Project check box that becomes available if the Java code language and the Maven build tool are selected.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select CI pipeline provisioner that will be handling a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner.</p> </li> <li>Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent.</li> <li> <p>Select the necessary codebase versioning type:</p> <ul> <li>default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number that will be used for all the artifacts stored in artifactory: binaries, pom.xml, metadata, etc. The version stored in repository (e.g. pom.xml) will not be affected or used. Using this versioning overrides any version stored in the repository files without changing actual file.</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> Edp versioning </p> <p>a. Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> </li> <li> <p>In the Select Deployment Script field, specify one of the available options: helm-chart / openshift-template that are predefined in case it is OpenShift or EKS.</p> </li> <li> <p>In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> <p> Integrate with jira server </p> </li> <li> <p>Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and setup the Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> </li> <li> <p>In the Select Jira Server field, select the Jira server.</p> </li> <li>Indicate the pattern using any character, which is followed on the project, to validate a commit message.</li> <li>Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message.</li> <li> <p>In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed.</p> <p> Advance mapping </p> <p>a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> <p>b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value.</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira;</li> <li>For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator;</li> <li>For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> <p>c. Click the plus icon to add more Jira field names.</p> <p>d. Click the delete icon to remove the Jira field name.</p> <p> Integrate with perf server </p> </li> <li> <p>Select the Integrate with Perf Server check box to enable the integration with the PERF Board (Project Performance Board) for monitoring the overall team performance and setting up necessary metrics.</p> <p>Note</p> <p>If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu.</p> </li> <li> <p>In the Select Perf Server field, select the name of the Perf server with which the integration should be performed. Click the Proceed button to switch to the next menu.</p> <p> Perf integration </p> </li> <li> <p>Select the necessary DataSource (Jenkins, Sonar, GitLab) from which the data should be transferred to the Project Performance Board.</p> </li> <li> <p>Click the Create button, check the CONFIRMATION summary, and click Continue to complete the application addition.</p> </li> </ol> <p>Note</p> <p>After the complete adding of the application, inspect the Application Overview part.</p>"},{"location":"user-guide/add-application/#the-application-info-menu","title":"The Application Info Menu","text":"<p> Application info </p>"},{"location":"user-guide/add-application/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p> Advanced settings </p>"},{"location":"user-guide/add-application/#related-articles","title":"Related Articles","text":"<ul> <li>Application Overview</li> <li>Delivery Dashboard Diagram</li> </ul> <ul> <li>Add CD Pipelines</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> <li>Promote Application in CD Pipeline</li> </ul>"},{"location":"user-guide/add-autotest/","title":"Add Autotests","text":"<p>Admin Console enables to clone or import an autotest, add it to the environment with its subsequent deployment in Gerrit (in case the Clone strategy is used) and building of the Code Review pipeline in Jenkins, as well as to use it for work with an application under development.  It is also possible to use autotests as quality gates in a newly created CD pipeline.</p> <p>Info</p> <p>Please refer to the Add Application section for the details on how to add an application codebase type. For the details on how to use autotests as quality gates, please refer to the the Stages Menu section of the Add CD Pipeline documentation.</p> <p>Navigate to the Autotests section on the left-side navigation bar and click the Create button.</p> <p>Once clicked, the three-step menu will appear:</p> <ul> <li>The Codebase Info Menu</li> <li>The Autotest Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"user-guide/add-autotest/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p>There are two available strategies: clone and import. The Clone strategy flow is displayed below:</p> <p> Clone autotest </p> <ol> <li>Clone - this strategy allows cloning the autotest from the indicated repository into EPAM Delivery Platform.    While cloning the existing repository, you have to fill in the additional fields as well.</li> <li>In the Git Repository URL field, specify the link to the repository with the autotest.</li> <li> <p>With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields:</p> <ul> <li>Repository Login \u2013 enter your login data.</li> <li> <p>Repository password (or API Token) \u2013 enter your password or indicate the API Token.</p> <p>Note</p> <p>The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials.</p> </li> </ul> <p>If there is a necessity to use the Import strategy that allows configuring a replication from the Git server, explore the steps below:</p> <p> Import autotest </p> <p>a. Import - this strategy allows configuring a replication from the Git server.</p> <p>Note</p> <p>In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page.</p> <p>b. In the Git Server field, select the necessary Git server from the drop-down list.</p> <p>c. In the Relative path field, indicate the respective path to the repository, e.g. /epmd-edp/examples/basic/edp-auto-tests-simple-example.</p> </li> <li> <p>After completing the Codebase Info menu step, click the Proceed button to switch to the next menu.</p> </li> <li> <p>Fill in the Autotest Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> <p>Info</p> <p>The Import strategy does not have an Autotest Name field.</p> </li> <li> <p>Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> </li> <li> <p>Type the necessary description in the Description field.</p> </li> <li> <p>In the Autotest Code Language field, select the Java code language (specify Java 8 or Java 11 to be used) and get the default Maven build tool OR add another code language. Selecting Other allows extending the default code languages and get the necessary build tool, for details, inspect the Add Other Code Language section.</p> <p>Note</p> <p>Using the Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>The Select Build Tool field can dispose of the default Maven tool, Gradle or other built tool in accordance with the selected code language.</p> </li> <li> <p>All the autotest reports will be created in the Allure framework that is available in the Autotest Report Framework field by default. Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner.</p> </li> <li> <p>Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent.</p> </li> <li> <p>Select the necessary codebase versioning type:</p> <ul> <li>default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml).</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> Edp versioning </p> <p>a. Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> </li> <li> <p>In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and     the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> <p> Jira integration </p> </li> <li> <p>Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> </li> <li> <p>As soon as the Jira server is set, select it in the Select Jira Server field.</p> </li> <li> <p>Indicate the pattern using any character, which is followed on the project, to validate a commit message.</p> </li> <li> <p>Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message.</p> </li> <li> <p>In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed.</p> <p> Advance mapping </p> <p>a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> <p>b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value.</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira;</li> </ul> <ul> <li>For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator;</li> </ul> <ul> <li>For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> <p>c. Click the plus icon to add more Jira field names.</p> <p>d. Click the delete icon to remove the Jira field name.</p> <p> Integrate with perf server </p> </li> <li> <p>Select the Integrate with Perf Server check box to enable the integration with the PERF Board (Project Performance Board) for monitoring the overall team performance and setting up necessary metrics.</p> <p>Note</p> <p>If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu.</p> </li> <li> <p>In the Select Perf Server field, select the name of the Perf server with which the integration should be performed and click the Proceed button to switch to the next menu.</p> <p> Perf integration </p> </li> <li> <p>Select the necessary DataSource (Jenkins/GitLab, Sonar) from which the data should be transferred to the Project Performance Board.</p> </li> <li> <p>Click the Create button to create an autotest, check the CONFIRMATION summary, click Continue to add an autotest to the Autotests list.</p> </li> </ol> <p>Note</p> <p>After the complete adding of the autotest, inspect the Autotest Overview part.</p>"},{"location":"user-guide/add-autotest/#the-autotest-info-menu","title":"The Autotest Info Menu","text":"<p> Autotest info </p>"},{"location":"user-guide/add-autotest/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p> Advanced settings </p>"},{"location":"user-guide/add-autotest/#related-articles","title":"Related Articles","text":"<ul> <li>Autotest Overview</li> <li>Delivery Dashboard Diagram</li> </ul> <ul> <li>Add Application</li> <li>Add CD Pipelines</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> </ul>"},{"location":"user-guide/add-cd-pipeline/","title":"Add CD Pipeline","text":"<p>Admin Console provides the ability to deploy an environment on your own and specify the essential components as well.</p> <p>Navigate to the Continuous Delivery section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear:</p> <ul> <li>The Pipeline Menu</li> <li>The Applications Menu</li> <li>The Stages Menu</li> </ul> <p>The creation of the CD pipeline becomes available as soon as an application is created including its provisioning in a branch and the necessary entities for the environment.</p> <p>After the complete adding of the CD pipeline, inspect the Check CD Pipeline Availability part.</p>"},{"location":"user-guide/add-cd-pipeline/#the-pipeline-menu","title":"The Pipeline Menu","text":"<p> Create CD pipeline </p> <ol> <li> <p>Type the name of the pipeline in the Pipeline Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> <p>Note</p> <p>The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name]. Please be aware that the namespace length should not exceed 63 symbols.</p> </li> <li> <p>Select the deployment type from the drop-down list:</p> <ul> <li>Container - the pipeline will be deployed in a Docker container;</li> <li>Custom - this mode allows to deploy non-container applications and customize the Init stage of CD pipeline.</li> </ul> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select the check box of the necessary application in the Applications menu.</p> </li> <li>Specify the necessary codebase Docker stream (the output for the branch and other stages from other CD pipelines) from the drop-down menu.</li> <li> <p>Select the Promote in pipeline check box in order to transfer the application from one to another stage by the specified codebase Docker stream. If the Promote in pipeline check box is not selected, the same codebase Docker stream will be deployed regardless of the stage, i.e. the codebase Docker stream input, which was selected for the pipeline, will be always used.</p> <p>Note</p> <p>The newly created CD pipeline has the following pattern combination: [pipeline name]-[branch name]. If there is another deployed CD pipeline stage with the respective codebase Docker stream (= image stream as an OpenShift term), the pattern combination will be as follows: [pipeline name]-[stage name]-[application name]-[verified].</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Click the plus sign icon in the Stages menu and fill in the necessary fields in the Adding Stage window :</p> <p> Adding stage </p> <p>a. Type the stage name;</p> <p>Note</p> <p>The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name]. Please be aware that the namespace length should not exceed 63 symbols.</p> <p>b. Enter the description for this stage;</p> <p>c. Select the quality gate type:</p> <ul> <li>Manual - means that the promoting process should be confirmed in Jenkins manually;</li> <li>Autotests - means that the promoting process should be confirmed by the successful passing of the autotests. In the additional fields, select the previously created autotest name and specify its branch for the autotest that will be launched on the current stage.</li> </ul> <p>Note</p> <p>Please be aware that autotests used in the CD pipeline cannot be removed. For the details on how to create an autotest codebase, please refer to the Add Autotest section.</p> <p>d. Type the step name, which will be displayed in Jenkins, for every quality gate type;</p> <p>e. Add an unlimited number of quality gates by clicking a corresponding plus sign icon and remove them as well by clicking the recycle bin icon;</p> <p>f. Select the trigger type. The available trigger types are manual and auto. By selecting the auto trigger type, the CD pipeline will be launched automatically after the image is built. Every trigger type has a set of default stages that differ by the input stage (auto-deploy-input or manual-deploy-input).</p> </li> </ol> <p>Note</p> <p>When changing the Trigger Type, the job-provision automatically will change the set of stages to the corresponding stages set for the CD pipeline.</p> <p>Note</p> <p>Execution sequence. The image promotion and execution of the pipelines depend on the sequence in which   the environments are added.</p> <p> Adding stage </p> <p>g. Select the groovy-pipeline library;</p> <p>h. Select the job provisioner. In case of working with non container-based applications, there is an option to use    a custom job provisioner. Please refer to the Manage Jenkins CD Job Provision    page for details.</p> <p>i. Click the Add button to display it in the Stages menu.</p> <p>Info</p> <p>Perform the same steps as described above if there is a necessity to add one more stage.</p> <p> Continuous delivery menu </p> <p>9.Edit the stage by clicking its name and applying changes, and remove the added stage by clicking the recycle bin icon next to its name.</p> <p>10.Click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new project with the stage name will be created in OpenShift.</p>"},{"location":"user-guide/add-cd-pipeline/#the-applications-menu","title":"The Applications Menu","text":"<p> CD pipeline applications </p>"},{"location":"user-guide/add-cd-pipeline/#the-stages-menu","title":"The Stages Menu","text":"<p> CD stages </p>"},{"location":"user-guide/add-cd-pipeline/#check-cd-pipeline-availability","title":"Check CD Pipeline Availability","text":"<p>As soon as the CD pipeline is provisioned and added to the CD Pipelines list, there is an ability to:</p> <p> CD page </p> <ol> <li> <p>Create another application by clicking the Create button and performing the same steps as described in the Add CD Pipeline section.</p> </li> <li> <p>Select a number of existing CD pipelines to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page.</p> </li> <li> <p>Sort the existing CD pipelines in a list by clicking the Name title. The CD pipelines will be displayed in alphabetical order.</p> </li> <li> <p>Search the necessary CD pipeline by entering the corresponding name, language or the build tool into the Search field.</p> </li> <li> <p>Navigate between pages if the number of CD pipelines exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"user-guide/add-cd-pipeline/#edit-cd-pipeline","title":"Edit CD Pipeline","text":"<ul> <li> <p>Edit the CD pipeline by clicking the pen icon next to its name in the CD Pipelines list:</p> <p> Edit CD pipeline </p> <ul> <li>apply the necessary changes (the list of applications for deploy, image streams, and promotion in the pipeline) and click the Proceed button to confirm the editions:</li> </ul> <p> Edit CD pipeline page </p> <ul> <li>add new extra stages steps by clicking the plus sign icon and filling in the necessary fields in the Adding Stage window.</li> </ul> <p> Add stages </p> <p>Note</p> <p>The added stage will appear in the Stages menu allowing to review its details or delete.</p> </li> </ul> <ul> <li> <p>Check the CD pipeline data and details by clicking the CD pipeline name in the CD Pipelines list:</p> <p> Link to Jenkins </p> <ul> <li>the main link on the top of the details page refers to Jenkins;</li> </ul> <p> Edit icon </p> <ul> <li>the pen icon refers to the same Edit CD Pipeline page as mentioned above and allows to apply the necessary changes;</li> </ul> <ul> <li>the Applications menu has the main information about the applications with the respective codebase Docker streams and links to Jenkins and Gerrit as well as the signification of the promotion in CD pipeline;</li> </ul> <ul> <li>the Stages menu includes the stages data that was previously mentioned, the direct links to the respective to every stage Kubernetes/OpenShift page, and the link to the Autotest details page in case there are added autotests. To enable or disable auto deployment of a specific stage, click the pen icon and select the necessary trigger type from the drop-down list.</li> </ul> <p> Edit trigger type </p> <p>Note</p> <p>The deletion of stages is performed sequentially, starting from the latest created stage. In order to remove a stage, click the corresponding delete icon, type the CD pipeline name and confirm the deletion by clicking the Delete button. If you remove the last stage, the whole CD pipeline will be removed as the CD pipeline does not exist without stages.</p> <ul> <li>the Deployed Version menu indicates the applications and stages with the appropriate status. The status will be changed after stage deployment.</li> </ul> <p> Deployed versions </p> <ul> <li>the Status Info menu displays all the actions that were performed during the deployment process:</li> </ul> <p> Status info </p> </li> </ul> <ul> <li> <p>Remove the added CD pipeline:</p> <p> Remove CD pipeline </p> <p>Info</p> <p>If there is a necessity to create another CD pipeline, navigate to the Continuous Delivery section, click the Create button and perform the same steps as described above.</p> <p>Info</p> <p>In OpenShift, if the deployment fails with the ImagePullBackOff error, delete the POD.</p> </li> </ul>"},{"location":"user-guide/add-cd-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add Autotest</li> <li>EDP Admin Console</li> <li>Customize CD Pipeline</li> <li>Delivery Dashboard Diagram</li> <li>Promote Application in CD Pipeline</li> </ul> <ul> <li>Manage Jenkins CD Pipeline Job Provision</li> </ul>"},{"location":"user-guide/add-custom-global-pipeline-lib/","title":"Add a Custom Global Pipeline Library","text":"<p>In order to add a new custom global pipeline library, perform the steps below:</p> <ol> <li> <p>Navigate to Jenkins and go to Manage Jenkins -&gt; Configure System -&gt; Global Pipeline Libraries.</p> <p>Note</p> <p>It is possible to configure as many libraries as necessary. Since these libraries will be globally usable, any pipeline in the system can utilize the functionality implemented in these libraries.</p> </li> <li> <p>Specify the following values:</p> <p> Add custom library </p> <p>a. Library name: The name of a custom library.</p> <p>b. Default version: The version which can be branched, tagged or hashed of a commit.</p> <p>c. Load implicitly: If checked, scripts will automatically have access to this library without needing to request it via @Library. It means that there is no need to upload the library manually because it will be downloaded automatically during the build for each job.</p> <p>d. Allow default version to be overridden: If checked, scripts may select a custom version of the library by appending @someversion in the @Library annotation. Otherwise, they are restricted to using the version selected here.</p> <p>e. Include @Library changes in job recent changes: If checked, any changes in the library will be included in the changesets of a build, and changing the library would cause new builds to run for Pipelines that include this library. This can be overridden in the jenkinsfile: @Library(value=\"name@version\", changelog=true|false).</p> <p>f. Cache fetched versions on controller for quick retrieval: If checked, versions fetched using this library will be cached on the controller. If a new library version is not downloaded during the build for some reason, remove the previous library version from cache in the Jenkins workspace.</p> <p>Note</p> <p>If the Default version check box is not defined, the pipeline must specify a version, for example, <code>@Library('my-shared-library@master')</code>. If the Allow default version to be overridden check box is enabled in the Shared Library\u2019s configuration, a @Library annotation may also override the default version defined for the library.</p> <p> Source code management </p> <p>g. Project repository: The URL of the repository</p> <p>h. Credentials: The credentials for the repository.</p> </li> <li> <p>Use the Custom Global Pipeline Libraries on the pipeline, for example:</p> </li> </ol> <p>Pipeline</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name'])_\n\nBuild()\n</code></pre> <p>Note</p> <p><code>edp-custom-shared-library-name</code> is the name of the Custom Global Pipeline Library that should be added to the Jenkins Global Settings.</p>"},{"location":"user-guide/add-custom-global-pipeline-lib/#related-articles","title":"Related Articles","text":"<ul> <li>Jenkins Official Documentation: Extending with Shared Libraries</li> </ul>"},{"location":"user-guide/add-library/","title":"Add Library","text":"<p>Admin Console helps to create, clone or import a library and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins.</p> <p>Navigate to the Libraries section on the left-side navigation bar and click the Create button.</p> <p>Once clicked, the three-step menu will appear:</p> <ul> <li>The Codebase Info Menu</li> <li>The Library Info Menu</li> <li>The Advanced Settings Menu</li> </ul>"},{"location":"user-guide/add-library/#the-codebase-info-menu","title":"The Codebase Info Menu","text":"<p> Create library </p> <ol> <li> <p>In the Codebase Integration Strategy field, select the necessary option that is the configuration strategy for the replication with Gerrit:</p> <ul> <li>Create \u2013 creates a project on the pattern in accordance with a code language, a build tool, and a framework.</li> </ul> <ul> <li>Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well.</li> </ul> <ul> <li>Import - allows configuring a replication from the Git server. While importing the existing repository, select the Git server and define the respective path to the repository.</li> </ul> <p>Note</p> <p>In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page.</p> </li> <li> <p>In the Git Repository URL field, specify the link to the repository that is to be cloned.</p> </li> <li> <p>With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields:</p> <ul> <li>Repository Login \u2013 enter your login data.</li> <li>Repository password (or API Token) \u2013 enter your password or indicate the API Token.</li> </ul> <p>Note</p> <p>The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Type the name of the library in the Library Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes.</p> <p>Info</p> <p>If the Import strategy is used, the Library Name field will not be displayed.</p> </li> <li> <p>Specify the name of the default branch where you want the development to be performed.</p> <p>Note</p> <p>The default branch cannot be deleted.</p> </li> <li> <p>To create a library with an empty repository in Gerrit, select the Empty project check box.</p> <p>Note</p> <p>The empty repository option is available only for the Create strategy.</p> </li> <li> <p>Select any of the supported code languages in the Library Code Language block:</p> <ul> <li>Java \u2013 selecting Java allows specify Java 8 or Java 11, and further usage of the Gradle or Maven tool.</li> <li>JavaScript - selecting JavaScript allows using the NPM tool.</li> <li>DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1.</li> <li>Groovy-pipeline - selecting Groovy-pipeline allows having the ability to customize a stages logic. For details, please refer to the Customize CD Pipeline page.</li> <li>Python - selecting Python allows using the Python v.3.8.</li> <li>Terraform - selecting Terraform allows using the Terraform different versions via the Terraform version manager (tfenv). EDP supports all actions available in Terraform, thus providing the ability to modify the virtual infrastructure and launch some checks with the help of linters. For details, please refer to the Use Terraform Library in EDP page.</li> <li>Rego - this option allows using Rego code language with an Open Policy Agent (OPA) Library. For details, please refer to the Use Open Policy Agent page.</li> <li>Container - this option allows using the Kaniko tool for building the container images from a Dockerfile. For details, please refer to the CI Pipeline for Container page.</li> <li>Other - selecting Other allows extending the default code languages when creating a codebase with the Clone/Import strategy. To add another code language, inspect the Add Other Code Language page.</li> </ul> <p>Note</p> <p>The Create strategy does not allow to customize the default code language set.</p> </li> <li> <p>The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language.</p> </li> <li> <p>Click the Proceed button to switch to the next menu.</p> </li> <li> <p>Select the CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner.</p> </li> <li> <p>Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent.</p> </li> <li> <p>Select the necessary codebase versioning type:</p> <ul> <li>default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually.</li> </ul> <ul> <li>edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml).</li> </ul> <p>When selecting the edp versioning type, the extra field will appear:</p> <p> EDP versioning </p> <p>a. Type the version number from which you want the artifacts to be versioned.</p> <p>Note</p> <p>The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details.</p> </li> <li> <p>In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and     the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page.</p> <p>Note</p> <p>The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable.</p> <p> Integrate with Jira server </p> </li> <li> <p>Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira. Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> </li> <li> <p>As soon as the Jira server is set, select it in the Select Jira Server field.</p> </li> <li> <p>Indicate the pattern using any character, which is followed on the project, to validate a commit message.</p> </li> <li> <p>Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message.</p> </li> <li> <p>In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed.</p> <p> Advanced mapping </p> <p>a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s, Component/s and Labels.</p> <p>b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value.</p> <ul> <li>For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT. Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira;</li> <li>For the Component/s field select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator;</li> <li>For the Labels field select the EDP_GITTAGvariable that defines a tag assigned to the commit in Git Hub. For example, build/2.7.0-SNAPSHOT.59.</li> </ul> <p>c. Click the plus icon to add more Jira field names.</p> <p>d. Click the delete icon to remove the Jira field name.</p> <p> Integrate with Perf server </p> </li> <li> <p>Select the Integrate with Perf Server check box to enable the integration with the PERF Board (Project Performance Board) for monitoring the overall team performance and setting up necessary metrics.</p> <p>Note</p> <p>If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu.</p> </li> <li> <p>In the Select Perf Server field, select the name of the Perf server with which the integration should be performed. Click the Proceed button to switch to the next menu.</p> <p> Perf integration </p> </li> <li> <p>Select the necessary DataSource (Jenkins/GitLab, Sonar) from which the data should be transferred to the Project Performance Board.</p> </li> <li> <p>Click the Create button, check the CONFIRMATION summary, and click Continue to add the library to the Libraries list.</p> <p>Note</p> <p>After the complete adding of the library, inspect the Library Overview part.</p> </li> </ol>"},{"location":"user-guide/add-library/#the-library-info-menu","title":"The Library Info Menu","text":"<p> Library info </p>"},{"location":"user-guide/add-library/#the-advanced-settings-menu","title":"The Advanced Settings Menu","text":"<p> Advanced settings </p>"},{"location":"user-guide/add-library/#related-articles","title":"Related Articles","text":"<ul> <li>Library Overview</li> <li>Delivery Dashboard Diagram</li> </ul> <ul> <li>Add CD Pipeline</li> <li>Add Other Code Language</li> <li>Adjust GitLab CI Tool</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Enable VCS Import Strategy</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Manage Jenkins Agent</li> <li>Perf Server Integration</li> <li>Use Terraform Library in EDP</li> <li>Use Open Policy Agent Library in EDP</li> </ul>"},{"location":"user-guide/application/","title":"Application","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing applications.</p>"},{"location":"user-guide/application/#check-and-remove-application","title":"Check and Remove Application","text":"<p>As soon as the application is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins for this application. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added application will be listed in the Applications list allowing you to do the following:</p> <p> Applications menu </p> <ol> <li> <p>Create another application by clicking the Create button and performing the same steps as described in the Add Applications section.</p> </li> <li> <p>Open application data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the created/cloned/imported application.</li> <li>Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type).</li> <li> <p>Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields:</p> <ul> <li>Build Number - indicates the current build number;</li> <li>Last Successful Build - indicates the last successful build number.</li> </ul> </li> </ul> <ul> <li>Status Info - displays all the actions that were performed during the creation/cloning/importing process.</li> </ul> </li> <li> <p>Edit the application codebase by clicking the pencil icon. For details see the Edit Existing Codebase section.</p> </li> <li> <p>Remove application with the corresponding database and Jenkins pipelines:</p> <ul> <li>Click the delete icon next to the application name;</li> <li>Type the required application name;</li> <li>Confirm the deletion by clicking the Delete button.</li> </ul> <p>Note</p> <p>The application that is used in a CD pipeline cannot be removed.</p> <p> Applications menu </p> </li> <li> <p>Select a number of existing applications to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page.</p> </li> <li> <p>Sort the existing applications in a list by clicking the Name title. The applications will be displayed in alphabetical order.</p> </li> <li> <p>Search the necessary application by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the application name, language or a build tool.</p> </li> <li> <p>Navigate between pages if the number of applications exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"user-guide/application/#add-a-new-branch","title":"Add a New Branch","text":"<p>Note</p> <p>Pay attention when specifying the branch name: the branch name is involved in the formation of the application version, so it must comply with the versioning semantic rules for the application.</p> <p>When adding an application, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li> <p>Navigate to the Branches block and click the Create button:]</p> <p> Add branch </p> </li> <li> <p>Fill in the required fields:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch;</p> <p>b. Branch Name - type the branch name. Pay attention that this field remains static if you create a release branch.</p> <p>c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number;</p> <p>f. Click the Proceed button and wait until the new branch will be added to the list.</p> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer here.</p> </li> </ol> <p>The default application repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"user-guide/application/#edit-existing-codebase","title":"Edit Existing Codebase","text":"<p>The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for applications via the Edit Codebase page.</p> <ol> <li> <p>Perform the editing from one of the following sections on the Admin Console interface:</p> <p> Edit codebase </p> <ul> <li>Navigate to the codebase overview page and click the pencil icon, or</li> </ul> <p> Edit codebase </p> <ul> <li>Navigate to the codebase list page and click the pencil icon.</li> </ul> <p> Edit codebase </p> </li> <li> <p>To enable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>mark the Integrate with Jira server check box and fill in the necessary fields;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</li> </ul> </li> <li> <p>To disable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>unmark the Integrate with Jira server check box;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</li> </ul> </li> </ol> <p>As a result, the necessary changes will be applied.</p>"},{"location":"user-guide/application/#remove-branch","title":"Remove Branch","text":"<p>In order to remove the added branch with the corresponding record in the Admin Console database, do the following:</p> <ol> <li>Navigate to the Branches block by clicking the application name link in the Applications list;</li> <li> <p>Click the delete icon related to the necessary branch:</p> <p> Remove branch </p> </li> <li> <p>Enter the branch name and click the Delete button;</p> </li> </ol> <p>Note</p> <p>The default master branch cannot be removed.</p>"},{"location":"user-guide/application/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Promote Application in CD Pipeline</li> </ul>"},{"location":"user-guide/autotest/","title":"Autotest","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing autotests.</p>"},{"location":"user-guide/autotest/#check-and-remove-autotest","title":"Check and Remove Autotest","text":"<p>As soon as the autotest is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins for this autotest. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added autotest will be listed in the Autotests list allowing you to do the following:</p> <p> Autotests page </p> <ol> <li> <p>Add another autotest by clicking the Create button and performing the same steps as described at the Add Autotest page.</p> </li> <li> <p>Open autotest data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the cloned/imported autotest.</li> <li>Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type).</li> <li>Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields:<ul> <li>Build Number - indicates the current build number;</li> <li>Last Successful Build - indicates the number of the last successful build.</li> </ul> </li> <li>Status Info - displays all the actions that were performed during the cloning/importing process.</li> </ul> </li> <li> <p>Edit the autotest codebase by clicking the pencil icon. For details see the Edit Existing Codebase section.</p> </li> <li> <p>Remove autotest with the corresponding database and Jenkins pipelines:</p> <ul> <li>Click the delete icon next to the autotest name;</li> <li>Type the required autotest name;</li> <li>Confirm the deletion by clicking the Delete button.</li> </ul> <p>Note</p> <p>The autotest that is used in a CD pipeline cannot be removed.</p> <p> Autotests page </p> </li> <li> <p>Select a number of existing autotests to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page.</p> </li> <li> <p>Sort the existing autotests in a list by clicking the Name title. The autotests will be displayed in alphabetical order.</p> </li> <li> <p>Search the necessary autotest by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the autotest name, language or a build tool.</p> </li> <li> <p>Navigate between pages, if the number of autotests exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"user-guide/autotest/#edit-existing-codebase","title":"Edit Existing Codebase","text":"<p>The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for autotests via the Edit Codebase page.</p> <ol> <li> <p>Perform the editing from one of the following sections on the Admin Console interface:</p> <p> Edit autotest </p> <ul> <li> <p>Navigate to the codebase overview page and click the pencil icon, or</p> <p> Edit autotest </p> </li> </ul> <ul> <li> <p>Navigate to the codebase list page and click the pencil icon.</p> <p> Edit autotest </p> </li> </ul> </li> <li> <p>To enable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>mark the Integrate with Jira server check box and fill in the necessary fields;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code-Review pipeline.</li> </ul> <p>Note</p> <p>Pay attention that the Jira integration feature is not available when using the GitLab CI tool.</p> <p>Note</p> <p>To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration and Adjust VCS Integration With Jira pages.</p> </li> <li> <p>To disable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>unmark the Integrate with Jira server check box;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</li> </ul> </li> </ol> <p>As a result, the necessary changes will be applied.</p>"},{"location":"user-guide/autotest/#add-a-new-branch","title":"Add a New Branch","text":"<p>Note</p> <p>Pay attention when specifying the branch name: the branch name is involved in the formation of the application version, so it must comply with the versioning semantic rules for the application.</p> <p>When adding an autotest, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li> <p>Navigate to the Branches block and click the Create button:</p> <p> Add branch </p> </li> <li> <p>Fill in the required fields:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch;</p> <p>b. Branch Name - type the branch name. Pay attention that this field remains static if you create a release branch.</p> <p>c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number;</p> <p>f. Click the Proceed button and wait until the new branch will be added to the list.</p> </li> </ol> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer to the Add Autotest instruction.</p> <p>The default autotest repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"user-guide/autotest/#remove-branch","title":"Remove Branch","text":"<p>In order to remove the added branch with the corresponding  record in the Admin Console database, do the following:</p> <ol> <li> <p>Navigate to the Branches block by clicking the autotest name link in the Autotests list;</p> </li> <li> <p>Click the delete icon related to the necessary branch:</p> <p> Remove branch </p> </li> <li> <p>Enter the branch name and click the Delete button;</p> <p>Note</p> <p>The default master branch cannot be removed.</p> </li> </ol>"},{"location":"user-guide/autotest/#add-autotest-as-a-quality-gate","title":"Add Autotest as a Quality Gate","text":"<p>In order to add an autotest as a quality gate to a newly added CD pipeline, do the following:</p> <ol> <li> <p>Create a CD pipeline with the necessary parameters. Please refer to the Add CD Pipeline section for the details.</p> </li> <li> <p>In the Stages menu, select the Autotest quality gate type. It means the promoting process should be confirmed by the successful passing of the autotests.</p> </li> <li> <p>In the additional fields, select the previously created autotest name and specify its branch.</p> </li> <li> <p>After filling in all the necessary fields, click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new namespace containing the stage name will be created in Kubernetes (in OpenShift, a new project will be created) with the following name pattern: [cluster name]-[cd pipeline name]-[stage name]</p> </li> </ol>"},{"location":"user-guide/autotest/#configure-autotest-launch-at-specific-stage","title":"Configure Autotest Launch at Specific Stage","text":"<p>In order to configure the added autotest launch at the specific stage with necessary parameters, do the following:</p> <ol> <li> <p>Add the necessary stage to the CD pipeline. Please refer to the Add CD Pipeline documentation for the details.</p> </li> <li> <p>Navigate to the run.json file and add the stage name and the specific parameters.</p> </li> </ol>"},{"location":"user-guide/autotest/#launch-autotest-locally","title":"Launch Autotest Locally","text":"<p>There is an ability to run the autotests locally using the IDEA (Integrated Development Environment Application, such as IntelliJ, NetBeans etc.). To launch the autotest project for the local verification, perform the following steps:</p> <ol> <li> <p>Clone the project to the local machine.</p> </li> <li> <p>Open the project in IDEA and find the run.json file to copy out the necessary command value.</p> </li> <li> <p>Paste the copied command value into the Command line field and run it with the necessary values and namespace.</p> </li> <li> <p>As a result, all launched tests will be executed.</p> </li> </ol>"},{"location":"user-guide/autotest/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotests</li> <li>Add CD Pipeline</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> </ul>"},{"location":"user-guide/build-pipeline/","title":"Build Pipeline","text":"<p>This section provides details on the Build pipeline of the EDP CI/CD pipeline framework. Explore below the pipeline purpose, stages and possible actions to perform.</p>"},{"location":"user-guide/build-pipeline/#build-pipeline-purpose","title":"Build Pipeline Purpose","text":"<p>The purpose of the Build pipeline contains the following points:</p> <ul> <li>Check out, test, tag and build an image from the mainstream branch after a patch set is submitted in order to inspect whether the integrated with the mainstream code fits all quality gates, can be built and tested;</li> <li>Be triggered if any new patch set is submitted;</li> <li>Tag a specific commit in Gerrit in case the build is successful;</li> <li>Build a Docker image with an application that can be afterward deployed using the Jenkins Deploy pipeline.</li> </ul> <p>Find below the functional diagram of the Build pipeline with the default stages:</p> <p> build-pipeline </p>"},{"location":"user-guide/build-pipeline/#build-pipeline-for-application-and-library","title":"Build Pipeline for Application and Library","text":"<p>The Build pipeline is triggered automatically after the Code Review pipeline is completed and the changes are submitted.</p> <p>To review the Build pipeline, take the following steps:</p> <ol> <li> <p>Open Jenkins via the created link in Gerrit or via the Admin Console Overview page.</p> </li> <li> <p>Click the Build pipeline link to open its stages for the application and library codebases:</p> <ul> <li>Init - initialization of the Code Review pipeline inputs;</li> </ul> <ul> <li>Checkout - checkout of the application code;</li> </ul> <ul> <li>Get-version - get the version from the pom.XML file and add the build number;</li> </ul> <ul> <li>Compile - code compilation;</li> </ul> <ul> <li>Tests - tests execution;</li> </ul> <ul> <li>Sonar - Sonar launch that checks the whole code;</li> </ul> <ul> <li>Build - artifact building and adding to Nexus;</li> </ul> <ul> <li>Build-image - docker image building and adding to Docker Registry. The Build pipeline for the library has the same stages as the application except the Build-image stage, i.e. the Docker image is not building.</li> </ul> <ul> <li>Push - artifact docker image pushing to Nexus and Docker Registry;</li> </ul> <ul> <li>Ecr-to-docker - the docker image, after being built, is copied from the ECR project registry to DockerHub via the Crane tool. The stage is not the default and can be set for the application codebase type.   To set this stage, please refer to the EcrToDocker.groovy file and to the Promote Docker Images From ECR to Docker Hub page.</li> </ul> <ul> <li>Git-tag - adding of the corresponding Git tag of the current commit to relate with the image, artifact, and build version.</li> </ul> </li> </ol> <p>Note</p> <p>For more details on stages, please refer to the Pipeline Stages documentation.</p> <p>After the Build pipeline runs all the stages successfully, the corresponding tag numbers will be created in Kubernetes/OpenShift and Nexus.</p>"},{"location":"user-guide/build-pipeline/#check-the-tag-in-kubernetesopenshift-and-nexus","title":"Check the Tag in Kubernetes/OpenShift and Nexus","text":"<ol> <li> <p>After the Build pipeline is completed, check the tag name and the same with the commit revision. Simply navigate to Gerrit \u2192 Projects \u2192 List \u2192 select the project \u2192 Tags.</p> <p>Note</p> <p>For the Import strategy, navigate to the repository from which a codebase is imported \u2192 Tags. It is actual both for GitHub and GitLab.</p> </li> <li> <p>Open the Kubernetes/OpenShift Overview page and click the link to Nexus and check the build of a new version.</p> </li> <li> <p>Switch to Kubernetes \u2192 CodebaseImageStream (or OpenShift \u2192 Builds \u2192 Images) \u2192 click the image stream that will be used for deployment.</p> </li> <li> <p>Check the corresponding tag.</p> </li> </ol>"},{"location":"user-guide/build-pipeline/#configure-and-start-pipeline-manually","title":"Configure and Start Pipeline Manually","text":"<p>The Build pipeline can be started manually. To set the necessary stages and trigger the pipeline manually, take the following steps:</p> <ol> <li> <p>Open the Build pipeline for the created library.</p> </li> <li> <p>Click the Build with parameters option from the left-side menu. Modify the stages by removing the whole objects massive:{\"name\". \"tests\"} where name is a key and tests is a stage name that should be executed.</p> </li> <li> <p>Open Jenkins and check the successful execution of all stages.</p> </li> </ol>"},{"location":"user-guide/build-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Autotest as Quality Gate</li> <li>Pipeline Stages</li> </ul>"},{"location":"user-guide/cd-pipeline-details/","title":"CD Pipeline Details","text":"<p>CD Pipeline (Continuous Delivery Pipeline) - an EDP business entity that describes the whole delivery process of the selected application set via the respective stages. The main idea of the CD pipeline is to promote the application build version between the stages by applying the sequential verification (i.e. the second stage will be available if the verification on the first stage is successfully completed). The CD pipeline can include the essential set of applications with its specific stages as well.</p> <p>In other words, the CD pipeline allows the selected image stream (Docker container in Kubernetes terms) to pass a set of stages for the verification process (SIT - system integration testing with the automatic type of a quality gate, QA - quality assurance, UAT - user acceptance testing with the manual testing).</p> <p>Note</p> <p>It is possible to change the image stream for the application in the CD pipeline. Please refer to the Edit CD Pipeline section for the details. </p> <p>A CI/CD pipeline helps to automate steps in a software delivery process, such as the code build initialization, automated tests running, and deploying to a staging or production environment. Automated pipelines remove manual errors, provide standardized development feedback cycle, and enable the fast product iterations. To get more information on the CI pipeline, please refer to the CI Pipeline Details chapter.</p> <p>The codebase stream is used as a holder for the output of the stage, i.e. after the Docker container (or an image stream in OpenShift terms) passes the stage verification, it will be placed to the new codebase stream. Every codebase has a branch that has its own codebase stream - a Docker container that is an output of the build for the corresponding branch.</p> <p>Note</p> <p>For more information on the main terms used in EPAM Delivery Platform, please refer to the EDP Glossary</p> <p> EDP CD pipeline </p> <p>Explore the details of the CD pipeline below.</p>"},{"location":"user-guide/cd-pipeline-details/#deploy-pipeline","title":"Deploy Pipeline","text":"<p>The Deploy pipeline is used by default on any stage of the Continuous Delivery pipeline. It addresses the following concerns:</p> <ul> <li>Deploying the application(s) to the main STAGE (SIT, QA, UAT) environment in order to run autotests and to promote image build versions to the next environments afterwards.</li> <li>Deploying the application(s) to a custom STAGE environment in order to run autotests and check manually that everything is ok with the application.</li> <li>Deploying the latest or a stable and some particular numeric version of an image build that exists in Docker registry.</li> <li>Promoting the image build versions from the main STAGE (SIT, QA, UAT) environment.</li> <li>Auto deploying the application(s) version from the passed payload (using the CODEBASE_VERSION job parameter).</li> </ul> <p>Find below the functional diagram of the Deploy pipeline with the default stages:</p> <p>Note</p> <p>The input for a CD pipeline depends on the Trigger Type for a deploy stage and can be either Manual or Auto.</p> <p> Deploy pipeline stages </p>"},{"location":"user-guide/cd-pipeline-details/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add CD Pipeline</li> <li>Add Library</li> <li>CI Pipeline Details</li> <li>CI/CD Overview</li> <li>EDP Glossary</li> <li>EDP Pipeline Framework</li> <li>EDP Pipeline Stages</li> <li>Prepare for Release</li> </ul>"},{"location":"user-guide/ci-pipeline-details/","title":"CI Pipeline Details","text":"<p>CI Pipeline (Continuous Integration Pipeline) - an EDP business entity that describes the integration of changes made to a codebase into a single project. The main idea of the CI pipeline is to review the changes in the code submitted through a Version Control System (VCS) and build a new codebase version so that it can be transmitted to the Continuous Delivery Pipeline for the rest of the delivery process.</p> <p>There are three codebase types in EPAM Delivery Platform:</p> <ol> <li>Applications - a codebase that is developed in the Version Control System, has the full lifecycle starting from the Code Review stage to its deployment to the environment;</li> <li>Libraries - this codebase is similar to the Application type, but it is not deployed and stored in the Artifactory. The library can be connected to other applications/libraries;</li> <li>Autotests - a codebase that inspects the code and can be used as a quality gate for the CD pipeline stage. The autotest only has the Code Review pipeline and is launched for the stage verification.</li> </ol> <p>Note</p> <p>For more information on the above mentioned codebase types, please refer to the Add Application, Add Library, Add Autotests and Autotest as Quality Gate pages.</p> <p> EDP CI pipeline </p>"},{"location":"user-guide/ci-pipeline-details/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Autotest as Quality Gate</li> <li>Build Pipeline</li> <li>Code Review Pipeline</li> <li>Pipeline Stages</li> </ul>"},{"location":"user-guide/cicd-overview/","title":"EDP CI/CD Overview","text":"<p>This chapter provides information on CI/CD basic definitions and flow, as well as its components and process.</p>"},{"location":"user-guide/cicd-overview/#cicd-basic-definitions","title":"CI/CD Basic Definitions","text":"<p>The Continuous Integration part means the following:</p> <ul> <li>all components of the application development are in the same place and perform the same processes for running;</li> <li>the results are published in one place and replicated into EPAM GitLab or VCS (version control system);</li> <li>the repository also includes a storage tool (e.g. Nexus) for all binary artifacts that are produced by the Jenkins CI server after submitting changes from Code Review tool into VCS;</li> </ul> <p>The <code>Code Review</code> and <code>Build</code> pipelines are used before the code is delivered. An important part of both of them is the integration tests that are launched during the testing stage.</p> <p>Many applications (SonarQube, Gerrit, etc,) used by the project need databases for their performance.</p> <p>The Continuous Delivery comprises an approach allowing to produce an application in short cycles so that it can be reliably released at any time point. This part is tightly bound with the usage of the <code>Code Review</code>, <code>Build</code>, and <code>Deploy</code> pipelines.</p> <p>The <code>Deploy</code> pipelines deploy the applications configuration and their specific versions, launch automated tests and control quality gates for the specified environment. As a result of the successfully completed process, the specific versions of images are promoted to the next environment. All environments are sequential and promote the build versions of applications one-by-one. The logic of each stage is described as a code of Jenkins pipelines and stored in the VCS.</p> <p>During the CI/CD, there are several continuous processes that run in the repository, find below the list of possible actions:</p> <ul> <li>Review the code with the help of Gerrit tool;</li> <li>Run the static analysis using SonarQube to control the quality of the source code and keep the historical data which helps to understand the trend and effectivity of particular teams and members;</li> <li>Analyze application source code using SAST, byte code, and binaries for coding/design conditions that are indicative of security vulnerabilities;</li> <li>Build the code with Jenkins and run automated tests that are written to make sure the applied changes will not break any functionality.</li> </ul> <p>Note</p> <p>For the details on autotests, please refer to the Autotest, Add Autotest, and Autotest as Quality Gate pages.</p> <p>The release process is divided into cycles and provides regular delivery of completed pieces of functionality while continuing the development and integration of new functionality into the product mainline.</p> <p>Explore the main flow that is displayed on the diagram below:</p> <p> EDP CI/CD pipeline </p>"},{"location":"user-guide/cicd-overview/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Library</li> <li>Add CD Pipeline</li> <li>CI Pipeline Details</li> <li>CD Pipeline Details</li> <li>Customize CI Pipeline</li> <li>EDP Pipeline Framework</li> <li>Customize CD Pipeline</li> <li>EDP Stages</li> <li>Glossary</li> <li>Use Terraform Library in EDP</li> </ul>"},{"location":"user-guide/code-review-pipeline/","title":"Code Review Pipeline","text":"<p>This section provides details on the Code Review pipeline of the EDP CI/CD framework. Explore below the pipeline purpose, stages and possible actions to perform.</p>"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline-purpose","title":"Code Review Pipeline Purpose","text":"<p>The purpose of the Code Review pipeline contains the following points:</p> <ul> <li>Check out and test a particular developer's change (Patch Set) in order to inspect whether the code fits all the quality gates and can be built and tested;</li> <li>Be triggered if any new Patch Set appears in Gerrit;</li> <li>Send feedback about the build process in Jenkins to review the card in Gerrit;</li> <li>Send feedback about Sonar violations that have been found during the Sonar stage.</li> </ul> <p>Find below the functional diagram of the Code Review pipeline with the default stages:</p> <p> Code review pipeline stages </p>"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline-for-applications-and-libraries","title":"Code Review Pipeline for Applications and Libraries","text":"<p>Note</p> <p>Make sure the necessary applications or libraries are added to the Admin Console. For the details on how to add a codebase, please refer to the Add Application or Add Library pages accordingly.</p> <p>To discover the Code Review pipeline, apply changes that will trigger the Code Review pipeline automatically and take the following steps:</p> <ol> <li> <p>Navigate to Jenkins. In Admin Console, go to the Overview section on the left-side navigation bar and click the link to Jenkins.</p> <p> Link to Jenkins </p> <p>or</p> <p>In Gerrit, go to the Patch Set page and click the CI Jenkins link in the Change Log section</p> <p> Link from Gerrit </p> <p>Note</p> <p>The Code Review pipeline starts automatically for every codebase type (Application, Autotests, Library).</p> </li> <li> <p>Check the Code Review pipeline for the application of for the library. Click the application name in Jenkins and switch to the additional release-01 branch that is created with the respective Code Review and Build pipelines.</p> </li> <li> <p>Click the Code Review pipeline link to open the Code Review pipeline stages for the application:</p> <ul> <li>Init - initialization of the codebase information and loading of the common libraries</li> <li>gerrit-checkout / checkout - the checkout of patch sets from Gerrit. The stage is called gerrit-checkout for the Create and Clone strategies of adding a codebase and checkout for the Import strategy.</li> <li>compile - the source code compilation</li> <li>tests - the launch of the tests</li> <li>sonar - the launch of the static code analyzer that checks the whole code</li> <li>helm-lint - the launch of the linting tests for deployment charts</li> <li>dockerfile-lint - the launch of the linting tests for Dockerfile</li> <li>commit-validate - the stage is optional and appears under enabled integration with Jira. Please refer to the Adjust Jira Integration and Adjust VCS Integration With Jira sections for the details.</li> </ul> </li> </ol> <p>Note</p> <p>For more details on EDP pipeline stages, please refer to the Pipeline Stages section.</p>"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline-for-autotests","title":"Code Review Pipeline for Autotests","text":"<p>To discover the Code Review pipeline for autotests, first, apply changes to a codebase that will trigger the Code Review pipeline automatically. The flow for the autotest is similar for that for applications and libraries, however, there are some differences. Explore them below.</p> <ol> <li> <p>Open the run.json file for the created autotest.</p> <p>Note</p> <p>Please refer to the Add Autotest page for the details on how to create an autotest.</p> <p>The run.json file keeps a command that is executed on this stage.</p> </li> <li> <p>Open the Code Review pipeline in Jenkins (via the link in Gerrit or via the Admin Console Overview page) and click the Configure option from the left side. There are only four stages available: Initialization - Gerrit-checkout - tests - sonar (the launch of the static code analyzer that checks the whole code).</p> </li> <li> <p>Open the Code Review pipeline in Jenkins with the successfully passed stages.</p> </li> </ol>"},{"location":"user-guide/code-review-pipeline/#retrigger-code-review-pipeline","title":"Retrigger Code Review Pipeline","text":"<p>The Code Review pipeline can be retriggered manually, especially if the pipeline failed before. To retrigger it, take the following steps:</p> <ol> <li> <p>In Jenkins, click the Retrigger option from the drop-down menu for the specific Code Review pipeline version number. Alternatively, click the Jenkins main page and select the Query and Trigger Gerrit Patches option.</p> </li> <li> <p>Click Search and select the check box of the necessary change and patch set and then click Trigger Selected.</p> </li> </ol> <p>As a result, the Code Review pipeline will be retriggered.</p>"},{"location":"user-guide/code-review-pipeline/#configure-code-review-pipeline","title":"Configure Code Review Pipeline","text":"<p>The Configure option allows adding/removing the stage from the Code Review pipeline if needed. To configure the Code Review pipeline, take the following steps:</p> <ol> <li> <p>Being in Jenkins, click the Configure option from the left-side menu.</p> </li> <li> <p>Define the stages set that will be executed for the current pipeline.</p> <ul> <li>To remove a stage, select and remove the whole objects massive: {\"name\".\"tests\"}, where name is a key and tests is a stage name that should be executed.</li> <li>To add a stage, define the objects massive: {\"name\".\"tests\"}, where name is a key and tests is a stage name that should be added.</li> </ul> <p>Note</p> <p>All stages are launched from the shared library on GitHub. The list of libraries is located in the edp-library-stages repository.</p> </li> <li> <p>To apply the new stage process, retrigger the Code Review pipeline. For details, please refer to the Retrigger Code Review Pipeline section.</p> </li> <li> <p>Open Jenkins and check that there is no removed stage in the Code Review pipeline.</p> </li> </ol>"},{"location":"user-guide/code-review-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Autotest</li> <li>Add Library</li> <li>Adjust Jira Integration</li> <li>Adjust VCS Integration With Jira</li> <li>Autotest as Quality Gate</li> <li>Pipeline Stages</li> </ul>"},{"location":"user-guide/container-stages/","title":"CI Pipeline for Container","text":"<p>EPAM Delivery Platform ensures the implemented Container support allowing to work with Dockerfile that is processed by means of stages in the Code-Review and Build pipelines. These pipelines are expected to be created after the Container Library is added.</p>"},{"location":"user-guide/container-stages/#code-review-pipeline-stages","title":"Code Review Pipeline Stages","text":"<p>In the Code Review pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage is a standard step during which all files are checked out from a selected branch of the Git repository.</p> </li> <li> <p>dockerfile-lint stage uses the hadolint tool to perform linting tests for the Dockerfile.</p> </li> <li> <p>dockerbuild-verify stage collects artifacts and builds an image from the Dockerfile without pushing to registry. This stage is intended to check if the image is built.</p> </li> </ol>"},{"location":"user-guide/container-stages/#build-pipeline-stages","title":"Build Pipeline Stages","text":"<p>In the Build pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage is a standard step during which all files are checked out from a master branch of the Git repository.</p> </li> <li> <p>get-version stage where the library version is determined either via:</p> <p>2.1. EDP versioning functionality.</p> <p>2.2. Default versioning functionality.</p> </li> <li> <p>dockerfile-lint stage uses the hadolint tool to perform linting tests for Dockerfile.</p> </li> <li> <p>build-image-kaniko stage builds Dockerfile using the Kaniko tool.</p> </li> <li> <p>git-tag stage that is intended for tagging a repository in Git.</p> </li> </ol>"},{"location":"user-guide/container-stages/#tools-for-container-images-building","title":"Tools for Container Images Building","text":"<p>EPAM Delivery Platform ensures the implemented Kaniko tool and <code>BuildConfig</code> object support. Using Kaniko tool allows building the container images from a Dockerfile both on the Kubernetes and OpenShift platforms. The <code>BuildConfig</code> object enables the building of the container images only on the OpenShift platform.</p> <p>EDP uses the <code>BuildConfig</code> object and the Kaniko tool for creating containers from a Dockerfile and pushing them to the internal container image registry. For Kaniko, it is also possible to change the Docker config file and push the containers to different container image registries.</p>"},{"location":"user-guide/container-stages/#supported-container-image-build-tools","title":"Supported Container Image Build Tools","text":"Platform Build Tools Kubernetes Kaniko OpenShift Kaniko, BuildConfig"},{"location":"user-guide/container-stages/#change-build-tool-in-the-build-pipeline","title":"Change Build Tool in the Build Pipeline","text":"<p>By default, EPAM Delivery Platform uses the <code>build-image-kaniko</code> stage for building container images on the Kubernetes platform and the <code>build-image-from-dockerfile</code> stage for building container images on the OpenShift platform.</p> <p>In order to change a build tool for the OpenShift Platform from the default <code>buildConfig</code> object to the Kaniko tool, perform the following steps:</p> <ol> <li>Modify or update a job provisioner logic, follow the instructions on the Manage Jenkins CI Pipeline Job Provisioner page.</li> <li>Update the required parameters for a new provisioner.    For example, if it is necessary to change the build tool for Container build pipeline, update the list of stages:<pre><code>stages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-from-dockerfile\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n</code></pre> <pre><code>stages['Build-library-kaniko'] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' +\n',{\"name\": \"dockerfile-lint\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]'\n</code></pre> </li> </ol>"},{"location":"user-guide/container-stages/#related-articles","title":"Related Articles","text":"<ul> <li>Use Dockerfile Linters for Code Review Pipeline</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/copy-shared-secrets/","title":"Copy Shared Secrets","text":"<p>The Copy Shared Secrets stage provides the ability to copy secrets from the current Kubernetes namespace into a namespace created during CD pipeline.</p> <p> Shared secrets </p> <p>Please follow the steps described below to copy the secrets:</p> <ol> <li> <p>Create a secret in the current Kubernetes namespace that should be used in the deployment. The secret label must be <code>app.edp.epam.com/use: cicd</code>, since the pipeline script will attempt to copy the secret by its label. For example:</p> <pre><code>kind: Secret\nmetadata:\nlabels:\napp.edp.epam.com/use: cicd\n</code></pre> </li> <li> <p>Add the following step to the CD pipeline <code>{\"name\":\"copy-secrets\",\"step_name\":\"copy-secrets\"}</code>. Alternatively, it is possible to create a custom job provisioner with this step.</p> </li> <li> <p>Run the job. The pipeline script will create a secret with the same data in the namespace generated by the cd pipeline.</p> <p>Note</p> <p>Service account tokens are not supported.</p> </li> </ol>"},{"location":"user-guide/copy-shared-secrets/#related-articles","title":"Related Articles","text":"<ul> <li>Customize CD Pipeline</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/customize-cd-pipeline/","title":"Customize CD Pipeline","text":"<p>Apart from running CD pipeline stages with the default logic, there is the ability to perform the following:</p> <ul> <li>Create your own logic for stages;</li> <li>Redefine the default EDP stages of a CD pipeline.</li> </ul> <p>In order to have the ability to customize a stage logic, create a CD pipeline stage source as a Library:</p> <ol> <li> <p>Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language:</p> <p>Note</p> <p>If you clone the library, make sure that the correct source branch is selected.</p> <p> Create library </p> <p>Select the required fields to build your library:</p> <p> Advanced settings </p> </li> <li> <p>Go to the Continuous Delivery section of the Admin Console and create a CD pipeline with the library stage source and its branch:</p> <p> Library source </p> </li> </ol>"},{"location":"user-guide/customize-cd-pipeline/#add-new-stage","title":"Add New Stage","text":"<p>Follow the steps below to add a new stage:</p> <ul> <li>Clone the repository with the added library;</li> <li>Create a \"stages\" directory in the root;</li> <li>Create a Jenkinsfile with default content:<pre><code>@Library(['edp-library-stages', 'edp-library-pipelines']) _\n\nDeploy()\n</code></pre> </li> </ul> <ul> <li>Create a groovy file with a meaningful name, e.g. NotificationStage.groovy;</li> <li>Put the required construction and your own logic into the file:<pre><code>import com.epam.edp.stages.impl.cd.Stage\n\n@Stage(name = \"notify\")\nclass Notify {\n    Script script\n    void run(context) {\n    --------------- Put your own logic here ------------------\n            script.println(\"Send notification logic\")\n    --------------- Put your own logic here ------------------\n    }\n}\nreturn Notify\n</code></pre> </li> </ul> <ul> <li> <p>Add a new stage to the STAGES parameter of the Jenkins job of your CD pipeline:</p> <p> Stages parameter </p> <p>Warning</p> <p>To make this stage permanently present, please modify the job provisioner.</p> </li> </ul> <ul> <li>Run the job to check that your new stage has been run during the execution.</li> </ul>"},{"location":"user-guide/customize-cd-pipeline/#redefine-existing-stage","title":"Redefine Existing Stage","text":"<p>By default, the following stages are implemented in EDP pipeline framework:</p> <ul> <li>deploy,</li> <li>deploy-helm,</li> <li>autotests,</li> <li>manual (Manual approve),</li> <li>promote-images.</li> </ul> <p>Using one of these names for annotation in your own class will lead to redefining the default logic with your own.</p> <p>Find below a sample of the possible flow of the redefining deploy stage:</p> <ul> <li>Clone the repository with the added library;</li> <li>Create a \"stages\" directory in the root;</li> <li>Create a Jenkinsfile with default content:<pre><code>@Library(['edp-library-stages', 'edp-library-pipelines']) _\n\nDeploy()\n</code></pre> </li> </ul> <ul> <li>Create a groovy file with a meaningful name, e.g. CustomDeployStage.groovy;</li> <li>Put the required construction and your own logic into the file:<pre><code>import com.epam.edp.stages.impl.cd.Stage\n\n@Stage(name = \"deploy\")\nclass CustomDeployStage {\n    Script script\n\n    void run(context) {\n    --------------- Put your own logic here ------------------\n            script.println(\"Custom deploy stage logic\")\n    --------------- Put your own logic here ------------------\n    }\n}\nreturn CustomDeployStage\n</code></pre> </li> </ul>"},{"location":"user-guide/customize-cd-pipeline/#add-a-new-stage-using-shared-library-via-custom-global-pipeline-libraries","title":"Add a New Stage Using Shared Library via Custom Global Pipeline Libraries","text":"<p>Note</p> <p>To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page.</p> <p>To redefine any stage and add custom logic using global pipeline libraries, perform the steps below:</p> <ul> <li> <p>Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language:</p> <p> Create library </p> <p>Select the required fields to build your library:</p> <p> Advanced settings </p> </li> </ul> <ul> <li>Clone the repository with the added library;</li> <li>Create a directory with the name <code>src/com/epam/edp/customStages/impl/cd/impl/</code> in the library repository, for instance: <code>src/com/epam/edp/customStages/impl/cd/impl/EmailNotify.groovy</code>;</li> <li>Add a Groovy file with another name to the same stages catalog, for instance \u2013 <code>EmailNotify.groovy</code>:<pre><code>package com.epam.edp.customStages.impl.cd.impl\n\nimport com.epam.edp.stages.impl.cd.Stage\n\n@Stage(name = \"notify\")\nclass Notify {\n    Script script\n    void run(context) {\n    --------------- Put your own logic here ------------------\n    script.println(\"Send notification logic\")\n    --------------- Put your own logic here ------------------\n   }\n}\n</code></pre> </li> </ul> <ul> <li> <p>Create a Jenkinsfile with default content and the added custom library to Jenkins:</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name']) _\n\nDeploy()\n</code></pre> <p>Note</p> <p><code>edp-custom-shared-library-name</code> is the name of your Custom Global Pipeline Library that should be added to the Jenkins Global Settings.</p> </li> </ul> <ul> <li> <p>Add a new stage to the STAGES parameter of the Jenkins job of your CD pipeline:</p> <p> Stages parameter </p> <p>Warning</p> <p>To make this stage permanently present, please modify the job provisioner.</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> </li> </ul> <ul> <li>Run the job to check that the new stage has been running during the execution.</li> </ul>"},{"location":"user-guide/customize-cd-pipeline/#redefine-a-default-stage-logic-via-custom-global-pipeline-libraries","title":"Redefine a Default Stage Logic via Custom Global Pipeline Libraries","text":"<p>Note</p> <p>To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page.</p> <p>By default, the following stages are implemented in EDP pipeline framework:</p> <ul> <li>deploy,</li> <li>deploy-helm,</li> <li>autotests,</li> <li>manual (Manual approve),</li> <li>promote-images.</li> </ul> <p>Using one of these names for annotation in your own class will lead to redefining the default logic with your own.</p> <p>To redefine any stage and add custom logic using global pipeline libraries, perform the steps below:</p> <ul> <li> <p>Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language:</p> <p> Create library </p> <p>Select the required fields to build your library:</p> <p> Advanced settings </p> </li> </ul> <ul> <li>Clone the repository with the added library;</li> <li>Create a directory with the name <code>src/com/epam/edp/customStages/impl/cd/impl/</code> in the library repository, for instance: <code>src/com/epam/edp/customStages/impl/cd/impl/CustomDeployStage.groovy;</code>;</li> <li>Add a Groovy file with another name to the same stages catalog, for instance \u2013 <code>CustomDeployStage.groovy</code>:<pre><code>package com.epam.edp.customStages.impl.cd.impl\n\nimport com.epam.edp.stages.impl.cd.Stage\n\n@Stage(name = \"deploy\")\nclass CustomDeployStage {\n    Script script\n\n    void run(context) {\n    --------------- Put your own logic here ------------------\n            script.println(\"Custom deploy stage logic\")\n    --------------- Put your own logic here ------------------\n    }\n}\n</code></pre> </li> </ul> <ul> <li> <p>Create a Jenkinsfile with default content and the added custom library to Jenkins:</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name']) _\n\nDeploy()\n</code></pre> <p>Note</p> <p><code>edp-custom-shared-library-name</code> is the name of your Custom Global Pipeline Library that should be added to the Jenkins Global Settings.</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> </li> </ul>"},{"location":"user-guide/customize-cd-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add a New Custom Global Pipeline Library</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/customize-ci-pipeline/","title":"Customize CI Pipeline","text":"<p>This chapter describes the main steps that should be followed when customizing a CI pipeline.</p>"},{"location":"user-guide/customize-ci-pipeline/#redefine-a-default-stage-logic-for-a-particular-application","title":"Redefine a Default Stage Logic for a Particular Application","text":"<p>To redefine any stage and add custom logic, perform the steps below:</p> <ol> <li> <p>Open the GitHub repository:</p> <ul> <li>Create a directory with the name \u201cstages\u201d in the application repository;</li> <li>Create a Groovy file with a meaningful name for a custom stage description, for instance: CustomSonar.groovy.</li> </ul> </li> <li> <p>Paste the copied skeleton from the reference stage and insert the necessary logic.</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> <p>The stage logic structure is the following:</p> <p>CustomSonar.groovy</p> <pre><code>import com.epam.edp.stages.impl.ci.ProjectType\nimport com.epam.edp.stages.impl.ci.Stage\n\n@Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY])\nclass CustomSonar {\n    Script script\n    void run(context) {\n        script.sh \"echo 'Your custom logic of the stage'\"\n    }\n}\nreturn CustomSonar\n</code></pre> <p>Info</p> <p>There is the ability to redefine the predefined EDP stage as well as to create it from scratch, it depends on the name that is used in the @Stage annotation. For example, using name = \"sonar\" will redefine an existing sonar stage with the same name, but using name=\"new-sonar\" will create a new stage.</p> <p>By default, the following stages are implemented in EDP:</p> <ul> <li>build</li> <li>build-image-from-dockerfile</li> <li>build-image</li> <li>build-image-kaniko</li> <li>checkout</li> <li>compile</li> <li>create-branch</li> <li>gerrit-checkout</li> <li>get-version</li> <li>git-tag</li> <li>push</li> <li>sonar</li> <li>sonar-cleanup</li> <li>tests</li> <li>trigger-job</li> </ul> <p>Mandatory points:</p> <ul> <li>Importing classes com.epam.edp.stages.impl.ci.ProjectType and com.epam.edp.stages.impl.ci.Stage;</li> <li>Annotating \"Stage\" for class - @Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]);</li> <li>Property with the type \"Script\";</li> <li>Void the \"run\" method with the \"context input parameter\" value;</li> <li>Bring the custom class back to the end of the file: return CustomSonar.</li> </ul> </li> <li> <p>Open Jenkins and make sure that all the changes are correct after the completion of the customized pipeline.</p> </li> </ol>"},{"location":"user-guide/customize-ci-pipeline/#add-a-new-stage-for-a-particular-application","title":"Add a New Stage for a Particular Application","text":"<p>To add a new stage for a particular application, perform the steps below:</p> <ol> <li>In the GitHub repository, add a Groovy file with another name to the same stages catalog.</li> <li> <p>Copy the part of a pipeline framework logic that cannot be predefined;</p> <p>The stage logic structure is the following:</p> <p>EmailNotify.groovy</p> <pre><code>import com.epam.edp.stages.impl.ci.ProjectType\nimport com.epam.edp.stages.impl.ci.Stage\n\n@Stage(name = \"email-notify\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass EmailNotify {\n    Script script\n    void run(context) {\n        -------------------'Your custom logic here'\n    }\n}\nreturn EmailNotify\n</code></pre> </li> <li> <p>Open the default set of stages and add a new one into the Default Value field by saving the respective type {\"name\": \"email-notify\"}, save the changes:   Add stage </p> </li> <li> <p>Open Jenkins to check the pipeline; as soon as the checkout stage is passed, the new stage will appear in the pipeline:   Check stage </p> <p>Warning</p> <p>To make this stage permanently present, please modify the job provisioner.</p> </li> </ol>"},{"location":"user-guide/customize-ci-pipeline/#redefine-a-default-stage-logic-via-custom-global-pipeline-libraries","title":"Redefine a Default Stage Logic via Custom Global Pipeline Libraries","text":"<p>Note</p> <p>To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page.</p> <p>To redefine any stage and add custom logic using global pipeline libraries, perform the steps below:</p> <ol> <li> <p>Open the GitHub repository:</p> <ul> <li>Create a directory with the name <code>/src/com/epam/edp/customStages/impl/ci/impl/stageName/</code> in the library repository, for instance: <code>/src/com/epam/edp/customStages/impl/ci/impl/sonar/</code>;</li> <li>Create a Groovy file with a meaningful name for a custom stage description, for instance \u2013 <code>CustomSonar.groovy</code>.</li> </ul> </li> <li> <p>Paste the copied skeleton from the reference stage and insert the necessary logic.</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> <p>The stage logic structure is the following:</p> <p>CustomSonar.groovy</p> <pre><code>package com.epam.edp.customStages.impl.ci.impl.sonar\n\nimport com.epam.edp.stages.impl.ci.ProjectType\nimport com.epam.edp.stages.impl.ci.Stage\n\n@Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY])\nclass CustomSonar {\n    Script script\n    void run(context) {\n        script.sh \"echo 'Your custom logic of the stage'\"\n    }\n}\n</code></pre> <p>Info</p> <p>There is the ability to redefine the predefined EDP stage as well as to create it from scratch, it depends on the name that is used in the @Stage annotation. For example, using name = \"sonar\" will redefine an existing sonar stage with the same name, but using name=\"new-sonar\" will create a new stage.</p> <p>By default, the following stages are implemented in EDP:</p> <ul> <li>build</li> <li>build-image-from-dockerfile</li> <li>build-image</li> <li>build-image-kaniko</li> <li>checkout</li> <li>compile</li> <li>create-branch</li> <li>gerrit-checkout</li> <li>get-version</li> <li>git-tag</li> <li>push</li> <li>sonar</li> <li>sonar-cleanup</li> <li>tests</li> <li>trigger-job</li> </ul> <p>Mandatory points:</p> <ul> <li>Defining a package com.epam.edp.customStages.impl.ci.impl.stageName;</li> <li>Importing classes com.epam.edp.stages.impl.ci.ProjectType and com.epam.edp.stages.impl.ci.Stage;</li> <li>Annotating \"Stage\" for class - @Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]);</li> <li>Property with the type \"Script\";</li> <li>Void the \"run\" method with the \"context input parameter\" value.</li> </ul> </li> </ol> <p>3.Open Jenkins and make sure that all the changes are correct after the completion of the customized pipeline.</p>"},{"location":"user-guide/customize-ci-pipeline/#add-a-new-stage-using-shared-library-via-custom-global-pipeline-libraries","title":"Add a New Stage Using Shared Library via Custom Global Pipeline Libraries","text":"<p>Note</p> <p>To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page.</p> <p>To redefine any stage and add custom logic using global pipeline libraries, perform the steps below:</p> <ol> <li> <p>Open the GitHub repository:</p> <ul> <li>Create a directory with the name <code>/src/com/epam/edp/customStages/impl/ci/impl/stageName/</code> in the library repository, for instance: <code>/src/com/epam/edp/customStages/impl/ci/impl/emailNotify/</code>;</li> <li>Add a Groovy file with another name to the same stages catalog, for instance \u2013 <code>EmailNotify.groovy</code>.</li> </ul> </li> <li> <p>Copy the part of a pipeline framework logic that cannot be predefined;</p> <p>Note</p> <p>Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub).</p> <p>The stage logic structure is the following:</p> <p>EmailNotify.groovy</p> <pre><code>package com.epam.edp.customStages.impl.ci.impl.emailNotify\n\nimport com.epam.edp.stages.impl.ci.ProjectType\nimport com.epam.edp.stages.impl.ci.Stage\n\n@Stage(name = \"email-notify\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass EmailNotify {\n    Script script\n    void run(context) {\n        -------------------'Your custom logic here'\n    }\n}\n</code></pre> </li> <li> <p>Open the default set of stages and add a new one into the Default Value field by saving the respective type {\"name\": \"email-notify\"}, save the changes:   Add stage </p> </li> <li> <p>Open Jenkins to check the pipeline; as soon as the checkout stage is passed, the new stage will appear in the pipeline:   Check stage </p> <p>Warning</p> <p>To make this stage permanently present, please modify the job provisioner.</p> </li> </ol>"},{"location":"user-guide/customize-ci-pipeline/#related-articles","title":"Related Articles","text":"<ul> <li>Add a New Custom Global Pipeline Library</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> <li>Add Security Scanner</li> </ul>"},{"location":"user-guide/d-d-diagram/","title":"Delivery Dashboard Diagram","text":"<p>Admin Console allows getting the general visualization of all the relations between CD pipeline, stages, codebases, branches, and image streams that are elements with the specific icon. To open the current project diagram, navigate to the Delivery Dashboard Diagram section on the navigation bar:</p> <p> Delivery dashboard </p> <p>Info</p> <p>All the requested changes (deletion, creation, adding) are displayed immediately on the Delivery Dashboard Diagram.</p> <p>Possible actions when using dashboard:</p> <ul> <li>To zoom in or zoom out the diagram scale, scroll up / down.</li> <li>To move the diagram, click and drag.</li> <li>To move an element, click it and drag to the necessary place.</li> <li>To see the relations for one element, click this element.</li> <li>To see the whole diagram, click the empty space.</li> </ul>"},{"location":"user-guide/d-d-diagram/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Admin Console</li> </ul>"},{"location":"user-guide/dockerfile-stages/","title":"Use Dockerfile Linters for Code Review Pipeline","text":"<p>This section contains the description of dockerbuild-verify, dockerfile-lint stages which one can use in Code Review pipeline.</p> <p>These stages help to obtain a quick response on the validity of the code in the Code Review pipeline in Kubernetes for all types of applications supported by EDP out of the box.</p> <p> Add stages </p> <p>Inspect the functions performed by the following stages:</p> <ol> <li> <p>dockerbuild-verify stage collects artifacts and builds an image from the Dockerfile without push to registry. This stage is intended to check if the image is built.</p> </li> <li> <p>dockerfile-lint stage launches the hadolint command in order to check the Dockerfile.</p> </li> </ol>"},{"location":"user-guide/dockerfile-stages/#related-articles","title":"Related Articles","text":"<ul> <li>Use Terraform Library in EDP</li> <li>EDP Pipeline Framework</li> <li>Promote Docker Images From ECR to Docker Hub</li> <li>CI Pipeline for Container</li> </ul>"},{"location":"user-guide/ecr-to-docker-stages/","title":"Promote Docker Images From ECR to Docker Hub","text":"<p>This section contains the description of the ecr-to-docker stage, available in the Build pipeline.</p> <p>The ecr-to-docker stage is intended to perform the push of Docker images collected from the Amazon ECR cluster storage to Docker Hub repositories, where the image becomes accessible to everyone who wants to use it. This stage is optional and is designed for working with various EDP components.</p> <p>Note</p> <p>When pushing the image from ECR to Docker Hub using crane, the SHA-256 value remains unchanged.</p> <p>To run the ecr-to-docker stage just for once, navigate to the Build with Parameters option, add this stage to the stages list, and click Build.  To add the ecr-to-docker stage to the pipeline, modify the job provisioner.</p> <p>Note</p> <p>To push properly the Docker image from the ECR storage, the ecr-to-docker stage should follow the build-image-kaniko stage. Add custom lib2 </p> <p>The ecr-to-docker stage contains a specific script that launches the following actions:</p> <ol> <li>Performs authorization in AWS ECR in the EDP private storage via awsv2.</li> <li>Performs authorization in the Docker Hub.</li> <li> <p>Checks whether a similar image exists in the Docker Hub in order to avoid its overwriting.</p> <ul> <li>If a similar image exists in the Docker Hub, the script will return the message about it and stop the execution. The ecr-to-docker stage in the Build pipeline will be marked in red.</li> <li>If there is no similar image, the script will proceed to promote the image using crane.</li> </ul> </li> </ol>"},{"location":"user-guide/ecr-to-docker-stages/#create-secret-for-ecr-to-docker-stage","title":"Create Secret for ECR-to-Docker Stage","text":"<p>The ecr-to-docker stage expects the authorization credentials to be added as Kubernetes secret into EDP-installed namespace. To create the dockerhub-credentials secret, run the following command:</p> <pre><code>  kubectl -n &lt;edp-project&gt; create secret generic dockerhub-credentials \\\n  --from-literal=accesstoken=&lt;dockerhub_access_token&gt; \\\n  --from-literal=account=&lt;dockerhub_account_name&gt; \\\n  --from-literal=username=&lt;dockerhub_user_name&gt;\n</code></pre> <p>Note</p> <ul> <li>The \u2039dockerhub_access_token\u203a should be created beforehand and in accordance with the official Docker Hub instruction.</li> <li>The \u2039dockerhub_account_name\u203a and \u2039dockerhub_user_name\u203a for the organization account repository will differ and be identical for the personal account repository.</li> <li>Pay attention that the Docker Hub repository for images uploading should be created beforehand and named by the following pattern: \u2039dockerhub_account_name\u203a/\u2039Application Name\u203a, where the \u2039Application Name\u203a should match the application name in the EDP Admin Console.</li> </ul>"},{"location":"user-guide/ecr-to-docker-stages/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Pipeline Framework</li> <li>Manage Access Token</li> <li>Manage Jenkins CI Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/helm-release-deletion/","title":"Helm Release Deletion","text":"<p>The Helm release deletion stage provides the ability to remove Helm releases from the namespace.</p> <p>Note</p> <p>Pay attention that this stages will remove all Helm releases from the namespace. To avoid loss of important data, before using this stage, make the necessary backups.</p> <p>To remove Helm releases, follow the steps below:</p> <ol> <li> <p>Add the following step to the CD pipeline <code>{\"name\":\"helm-uninstall\",\"step_name\":\"helm-uninstall\"}</code>. Alternatively, with this step, it is possible to create a custom job provisioner.</p> </li> <li> <p>Run the job. The pipeline script will remove Helm releases from the namespace.</p> </li> </ol>"},{"location":"user-guide/helm-release-deletion/#related-articles","title":"Related Articles","text":"<ul> <li>Customize CD Pipeline</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/helm-stages/","title":"Helm Chart Testing and Documentation Tools","text":"<p>This section contains the description of the helm-lint and helm-docs stages that can be used in the Code Review pipeline.</p> <p>The stages help to obtain a quick response on the validity of the helm chart code and documentation in the Code Review pipeline.</p> <p>Inspect the functions performed by the following stages:</p> <ol> <li> <p>helm-lint stage launches the ct lint --charts-deploy-templates/ command in order to validate the chart.</p> <p> Helm lint </p> <ul> <li>chart_schema.yaml - this file contains some rules by which the chart validity is checked. These rules are necessary for the YAML scheme validation.</li> </ul> <p>See the current scheme:</p> View: chart_schema.yaml <pre><code>name: str()\nhome: str()\nversion: str()\ntype: str()\napiVersion: str()\nappVersion: any(str(), num())\ndescription: str()\nkeywords: list(str(), required=False)\nsources: list(str(), required=True)\nmaintainers: list(include('maintainer'), required=True)\ndependencies: list(include('dependency'), required=False)\nicon: str(required=False)\nengine: str(required=False)\ncondition: str(required=False)\ntags: str(required=False)\ndeprecated: bool(required=False)\nkubeVersion: str(required=False)\nannotations: map(str(), str(), required=False)\n---\nmaintainer:\nname: str(required=True)\nemail: str(required=False)\nurl: str(required=False)\n---\ndependency:\nname: str()\nversion: str()\nrepository: str()\ncondition: str(required=False)\ntags: list(str(), required=False)\nenabled: bool(required=False)\nimport-values: any(list(str()), list(include('import-value')), required=False)\nalias: str(required=False)\n</code></pre> <ul> <li>ct.yaml - this file contains rules that will skip the validation of certain rules.</li> </ul> <p>To get more information about the chart testing lint, please refer to the ct_lint documentation.</p> </li> <li> <p>helm-docs stage helps to validate the generated documentation for the Helm deployment templates in the Code Review pipeline for all types of applications supported by EDP. This stage launches the helm-docs command in order to validate the chart documentation file existence and verify its relevance.</p> <p>Requirements: helm-docs v1.10.0</p> <p>Note</p> <p>The helm-docs stage is optional. To extend the pipeline with an additional stage, please refer to the Configure Code Review Pipeline page.</p> <p> Helm docs </p> <p>Note</p> <p>The example of the generated documentation.</p> </li> </ol>"},{"location":"user-guide/helm-stages/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Pipeline Framework</li> </ul>"},{"location":"user-guide/library/","title":"Library","text":"<p>This section describes the subsequent possible actions that can be performed with the newly added or existing libraries.</p>"},{"location":"user-guide/library/#check-and-remove-library","title":"Check and Remove Library","text":"<p>As soon as the library is successfully provisioned, the following will be created:</p> <ul> <li>Code Review and Build pipelines in Jenkins for this library. The Build pipeline will be triggered automatically if at least one environment is already added.</li> <li>A new project in Gerrit or another VCS.</li> <li>SonarQube integration will be available after the Build pipeline in Jenkins is passed.</li> <li>Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well.</li> </ul> <p>Info</p> <p>To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link.</p> <p>The added library will be listed in the Libraries list allowing to do the following:</p> <p> Library menu </p> <ol> <li> <p>Create another library by clicking the Create button and performing the same steps as described on the Add Library page;</p> </li> <li> <p>Open library data by clicking its link name. Once clicked, the following blocks will be displayed:</p> <ul> <li>General Info - displays common information about the created/cloned/imported library.</li> <li>Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type).</li> <li> <p>Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields:</p> <ul> <li>Build Number - indicates the current build number;</li> <li>Last Successful Build - indicates the last successful build number.</li> </ul> </li> </ul> <ul> <li>Status Info - displays all the actions that were performed during the creation/cloning/importing process.</li> </ul> </li> <li> <p>Edit the library codebase by clicking the pencil icon. For details see the Edit Existing Codebase section.</p> </li> <li> <p>Remove library with the corresponding database and Jenkins pipelines:</p> <ul> <li>Click the delete icon next to the library name;</li> <li>Type the required library name;</li> <li>Confirm the deletion by clicking the Delete button.</li> </ul> <p>Note</p> <p>The library that is used in a CD pipeline cannot be removed.</p> <p> Library menu </p> </li> <li> <p>Select a number of existing libraries to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page.</p> </li> <li> <p>Sort the existing libraries in a list by clicking the Name title. The libraries will be displayed in an alphabetical order.</p> </li> <li> <p>Search the necessary application by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the library name, language or a build tool.</p> </li> <li> <p>Navigate between pages, if the number of libraries exceeds the capacity of a single page.</p> </li> </ol>"},{"location":"user-guide/library/#edit-existing-codebase","title":"Edit Existing Codebase","text":"<p>The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for applications via the Edit Codebase page.</p> <ol> <li> <p>Perform the editing from one of the following sections on the Admin Console interface:</p> <p> Edit library </p> <ul> <li> <p>Navigate to the codebase overview page and click the pencil icon, or</p> <p> Edit library </p> </li> </ul> <ul> <li> <p>Navigate to the codebase list page and click the pencil icon.</p> <p> Edit library </p> </li> </ul> </li> <li> <p>To enable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>mark the Integrate with Jira server check box and fill in the necessary fields;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline.</li> </ul> </li> <li> <p>To disable Jira integration, on the Edit Codebase page do the following:</p> <ul> <li>unmark the Integrate with Jira server check box;</li> <li>click the Proceed button to apply the changes;</li> <li>navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline.</li> </ul> </li> </ol> <p>As a result, the necessary changes will be applied.</p>"},{"location":"user-guide/library/#add-a-new-branch","title":"Add a New Branch","text":"<p>Note</p> <p>Pay attention when specifying the branch name: the branch name is involved in the formation of the application version, so it must comply with the versioning semantic rules for the application.</p> <p>When adding a library, the default branch is a master branch. In order to add a new branch, follow the steps below:</p> <ol> <li> <p>Navigate to the Branches block and click the Create button:</p> <p> Add branch </p> </li> <li> <p>Fill in the required fields:</p> <p> New branch </p> <p>a. Release Branch - select the Release Branch check box if you need to create a release branch;</p> <p>b. Branch Name - type the branch name. Pay attention that this field remain static if you create a release branch.</p> <p>c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used.</p> <p>d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number.</p> <p>e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number;</p> <p>f. Click the Proceed button and wait until the new branch will be added to the list.</p> </li> </ol> <p>Info</p> <p>Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer to Advanced Settings Menu section of the Admin Console user guide.</p> <p>The default library repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.</p>"},{"location":"user-guide/library/#remove-branch","title":"Remove Branch","text":"<p>In order to remove the added branch with the corresponding  record in the Admin Console database, do the following:</p> <ol> <li> <p>Navigate to the Branches block by clicking the library name link in the Libraries list;</p> </li> <li> <p>Click the delete icon related to the necessary branch:</p> <p> Remove branch </p> </li> <li> <p>Enter the branch name and click the Delete button;</p> </li> </ol> <p>Note</p> <p>The default master branch cannot be removed.</p>"},{"location":"user-guide/library/#related-articles","title":"Related Articles","text":"<ul> <li>Add Library</li> </ul>"},{"location":"user-guide/opa-stages/","title":"Use Open Policy Agent","text":"<p>Open Policy Agent (OPA) is a policy engine that provides:</p> <ul> <li>High-level declarative policy language Rego;</li> <li>API and tooling for policy execution.</li> </ul> <p>EPAM Delivery Platform ensures the implemented Open Policy Agent support allowing to work with Open Policy Agent bundles that is processed by means of stages in the Code Review and Build pipelines. These pipelines are expected to be created after the Rego OPA Library is added.</p>"},{"location":"user-guide/opa-stages/#code-review-pipeline-stages","title":"Code Review Pipeline Stages","text":"<p>In the Code Review pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository.</p> </li> <li> <p>tests stage containing a script that performs the following actions:</p> <p>2.1. Runs policy tests.</p> <p>2.2. Converts OPA test results into JUnit format.</p> <p>2.3. Publishes JUnit-formatted results to Jenkins.</p> </li> </ol>"},{"location":"user-guide/opa-stages/#build-pipeline-stages","title":"Build Pipeline Stages","text":"<p>In the Build pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository.</p> </li> <li> <p>get-version optional stage, a step where library version is determined either via:</p> <p>2.1. Standard EDP versioning functionality.</p> <p>2.2. Manually specified version. In this case .manifest file in a root directory MUST be provided. File must contain a JSON document with revision field. Minimal example: <code>{ \"revision\": \"1.0.0\" }\"</code>.</p> </li> <li> <p>tests stage containing a script that performs the following actions:   3.1. Runs policy tests.   3.2. Converts OPA test results into JUnit format.   3.3. Publishes JUnit-formatted results to Jenkins.</p> </li> <li> <p>git-tag stage, a standard step where git branch is tagged with a version.</p> </li> </ol>"},{"location":"user-guide/opa-stages/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Pipeline Framework</li> </ul>"},{"location":"user-guide/pipeline-framework/","title":"EDP Pipeline Framework","text":"<p>This chapter provides detailed information about the EDP pipeline framework concepts and parts, as well as the accurate data about the <code>Code Review</code>, <code>Build</code> and <code>Deploy</code> pipelines with the respective stages.</p>"},{"location":"user-guide/pipeline-framework/#edp-pipeline-framework-overview","title":"EDP Pipeline Framework Overview","text":"<p>Note</p> <p>The whole logic is applied to Jenkins as it is the main tool for the CI/CD processes organization.</p> <p> EDP pipeline framework basic </p> <p>The general EDP Pipeline Framework consists of several parts:</p> <ul> <li>Jenkinsfile - a text file that keeps the definition of a Jenkins Pipeline and is checked into source control. Every Job has its Jenkinsfile stored in the specific application repository and in Jenkins as the plain text. The behavior logic of the pipelines can be customized easily by modifying a source code which is always copied to the EDP repository after the EDP installation.</li> </ul> <p> Jenkinsfile example </p> <ul> <li>Loading Shared Libraries - a part where every job loads libraries with the help of the shared libraries mechanism for Jenkins that allows to create reproducible pipelines, write them uniformly, and manage the update process. There are two main libraries: EDP Pipelines with the common logic described for the main pipelines Code Review, Build, Deploy pipelines and EDP Stages library that keeps the description of the stages for every pipeline.</li> </ul> <ul> <li>Run Stages - a part where the predefined default stages are launched.</li> </ul> <p> Pipeline script </p>"},{"location":"user-guide/pipeline-framework/#cicd-jobs-comparison","title":"CI/CD Jobs Comparison","text":"<p>Explore the CI and CD job comparison. Please note that the dynamic stages order can be changed, meanwhile, the predefined stages order in the reference pipeline cannot be changed, i.e. only the predefined stages set can be run.</p> <p> CI/CD jobs comparison </p>"},{"location":"user-guide/pipeline-framework/#context","title":"Context","text":"<p>Context - a variable that stores and transfers all necessary parameters between stages that are used by pipeline during performing.</p> <ol> <li>The context type is \"Map\".</li> <li>Each stage has input and output context.</li> <li>Each stage has a mandatory input context.</li> </ol> <p>Note</p> <p>If the input context isn't transferred, the stage will be failed.</p>"},{"location":"user-guide/pipeline-framework/#annotations-for-cicd-stages","title":"Annotations for CI/CD Stages","text":"<p>Annotation for CI Stages:</p> <ul> <li>The annotation type is \"Map\";</li> <li>The annotation consists of the name, buildTool, and codebaseType.</li> </ul> <p>Annotation for CD Stages:</p> <ul> <li>The annotation type is \"Map\";</li> <li>The annotation consists of a name.</li> </ul>"},{"location":"user-guide/pipeline-framework/#code-review-pipeline","title":"Code Review Pipeline","text":"<p>CodeReview() \u2013 a function that allows using the EDP implementation for the Code Review pipeline.</p> <p>Note</p> <p>All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context.</p> <p>The Code Review pipeline consists of several steps:</p> <p>On the master:</p> <ul> <li>Initialization of all objects (Platform, Job, Gerrit, Nexus, Sonar, Application, StageFactory) and loading of the default implementations of EDP stages.</li> </ul> <p>On a particular Jenkins agent that depends on the build tool:</p> <ul> <li>Creating workdir for application sources;</li> <li>Loading build tool implementation for a particular application;</li> <li>Run in a loop all stages (From) and run them either in parallel or one by one.</li> </ul>"},{"location":"user-guide/pipeline-framework/#code-review-pipeline-overview","title":"Code Review Pipeline Overview","text":"<p>Using in pipelines - @Library(['edp-library-pipelines@version'])</p> <p>The corresponding enums, interfaces, classes, and their methods can be used separately from the EDP Pipelines library function (please refer to Table 1 and Table 2).</p> <p>Table 1.  Enums and Interfaces with the respective properties, methods, and examples.</p> <p> Enums Interfaces PlatformType:  - OPENSHIFT  - KUBERNETES  JobType:  - CODEREVIEW  - BUILD  - DEPLOY BuildToolType:  - MAVEN  - GRADLE  - NPM  - DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".  Methods: getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example: <code>context.platform.getJsonPathValue(''cm'',</code><code>''project-settings'', ''.data.username'')</code>. BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. Should be invoked on Jenkins build agents. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus. Methods: init: return parameters of buildTool that are needed for running stages. Example:  <code>context.buildTool = new BuildToolFactory().</code><code>getBuildToolImpl</code><code>(context.application.config.build_tool, this,</code><code>context.nexus) context.buildTool.init()</code>. <p></p> <p>Table 2.  Classes with the respective properties, methods, and examples.</p> Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting an implementation of CLI of the platform. At the moment OpenShift and Kubernetes are supported. Methods: <code>getPlatformImpl(PlatformType platform, Script script): return Class Platform</code>. Example:  <code>context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)</code>. Application(String name, Platform platform, Script script) - Class that describes the application object. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). String name - Name for the application for creating an object. Map config - Map of configuration settings for the particular application that is loaded from config map project-settings. String version - Application version, initially empty. Is set on the get-version step. String deployableModule - The name of the deployable module for multi-module applications, initially empty. String buildVersion - Version of the built artifact, contains build number of Job initially empty. String deployableModuleDir - The name of deployable module directory for multi-module applications, initially empty. Array imageBuildArgs - List of arguments for building an application Docker image. Methods: setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map. Example: <code>context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project)</code> Job(type: JobType.value, platform: Platform, script: Script) - Class that describes the Gerrit tool. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). JobType.value type. String deployTemplatesDirectory - The name of the directory in application repository where deploy templates are located. It can be set for a particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter. String edpName - The name of the EDP Project. Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable. String envToPromote - The name of the environment for promoting images. Boolean promoteImages - Defines whether images should be promoted or not. Methods: getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of the Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to the existing description of the Jenkins job. printDebugInfo(Map context): print context info to the log of Jenkins' job. runStage(String stage_name, Map context): run the particular stage according to its name. Example: <code>context.job = new Job(JobType.CODEREVIEW.value,</code> <code>context.platform, this)</code> <code>context.job.init()</code> <code>context.job.printDebugInfo(context)</code> <code>context.job.setDisplayName(\"test\")</code> <code>context.job.setDescription(\"Name: ${context.application.config.name}\")</code> Gerrit(Job job, Platform platform, Script script) - Class that describes the Gerrit tool. Properties: Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String credentialsId - Credential Id in Jenkins for Gerrit.String autouser - Username of an auto user in Gerrit for integration with Jenkins.String host - Gerrit host.String project - the project name of the built application.String branch - branch to build the application from.String changeNumber - change number of Gerrit commit.String changeName - change name of Gerrit commit.String refspecName - refspecName of Gerrit commit.String sshPort - Gerrit ssh port number.String patchsetNumber - patchsetNumber of Gerrit commit.Methods: init(): set all the properties of Gerrit object. Example: <code>context.gerrit = new Gerrit(context.job, context.platform, this)</code> <code>context.gerrit.init()</code> Nexus(Job job, Platform platform, Script script) - Class that describes the Nexus tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String autouser - Username of an auto user in Nexus for integration with Jenkins.String credentialsId - Credential Id in Jenkins for Nexus.String host - Nexus host.String port - Nexus http(s) port.String repositoriesUrl - Base URL of repositories in Nexus.String restUrl - URL of Rest API.Methods:init(): set all the properties of Nexus objectExample: <code>context.nexus = new Nexus(context.job, context.platform, this)</code> <code>context.nexus.init()</code> Sonar(Job job, Platform platform, Script script) - Class that describes the Sonar tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String route - External route of the sonar application.Methods:init(): set all the properties of Sonar objectExample: <code>context.sonar = new Sonar(context.job, context.platform, this)</code> <code>context.sonar.init()</code>"},{"location":"user-guide/pipeline-framework/#code-review-pipeline-stages","title":"Code Review Pipeline Stages","text":"<p>Each EDP stage implementation has run method that is as input parameter required to pass the \"Map\" context with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific.</p> <p>The Code Review pipeline includes the following default stages: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Tests \u2192 Sonar.</p> <p>Info</p> <p>To get the full description of every stage, please refer to the EDP Stages Framework section.</p>"},{"location":"user-guide/pipeline-framework/#how-to-redefine-or-extend-the-edp-pipeline-stages-library","title":"How to Redefine or Extend the EDP Pipeline Stages Library","text":"<p>Inspect the points below to redefine or extend the EDP Pipeline Stages Library:</p> <ul> <li>Create \u201cstage\u201d folder in your App repository.</li> <li>Create a Groovy file with a meaningful name for the custom stage description. For instance \u2013 CustomBuildMavenApplication.groovy.</li> <li>Describe the stage logic.</li> </ul> <p>Redefinition:</p> <pre><code>import com.epam.edp.stages.ProjectType\nimport com.epam.edp.stages.Stage\n@Stage(name = \"compile\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass CustomBuildMavenApplication {\nScript script\nvoid run(context) {\nscript.sh \"echo 'Your custom logic of the stage'\"\n}\n}\nreturn CustomBuildMavenApplication\n</code></pre> <p>Extension:</p> <pre><code>import com.epam.edp.stages.ProjectType\nimport com.epam.edp.stages.Stage\n@Stage(name = \"new-stage\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass NewStageMavenApplication {\nScript script\nvoid run(context) {\nscript.sh \"echo 'Your custom logic of the stage'\"\n}\n}\nreturn NewStageMavenApplication\n</code></pre>"},{"location":"user-guide/pipeline-framework/#using-edp-stages-library-in-the-pipeline","title":"Using EDP Stages Library in the Pipeline","text":"<p>In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following:</p> <ul> <li>import library - @Library(['edp-library-stages'])</li> <li>import StageFactory class - import com.epam.edp.stages.StageFactory</li> <li>define context Map \u2013 context = [:]</li> <li>define stagesFactory instance and load EDP stages:</li> </ul> <pre><code>  context.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n</code></pre> <p>After that, there is the ability to run any EDP stage beforehand by defining a necessary context: <code>context.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)</code></p> <p>For instance, the pipeline can look like:</p> <pre><code>@Library(['edp-library-stages']) _\n\nimport com.epam.edp.stages.StageFactory\nimport org.apache.commons.lang.RandomStringUtils\n\ncontext = [:]\n\nnode('maven') {\ncontext.workDir = new File(\"/tmp/${RandomStringUtils.random(10, true, true)}\")\ncontext.workDir.deleteDir()\n\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.gerrit = [:]\ncontext.application = [:]\ncontext.application.config = [:]\ncontext.buildTool = [:]\ncontext.nexus = [:]\n\n\n\nstage(\"checkout\") {\ncontext.gerrit.branch = \"master\"\ncontext.gerrit.credentialsId = \"jenkins\"\ncontext.application.config.cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\"\ncontext.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)\n}\n\n\nstage(\"compile\") {\ncontext.buildTool.command = \"mvn\"\ncontext.nexus.credentialsId = \"nexus\"\ncontext.factory.getStage(\"compile\",\"maven\",\"application\").run(context)\n}\n}\n</code></pre> <p>Or in a declarative way:</p> <pre><code>@Library(['edp-library-stages']) _\n\nimport com.epam.edp.stages.StageFactory\nimport org.apache.commons.lang.RandomStringUtils\n\ncontext = [:]\n\npipeline {\nagent { label 'maven' }\nstages {\nstage('Init'){\nsteps {\nscript {\ncontext.workDir = new File(\"/tmp/${RandomStringUtils.random(10, true, true)}\")\ncontext.workDir.deleteDir()\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.gerrit = [:]\ncontext.application = [:]\ncontext.application.config = [:]\ncontext.buildTool = [:]\ncontext.nexus = [:]\n}\n}\n}\n\nstage(\"Checkout\") {\nsteps {\nscript {\ncontext.gerrit.branch = \"master\"\ncontext.gerrit.credentialsId = \"jenkins\"\ncontext.application.config.cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\"\ncontext.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)\n}\n}\n}\n\nstage('Compile') {\nsteps {\nscript {\ncontext.buildTool.command = \"mvn\"\ncontext.nexus.credentialsId = \"nexus\"\ncontext.factory.getStage(\"compile\",\"maven\",\"application\").run(context)\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"user-guide/pipeline-framework/#build-pipeline","title":"Build Pipeline","text":"<p>Build() \u2013 a function that allows using the EDP implementation for the Build pipeline. All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context.</p> <p>The Build pipeline consists of several steps:</p> <p>On the master:</p> <ul> <li>Initialization of all objects (Platform, Job, Gerrit, Nexus, Sonar, Application, StageFactory) and loading default implementations of EDP stages.</li> </ul> <p>On a particular Jenkins agent that depends on the build tool:</p> <ul> <li>Creating workdir for application sources;</li> <li>Loading build tool implementation for a particular application;</li> <li>Run in a loop all stages (From) and run them either in parallel or one by one.</li> </ul>"},{"location":"user-guide/pipeline-framework/#build-pipeline-overview","title":"Build Pipeline Overview","text":"<p>Using in pipelines - @Library(['edp-library-pipelines@version'])</p> <p>The corresponding enums, interfaces, classes, and their methods can be used separately from the EDP Pipelines library function (please refer to Table 3 and Table 4).</p> <p>Table 3.  Enums and Interfaces with the respective properties, methods, and examples.  Enums Interfaces PlatformType:- OPENSHIFT- KUBERNETESJobType:- CODEREVIEW- BUILD- DEPLOYBuildToolType:- MAVEN- GRADLE- NPM- DOTNET Platform() -  contains methods for working with platform CLI. At the moment only OpenShift is supported.Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Methods:getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility.Example:<code>context.platform.getJsonPathValue(\"cm\",\"project-settings\",</code><code>\".data.username\")</code>BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. Should be invoked on Jenkins build agents.Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Nexus object - Object of class Nexus. See description below:Methods:init: return parameters of buildTool that are needed for running stages.Example:<code>context.buildTool = new BuildToolFactory().getBuildToolImpl</code><code>(context.application.config.build_tool, this,</code><code>context.nexus)context.buildTool.init()</code> <p> Table 4.  Classes with the respective properties, methods, and examples.</p> Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting an implementation of CLI of the platform. At the moment OpenShift and Kubernetes are supported. Methods:getPlatformImpl(PlatformType platform, Script script): return Class PlatformExample:<code>context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)</code> Application(String name, Platform platform, Script script) - Class that describes the application object. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().String name - Name for the application for creating an object.Map config - Map of configuration settings for the particular application that is loaded from config map project-settings.String version - Application version, initially empty. Is set on the get-version step.String deployableModule - The name of the deployable module for multi-module applications, initially empty.String buildVersion - Version of the built artifact, contains build number of Job initially empty.String deployableModuleDir - The name of deployable module directory for multi-module applications, initially empty.Array imageBuildArgs - List of arguments for building the application Docker image.Methods:setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map.Example:<code>context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project)</code> Job(type: JobType.value, platform: Platform, script: Script) - Class that describes the Gerrit tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().JobType.value type.String deployTemplatesDirectory - The name of the directory in application repository, where deploy templates are located. It can be set for a particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter.String edpName - The name of the EDP Project.Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable.String envToPromote - The name of the environment for promoting images.Boolean promoteImages - Defines whether images should be promoted or not.Methods:getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job.init(): set all the properties of the Job object.setDisplayName(String displayName): set display name of the Jenkins job.setDescription(String description, Boolean addDescription = false): set new or add to the existing description of the Jenkins job.printDebugInfo(Map context): print context info to the log of Jenkins' job.runStage(String stage_name, Map context): run the particular stage according to its name.Example:<code>context.job = new Job(JobType.CODEREVIEW.value, context.platform, this) context.job.init() context.job.printDebugInfo(context) context.job.setDisplayName(\"test\") context.job.setDescription(\"Name: ${context.application.config.name}\")</code> Gerrit(Job job, Platform platform, Script script) - Class that describes the Gerrit tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String credentialsId - Credentials Id in Jenkins for Gerrit.String autouser - Username of an auto user in Gerrit for integration with Jenkins.String host - Gerrit host.String project - the project name of the built application.String branch - branch to build an application from.String changeNumber - change number of Gerrit commit.String changeName - change name of Gerrit commit.String refspecName - refspecName of Gerrit commit.String sshPort - Gerrit ssh port number.String patchsetNumber - patchsetNumber of Gerrit commit.Methods:init(): set all the properties of Gerrit objectExample: <code>context.gerrit = new Gerrit(context.job, context.platform, this) context.gerrit.init()</code> Nexus(Job job, Platform platform, Script script) - Class that describes the Nexus tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String autouser - Username of an auto user in Nexus for integration with Jenkins.String credentialsId - Credentials Id in Jenkins for Nexus.String host - Nexus host.String port - Nexus http(s) port.String repositoriesUrl - Base URL of repositories in Nexus.String restUrl - URL of Rest API.Methods:init(): set all the properties of the Nexus object.Example:<code>context.nexus = new Nexus(context.job, context.platform, this) context.nexus.init()</code> Sonar(Job job, Platform platform, Script script) - Class that describes the Sonar tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform().Job job - Object of a class Job().String route - External route of the sonar application.Methods:init(): set all the properties of Sonar object.Example:<code>context.sonar = new Sonar(context.job, context.platform, this) context.sonar.init()</code>"},{"location":"user-guide/pipeline-framework/#build-pipeline-stages","title":"Build Pipeline Stages","text":"<p>Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific.</p> <p>The Build pipeline includes the following default stages: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Get version \u2192 Tests \u2192 Sonar \u2192 Build \u2192 Build Docker Image \u2192 Push \u2192 Git tag.</p> <p>Info</p> <p>To get the full description of every stage, please refer to the EDP Stages Framework section.</p>"},{"location":"user-guide/pipeline-framework/#how-to-redefine-or-extend-edp-pipeline-stages-library","title":"How to Redefine or Extend EDP Pipeline Stages Library","text":"<p>Inspect the points below to redefine or extend the EDP Pipeline Stages Library:</p> <ul> <li>Create a \u201cstage\u201d folder in the App repository.</li> <li>Create a Groovy file with a meaningful name for the custom stage description. For instance \u2013 CustomBuildMavenApplication.groovy</li> <li>Describe stage logic.</li> </ul> <p>Redefinition:</p> <pre><code>import com.epam.edp.stages.ProjectType\nimport com.epam.edp.stages.Stage\n@Stage(name = \"compile\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass CustomBuildMavenApplication {\nScript script\nvoid run(context) {\nscript.sh \"echo 'Your custom logic of the stage'\"\n}\n}\nreturn CustomBuildMavenApplication\n</code></pre> <p>Extension:</p> <pre><code>import com.epam.edp.stages.ProjectType\nimport com.epam.edp.stages.Stage\n@Stage(name = \"new-stage\", buildTool = \"maven\", type = ProjectType.APPLICATION)\nclass NewStageMavenApplication {\nScript script\nvoid run(context) {\nscript.sh \"echo 'Your custom logic of the stage'\"\n}\n}\nreturn NewStageMavenApplication\n</code></pre>"},{"location":"user-guide/pipeline-framework/#using-edp-stages-library-in-the-pipeline_1","title":"Using EDP Stages Library in the Pipeline","text":"<p>In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following:</p> <ul> <li>import library - @Library(['edp-library-stages'])</li> <li>import StageFactory class - import com.epam.edp.stages.StageFactory</li> <li>define context Map \u2013 context = [:]</li> <li>define stagesFactory instance and load EDP stages:</li> </ul> <pre><code>context.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n</code></pre> <p>After that, there is the ability to run any EDP stage beforehand by defining a requirement context <code>context.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)</code></p> <p>For instance, the pipeline can look like:</p> <pre><code>@Library(['edp-library-stages']) _\n\nimport com.epam.edp.stages.StageFactory\nimport org.apache.commons.lang.RandomStringUtils\n\ncontext = [:]\n\nnode('maven') {\ncontext.workDir = new File(\"/tmp/${RandomStringUtils.random(10, true, true)}\")\ncontext.workDir.deleteDir()\n\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.gerrit = [:]\ncontext.application = [:]\ncontext.application.config = [:]\ncontext.buildTool = [:]\ncontext.nexus = [:]\n\n\n\nstage(\"checkout\") {\ncontext.gerrit.branch = \"master\"\ncontext.gerrit.credentialsId = \"jenkins\"\ncontext.application.config.cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\"\ncontext.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)\n}\n\n\nstage(\"compile\") {\ncontext.buildTool.command = \"mvn\"\ncontext.nexus.credentialsId = \"nexus\"\ncontext.factory.getStage(\"compile\",\"maven\",\"application\").run(context)\n}\n}\n</code></pre> <p>Or in a declarative way:</p> <pre><code>@Library(['edp-library-stages']) _\n\nimport com.epam.edp.stages.StageFactory\nimport org.apache.commons.lang.RandomStringUtils\n\ncontext = [:]\n\npipeline {\nagent { label 'maven' }\nstages {\nstage('Init'){\nsteps {\nscript {\ncontext.workDir = new File(\"/tmp/${RandomStringUtils.random(10, true, true)}\")\ncontext.workDir.deleteDir()\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.gerrit = [:]\ncontext.application = [:]\ncontext.application.config = [:]\ncontext.buildTool = [:]\ncontext.nexus = [:]\n}\n}\n}\n\nstage(\"Checkout\") {\nsteps {\nscript {\ncontext.gerrit.branch = \"master\"\ncontext.gerrit.credentialsId = \"jenkins\"\ncontext.application.config.cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\"\ncontext.factory.getStage(\"checkout\",\"maven\",\"application\").run(context)\n}\n}\n}\n\nstage('Compile') {\nsteps {\nscript {\ncontext.buildTool.command = \"mvn\"\ncontext.nexus.credentialsId = \"nexus\"\ncontext.factory.getStage(\"compile\",\"maven\",\"application\").run(context)\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"user-guide/pipeline-framework/#edp-library-stages-description","title":"EDP Library Stages Description","text":"<p>Using in pipelines - @Library(['edp-library-stages@version'])</p> <p>The corresponding enums, classes, interfaces and their methods can be used separately from the EDP Stages library function (please refer to Table 5).</p> <p>Table 5.  Enums and Classes with the respective properties, methods, and examples.</p> Enums Classes ProjectType: - APPLICATION  - AUTOTESTS  - LIBRARY StageFactory() - Class that contains methods getting an implementation of the particular stage either EDP from shared library or custom from application repository.Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Map stages - Map of stages implementations.Methods:loadEdpStages(): return a list of Classes that describes EDP stages implementations.loadCustomStages(String directory): return a list of Classes that describes EDP custom stages from application repository from \"directory\". The \"directory\" should have an absolute path to files with classes of custom stages implementations. Should be run from a Jenkins agent.add(Class clazz): register class for some particular stage in stages map of StageFactory class.getStage(String name, String buildTool, String type): return an object of the class for a particular stage from stages property based on stage name and buildTool, type of application.Example:<code>context.factory = new StageFactory(script: this)</code><code>context.factory.loadEdpStages().each() { context.factory.add(it) }</code><code>context.factory.loadCustomStages(\"${context.workDir}/stages\").each() { context.factory.add(it) }</code><code>context.factory.getStage(stageName.toLowerCase(),context.application.config.build_tool.toLowerCase(),</code><code>context.application.config.type).run(context)</code>"},{"location":"user-guide/pipeline-framework/#edp-stages-framework","title":"EDP Stages Framework","text":"<p>Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific.</p> <p>Inspect the Table 6 and Table 7 that contain the full description of every stage that can be included in Code Review and Build pipelines: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Get version \u2192 Tests \u2192 Sonar \u2192 Build \u2192 Build Docker Image \u2192 Push \u2192 Git tag.</p> <p>Table 6.  The Checkout, Gerrit Checkout, Compile, Get version, and Tests stages description.</p> Checkout Gerrit Checkout Compile Get version Tests name = \"checkout\",buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- StageFactory context.factory- String context.gerrit.branch- String context.gerrit.credentialsId- String context.application.config.cloneUrl name = \"gerrit-checkout\",buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"]type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]context required:- String context.workDir- StageFactory context.factory- String context.gerrit.changeName- String context.gerrit.refspecName- String context.gerrit.credentialsId- String context.application.config.cloneUrl name = \"compile\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.sln_filenameoutput:- String context.buildTool.sln_filenamebuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.command- String context.nexus.credentialsIdbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.command- String context.nexus.credentialsIdbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.groupRepository name = \"get-version\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- Map(empty) context.application- String context.gerrit.branch- Job context.joboutput:-String context.application.deplyableModule- String context.application.deplyableModuleDir- String context.application.version- String context.application.buildVersionbuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.command- Job context.job- String context.gerrit.branchoutput:- String context.application.deplyableModuleDir- String context.application.version- String context.application.buildVersionbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.command- Job context.job- String context.gerrit.branchoutput:- String context.application.deplyableModule- String context.application.deplyableModuleDir- String context.application.version- String context.application.buildVersionbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- Job context.job- String context.gerrit.branchoutput:- String context.application.deplyableModuleDir- String context.application.version- String context.application.buildVersion name = \"tests\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDirbuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.commandbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.commandtype = [ProjectType.AUTOTESTS]context required:- String context.workDir- String context.buildTool.command- String context.application.config.report_frameworkbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir <p>Table 7.  The Sonar, Build, Build Docker Image, Push, and Git tag stages description.</p> Sonar Build Build Docker Image Push Git tag name = \"sonar\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.job.type- String context.application.name- String context.buildTool.sln_filename- String context.sonar.route- String context.gerrit.changeName(Only for codereview pipeline)- String context.gerrit.branch(Only for build pipeline)buildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.job.type- String context.nexus.credentialsId- String context.buildTool.command- String context.application.name- String context.sonarRoute- String context.gerrit.changeName(Only for codereview pipeline)- String context.gerrit.branch(Only for build pipeline)buildTool = [\"maven\"]type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]context required:- String context.workDir- String context.job.type- String context.nexus.credentialsId- String context.application.name- String context.buildTool.command- String context.sonar.route- String context.gerrit.changeName(Only for codereview pipeline)- String context.gerrit.branch(Only for build pipeline)buildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.job.type- String context.sonar.route- String context.application.name- String context.gerrit.changeName(Only for codereview pipeline)- String context.gerrit.branch(Only for build pipeline) name = \"build\"buildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.command- String context.nexus.credentialsIdbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.buildTool.command- String context.nexus.credentialsIdbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.groupRepository name = \"build-image\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.application.deployableModule- String context.application.deployableModuleDir- String context.application.name- String context.application.config.language- String context.application.buildVersion- Boolean context.job.promoteImages- String context.job.envToPromotebuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.application.deployableModule- String context.application.deployableModuleDir- String context.application.name- String context.application.config.language- String context.application.buildVersion- Boolean context.job.promoteImages- String context.job.envToPromotebuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.application.deployableModule- String context.application.deployableModuleDir- String context.application.name- String context.application.config.language- String context.application.buildVersion- Boolean context.job.promoteImages- String context.job.envToPromotebuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.application.deployableModule- String context.application.deployableModuleDir- String context.application.name- String context.application.config.language- String context.application.buildVersion- Boolean context.job.promoteImages- String context.job.envToPromote name = \"push\"buildTool = [\"dotnet\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.gerrit.project- String context.buildTool.sln_filename- String context.buildTool.snugetApiKey- String context.buildTool.hostedRepositorybuildTool = [\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.application.version- String context.buildTool.hostedRepository- String context. buildTool.settingsbuildTool = [\"maven\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.application.version- String context.buildTool.hostedRepository- String context.buildTool.commandbuildTool = [\"npm\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.nexus.credentialsId- String context.buildTool.hostedRepository- String context.gerrit.autouser name = \"git-tag\"buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"]type = [ProjectType.APPLICATION]context required:- String context.workDir- String context.gerrit.credentialsId- String context.gerrit.sshPort- String context.gerrit.host- String context.gerrit.autouser- String context.application.buildVersion"},{"location":"user-guide/pipeline-framework/#deploy-pipeline","title":"Deploy Pipeline","text":"<p>Deploy() \u2013 a function that allows using the EDP implementation for the deploy pipeline. All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context.</p> <p>The deploy pipeline consists of several steps:</p> <p>On the master:</p> <ul> <li>Initialization of all objects (Platform, Job, Gerrit, Nexus, StageFactory) and loading the default implementations of EDP stages;</li> <li>Creating an environment if it doesn`t exist;</li> <li>Deploying the last versions of the applications;</li> <li>Run predefined manual gates.</li> </ul> <p>On a particular autotest Jenkins agent that depends on the build tool:</p> <ul> <li>Creating workdir for autotest sources;</li> <li>Run predefined autotests.</li> </ul>"},{"location":"user-guide/pipeline-framework/#edp-library-pipelines-description","title":"EDP Library Pipelines Description","text":"<p>_Using in pipelines - @Library(['edp-library-pipelines@version']) _</p> <p>The corresponding enums and interfaces with their methods can be used separately from the EDP Pipelines library function (please refer to Table 8 and Table 9).</p> <p>Table 8.  Enums and Interfaces with the respective properties, methods, and examples.</p> <p> Enums Interfaces PlatformType:- OPENSHIFT- KUBERNETESJobType:- CODEREVIEW- BUILD- DEPLOYBuildToolType:- MAVEN- GRADLE- NPM- DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported.Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Methods:getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example: <code>context.platform.getJsonPathValue(\"cm\",\"project-settings\",</code><code>\".data.username\")</code> BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. (Should be invoked on Jenkins build agents)Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus.Methods:init: return parameters of buildTool that are needed for running stages. Example:<code>context.buildTool = new BuildToolFactory().getBuildToolImpl</code><code>(context.application.config.build_tool, this, context.nexus)</code><code>context.buildTool.init()</code> <p> Table 9.  Classes with the respective properties, methods, and examples.</p> Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting implementation of CLI of platform. At the moment OpenShift and Kubernetes are supported. Methods:getPlatformImpl(PlatformType platform, Script script): return Class PlatformExample: <code>context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)</code> Application(String name, Platform platform, Script script) - Class that describe the application object. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform()String name - Name for the application for creating objectMap config - Map of configuration settings for particular application that is loaded from config map project-settingsString version - Application version, initially empty. Is set on get-version step.String deployableModule - The name of deployable module for multi module applications, initially empty.String buildVersion - Version of built artifact, contains build number of Job initially emptyString deployableModuleDir - The name of deployable module directory for multi module applications, initially empty.Array imageBuildArgs - List of arguments for building application Docker imageMethods: setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config mapExample: <code>context.application = new Application(context.job, context.gerrit.project, context.platform, this)</code> <code>context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project)</code> Job(type: JobType.value, platform: Platform, script: Script) - Class that describe the Gerrit tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\"Platform platform - Object of a class Platform().JobType.value type.String deployTemplatesDirectory - The name of the directory in application repository, where deploy templates are located. Can be set for particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter.String edpName - The name of the EDP Project.Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable.String envToPromote - The name of the environment for promoting images.Boolean promoteImages - Defines whether images should be promoted or not. Methods:getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to existing description of the Jenkins job. printDebugInfo(Map context): print context info to log of Jenkins job. runStage(String stage_name, Map context): run the particular stage according to its name. Example: <code>context.job = new Job(JobType.DEPLOY.value, context.platform, this)</code> <code>context.job.init()</code> <code>context.job.printDebugInfo(context)</code> <code>context.job.setDisplayName(\"test\")</code> <code>context.job.setDescription(\"Name: ${context.application.config.name}\")</code> Gerrit(Job job, Platform platform, Script script) - Class that describe the Gerrit tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\".Platform platform - Object of a class Platform(). Job job - Object of a class Job().String credentialsId - Credential Id in Jenkins for Gerrit. String autouser - Username of autouser in Gerrit for integration with Jenkins. String host - Gerrit host. String project - project name of built application. String branch - branch to build application from. String changeNumber - change number of Gerrit commit. String changeName - change name of Gerrit commit. String refspecName - refspecName of Gerrit commit. String sshPort - gerrit ssh port number. String patchsetNumber - patchsetNumber of Gerrit commit.Methods:init(): set all the properties of Gerrit object. Example:<code>context.gerrit = new Gerrit(context.job, context.platform, this)</code><code>context.gerrit.init()</code>. Nexus(Job job, Platform platform, Script script) - Class that describe the Nexus tool. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String autouser - Username of autouser in Nexus for integration with Jenkins. String credentialsId - Credential Id in Jenkins for Nexus. String host - Nexus host. String port - Nexus http(s) port. String repositoriesUrl - Base URL of repositories in Nexus. String restUrl - URL of Rest API. Methods:init(): set all the properties of Nexus object. Example: <code>context.nexus = new Nexus(context.job, context.platform, this)</code> <code>context.nexus.init()</code>."},{"location":"user-guide/pipeline-framework/#edp-library-stages-description_1","title":"EDP Library Stages Description","text":"<p>Using in pipelines - @Library(['edp-library-stages@version']) _</p> <p>The corresponding classes with methods can be used separately from the EDP Pipelines library function (please refer to Table 10).</p> <p>Table 10.  Classes with the respective properties, methods, and examples.</p> Classes Description (properties, methods, and examples) StageFactory() - Class that contains methods getting implementation of particular stage either EDP from shared library or custom from application repository. Properties:Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\"Map stages - Map of stages implementationsMethods:loadEdpStages(): return list of Classes that describes EDP stages implementationsloadCustomStages(String directory): return list of Classes that describes EDP custom stages from application repository from \"directory\". The \"directory\" should be absolute path to files with classes of custom stages implementations. Should be run from Jenkins agent.add(Class clazz): register class for some particular stage in stages map of StageFactory classgetStage(String name, String buildTool, String type): return object of the class for particular stage from stages property based on stage name and buildTool, type of applicationExample:<code>context.factory = new StageFactory(script: this)</code><code>context.factory.loadEdpStages().each() { context.factory.add(it) }</code><code>context.factory.loadCustomStages(\"${context.workDir}/stages\").each() { context.factory.add(it) }</code><code>context.factory.getStage(stageName.toLowerCase(),context.application.config.build_tool.toLowerCase(),</code><code>context.application.config.type).run(context)</code>."},{"location":"user-guide/pipeline-framework/#deploy-pipeline-stages","title":"Deploy Pipeline Stages","text":"<p>Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific.</p> <p>The stages for the deploy pipeline are independent of the build tool and application type. Find below (see Table 11 ) the full description of every stage: Deploy \u2192 Automated tests \u2192 Promote Images.</p> <p>Table 11.  The Deploy, Automated tests, and Promote Images stages description.</p> Deploy Automated tests Promote Images name = \"deploy\"buildTool = nulltype = nullcontext required:\u2022   String context.workDir\u2022   StageFactory context.factory\u2022 String context.gerrit.autouser\u2022   String context.gerrit.host\u2022   String context.application.config.cloneUrl\u2022   String context.jenkins.token\u2022 String context.job.edpName\u2022   String context.job.buildUrl\u2022  String context.job.jenkinsUrl\u2022    String context.job.metaProject\u2022   List context.job.applicationsList [['name':'application1_name','version':'application1_version],...]\u2022 String context.job.deployTemplatesDirectoryoutput:\u2022   List context.job.updatedApplicaions [['name':'application1_name','version':'application1_version],...]   name = \"automation-tests\", buildTool = null, type = nullcontext required:- String context.workDir- StageFactory context.factory- String context.gerrit.credentialsId- String context.autotest.config.cloneUrl- String context.autotest.name- String context.job.stageWithoutPrefixName- String context.buildTool.settings- String context.autotest.config.report_framework name = \"promote-images\"buildTool = nulltype = nullcontext required:- String context.workDir- String context.buildTool.sln_filename- List context.job.updatedApplicaions [['name':'application1_name','version':'application1_version],...]"},{"location":"user-guide/pipeline-framework/#how-to-redefine-or-extend-edp-pipeline-stages-library_1","title":"How to Redefine or Extend EDP Pipeline Stages Library","text":"<p>Info</p> <p>Currently, the redefinition of Deploy pipeline stages is prohibited.</p>"},{"location":"user-guide/pipeline-framework/#using-edp-library-stages-in-the-pipeline","title":"Using EDP Library Stages in the Pipeline","text":"<p>In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following:</p> <ul> <li>import libraries - @Library(['edp-library-stages', 'edp-library-pipelines']) _</li> <li>import reference EDP classes(See example below)</li> <li>define context Map \u2013 context = [:]</li> <li>define reference \"init\" stage</li> </ul> <p>After that, there is the ability to run any EDP stage beforehand by defining requirement context <code>context.job.runStage(\"Deploy\", context)</code>.</p> <p>For instance, the pipeline can look like:</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines']) _\n\nimport com.epam.edp.stages.StageFactory\nimport com.epam.edp.platform.PlatformFactory\nimport com.epam.edp.platform.PlatformType\nimport com.epam.edp.JobType\n\ncontext = [:]\n\nnode('master') {\nstage(\"Init\") {\ncontext.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)\ncontext.job = new com.epam.edp.Job(JobType.DEPLOY.value, context.platform, this)\ncontext.job.init()\ncontext.job.initDeployJob()\nprintln(\"[JENKINS][DEBUG] Created object job with type - ${context.job.type}\")\n\ncontext.nexus = new com.epam.edp.Nexus(context.job, context.platform, this)\ncontext.nexus.init()\n\ncontext.jenkins = new com.epam.edp.Jenkins(context.job, context.platform, this)\ncontext.jenkins.init()\n\ncontext.gerrit = new com.epam.edp.Gerrit(context.job, context.platform, this)\ncontext.gerrit.init()\n\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.environment = new com.epam.edp.Environment(context.job.deployProject, context.platform, this)\ncontext.job.printDebugInfo(context)\ncontext.job.setDisplayName(\"${currentBuild.displayName}-${context.job.deployProject}\")\n\ncontext.job.generateInputDataForDeployJob()\n}\n\nstage(\"Pre Deploy Custom stage\") {\nprintln(\"Some custom pre deploy logic\")\n}\n\ncontext.job.runStage(\"Deploy\", context)\n\nstage(\"Post Deploy Custom stage\") {\nprintln(\"Some custom post deploy logic\")\n}\n}\n</code></pre> <p>Or in a declarative way:</p> <pre><code>@Library(['edp-library-stages', 'edp-library-pipelines']) _\n\nimport com.epam.edp.stages.StageFactory\nimport com.epam.edp.platform.PlatformFactory\nimport com.epam.edp.platform.PlatformType\nimport com.epam.edp.JobType\n\ncontext = [:]\n\npipeline {\nagent { label 'master'}\nstages {\nstage('Init') {\nsteps {\nscript {\ncontext.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this)\ncontext.job = new com.epam.edp.Job(JobType.DEPLOY.value, context.platform, this)\ncontext.job.init()\ncontext.job.initDeployJob()\nprintln(\"[JENKINS][DEBUG] Created object job with type - ${context.job.type}\")\n\ncontext.nexus = new com.epam.edp.Nexus(context.job, context.platform, this)\ncontext.nexus.init()\n\ncontext.jenkins = new com.epam.edp.Jenkins(context.job, context.platform, this)\ncontext.jenkins.init()\n\ncontext.gerrit = new com.epam.edp.Gerrit(context.job, context.platform, this)\ncontext.gerrit.init()\n\ncontext.factory = new StageFactory(script: this)\ncontext.factory.loadEdpStages().each() { context.factory.add(it) }\n\ncontext.environment = new com.epam.edp.Environment(context.job.deployProject, context.platform, this)\ncontext.job.printDebugInfo(context)\ncontext.job.setDisplayName(\"${currentBuild.displayName}-${context.job.deployProject}\")\n\ncontext.job.generateInputDataForDeployJob()\n}\n}\n}\nstage('Deploy') {\nsteps {\nscript {\ncontext.factory.getStage(\"deploy\").run(context)\n}\n}\n}\n\nstage('Custom stage') {\nsteps {\nprintln(\"Some custom logic\")\n}\n}\n}\n}\n</code></pre>"},{"location":"user-guide/pipeline-framework/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add Library</li> <li>Add CD Pipeline</li> <li>CI Pipeline Details</li> <li>CD Pipeline Details</li> <li>Customize CI Pipeline</li> <li>Customize CD Pipeline</li> <li>EDP Stages</li> <li>Glossary</li> <li>Use Terraform Library in EDP</li> </ul>"},{"location":"user-guide/pipeline-stages/","title":"Pipeline Stages","text":"<p>Get acquainted with EDP CI/CD workflow and stages description.</p>"},{"location":"user-guide/pipeline-stages/#edp-cicd-workflow","title":"EDP CI/CD Workflow","text":"<p>Within EDP, the pipeline framework comprises the following pipelines:</p> <ul> <li>Code Review;</li> <li>Build;</li> <li>Deploy.</li> </ul> <p>Note</p> <p>Please refer to the EDP Pipeline Framework page for details.</p> <p>The diagram below shows the delivery path through these pipelines and the respective stages. Please be aware that stages may differ for different codebase types.</p> <p> stages </p>"},{"location":"user-guide/pipeline-stages/#stages-description","title":"Stages Description","text":"<p>The table below provides the details on all the stages in the EDP pipeline framework:</p> Name Dependency Description Pipeline Application Library Autotest Source code Documentation init Initiates information gathering Create Release, Code Review, Build + + Build.groovy checkout Performs for all files the checkout from a selected branch of the Git repository. For the main branch - from HEAD, for code review - from the commit Create Release, Build + + Checkout.groovy sast Launches vulnerability testing via Semgrep scanner. Pushes a vulnerability report to the DefectDojo. Build + Security compile Compiles the code, includes individual groovy files for each type of app or lib (NPM, DotNet, Python, Maven, Gradle) Code Review, Build + + Compile tests Launches testing procedure, includes individual groovy files for each type of app or lib Code Review, Build + + + Tests sonar Launches testing via SonarQube scanner and includes individual groovy files for each type of app or lib Code Review, Build + + Sonar build Builds the application, includes individual groovy files for each type of app or lib (Go, Maven, Gradle, NPM) Code Review, Build + Build create-branch EDP create-release process Creates default branch in Gerrit during create and clone strategies Create Release + + + CreateBranch.groovy trigger-job EDP create-release process Triggers \"build\" job Create Release + + + TriggerJob.groovy gerrit-checkout Performs checkout to the current project branch in Gerrit Code Review + + + GerritCheckout.groovy commit-validate Optional in EDP Admin Console Takes Jira parameters, when \"Jira Integration\" is enabled for the project in the Admin Console. Code Review + + CommitValidate.groovy dockerfile-lint Launches linting tests for Dockerfile Code Review + LintDockerApplicationLibrary.groovy Use Dockerfile Linters for Code Review dockerbuild-verify \"Build\" stage (if there are no \"COPY\" layers in Dockerfile) Launches build procedure for Dockerfile without pushing an image to the repository Code Review + BuildDockerfileApplicationLibrary.groovy Use Dockerfile Linters for Code Review helm-lint Launches linting tests for deployment charts Code Review + LintHelmApplicationLibrary.groovy Use helm-lint for Code Review helm-docs Checks generated documentation for deployment charts Code Review + HelmDocsApplication.groovy Use helm-docs for Code Review helm-uninstall Helm release deletion step to clear Helm releases Deploy + HelmUninstall.groovy Helm release deletion semi-auto-deploy-input Provides auto deploy with timeout and manual deploy flow Deploy + SemiAutoDeployInput.groovy Semi Auto Deploy get-version Defines the versioning of the project depending on the versioning schema selected in Admin Console Build + + GetVersion terraform-plan AWS credentials added to Jenkins Checks Terraform version, and installs default version if necessary, and launches terraform init, returns AWS username which used for action, and terraform plan command is called with an output of results to .tfplan file Build + TerraformPlan.groovy Use Terraform library in EDP terraform-apply AWS credentials added to Jenkins, the \"Terraform-plan\" stage Checks Terraform version, and installs default version if necessary, and launches terraform init, launches terraform plan from saves before .tfplan file, asks to approve, and run terraform apply from .tfplan file Build + TerraformApply.groovy Use Terraform library in EDP build-image-from-dockerfile Platform: OpenShift Builds Dockerfile Build + + .groovy files for building Dockerfile image build-image-kaniko Platform: k8s Builds Dockerfile using the Kaniko tool Build + BuildImageKaniko.groovy push Pushes an artifact to the Nexus repository Build + + Push create-Jira-issue-metadata \"get-version\" stage Creates a temporary CR in the namespace and after that pushes Jira Integration data to Jira ticket, and delete CR Build + + JiraIssueMetadata.groovy ecr-to-docker DockerHub credentials added to Jenkins Copies the docker image from the ECR project registry to DockerHub via the Crane tool after it is built Build + EcrToDocker.groovy Promote Docker Images From ECR to Docker Hub git-tag \"Get-version\" stage Creates a tag in SCM for the current build Build + + GitTagApplicationLibrary.groovy deploy Deploys the application Deploy + Deploy.groovy manual Works with the manual approve to proceed Deploy + ManualApprove.groovy promote-images Promotes docker images to the registry Deploy + PromoteImage.groovy <p>Note</p> <p>The Create Release pipeline is an internal EDP mechanism for adding, importing or cloning a codebase. It is not a part of the pipeline framework.</p>"},{"location":"user-guide/pipeline-stages/#related-articles","title":"Related Articles","text":"<ul> <li>Manage Jenkins CI Job Provisioner</li> <li>GitLab Integration</li> <li>GitHub Integration</li> </ul>"},{"location":"user-guide/prepare-for-release/","title":"Prepare for Release","text":"<p>After the necessary applications are added to EDP, they can be managed via the Admin Console. To prepare for the release, create a new branch from a selected commit with a set of CI pipelines (Code Review and Build pipelines), launch the Build pipeline, and add a new CD pipeline as well.</p> <p>Note</p> <p>Please refer to the Add Application and Add CD Pipeline for the details on how to add an application or a CD pipeline.</p> <p>Become familiar with the following preparation steps for release and a CD pipeline structure:</p> <ul> <li>Create a new branch</li> <li>Launch the Build pipeline</li> <li>Add a new CD pipeline</li> <li>Check CD pipeline structure</li> </ul>"},{"location":"user-guide/prepare-for-release/#create-a-new-branch","title":"Create a New Branch","text":"<ol> <li> <p>Open Gerrit via the Admin Console Overview page to have this tab available in a web browser.</p> </li> <li> <p>Being in Admin Console, open the Applications section and click an application from the list to create a new branch.</p> </li> <li> <p>Once clicked the application name, scroll down to the Branches menu and click the Create button to open the Create New Branch dialog box, fill in the Branch Name field by typing a branch name.</p> <ul> <li>Open the Gerrit tab in the web browser, navigate to Projects \u2192 List \u2192 select the application \u2192 Branches \u2192 gitweb for a necessary branch.</li> </ul> <ul> <li>Select the commit that will be the last included to a new branch commit.</li> </ul> <ul> <li>Copy to clipboard the commit hash.</li> </ul> </li> <li> <p>Paste the copied hash to the From Commit Hash field and click Proceed.</p> </li> </ol> <p>Note</p> <p>If the commit hash is not added to the From Commit Hash field, the new branch will be created from the head of the master branch.</p>"},{"location":"user-guide/prepare-for-release/#launch-the-build-pipeline","title":"Launch the Build Pipeline","text":"<ol> <li> <p>After the new branches are added, open the details page of every application and click the CI link that refers to Jenkins.</p> <p>Note</p> <p>The adding of a new branch may take some time. As soon as the new branch is created, it will be displayed in the list of the Branches menu.</p> </li> <li> <p>To build a new version of a corresponding Docker container (an image stream in OpenShift terms) for the new branch, start the Build pipeline. Being in Jenkins, select the new branch tab and click the link to the Build pipeline.</p> </li> <li> <p>Navigate to the Build with Parameters option and click the Build button to launch the Build pipeline.</p> <p>Warning</p> <p>The predefined default parameters should not be changed when triggering the Build pipeline, otherwise, it will lead to the pipeline failure.</p> </li> </ol>"},{"location":"user-guide/prepare-for-release/#add-a-new-cd-pipeline","title":"Add a New CD Pipeline","text":"<ol> <li> <p>Add a new CD pipeline and indicate the new release branch using the Admin console tool. Pay attention to the Applications menu, the necessary application(s) should be selected there, as well as the necessary branch(es) from the drop-down list.</p> <p>Note</p> <p>For the details on how to add a CD pipeline, please refer to the Add CD Pipeline page.</p> </li> <li> <p>As soon as the Build pipelines are successfully passed in Jenkins, the Docker Registry, which is used in EDP by default, will have the new image streams (Docker container in Kubernetes terms) version that corresponds to the current branch.</p> </li> <li> <p>Open the Kubernetes/OpenShift page of the project via the Admin Console Overview page \u2192 go to CodebaseImageStream (in OpenShift, go to Builds \u2192 Images) \u2192 check whether the image streams are created under the specific name (the combination of the application and branch names) and the specific tags are added. Click every image stream link.</p> </li> </ol>"},{"location":"user-guide/prepare-for-release/#check-cd-pipeline-structure","title":"Check CD Pipeline Structure","text":"<p>When the CD pipeline is added through the Admin Console, it becomes available in the CD pipelines list. Every pipeline has the details page with the additional information. To explore the CD pipeline structure, follow the steps below:</p> <ol> <li> <p>Open Admin Console and navigate to Continuous Delivery section, click the newly created CD pipeline name.</p> </li> <li> <p>Discover the CD pipeline components:</p> <ul> <li>Applications - the list of applications with the image streams and links to Jenkins for the respective branch;</li> </ul> <ul> <li>Stages - a set of stages with the defined characteristics and links to Kubernetes/OpenShift project;</li> </ul> <p>Note</p> <p>Initially, an environment is empty and does not have any deployment unit. When deploying the subsequent stages, the artifacts of the selected versions will be deployed to the current project and the environment will display the current stage status. The project has a standard pattern: \u2039edp-name\u203a-\u2039pipeline-name\u203a-\u2039stage-name\u203a.</p> <ul> <li>Deployed Versions - the deployment status of the specific application and the predefined stage.</li> </ul> </li> </ol>"},{"location":"user-guide/prepare-for-release/#launch-cd-pipeline-manually","title":"Launch CD Pipeline Manually","text":"<p>Follow the steps below to deploy the QA and UAT application stages:</p> <ol> <li> <p>As soon as the Build pipelines for both applications are successfully passed, the new version of the Docker container will appear, thus allowing to launch the CD pipeline. Simply navigate to Continuous Delivery and click the pipeline name to open it in Jenkins.</p> </li> <li> <p>Click the QA stage link.</p> </li> <li> <p>Deploy the QA stage by clicking the Build Now option.</p> </li> <li> <p>After the initialization step starts, in case another menu is opened, the Pause for Input option will appear. Select the application version in the drop-down list and click Proceed. The pipeline passes the following stages:</p> <ul> <li>Init - initialization of the Jenkins pipeline outputs with the stages that are the Groovy scripts that execute the current code;</li> <li>Deploy - the deployment of the selected versions of the docker container and third-party services. As soon as the Deployed pipeline stage is completed, the respective environment will be deployed.</li> <li>Approve - the verification stage that enables to Proceed or Abort this stage;</li> <li>Promote-images - the creation of the new image streams for the current versions with the pattern combination: [pipeline name]-[stage name]-[application name]-[verified];</li> </ul> <p>After all the stages are passed, the new image streams will be created in the Kubernetes/OpenShift with the new names.</p> </li> <li> <p>Deploy the UAT stage, which takes the versions that were verified during the QA stage, by clicking the Build Now option, and select the necessary application versions. The launch process is the same as for all the deploy pipelines.</p> </li> <li> <p>To get the status of the pipeline deployment, open the CD pipeline details page and check the Deployed versions state.</p> </li> </ol>"},{"location":"user-guide/prepare-for-release/#cd-pipeline-as-a-team-environment","title":"CD Pipeline as a Team Environment","text":"<p>Admin Console allows creating a CD pipeline with a part of the application set as a team environment. To do this, perform the following steps;</p> <ol> <li>Open the Continuous Delivery section \u2192 click the Create button \u2192 enter the pipeline name (e.g. team-a) \u2192 select ONE application and choose the master branch for it \u2192 add one DEV stage.</li> <li>As soon as the CD pipeline is added to the CD pipelines list, its details page will display the links to Jenkins and Kubernetes/OpenShift.</li> <li>Open Jenkins and deploy the DEV stage by clicking the Build Now option.</li> <li>Kubernetes/OpenShift keeps an independent environment that allows checking the new versions, thus speeding up the developing process when working with several microservices.</li> </ol> <p>As a result, the team will have the same abilities to verify the code changes when developing and during the release.</p>"},{"location":"user-guide/prepare-for-release/#related-articles","title":"Related Articles","text":"<ul> <li>Add Application</li> <li>Add CD Pipeline</li> <li>Autotest as Qulity Gate</li> <li>Build Pipeline</li> <li>CD Pipeline Details</li> <li>Customize CD Pipeline</li> </ul>"},{"location":"user-guide/semi-auto-deploy/","title":"Semi Auto Deploy","text":"<p>The Semi Auto Deploy stage provides the ability to deploy applications with the custom logic that comprises the following behavior:</p> <ul> <li>When the build of an application selected for deploy in the CD pipeline is completed, the Deploy pipeline is automatically triggered;</li> <li>By default, the deploy stage waits for 5 minutes, and if the user does not interfere with the process (cancels or selects certain versions of the application to deploy), then the deploy stage will deploy the latest versions of all applications;</li> <li>The stage can be used in the manual mode.</li> </ul> <p>To enable the Semi Auto Deploy stage during the deploy process, follow the steps below:</p> <ol> <li>Create or update the CD pipeline: make sure the trigger type for the stage is set to auto.</li> <li>Replace the <code>{\"name\":\"auto-deploy-input\",\"step_name\":\"auto-deploy-input\"}</code> step to the <code>{\"name\":\"semi-auto-deploy-input\",\"step_name\":\"semi-auto-deploy-input\"}</code> step in the CD pipeline. Alternatively, it is possible to create a custom job provisioner with this step.</li> <li>Run the Build pipeline for any application selected in the CD pipeline.</li> </ol>"},{"location":"user-guide/semi-auto-deploy/#exceptional-cases","title":"Exceptional Cases","text":"<p>After the timeout starts and in case the pipeline has been interrupted not from the Input requested menu, the automatic deployment will be proceeding. To resolve the issue and stop the pipeline, click the Input requested menu -&gt; Abort or being on the pipeline UI, click the Abort button.</p>"},{"location":"user-guide/semi-auto-deploy/#related-articles","title":"Related Articles","text":"<ul> <li>Add CD Pipeline</li> <li>Customize CD Pipeline</li> <li>Manage Jenkins CD Pipeline Job Provisioner</li> </ul>"},{"location":"user-guide/terraform-stages/","title":"CI Pipeline for Terraform","text":"<p>EPAM Delivery Platform ensures the implemented Terraform support allowing to work with Terraform code that is processed by means of stages in the Code-Review and Build pipelines. These pipelines are expected to be created after the Terraform Library is added.</p>"},{"location":"user-guide/terraform-stages/#code-review-pipeline-stages","title":"Code Review Pipeline Stages","text":"<p>In the Code Review pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository.</p> </li> <li> <p>terraform-lint stage containing a script that performs the following actions:</p> <p>2.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager.</p> <p>2.2. Launches the terraform init command that initializes backend.</p> <p>2.3. Launches the linters described below. Pay attention that if at least one of these checks is not true (returns with an error), the Code Review pipeline will fail on this step and will be displayed in red.</p> <p>* terraform fmt linter checks the formatting of the Terraform code;</p> <p>* tflint linter checks Terraform linters for possible errors and deprecated syntax;</p> <p>* terraform validate linter validates the Terraform code.</p> </li> </ol>"},{"location":"user-guide/terraform-stages/#build-pipeline-stages","title":"Build Pipeline Stages","text":"<p>In the Build pipeline, the following stages are available:</p> <ol> <li> <p>checkout stage is a standard step during which all files are checked out from a master branch of Git repository.</p> <p>Note</p> <p>With the default versioning, in the base directory of the project, create a file named 'VERSION' with a proper Terraform version (e.g.1.0.0).</p> </li> <li> <p>terraform-lint stage containing a script that performs the same actions as in the Code Review pipeline, namely:</p> <p>2.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager.</p> <p>2.2. Launches the terraform init stage that initializes backend.</p> <p>2.3. Launches the linters described below. Pay attention that if at least one of these checks is not true (returns with an error), the Build pipeline will fail on this step and will be displayed in red.</p> <p>- terraform fmt linter checks the formatting of the Terraform code;</p> <p>- tflint linter checks Terraform linters for possible errors and deprecated syntax;</p> <p>- terraform validate linter validates the Terraform code.</p> </li> <li> <p>terraform-plan stage containing a script that performs the following actions:</p> <p>3.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager.</p> <p>3.2. Launches the terraform init command that initializes backend.</p> <p>3.3. Returns the name of the user, on behalf of whom the actions will be performed, with the help of aws.</p> <p>3.4. Launches the terraform-plan command saving the results in the .tfplan file.</p> <p>Note</p> <p>EDP expects AWS credentials to be added in Jenkins under the name aws.user. To learn how to create credentials for the terraform-plan and terraform-apply stages, see the section Create AWS Credentials.</p> </li> <li> <p>terraform-apply stage containing a script that performs the following actions:</p> <p>4.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager.</p> <p>4.2. Launches the terraform init command that initializes backend.</p> <p>4.3. Launches the terraform-plan command saving the results in the tfplan file.</p> <p>4.4. Approves the application of Terraform code in your project by manually clicking the Proceed button. To decline the Terraform code, click the Abort button. If none of the buttons is selected within 30 minutes, by default the terraform-plan command will not be applied.</p> <p>4.5. Launches the terraform-apply command.</p> </li> </ol>"},{"location":"user-guide/terraform-stages/#create-aws-credentials","title":"Create AWS Credentials","text":"<p>To create credentials that will be used in terraform-plan and terraform-apply stages, perform the following steps:</p> <p>1. Go to Jenkins -&gt; Manage Jenkins -&gt; Manage Credentials. In the Store scoped to Jenkins section select global as Domains.     Jenkins credential </p> <p>2. Click the Add Credentials tab and select AWS Credentials in the Kind dropdown.     Jenkins credential </p> <p>3. Enter the ID name. By default, EDP expects AWS credentials to be under the ID aws.user.</p> <p>4. Enter values into the Access Key ID and Secret Access Key fields (credentials should belong to a user in AWS).</p> <p>5. Click OK to save these credentials. Now the ID of the credentials is visible in the Global credentials table in Jenkins.</p>"},{"location":"user-guide/terraform-stages/#use-existing-aws-credentials","title":"Use Existing AWS Credentials","text":"<p>To use other existing credentials (e.g. from other accounts) instead of the expected ones in the Build pipeline and in the terraform-plan and terraform-apply stages, perform the following steps:</p> <ol> <li> <p>Navigate to the Build pipeline and select the Configure tab.</p> </li> <li> <p>Click the Add Parameter button and select the String Parameter option.   Add string parameter </p> </li> <li> <p>Fill in the respective fields with the variable name AWS_CREDENTIALS, description, and the default value (e.g.,aws.user, used previously in pipelines).   Set value </p> </li> </ol> <p>Now during the launch of the Build pipeline, it is possible to select the desired credentials, added in Jenkins, in the AWS_CREDENTIALS field of the Build pipeline settings.</p>"},{"location":"user-guide/terraform-stages/#related-articles","title":"Related Articles","text":"<ul> <li>EDP Pipeline Framework</li> <li>Associate IAM Roles With Service Accounts</li> </ul>"}]}