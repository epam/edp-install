{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EPAM Delivery Platform \u2693\ufe0e What It Is \u2693\ufe0e EPAM Delivery platform (EDP) is an open-source cloud-agnostic SaaS/PaaS solution for software development, licensed under Apache License 2.0 . It provides a pre-defined set of CI/CD patterns and tools, which allow a user to start product development quickly with established code review , release , versioning , branching , build processes. These processes include static code analysis, security checks, linters, validators, dynamic feature environments provisioning. EDP consolidates the top Open-Source CI/CD tools by running them on Kubernetes/OpenShift, which enables web/app development either in isolated (on-prem) or cloud environments. EPAM Delivery Platform, which is also called \"The Rocket\" , is a platform that allows shortening the time that is passed before an active development can be started from several months to several hours. EDP consists of the following: The platform based on managed infrastructure and container orchestration Security covering authentication, authorization, and SSO for platform services Development and testing toolset Well-established engineering process and EPAM practices (EngX) reflected in CI/CD pipelines, and delivery analytics Local development with debug capabilities Features \u2693\ufe0e Deployed and configured CI/CD toolset ( Jenkins , Gerrit , Nexus , SonarQube ) Gerrit , GitLab or GitHub as a version control system for your code Jenkins is a pipeline orchestrator CI pipelines for Python, Java 8, Java 11, .Net, Go, React, Terraform, Jenkins Groovy Pipelines, Dockerfile, Helm Build tools: Go, Apache Maven, Apache Gradle Admin Console UI as a single entry point CD pipeline for Microservice Deployment Kubernetes native approach ( CRD, CR ) to declare CI/CD pipelines What's Inside \u2693\ufe0e EPAM Delivery Platform (EDP) is suitable for all aspects of delivery starting from development including the capability to deploy production environment. EDP architecture is represented on a diagram below. EDP consists of three cross-cutting concerns: Infrastructure as a Service; Container orchestration and centralized services; Security. On the top of these indicated concerns, EDP adds several blocks that include: EDP CI/CD Components . EDP component enables a feature in CI/CD or an instance artifacts storage and distribution (Nexus or Artifactory), static code analysis (Sonar), etc.; EDP Artifacts . This element represents an artifact that is being delivered through EDP and presented as a code. Artifact samples: frontend, backend, mobile, applications, functional and non-functional autotests, workloads for 3rd party components that can be deployed together with applications. EDP development and production environments that share the same logic. Environments wrap a set of artifacts with a specific version, and allow performing SDLC routines in order to be sure of the artifacts quality; Pipelines . Pipelines cover CI/CD process, production rollout and updates. They also connect three elements indicated above via automation allowing SDLC routines to be non-human; Technology Stack \u2693\ufe0e Explore the EDP technology stack diagram The EDP IaaS layer supports most popular public clouds AWS, Azure and GCP keeping the capability to be deployed on private/hybrid clouds based on OpenStack. EDP containers are based on Docker technology , orchestrated by Kubernetes compatible solutions. There are two main options for Kubernetes provided by EDP: Managed Kubernetes in Public Clouds to avoid installation and management of Kubernetes cluster, and get all benefits of scaling, reliability of this solution; OpenShift that is a Platform as a Service on the top of Kubernetes from Red Hat. OpenShift is the default option for on-premise installation and it can be considered whether the solution built on the top of EDP should be cloud-agnostic or require enterprise support ; There is no limitation to run EDP on vanilla Kubernetes. Note To get accurate information about EDP architecture, please refer to the EDP Architecture page.","title":"Overview"},{"location":"#epam-delivery-platform","text":"","title":"EPAM Delivery Platform"},{"location":"#what-it-is","text":"EPAM Delivery platform (EDP) is an open-source cloud-agnostic SaaS/PaaS solution for software development, licensed under Apache License 2.0 . It provides a pre-defined set of CI/CD patterns and tools, which allow a user to start product development quickly with established code review , release , versioning , branching , build processes. These processes include static code analysis, security checks, linters, validators, dynamic feature environments provisioning. EDP consolidates the top Open-Source CI/CD tools by running them on Kubernetes/OpenShift, which enables web/app development either in isolated (on-prem) or cloud environments. EPAM Delivery Platform, which is also called \"The Rocket\" , is a platform that allows shortening the time that is passed before an active development can be started from several months to several hours. EDP consists of the following: The platform based on managed infrastructure and container orchestration Security covering authentication, authorization, and SSO for platform services Development and testing toolset Well-established engineering process and EPAM practices (EngX) reflected in CI/CD pipelines, and delivery analytics Local development with debug capabilities","title":"What It Is"},{"location":"#features","text":"Deployed and configured CI/CD toolset ( Jenkins , Gerrit , Nexus , SonarQube ) Gerrit , GitLab or GitHub as a version control system for your code Jenkins is a pipeline orchestrator CI pipelines for Python, Java 8, Java 11, .Net, Go, React, Terraform, Jenkins Groovy Pipelines, Dockerfile, Helm Build tools: Go, Apache Maven, Apache Gradle Admin Console UI as a single entry point CD pipeline for Microservice Deployment Kubernetes native approach ( CRD, CR ) to declare CI/CD pipelines","title":"Features"},{"location":"#whats-inside","text":"EPAM Delivery Platform (EDP) is suitable for all aspects of delivery starting from development including the capability to deploy production environment. EDP architecture is represented on a diagram below. EDP consists of three cross-cutting concerns: Infrastructure as a Service; Container orchestration and centralized services; Security. On the top of these indicated concerns, EDP adds several blocks that include: EDP CI/CD Components . EDP component enables a feature in CI/CD or an instance artifacts storage and distribution (Nexus or Artifactory), static code analysis (Sonar), etc.; EDP Artifacts . This element represents an artifact that is being delivered through EDP and presented as a code. Artifact samples: frontend, backend, mobile, applications, functional and non-functional autotests, workloads for 3rd party components that can be deployed together with applications. EDP development and production environments that share the same logic. Environments wrap a set of artifacts with a specific version, and allow performing SDLC routines in order to be sure of the artifacts quality; Pipelines . Pipelines cover CI/CD process, production rollout and updates. They also connect three elements indicated above via automation allowing SDLC routines to be non-human;","title":"What's Inside"},{"location":"#technology-stack","text":"Explore the EDP technology stack diagram The EDP IaaS layer supports most popular public clouds AWS, Azure and GCP keeping the capability to be deployed on private/hybrid clouds based on OpenStack. EDP containers are based on Docker technology , orchestrated by Kubernetes compatible solutions. There are two main options for Kubernetes provided by EDP: Managed Kubernetes in Public Clouds to avoid installation and management of Kubernetes cluster, and get all benefits of scaling, reliability of this solution; OpenShift that is a Platform as a Service on the top of Kubernetes from Red Hat. OpenShift is the default option for on-premise installation and it can be considered whether the solution built on the top of EDP should be cloud-agnostic or require enterprise support ; There is no limitation to run EDP on vanilla Kubernetes. Note To get accurate information about EDP architecture, please refer to the EDP Architecture page.","title":"Technology Stack"},{"location":"faq/","text":"FAQ \u2693\ufe0e How Do I Set Parallel Reconciliation for a Number of Codebase Branches? \u2693\ufe0e Set the CODEBASE_BRANCH_MAX_CONCURRENT_RECONCILES Env variable in codebase-operator by updating Deployment template. For example: ... env: - name: WATCH_NAMESPACE ... - name: CODEBASE_BRANCH_MAX_CONCURRENT_RECONCILES value: 10 ... It's not recommended to set the value above 10.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#how-do-i-set-parallel-reconciliation-for-a-number-of-codebase-branches","text":"Set the CODEBASE_BRANCH_MAX_CONCURRENT_RECONCILES Env variable in codebase-operator by updating Deployment template. For example: ... env: - name: WATCH_NAMESPACE ... - name: CODEBASE_BRANCH_MAX_CONCURRENT_RECONCILES value: 10 ... It's not recommended to set the value above 10.","title":"How Do I Set Parallel Reconciliation for a Number of Codebase Branches?"},{"location":"features/","text":"Basic Concepts \u2693\ufe0e Consult EDP Glossary section for definitions mentioned on this page and EDP Toolset to have a full list of tools used with the Platform. The below table contains a full list of features provided by EDP. Features Description Cloud Agnostic EDP runs on Kubernetes cluster, so any Public Cloud Provider which provides Kubernetes can be used. Kubernetes clusters deployed on-premises work as well CI/CD for Microservices EDP is initially designed to support CI/CD for Microservices running as containerized applications inside Kubernetes Cluster. EDP also supports CI for: - Terraform Modules, - Open Policy Rules, - Workflows for Java11, JavaScript (React), .Net, Python, Groovy Pipelines, Go Version Control System (VCS) EDP installs Gerrit as a default Source Code Management (SCM) tool. EDP also supports GitHub and GitLab integration Branching Strategy EDP supports Trunk-based development as well as GitHub/GitLab flow . EDP creates two Pipelines per each codebase branch (see Pipeline Framework ): Code Review and Build Repository Structure EDP provides separate Git repository per each Codebase and doesn't work with Monorepo . However, EDP does support customization and runs helm-lint , dockerfile-lint steps using Monorepo approach. Artifacts Versioning EDP supports two approaches for Artifacts versioning: - default (BRANCH-[TECH_STACK_VERSION]-BUILD_ID) - EDP (MAJOR.MINOR.PATCH-BUILD_ID), which is SemVer . Custom versioning can be created by implementing get-version stage Application Library EDP provides baseline codebase templates for Microservices, Libraries, within create strategy while onboarding new Codebase Stages Library Each EDP Pipeline consists of pre-defined steps (stages). Consult library documentation for more details CI Pipelines EDP provides CI Pipelines (running in Jenkins) for first-class citizens: - Applications (Microservices) based on Java8, Java11, JavaScript (React), .Net, Python, Go - Libraries based on Java8, Java11, JavaScript (React), .Net, Python, Go, Groovy Pipelines, Terraform - Autotests based on Java8, Java11 CD Pipelines EDP provides capabilities to design CD Pipelines (in Admin Console) for Microservices and defines logic for artifacts flow (promotion) from env to env. Artifacts promotion is performed automatically ( Autotests ), manually ( User Approval ) or combining both approaches Autotests EDP provides CI pipeline for autotest implemented in Java. Autotests can be used as Quality Gates in CD Pipelines Custom Pipeline Library EDP can be extended by introducing Custom Pipeline Library Dynamic Environments Each EDP CD Pipeline creates/destroys environment upon user requests","title":"Basic Concepts"},{"location":"features/#basic-concepts","text":"Consult EDP Glossary section for definitions mentioned on this page and EDP Toolset to have a full list of tools used with the Platform. The below table contains a full list of features provided by EDP. Features Description Cloud Agnostic EDP runs on Kubernetes cluster, so any Public Cloud Provider which provides Kubernetes can be used. Kubernetes clusters deployed on-premises work as well CI/CD for Microservices EDP is initially designed to support CI/CD for Microservices running as containerized applications inside Kubernetes Cluster. EDP also supports CI for: - Terraform Modules, - Open Policy Rules, - Workflows for Java11, JavaScript (React), .Net, Python, Groovy Pipelines, Go Version Control System (VCS) EDP installs Gerrit as a default Source Code Management (SCM) tool. EDP also supports GitHub and GitLab integration Branching Strategy EDP supports Trunk-based development as well as GitHub/GitLab flow . EDP creates two Pipelines per each codebase branch (see Pipeline Framework ): Code Review and Build Repository Structure EDP provides separate Git repository per each Codebase and doesn't work with Monorepo . However, EDP does support customization and runs helm-lint , dockerfile-lint steps using Monorepo approach. Artifacts Versioning EDP supports two approaches for Artifacts versioning: - default (BRANCH-[TECH_STACK_VERSION]-BUILD_ID) - EDP (MAJOR.MINOR.PATCH-BUILD_ID), which is SemVer . Custom versioning can be created by implementing get-version stage Application Library EDP provides baseline codebase templates for Microservices, Libraries, within create strategy while onboarding new Codebase Stages Library Each EDP Pipeline consists of pre-defined steps (stages). Consult library documentation for more details CI Pipelines EDP provides CI Pipelines (running in Jenkins) for first-class citizens: - Applications (Microservices) based on Java8, Java11, JavaScript (React), .Net, Python, Go - Libraries based on Java8, Java11, JavaScript (React), .Net, Python, Go, Groovy Pipelines, Terraform - Autotests based on Java8, Java11 CD Pipelines EDP provides capabilities to design CD Pipelines (in Admin Console) for Microservices and defines logic for artifacts flow (promotion) from env to env. Artifacts promotion is performed automatically ( Autotests ), manually ( User Approval ) or combining both approaches Autotests EDP provides CI pipeline for autotest implemented in Java. Autotests can be used as Quality Gates in CD Pipelines Custom Pipeline Library EDP can be extended by introducing Custom Pipeline Library Dynamic Environments Each EDP CD Pipeline creates/destroys environment upon user requests","title":"Basic Concepts"},{"location":"getting-started/","text":"Getting Started \u2693\ufe0e Requirements \u2693\ufe0e Kubernetes cluster 1.18+, or OpenShift 4.6+ kubectl tool helm 3.5.x+ Keycloak 11.0+ Kiosk v0.2.9 Amazon EKS Pod Identity Webhook in case of using AWS ECR as Docker Registry Hardware \u2693\ufe0e Minimal: CPU: 4 Core Memory: 16 Gb EDP Toolset \u2693\ufe0e List of Tools used on the Platform: Domain Related Tools/Solutions Artefacts Management Nexus Repository, AWS ECR AWS Amazon EKS Pod Identity Webhook, AWS ECR, AWS EFS Build .NET, Go, Apache Gradle, Apache Maven, NPM Cluster Backup Velero Code Review Gerrit, GitLab, GitHub Docker Hadolint, kaniko, crane Infrastructure as Code Terraform, TFLint Kubernetes deployment kubectl, helm, ct (Chart Testing) Kubernetes Multitenancy Kiosk Logging EFK, ELK, Loki Monitoring Prometheus, Grafana Pipeline Orchestration Jenkins, GitLab CI (basic) Policies/Rules Open Policy Agent SSO Keycloak, keycloak-proxy Static Code Analysis SonarQube Test Report Tool Allure Install prerequisites \u2693\ufe0e Install EDP \u2693\ufe0e Find below the example of the installation command: helm install edp epamedp / edp - install -- wait -- timeout = 900 s \\ -- version < edp_version > \\ -- set global . edpName =< edp - project > \\ -- set global . dnsWildCard =< cluster_DNS_wilcdard > \\ -- set global . webConsole . url =< kubeconfig . clusters . cluster . server > \\ -- set global . platform =< platform_type > \\ -- set dockerRegistry . url =< aws_account_id > . dkr . ecr . < region > . amazonaws . com \\ -- set keycloak - operator . keycloak . url =< keycloak_endpoint > \\ -- set gerrit - operator . gerrit . sshPort =< gerrit_ssh_port > \\ -- namespace < edp - project > Warning Please be aware that the command above is an example. To install EDP with the necessary parameters, please refer to the Install EDP section of the Operator Guide . Mind the parameters in the EDP installation chart. For details, please refer to the values.yaml .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#requirements","text":"Kubernetes cluster 1.18+, or OpenShift 4.6+ kubectl tool helm 3.5.x+ Keycloak 11.0+ Kiosk v0.2.9 Amazon EKS Pod Identity Webhook in case of using AWS ECR as Docker Registry","title":"Requirements"},{"location":"getting-started/#hardware","text":"Minimal: CPU: 4 Core Memory: 16 Gb","title":"Hardware"},{"location":"getting-started/#edp-toolset","text":"List of Tools used on the Platform: Domain Related Tools/Solutions Artefacts Management Nexus Repository, AWS ECR AWS Amazon EKS Pod Identity Webhook, AWS ECR, AWS EFS Build .NET, Go, Apache Gradle, Apache Maven, NPM Cluster Backup Velero Code Review Gerrit, GitLab, GitHub Docker Hadolint, kaniko, crane Infrastructure as Code Terraform, TFLint Kubernetes deployment kubectl, helm, ct (Chart Testing) Kubernetes Multitenancy Kiosk Logging EFK, ELK, Loki Monitoring Prometheus, Grafana Pipeline Orchestration Jenkins, GitLab CI (basic) Policies/Rules Open Policy Agent SSO Keycloak, keycloak-proxy Static Code Analysis SonarQube Test Report Tool Allure","title":"EDP Toolset"},{"location":"getting-started/#install-prerequisites","text":"","title":"Install prerequisites"},{"location":"getting-started/#install-edp","text":"Find below the example of the installation command: helm install edp epamedp / edp - install -- wait -- timeout = 900 s \\ -- version < edp_version > \\ -- set global . edpName =< edp - project > \\ -- set global . dnsWildCard =< cluster_DNS_wilcdard > \\ -- set global . webConsole . url =< kubeconfig . clusters . cluster . server > \\ -- set global . platform =< platform_type > \\ -- set dockerRegistry . url =< aws_account_id > . dkr . ecr . < region > . amazonaws . com \\ -- set keycloak - operator . keycloak . url =< keycloak_endpoint > \\ -- set gerrit - operator . gerrit . sshPort =< gerrit_ssh_port > \\ -- namespace < edp - project > Warning Please be aware that the command above is an example. To install EDP with the necessary parameters, please refer to the Install EDP section of the Operator Guide . Mind the parameters in the EDP installation chart. For details, please refer to the values.yaml .","title":"Install EDP"},{"location":"glossary/","text":"Glossary \u2693\ufe0e Get familiar with the definitions and context for the most useful EDP terms presented in table below. Terms Details EDP Component - an item used in CI/CD process Admin Console - an EDP component that helps to manage, set up, and control the business entities. Artifactory - an EDP component that stores all the binary artifacts. NOTE : Nexus is used as a possible implementation of a repository. CI/CD Server - an EDP component that launches pipelines that perform the build, QA, and deployment code logic. NOTE : Jenkins is used as a possible implementation of a CI/CD server. Code Review tool - an EDP component that collaborates with the changes in the codebase. NOTE : Gerrit is used as a possible implementation of a code review tool. Identity Server - an authentication server providing a common way to verify requests to all of the applications. NOTE : Keycloak is used as a possible implementation of an identity server. Security Realm Tenant - a realm in identity server (e.g Keycloak) where all users' accounts and their access permissions are managed. The realm is unique for the identity server instance. Static Code Analyzer - an EDP component that inspects continuously a code quality before the necessary changes appear in a master branch. NOTE : SonarQube is used as a possible implementation of a static code analyzer. VCS (Version Control System) - a replication of the Gerrit repository that displays all the changes made by developers. NOTE : GitHub and GitLab are used as the possible implementation of a repository with the version control system. EDP Business Entity - a part of the CI/CD process (the integration, delivery, and deployment of any codebase changes) Application - a codebase type that is built as the binary artifact and deployable unit with the code that is stored in VCS. As a result, the application becomes a container and can be deployed in an environment. Autotests - a codebase type that inspects a product (e.g. an application set) on a stage. Autotests are not deployed to any container and launched from the respective code stage. CD Pipeline (Continuous Delivery Pipeline) - an EDP business entity that describes the whole delivery process of the selected application set via the respective stages. The main idea of the CD pipeline is to promote the application version between the stages by applying the sequential verification (i.e. the second stage will be available if the verification on the first stage is successfully completed). NOTE : The CD pipeline can include the essential set of applications with its specific stages as well. CD Pipeline Stage - an EDP business entity that is presented as the logical gate required for the application set inspection. Every stage has one OpenShift project where the selected application set is deployed. All stages are sequential and promote applications one-by-one. Codebase - an EDP business entity that possesses a code. Codebase Branch - an EDP business entity that represents a specific version in a Git branch. Every codebase branch has a Codebase Docker Stream entity. Codebase Docker Stream - a deployable component that leads to the application build and displays that the last build was verified on the specific stage. Every CD pipeline stage accepts a set of Codebase Docker Streams (CDS) that are input and output. SAMPLE: if an application1 has a master branch, the input CDS will be named as [app name]-[pipeline name]-[stage name]-[master] and the output after the passing of the DEV stage will be as follows: [app name]-[pipeline name]-[stage name]-[dev]-[verified]. Library - a codebase type that is built as the binary artifact, i.e. it`s stored in the Artifactory and can be uploaded by other applications, autotests or libraries. Quality Gate - an EDP business entity that represents the minimum acceptable results after the testing. Every stage has a quality gate that should be passed to promote the application. The stage quality gate can be a manual approve from a QA specialist OR a successful autotest launch. Quality Gate Type - this value defines trigger type that promotes artifacts (images) to the next environment in CD Pipeline. There are manual and automatic types of quality gates. The manual type means that the promoting process should be confirmed in Jenkins. The automatic type promotes the images automatically in case there are no errors in the Allure Report. NOTE : If any of the test types is not passed, the CD pipeline will fail. Trigger Type - a value that defines a trigger type used for the CD pipeline triggering. There are manual and automatic types of triggering. The manual type means that the CD pipeline should be triggered manually. The automatic type triggers the CD pipeline automatically as soon as the Codebase Docker Stream was changed. EDP CI/CD Pipelines Framework - a library that allows extending the Jenkins pipelines and stages to develop an application. Pipelines are presented as the shared library that can be connected in Jenkins. The library is connected using the Git repository link (a public repository that is supported by EDP) on the GitHub. Allure Report - a tool that represents test results in one brief report in a clear form. Automated Tests - different types of automated tests that can be run on the environment for a specific stage. Build Pipeline - a Jenkins pipeline that builds a corresponding codebase branch in the Codebase. Build Stage - a stage that takes place after the code has been submitted/merged to the repository of the main branch ( the pull request from the feature branch is merged to the main one, the Patch set is submitted in Gerrit ). Code Review Pipeline - a Jenkins pipeline that inspects the code candidate in the Code Review tool. Code Review Stage - a stage where code is reviewed before it goes to the main branch repository of the version control system ( the commit to the feature branch is pushed, the Patch set is created in Gerrit ). Deploy Pipeline - a Jenkins pipeline that is responsible for the CD Pipeline Stage deployment with the full set of applications and autotests. Deployment Stage - a part of the Continuous Delivery where artifacts are being deployed to environments. EDP CI/CD Pipelines - an orchestrator for stages that is responsible for the common technical events, e.g. initialization, in Jenkins pipeline. The set of stages for the pipeline is defined as an input JSON file for the respective Jenkins job. NOTE : There is the ability to create the necessary realization of the library pipeline on your own as well. EDP CI/CD Stages - a repository that is launched in the Jenkins pipeline. Every stage is presented as an individual Groovy file in a corresponding repository. Such single responsibility realization allows rewriting of one essential stage without changing the whole pipeline. Environment - a part of the stage where the built and packed into an image application are deployed for further testing. It`s possible to deploy several applications to several environments (Team and Integration environments) within one stage. Integration Environment - an environment type that is always deployed as soon as the new application version is built in order to launch the integration test and promote images to the next stages. The Integration Environment can be triggered manually or in case a new image appears in the Docker registry. Jenkinsfile - a text file that keeps the definition of a Jenkins Pipeline and is checked into source control. Every Job has its Jenkinsfile that is stored in the specific application repository and in Jenkins as the plain text. Jenkins Node - a machine that is a part of the Jenkins environment that is capable of executing a pipeline. Jenkins Pipeline - a user-defined model of a CD pipeline. The pipeline code defines the entire build process. Jenkins Stage - a part of the whole CI/CD process that should pass the source code in order to be released and deployed on the production. Team Environment - an environment type that can be deployed at any time by the manual trigger of the Deploy pipeline where team or developers can check out their applications. NOTE : The promotion from such kind of environment is prohibited and developed only for the local testing. OpenShift / Kubernetes (K8S) ConfigMap - a resource that stores configuration data and processes the strings that do not contain sensitive information. Docker Container - is a lightweight, standalone, and executable package. Docker Registry - a store for the Docker Container that is created for the application after the Build pipeline performance. OpenShift Web Console - a web console that enables to view, manage, and change OpenShift / K8S resources using browser. Operator Framework - a deployable unit in OpenShift that is responsible for one or a set of resources and performs its life circle (adding, displaying, and provisioning). Path - a route component that helps to find a specified path (e.g. /api) at once and skip the other. Pod - the smallest deployable unit of the large microservice application that is responsible for the application launch. The pod is presented as the one launched Docker container. When the Docker container is collected, it will be kept in Docker Registry and then saved as Pod in the OpenShift project. NOTE : The Deployment Config is responsible for the Pod push, restart, and stop processes. PV (Persistent Volume) - a cluster resource that captures the details of the storage implementation and has an independent lifecycle of any individual pod. PVC (Persistent Volume Claim) - a user request for storage that can request specific size and access mode. PV resources are consumed by PVCs. Route - a resource in OpenShift that allows getting the external access to the pushed application. Secret - an object that stores and manages all the sensitive information (e.g. passwords, tokens, and SSH keys). Service - an external connection point with Pod that is responsible for the network. A specific Service is connected to a specific Pod using labels and redirects all the requests to Pod as well. Site - a route component (link name) that is created from the indicated application name and applies automatically the project name and a wildcard DNS record.","title":"Glossary"},{"location":"glossary/#glossary","text":"Get familiar with the definitions and context for the most useful EDP terms presented in table below. Terms Details EDP Component - an item used in CI/CD process Admin Console - an EDP component that helps to manage, set up, and control the business entities. Artifactory - an EDP component that stores all the binary artifacts. NOTE : Nexus is used as a possible implementation of a repository. CI/CD Server - an EDP component that launches pipelines that perform the build, QA, and deployment code logic. NOTE : Jenkins is used as a possible implementation of a CI/CD server. Code Review tool - an EDP component that collaborates with the changes in the codebase. NOTE : Gerrit is used as a possible implementation of a code review tool. Identity Server - an authentication server providing a common way to verify requests to all of the applications. NOTE : Keycloak is used as a possible implementation of an identity server. Security Realm Tenant - a realm in identity server (e.g Keycloak) where all users' accounts and their access permissions are managed. The realm is unique for the identity server instance. Static Code Analyzer - an EDP component that inspects continuously a code quality before the necessary changes appear in a master branch. NOTE : SonarQube is used as a possible implementation of a static code analyzer. VCS (Version Control System) - a replication of the Gerrit repository that displays all the changes made by developers. NOTE : GitHub and GitLab are used as the possible implementation of a repository with the version control system. EDP Business Entity - a part of the CI/CD process (the integration, delivery, and deployment of any codebase changes) Application - a codebase type that is built as the binary artifact and deployable unit with the code that is stored in VCS. As a result, the application becomes a container and can be deployed in an environment. Autotests - a codebase type that inspects a product (e.g. an application set) on a stage. Autotests are not deployed to any container and launched from the respective code stage. CD Pipeline (Continuous Delivery Pipeline) - an EDP business entity that describes the whole delivery process of the selected application set via the respective stages. The main idea of the CD pipeline is to promote the application version between the stages by applying the sequential verification (i.e. the second stage will be available if the verification on the first stage is successfully completed). NOTE : The CD pipeline can include the essential set of applications with its specific stages as well. CD Pipeline Stage - an EDP business entity that is presented as the logical gate required for the application set inspection. Every stage has one OpenShift project where the selected application set is deployed. All stages are sequential and promote applications one-by-one. Codebase - an EDP business entity that possesses a code. Codebase Branch - an EDP business entity that represents a specific version in a Git branch. Every codebase branch has a Codebase Docker Stream entity. Codebase Docker Stream - a deployable component that leads to the application build and displays that the last build was verified on the specific stage. Every CD pipeline stage accepts a set of Codebase Docker Streams (CDS) that are input and output. SAMPLE: if an application1 has a master branch, the input CDS will be named as [app name]-[pipeline name]-[stage name]-[master] and the output after the passing of the DEV stage will be as follows: [app name]-[pipeline name]-[stage name]-[dev]-[verified]. Library - a codebase type that is built as the binary artifact, i.e. it`s stored in the Artifactory and can be uploaded by other applications, autotests or libraries. Quality Gate - an EDP business entity that represents the minimum acceptable results after the testing. Every stage has a quality gate that should be passed to promote the application. The stage quality gate can be a manual approve from a QA specialist OR a successful autotest launch. Quality Gate Type - this value defines trigger type that promotes artifacts (images) to the next environment in CD Pipeline. There are manual and automatic types of quality gates. The manual type means that the promoting process should be confirmed in Jenkins. The automatic type promotes the images automatically in case there are no errors in the Allure Report. NOTE : If any of the test types is not passed, the CD pipeline will fail. Trigger Type - a value that defines a trigger type used for the CD pipeline triggering. There are manual and automatic types of triggering. The manual type means that the CD pipeline should be triggered manually. The automatic type triggers the CD pipeline automatically as soon as the Codebase Docker Stream was changed. EDP CI/CD Pipelines Framework - a library that allows extending the Jenkins pipelines and stages to develop an application. Pipelines are presented as the shared library that can be connected in Jenkins. The library is connected using the Git repository link (a public repository that is supported by EDP) on the GitHub. Allure Report - a tool that represents test results in one brief report in a clear form. Automated Tests - different types of automated tests that can be run on the environment for a specific stage. Build Pipeline - a Jenkins pipeline that builds a corresponding codebase branch in the Codebase. Build Stage - a stage that takes place after the code has been submitted/merged to the repository of the main branch ( the pull request from the feature branch is merged to the main one, the Patch set is submitted in Gerrit ). Code Review Pipeline - a Jenkins pipeline that inspects the code candidate in the Code Review tool. Code Review Stage - a stage where code is reviewed before it goes to the main branch repository of the version control system ( the commit to the feature branch is pushed, the Patch set is created in Gerrit ). Deploy Pipeline - a Jenkins pipeline that is responsible for the CD Pipeline Stage deployment with the full set of applications and autotests. Deployment Stage - a part of the Continuous Delivery where artifacts are being deployed to environments. EDP CI/CD Pipelines - an orchestrator for stages that is responsible for the common technical events, e.g. initialization, in Jenkins pipeline. The set of stages for the pipeline is defined as an input JSON file for the respective Jenkins job. NOTE : There is the ability to create the necessary realization of the library pipeline on your own as well. EDP CI/CD Stages - a repository that is launched in the Jenkins pipeline. Every stage is presented as an individual Groovy file in a corresponding repository. Such single responsibility realization allows rewriting of one essential stage without changing the whole pipeline. Environment - a part of the stage where the built and packed into an image application are deployed for further testing. It`s possible to deploy several applications to several environments (Team and Integration environments) within one stage. Integration Environment - an environment type that is always deployed as soon as the new application version is built in order to launch the integration test and promote images to the next stages. The Integration Environment can be triggered manually or in case a new image appears in the Docker registry. Jenkinsfile - a text file that keeps the definition of a Jenkins Pipeline and is checked into source control. Every Job has its Jenkinsfile that is stored in the specific application repository and in Jenkins as the plain text. Jenkins Node - a machine that is a part of the Jenkins environment that is capable of executing a pipeline. Jenkins Pipeline - a user-defined model of a CD pipeline. The pipeline code defines the entire build process. Jenkins Stage - a part of the whole CI/CD process that should pass the source code in order to be released and deployed on the production. Team Environment - an environment type that can be deployed at any time by the manual trigger of the Deploy pipeline where team or developers can check out their applications. NOTE : The promotion from such kind of environment is prohibited and developed only for the local testing. OpenShift / Kubernetes (K8S) ConfigMap - a resource that stores configuration data and processes the strings that do not contain sensitive information. Docker Container - is a lightweight, standalone, and executable package. Docker Registry - a store for the Docker Container that is created for the application after the Build pipeline performance. OpenShift Web Console - a web console that enables to view, manage, and change OpenShift / K8S resources using browser. Operator Framework - a deployable unit in OpenShift that is responsible for one or a set of resources and performs its life circle (adding, displaying, and provisioning). Path - a route component that helps to find a specified path (e.g. /api) at once and skip the other. Pod - the smallest deployable unit of the large microservice application that is responsible for the application launch. The pod is presented as the one launched Docker container. When the Docker container is collected, it will be kept in Docker Registry and then saved as Pod in the OpenShift project. NOTE : The Deployment Config is responsible for the Pod push, restart, and stop processes. PV (Persistent Volume) - a cluster resource that captures the details of the storage implementation and has an independent lifecycle of any individual pod. PVC (Persistent Volume Claim) - a user request for storage that can request specific size and access mode. PV resources are consumed by PVCs. Route - a resource in OpenShift that allows getting the external access to the pushed application. Secret - an object that stores and manages all the sensitive information (e.g. passwords, tokens, and SSH keys). Service - an external connection point with Pod that is responsible for the network. A specific Service is connected to a specific Pod using labels and redirects all the requests to Pod as well. Site - a route component (link name) that is created from the indicated application name and applies automatically the project name and a wildcard DNS record.","title":"Glossary"},{"location":"roadmap/","text":"RoadMap \u2693\ufe0e RoadMap consists of three streams: Architecture Building Blocks Admin Console Documentation I. Architecture \u2693\ufe0e Goals: Improve reusability for EDP components Integrate Kubernetes Native Deployment solutions Introduce abstraction layer for CI/CD components Build processes around the GitOps approach Introduce secrets management Kubernetes Multitenancy \u2693\ufe0e Multiple instances of EDP are run in a single Kubernetes cluster. One way to achieve this is to use Multitenancy . Initially, Kiosk was selected as tools that provides this capability. An alternative option that EDP Team took into consideration is Capsule . Another tool which goes far beyond multitenancy is vcluster going a good candidate for e2e testing scenarios where one needs simple lightweight kubernetes cluster in CI pipelines. Microservice Reference Architecture Framework \u2693\ufe0e EDP provides basic Application Templates for a number of technology stacks (Java, .Net, NPM, Python) and Helm is used as a deployment tool. The goal is to extend this library and provide: Application Templates which are built on pre-defined architecture patterns (e.g., Microservice, API Gateway, Circuit Breaker, CQRS, Event Driven) and Deployment Approaches : Canary, Blue/Green. This requires additional tools installation on cluster as well. Policy Enforcement for Kubernetes \u2693\ufe0e Running workload in Kubernetes calls for extra effort from Cluster Administrators to ensure those workloads do follow best practices or specific requirements defined on organization level. Those requirements can be formalized in policies and integrated into: CI Pipelines and Kubernetes Cluster (through Admission Controller approach) - to guarantee proper resource management during development and runtime phases. EDP uses Open Policy Agent (from version 2.8.0), since it supports compliance check for more use-cases: Kubernetes Workloads, Terraform and Java code, HTTP APIs and many others . Kyverno is another option being checked in scope of this activity. Secrets Management \u2693\ufe0e EDP should provide secrets management as a part of platform. There are multiple tools providing secrets management capabilities. The aim is to be aligned with GitOps and Operator Pattern approaches so HashiCorp Vault , Banzaicloud Bank Vaults , Bitnami Sealed Secrets are currently used for internal projects and some of them should be made publicly available - as a part of EDP Deployment. Release Management \u2693\ufe0e Conventional Commits and Conventional Changelog are two approaches to be used as part of release process. Today EDP provides only capabilities to manage Release Branches . This activity should address this gap by formalizing and implementing Release Process as a part of EDP. Topics to be covered: Versioning, Tagging, Artifacts Promotion. Kubernetes Native CI/CD Pipelines \u2693\ufe0e EDP uses Jenkins as Pipeline Orchestrator. Jenkins runs workload for CI and CD parts. There is also basic support for GitLab CI , but it provides Docker image build functionality only. EDP works on providing an alternative to Jenkins and use Kubernetes Native Approach for pipeline management. There are a number of tools, which provides such capability: ArgoCD Argo Workflows Argo Rollouts Tekton Drone Flux This list is under investigation and solution is going to be implemented in two steps: Introduce tool that provide Continues Deployment approach. ArgoCD is one of the best to go with. Integrate EDP with tool that provides Continues Integration capabilities. Advanced EDP Role-based Model \u2693\ufe0e EDP has a number of base roles which are used across EDP. In some cases it is necessary to provide more granular permissions for specific users. It is possible to do this using Kubernetes Native approach. Notifications Framework \u2693\ufe0e EDP has a number of components which need to report their statuses: Build/Code Review/Deploy Pipelines, changes in Environments, updates with artifacts. The goal for this activity is to onboard Kubernetes Native approach which provides Notification capabilities with different sources/channels integration (e.g. Email, Slack, MS Teams). Some of these tools are Argo Events , Botkube . Reconciler Component Retirement \u2693\ufe0e Persistent layer, which is based on edp-db (PostgreSQL) and reconciler component should be retired in favour of Kubernetes Custom Resource (CR) . The latest features in EDP are implemented using CR approach. II. Building Blocks \u2693\ufe0e Goals: Introduce best practices from Microservice Reference Architecture deployment and observability using Kubernetes Native Tools Enable integration with the Centralized Test Reporting Frameworks Onboard SAST/DAST tool as a part of CI pipelines and Non-Functional Testing activities Infrastructure as Code \u2693\ufe0e EDP Target tool for Infrastructure as Code (IaC) is Terraform . EDP sees two CI/CD scenarios while working with IaC: Module Development and Live Environment Deployment . Today, EDP provides basic capabilities (CI Pipelines) for Terraform Module Development . At the same time, currently EDP doesn't provide Deployment pipelines for Live Environments and the feature is under development. Terragrunt is an option to use in Live Environment deployment. Another Kubernetes Native approach to provision infrastructure components is Crossplane . Database Schema Management \u2693\ufe0e One of the challenges for Application running in Kubernetes is to manage database schema. There are a number of tools which provides such capabilities, e.g. Liquibase , Flyway . Both tools provide versioning control for database schemas. There are different approaches on how to run migration scripts in Kubernetes : in init container , as separate Job or as a separate CD stage. Purpose of this activity is to provide database schema management solution in Kubernetes as a part of EDP. EDP Team investigates SchemaHero tool and use-cases which suits Kubernetes native approach for database schema migrations. Open Policy Agent \u2693\ufe0e Open Policy Agent is introduced in version 2.8.0 . EDP now supports CI for Rego Language , so you can develop your own policies. The next goal is to provide pipeline steps for running compliance policies check for Terraform, Java, Helm Chart as a part of CI process. Report Portal \u2693\ufe0e EDP uses Allure Framework as a Test Report tool . Another option is to integrate Report Portal into EDP ecosystem. Carrier \u2693\ufe0e Carrier provides Non-functional testing capabilities. Java 17 \u2693\ufe0e EDP supports two LTS versions of Java: 8 and 11. The goal is to provide Java 17 (LTS) support. Velero \u2693\ufe0e Velero is used as a cluster backup tool and is deployed as a part of Platform. Currently, Multitenancy/On-premise support for backup capabilities is in process. Istio \u2693\ufe0e Istio is to be used as a Service Mesh and to address challenges for Microservice or Distributed Architectures. Kong \u2693\ufe0e Kong is one of tools which is planned to use as an API Gateway solution provider. Another possible candidate for investigation is Ambassador API Gateway OpenShift 4.X \u2693\ufe0e OpenShift 4.6 is a platform that EDP supports. III. Admin Console (UI) \u2693\ufe0e Goals: Improve U\u0425 for different user types to address their concerns in the delivery model Introduce user management capabilities Enrich with traceability metrics for products Users Management \u2693\ufe0e EDP uses Keycloak as Identity and Access provider. EDP roles/groups are managed inside Keycloak realm, then these changes are propagated across EDP Tools. The plan is to provide this functionality in EDP Admin Console using Kubernetes native approach (Custom Resources). The Delivery Pipelines Dashboard \u2693\ufe0e EDP CD Pipeline section in Admin Console provides basic information like: environments, artifact versions deployed per each environment, direct links to namespaces. One option is to enrich this panel with metrics (from prometheus, custom resources, events, etc). Another option is to use existing dashboards and expose EDP metrics to them, e.g. plugin for Lens , OpenShift UI Console Split Jira and Commit Validation Sections \u2693\ufe0e Commit Validate step was initially designed to be aligned with Jira Integration and cannot be used as single feature. Target state is to ensure features CommitMessage Validation and Jira Integration both can be used independently. We also want to add support for Conventional Commits . IV. Documentation as Code \u2693\ufe0e Goal: Transparent documentation and clear development guidelines for EDP customization. Consolidate documentation in a single repository edp-install , use mkdocs tool to generate docs and GitHub Pages as a hosting solution.","title":"RoadMap"},{"location":"roadmap/#roadmap","text":"RoadMap consists of three streams: Architecture Building Blocks Admin Console Documentation","title":"RoadMap"},{"location":"roadmap/#i-architecture","text":"Goals: Improve reusability for EDP components Integrate Kubernetes Native Deployment solutions Introduce abstraction layer for CI/CD components Build processes around the GitOps approach Introduce secrets management","title":"I. Architecture"},{"location":"roadmap/#kubernetes-multitenancy","text":"Multiple instances of EDP are run in a single Kubernetes cluster. One way to achieve this is to use Multitenancy . Initially, Kiosk was selected as tools that provides this capability. An alternative option that EDP Team took into consideration is Capsule . Another tool which goes far beyond multitenancy is vcluster going a good candidate for e2e testing scenarios where one needs simple lightweight kubernetes cluster in CI pipelines.","title":"Kubernetes Multitenancy"},{"location":"roadmap/#microservice-reference-architecture-framework","text":"EDP provides basic Application Templates for a number of technology stacks (Java, .Net, NPM, Python) and Helm is used as a deployment tool. The goal is to extend this library and provide: Application Templates which are built on pre-defined architecture patterns (e.g., Microservice, API Gateway, Circuit Breaker, CQRS, Event Driven) and Deployment Approaches : Canary, Blue/Green. This requires additional tools installation on cluster as well.","title":"Microservice Reference Architecture Framework"},{"location":"roadmap/#policy-enforcement-for-kubernetes","text":"Running workload in Kubernetes calls for extra effort from Cluster Administrators to ensure those workloads do follow best practices or specific requirements defined on organization level. Those requirements can be formalized in policies and integrated into: CI Pipelines and Kubernetes Cluster (through Admission Controller approach) - to guarantee proper resource management during development and runtime phases. EDP uses Open Policy Agent (from version 2.8.0), since it supports compliance check for more use-cases: Kubernetes Workloads, Terraform and Java code, HTTP APIs and many others . Kyverno is another option being checked in scope of this activity.","title":"Policy Enforcement for Kubernetes"},{"location":"roadmap/#secrets-management","text":"EDP should provide secrets management as a part of platform. There are multiple tools providing secrets management capabilities. The aim is to be aligned with GitOps and Operator Pattern approaches so HashiCorp Vault , Banzaicloud Bank Vaults , Bitnami Sealed Secrets are currently used for internal projects and some of them should be made publicly available - as a part of EDP Deployment.","title":"Secrets Management"},{"location":"roadmap/#release-management","text":"Conventional Commits and Conventional Changelog are two approaches to be used as part of release process. Today EDP provides only capabilities to manage Release Branches . This activity should address this gap by formalizing and implementing Release Process as a part of EDP. Topics to be covered: Versioning, Tagging, Artifacts Promotion.","title":"Release Management"},{"location":"roadmap/#kubernetes-native-cicd-pipelines","text":"EDP uses Jenkins as Pipeline Orchestrator. Jenkins runs workload for CI and CD parts. There is also basic support for GitLab CI , but it provides Docker image build functionality only. EDP works on providing an alternative to Jenkins and use Kubernetes Native Approach for pipeline management. There are a number of tools, which provides such capability: ArgoCD Argo Workflows Argo Rollouts Tekton Drone Flux This list is under investigation and solution is going to be implemented in two steps: Introduce tool that provide Continues Deployment approach. ArgoCD is one of the best to go with. Integrate EDP with tool that provides Continues Integration capabilities.","title":"Kubernetes Native CI/CD Pipelines"},{"location":"roadmap/#advanced-edp-role-based-model","text":"EDP has a number of base roles which are used across EDP. In some cases it is necessary to provide more granular permissions for specific users. It is possible to do this using Kubernetes Native approach.","title":"Advanced EDP Role-based Model"},{"location":"roadmap/#notifications-framework","text":"EDP has a number of components which need to report their statuses: Build/Code Review/Deploy Pipelines, changes in Environments, updates with artifacts. The goal for this activity is to onboard Kubernetes Native approach which provides Notification capabilities with different sources/channels integration (e.g. Email, Slack, MS Teams). Some of these tools are Argo Events , Botkube .","title":"Notifications Framework"},{"location":"roadmap/#reconciler-component-retirement","text":"Persistent layer, which is based on edp-db (PostgreSQL) and reconciler component should be retired in favour of Kubernetes Custom Resource (CR) . The latest features in EDP are implemented using CR approach.","title":"Reconciler Component Retirement"},{"location":"roadmap/#ii-building-blocks","text":"Goals: Introduce best practices from Microservice Reference Architecture deployment and observability using Kubernetes Native Tools Enable integration with the Centralized Test Reporting Frameworks Onboard SAST/DAST tool as a part of CI pipelines and Non-Functional Testing activities","title":"II. Building Blocks"},{"location":"roadmap/#infrastructure-as-code","text":"EDP Target tool for Infrastructure as Code (IaC) is Terraform . EDP sees two CI/CD scenarios while working with IaC: Module Development and Live Environment Deployment . Today, EDP provides basic capabilities (CI Pipelines) for Terraform Module Development . At the same time, currently EDP doesn't provide Deployment pipelines for Live Environments and the feature is under development. Terragrunt is an option to use in Live Environment deployment. Another Kubernetes Native approach to provision infrastructure components is Crossplane .","title":"Infrastructure as Code"},{"location":"roadmap/#database-schema-management","text":"One of the challenges for Application running in Kubernetes is to manage database schema. There are a number of tools which provides such capabilities, e.g. Liquibase , Flyway . Both tools provide versioning control for database schemas. There are different approaches on how to run migration scripts in Kubernetes : in init container , as separate Job or as a separate CD stage. Purpose of this activity is to provide database schema management solution in Kubernetes as a part of EDP. EDP Team investigates SchemaHero tool and use-cases which suits Kubernetes native approach for database schema migrations.","title":"Database Schema Management"},{"location":"roadmap/#open-policy-agent","text":"Open Policy Agent is introduced in version 2.8.0 . EDP now supports CI for Rego Language , so you can develop your own policies. The next goal is to provide pipeline steps for running compliance policies check for Terraform, Java, Helm Chart as a part of CI process.","title":"Open Policy Agent"},{"location":"roadmap/#report-portal","text":"EDP uses Allure Framework as a Test Report tool . Another option is to integrate Report Portal into EDP ecosystem.","title":"Report Portal"},{"location":"roadmap/#carrier","text":"Carrier provides Non-functional testing capabilities.","title":"Carrier"},{"location":"roadmap/#java-17","text":"EDP supports two LTS versions of Java: 8 and 11. The goal is to provide Java 17 (LTS) support.","title":"Java 17"},{"location":"roadmap/#velero","text":"Velero is used as a cluster backup tool and is deployed as a part of Platform. Currently, Multitenancy/On-premise support for backup capabilities is in process.","title":"Velero"},{"location":"roadmap/#istio","text":"Istio is to be used as a Service Mesh and to address challenges for Microservice or Distributed Architectures.","title":"Istio"},{"location":"roadmap/#kong","text":"Kong is one of tools which is planned to use as an API Gateway solution provider. Another possible candidate for investigation is Ambassador API Gateway","title":"Kong"},{"location":"roadmap/#openshift-4x","text":"OpenShift 4.6 is a platform that EDP supports.","title":"OpenShift 4.X"},{"location":"roadmap/#iii-admin-console-ui","text":"Goals: Improve U\u0425 for different user types to address their concerns in the delivery model Introduce user management capabilities Enrich with traceability metrics for products","title":"III. Admin Console (UI)"},{"location":"roadmap/#users-management","text":"EDP uses Keycloak as Identity and Access provider. EDP roles/groups are managed inside Keycloak realm, then these changes are propagated across EDP Tools. The plan is to provide this functionality in EDP Admin Console using Kubernetes native approach (Custom Resources).","title":"Users Management"},{"location":"roadmap/#the-delivery-pipelines-dashboard","text":"EDP CD Pipeline section in Admin Console provides basic information like: environments, artifact versions deployed per each environment, direct links to namespaces. One option is to enrich this panel with metrics (from prometheus, custom resources, events, etc). Another option is to use existing dashboards and expose EDP metrics to them, e.g. plugin for Lens , OpenShift UI Console","title":"The Delivery Pipelines Dashboard"},{"location":"roadmap/#split-jira-and-commit-validation-sections","text":"Commit Validate step was initially designed to be aligned with Jira Integration and cannot be used as single feature. Target state is to ensure features CommitMessage Validation and Jira Integration both can be used independently. We also want to add support for Conventional Commits .","title":"Split Jira and Commit Validation Sections"},{"location":"roadmap/#iv-documentation-as-code","text":"Goal: Transparent documentation and clear development guidelines for EDP customization. Consolidate documentation in a single repository edp-install , use mkdocs tool to generate docs and GitHub Pages as a hosting solution.","title":"IV. Documentation as Code"},{"location":"developer-guide/","text":"Overview \u2693\ufe0e The EDP Developer guide is intended for developers and provides details on the necessary actions to extend the EDP functionality.","title":"Overview"},{"location":"developer-guide/#overview","text":"The EDP Developer guide is intended for developers and provides details on the necessary actions to extend the EDP functionality.","title":"Overview"},{"location":"developer-guide/edp-workflow/","text":"EDP Project Rules. Working Process \u2693\ufe0e This page contains the details on the project rules and working process for EDP team and contributors. Explore the main points about working with Gerrit, following the main commit flow, as well as the details about commit types and message below. Project Rules \u2693\ufe0e Before starting the development, please check the project rules: It is highly recommended to become familiar with the Gerrit flow. For details, please refer to the Gerrit official documentation and pay attention to the main points: a. Voting in Gerrit b. Resolution of Merge Conflict c. Comments resolution d. One Jira task should have one Merge Request (MR). If there are many changes within one MR, add the next patch set to the open MR by selecting the Amend commit check box. Only the Assignee is responsible for the MR merge and Jira task status. Every MR should be merged in a timely manner. Log time to Jira ticket. Working Process \u2693\ufe0e With EDP, the main workflow is based on the getting a Jira task and creating a Merge Request according to the rules described below. Workflow Get Jira task \u2192 implement, verify by yourself the results \u2192 create Merge Request (MR) \u2192 send for review \u2192 resolve comments/add changes, ask colleagues for the final review \u2192 track the MR merge \u2192 verify by yourself the results \u2192 change the status in the Jira ticket to CODE COMPLETE or RESOLVED \u2192 share necessary links with a QA specialist in the QA Verification channel \u2192 QA specialist closes the Jira task after his verification \u2192 Jira task should be CLOSED. Commit Flow Get Jira task. Please be aware of the following points: a. Every task has a reporter who can provide more details in case something is not clear. b. The responsible person for the task and code implementation is the assignee who tracks the following: actual Jira task status time logging add comments, attach necessary files in comments, add link that refers to the merged MR (optional, if not related to many repositories) code review and the final merge MS Teams chats - ping other colleagues, answer questions, etc. verification by a QA specialist bug fixing c. Pay attention to the task Status that differs in different entities, the workflow will help to see the whole task processing: d. There are several entities that are used on the EDP project: Story, Improvement, Task, Bug. Implement feature, improvement, fix and check the results on your own. If it is impossible to check the results of your work before the merge, verify all later. Create a Merge Request, for details, please refer to the Code Review Process . When committing, use the pattern: [EPMDEDP-JIRA Task Number]: commit type: Commit message. a. [EPMDEDP] - is the default part; b. JIRA Task Number - the number of your Jira task; c. commit type: feat : (new feature for the user, not a new feature for build script) fix : (bug fix for the user, not a fix to a build script) docs : (changes to the documentation) style : (formatting, missing semicolons, etc; no production code change) refactor : (refactoring production code, eg. renaming a variable) test : (adding missing tests, refactoring tests; no production code change) chore : (updating grunt tasks etc; no production code change) ! : (added to other commit types to mark breaking changes) For example: [ EPMDEDP - 0000 ]: feat ! : Job provisioner is responsible for the formation of Jenkinsfile BREAKING CHANGE : Job provisioner creates Jenkinsfile and configures it in Jenkins pipeline as a pipeline script . d. Commit message: brief, for example: [EPMDEDP-0000]: fix: Fix Gerrit plugin for Jenkins provisioning or descriptive, for example: [EPMDEDP-0000]: feat: Provide the ability to configure hadolint check *Add configuration files .hadolint.yaml and .hadolint.yml to stash Note Make sure there is a descriptive commit message for a breaking change Merge Request. For example: [EPMDEDP-0000]: feat!: Job provisioner is responsible for the formation of Jenkinsfile BREAKING CHANGE: Job provisioner creates Jenkinsfile and configures it in Jenkins pipeline as a pipeline script. Related Articles \u2693\ufe0e Conventional Commits Semantic Commit Messages Karma","title":"EDP Project Rules. Working Process"},{"location":"developer-guide/edp-workflow/#edp-project-rules-working-process","text":"This page contains the details on the project rules and working process for EDP team and contributors. Explore the main points about working with Gerrit, following the main commit flow, as well as the details about commit types and message below.","title":"EDP Project Rules. Working Process"},{"location":"developer-guide/edp-workflow/#project-rules","text":"Before starting the development, please check the project rules: It is highly recommended to become familiar with the Gerrit flow. For details, please refer to the Gerrit official documentation and pay attention to the main points: a. Voting in Gerrit b. Resolution of Merge Conflict c. Comments resolution d. One Jira task should have one Merge Request (MR). If there are many changes within one MR, add the next patch set to the open MR by selecting the Amend commit check box. Only the Assignee is responsible for the MR merge and Jira task status. Every MR should be merged in a timely manner. Log time to Jira ticket.","title":"Project Rules"},{"location":"developer-guide/edp-workflow/#working-process","text":"With EDP, the main workflow is based on the getting a Jira task and creating a Merge Request according to the rules described below. Workflow Get Jira task \u2192 implement, verify by yourself the results \u2192 create Merge Request (MR) \u2192 send for review \u2192 resolve comments/add changes, ask colleagues for the final review \u2192 track the MR merge \u2192 verify by yourself the results \u2192 change the status in the Jira ticket to CODE COMPLETE or RESOLVED \u2192 share necessary links with a QA specialist in the QA Verification channel \u2192 QA specialist closes the Jira task after his verification \u2192 Jira task should be CLOSED. Commit Flow Get Jira task. Please be aware of the following points: a. Every task has a reporter who can provide more details in case something is not clear. b. The responsible person for the task and code implementation is the assignee who tracks the following: actual Jira task status time logging add comments, attach necessary files in comments, add link that refers to the merged MR (optional, if not related to many repositories) code review and the final merge MS Teams chats - ping other colleagues, answer questions, etc. verification by a QA specialist bug fixing c. Pay attention to the task Status that differs in different entities, the workflow will help to see the whole task processing: d. There are several entities that are used on the EDP project: Story, Improvement, Task, Bug. Implement feature, improvement, fix and check the results on your own. If it is impossible to check the results of your work before the merge, verify all later. Create a Merge Request, for details, please refer to the Code Review Process . When committing, use the pattern: [EPMDEDP-JIRA Task Number]: commit type: Commit message. a. [EPMDEDP] - is the default part; b. JIRA Task Number - the number of your Jira task; c. commit type: feat : (new feature for the user, not a new feature for build script) fix : (bug fix for the user, not a fix to a build script) docs : (changes to the documentation) style : (formatting, missing semicolons, etc; no production code change) refactor : (refactoring production code, eg. renaming a variable) test : (adding missing tests, refactoring tests; no production code change) chore : (updating grunt tasks etc; no production code change) ! : (added to other commit types to mark breaking changes) For example: [ EPMDEDP - 0000 ]: feat ! : Job provisioner is responsible for the formation of Jenkinsfile BREAKING CHANGE : Job provisioner creates Jenkinsfile and configures it in Jenkins pipeline as a pipeline script . d. Commit message: brief, for example: [EPMDEDP-0000]: fix: Fix Gerrit plugin for Jenkins provisioning or descriptive, for example: [EPMDEDP-0000]: feat: Provide the ability to configure hadolint check *Add configuration files .hadolint.yaml and .hadolint.yml to stash Note Make sure there is a descriptive commit message for a breaking change Merge Request. For example: [EPMDEDP-0000]: feat!: Job provisioner is responsible for the formation of Jenkinsfile BREAKING CHANGE: Job provisioner creates Jenkinsfile and configures it in Jenkins pipeline as a pipeline script.","title":"Working Process"},{"location":"developer-guide/edp-workflow/#related-articles","text":"Conventional Commits Semantic Commit Messages Karma","title":"Related Articles"},{"location":"developer-guide/local-development/","text":"Local Development \u2693\ufe0e Requirements \u2693\ufe0e GoLang version higher than 1.13; Note The GOPATH and GOROOT environment variables should be added in PATH. PostgreSQL client version higher than 9.5; Configured access to the VCS; GoLand Intellij IDEA or another IDE. Start Operator \u2693\ufe0e In order to run the operator, follow the steps below: Clone repository; Open folder in GoLand Intellij IDEA, click the button and select the Go Build option: In Configuration tab, fill in the following: 3.1. In the Field field, indicate the path to the main.go file; 3.2. In the Working directory field, indicate the path to the operator; 3.3. In the Environment field, specify the platform name (OpenShift/Kubernetes); Create the PostgreSQL database, schema, and a user for the EDP Admin Console operator: Create database with a user: CREATE DATABASE edp-db WITH ENCODING 'UTF8'; CREATE USER postgres WITH PASSWORD 'password'; GRANT ALL PRIVILEGES ON DATABASE 'edp-db' to postgres; Create a schema: CREATE SCHEMA [ IF NOT EXISTS ] ' develop ' ; EDP Admin Console operator supports two modes for running: local and prod. For local deploy, modify edp-admin-console/conf/app.conf and set the following parameters: runmode = local [ local ] dbEnabled = true pgHost = localhost pgPort = 5432 pgDatabase = edp - db pgUser = postgres pgPassword = password edpName = develop Run go build main.go (Shift+F10); After the successful setup, follow the http://localhost:8080 URL address to check the result: Exceptional Cases \u2693\ufe0e After starting the Go build process, the following error will appear: go : finding github . com / openshift / api v3 .9.0 go : finding github . com / openshift / client - go v3 .9.0 go : errors parsing go . mod : C : \\ Users \\ << username >> \\ Desktop \\ EDP \\ edp - admin - console \\ go . mod : 36 : require github . com / openshift / api : version \"v3.9.0\" invalid : unknown revision v3 .9.0 Compilation finished with exit code 1 To resolve the issue, update the go dependency by applying the Golang command: go get github . com / openshift / api @v3 .9.0","title":"Local Development"},{"location":"developer-guide/local-development/#local-development","text":"","title":"Local Development"},{"location":"developer-guide/local-development/#requirements","text":"GoLang version higher than 1.13; Note The GOPATH and GOROOT environment variables should be added in PATH. PostgreSQL client version higher than 9.5; Configured access to the VCS; GoLand Intellij IDEA or another IDE.","title":"Requirements"},{"location":"developer-guide/local-development/#start-operator","text":"In order to run the operator, follow the steps below: Clone repository; Open folder in GoLand Intellij IDEA, click the button and select the Go Build option: In Configuration tab, fill in the following: 3.1. In the Field field, indicate the path to the main.go file; 3.2. In the Working directory field, indicate the path to the operator; 3.3. In the Environment field, specify the platform name (OpenShift/Kubernetes); Create the PostgreSQL database, schema, and a user for the EDP Admin Console operator: Create database with a user: CREATE DATABASE edp-db WITH ENCODING 'UTF8'; CREATE USER postgres WITH PASSWORD 'password'; GRANT ALL PRIVILEGES ON DATABASE 'edp-db' to postgres; Create a schema: CREATE SCHEMA [ IF NOT EXISTS ] ' develop ' ; EDP Admin Console operator supports two modes for running: local and prod. For local deploy, modify edp-admin-console/conf/app.conf and set the following parameters: runmode = local [ local ] dbEnabled = true pgHost = localhost pgPort = 5432 pgDatabase = edp - db pgUser = postgres pgPassword = password edpName = develop Run go build main.go (Shift+F10); After the successful setup, follow the http://localhost:8080 URL address to check the result:","title":"Start Operator"},{"location":"developer-guide/local-development/#exceptional-cases","text":"After starting the Go build process, the following error will appear: go : finding github . com / openshift / api v3 .9.0 go : finding github . com / openshift / client - go v3 .9.0 go : errors parsing go . mod : C : \\ Users \\ << username >> \\ Desktop \\ EDP \\ edp - admin - console \\ go . mod : 36 : require github . com / openshift / api : version \"v3.9.0\" invalid : unknown revision v3 .9.0 Compilation finished with exit code 1 To resolve the issue, update the go dependency by applying the Golang command: go get github . com / openshift / api @v3 .9.0","title":"Exceptional Cases"},{"location":"developer-guide/mk-docs-development/","text":"Documentation Flow \u2693\ufe0e This section defines necessary steps to start developing the EDP documentation in the MkDocs Framework. The framework presents a static site generator with documentation written in Markdown. All the docs are configured with a YAML configuration file. Note For more details on the framework, please refer to the MkDocs official website . There are two options for working with MkDocs: Work with MkDocs if Docker is installed Work with MkDocs if Docker is not installed Please see below the detailed description of each options and choose the one that suits you. MkDocs With Docker \u2693\ufe0e Prerequisites: Docker is installed. make utility is installed. Git is installed. Please refer to the Git downloads . To work with MkDocs, take the following steps: Clone the edp-install repository to your local folder. Run the following command: make docs Enter the localhost:8000 address in the browser and check that documentation pages are available. Open the file editor, navigate to edp-install->docs and make necessary changes. Check all the changes at localhost:8000. Create a merge request with changes. MkDocs Without Docker \u2693\ufe0e Prerequisites: Git is installed. Please refer to the Git downloads . Python 3.9.5 is installed. To work with MkDocs without Docker, take the following steps: Clone the edp-install repository to your local folder. Run the following command: pip install -r hack/mkdocs/requirements.txt Run the local development command: mkdocs serve --dev-addr 0.0.0.0:8000 Enter the localhost:8000 address in the browser and check that documentation pages are available. Open the file editor, navigate to edp-install->docs and make necessary changes. Check all the changes at localhost:8000. Create a merge request with changes.","title":"Documentation Flow"},{"location":"developer-guide/mk-docs-development/#documentation-flow","text":"This section defines necessary steps to start developing the EDP documentation in the MkDocs Framework. The framework presents a static site generator with documentation written in Markdown. All the docs are configured with a YAML configuration file. Note For more details on the framework, please refer to the MkDocs official website . There are two options for working with MkDocs: Work with MkDocs if Docker is installed Work with MkDocs if Docker is not installed Please see below the detailed description of each options and choose the one that suits you.","title":"Documentation Flow"},{"location":"developer-guide/mk-docs-development/#mkdocs-with-docker","text":"Prerequisites: Docker is installed. make utility is installed. Git is installed. Please refer to the Git downloads . To work with MkDocs, take the following steps: Clone the edp-install repository to your local folder. Run the following command: make docs Enter the localhost:8000 address in the browser and check that documentation pages are available. Open the file editor, navigate to edp-install->docs and make necessary changes. Check all the changes at localhost:8000. Create a merge request with changes.","title":"MkDocs With Docker"},{"location":"developer-guide/mk-docs-development/#mkdocs-without-docker","text":"Prerequisites: Git is installed. Please refer to the Git downloads . Python 3.9.5 is installed. To work with MkDocs without Docker, take the following steps: Clone the edp-install repository to your local folder. Run the following command: pip install -r hack/mkdocs/requirements.txt Run the local development command: mkdocs serve --dev-addr 0.0.0.0:8000 Enter the localhost:8000 address in the browser and check that documentation pages are available. Open the file editor, navigate to edp-install->docs and make necessary changes. Check all the changes at localhost:8000. Create a merge request with changes.","title":"MkDocs Without Docker"},{"location":"developer-guide/rest-api/","text":"EDP API \u2693\ufe0e Create Codebase Entity \u2693\ufe0e EDP allows you to create three codebase types: Application, Autotest and Library. There are also several strategy types for each codebase: Create, Clone and Import. Depending on the selected codebase type and the respective strategy, you should specify a different set of fields in a request. Note The Route, Database and VCS are optional fields. In accordance with the necessary deploy set, you have to add the necessary fields into request Request \u2693\ufe0e POST /api/v1/edp/codebase Application (Create) \u2693\ufe0e { \"name\": \"app01\", \"type\": \"application\", \"strategy\": \"create\", \"lang\": \"java\", \"framework\": \"springboot\", \"buildTool\": \"maven\", \"multiModule\": false, \"route\": { \"site\": \"api\", \"path\": \"/\" }, \"database\": { \"kind\": \"postgresql\", \"version\": \"postgres:9.6\", \"capacity\": \"1Gi\", \"storage\": \"efs\" }, \"description\": \"Description\", \"gitServer\": \"gerrit\", \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\", \"deploymentScript\": \"openshift-template\" } Application (Clone) \u2693\ufe0e { \" name \" : \" app01 \" , \" type \" : \" application \" , \" strategy \" : \" clone \" , \" lang \" : \" java \" , \" framework \" : \" springboot \" , \" buildTool \" : \" maven \" , \" multiModule \" : false , \" repository \" : { \" url \" : \" http(s)://git.sample.com/sample.git \" , // login and password are required only if repo is private \" login \" : \" login \" , \" password \" : \" password \" }, \" description \" : \" Description \" , \" gitServer \" : \" gerrit \" , \" jenkinsSlave \" : \" maven \" , \" jobProvisioning \" : \" default \" , \" deploymentScript \" : \" openshift-template \" } Application (Import) \u2693\ufe0e { \"type\": \"application\", \"strategy\": \"import\", \"lang\": \"java\", \"framework\": \"springboot\", \"buildTool\": \"maven\", \"multiModule\": false, \"description\": \"Description\", \"gitServer\": \"git-epam\", \"gitUrlPath\": \"/relative/path/to/repo\", \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\", \"deploymentScript\": \"openshift-template\" } Autotests (Clone) \u2693\ufe0e { \" name \" : \" aut01 \" , \" type \" : \" autotests \" , \" strategy \" : \" clone \" , \" lang \" : \" java \" , \" framework \" : \" springboot \" , \" buildTool \" : \" maven \" , \" testReportFramework \" : \" allure \" , \" repository \" : { \" url \" : \" http(s)://git.sample.com/sample.git \" , // login and password are required only if repo is private \" login \" : \" login \" , \" password \" : \" password \" }, \" description \" : \" Description \" , \" jenkinsSlave \" : \" maven \" , \" jobProvisioning \" : \" default \" } Autotests (Import) \u2693\ufe0e { \"type\": \"autotests\", \"strategy\": \"import\", \"lang\": \"java\", \"framework\": \"springboot\", \"buildTool\": \"maven\", \"testReportFramework\": \"allure\", \"description\": \"Description\", \"gitServer\": \"git-epam\", \"gitRelativePath\": \"/relative/path/to/repo\", \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\" } Library (Create) \u2693\ufe0e { \"name\": \"lib01\", \"type\": \"library\", \"strategy\": \"create\", \"lang\": \"java\", \"buildTool\": \"maven\", \"multiModule\": false, \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\", } Library (Clone) \u2693\ufe0e { \" name \" : \" lib01 \" , \" type \" : \" library \" , \" strategy \" : \" clone \" , \" lang \" : \" java \" , \" buildTool \" : \" maven \" , \" multiModule \" : false , \" repository \" : { \" url \" : \" http(s)://git.sample.com/sample.git \" , // login and password are required only if repo is private \" login \" : \" login \" , \" password \" : \" password \" }, \" vcs \" : null , \" jenkinsSlave \" : \" maven \" , \" jobProvisioning \" : \" default \" , } Library (Import) \u2693\ufe0e { \"type\": \"library\", \"strategy\": \"import\", \"lang\": \"java\", \"buildTool\": \"maven\", \"multiModule\": false, \"gitServer\": \"git-epam\", \"gitUrlPath\": \"/relative/path/to/repo\", \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\", } Response \u2693\ufe0e Status 200 OK Get Codebase by Name \u2693\ufe0e Request \u2693\ufe0e GET /api/v1/edp/codebase/{codebaseName} example: localhost/api/v1/edp/codebase/app01 Response \u2693\ufe0e Status 200 OK { \"id\" : 1 , \"name\" : \"app01\" , \"language\" : \"java\" , \"build_tool\" : \"maven\" , \"framework\" : \"springboot\" , \"strategy\" : \"create\" , \"git_url\" : \"\" , \"route_site\" : \"api\" , \"route_path\" : \"/\" , \"type\" : \"application\" , \"status\" : \"active\" , \"testReportFramework\" : \"\" , \"description\" : \"Description\" , \"codebase_branch\" : [ { \"id\" : 1 , \"branchName\" : \"master\" , \"from_commit\" : \"\" , \"status\" : \"active\" , \"branchLink\" : \"\" , \"jenkinsLink\" : \"\" , \"appName\" : \"\" , \"codebaseDockerStream\" : null } ], \"gitServer\" : \"gerrit\" , \"gitProjectPath\" : null , \"jenkinsSlave\" : \"maven\" , \"jobProvisioning\" : \"default\" , \"deploymentScript\" : \"openshift-template\" } Get All Codebases \u2693\ufe0e Request \u2693\ufe0e GET /api/v1/edp/codebase?type={codebaseType} example: localhost/api/v1/edp/codebase?type=application Response \u2693\ufe0e Status 200 OK [ { \"id\" : 1 , \"name\" : \"app01\" , \"language\" : \"java\" , \"build_tool\" : \"maven\" , \"framework\" : \"springboot\" , \"strategy\" : \"create\" , \"git_url\" : \"\" , \"route_site\" : \"api\" , \"route_path\" : \"/\" , \"type\" : \"application\" , \"status\" : \"active\" , \"testReportFramework\" : \"\" , \"description\" : \"Description\" , \"codebase_branch\" : [ { \"id\" : 1 , \"branchName\" : \"master\" , \"from_commit\" : \"\" , \"status\" : \"active\" , \"branchLink\" : \"\" , \"jenkinsLink\" : \"\" , \"appName\" : \"\" , \"codebaseDockerStream\" : [ { \"id\" : 1 , \"ocImageStreamName\" : \"app01-master\" , \"imageLink\" : \"\" , \"jenkinsLink\" : \"\" } ] } ], \"gitServer\" : \"gerrit\" , \"gitProjectPath\" : null , \"jenkinsSlave\" : \"maven\" , \"jobProvisioning\" : \"\" , \"deploymentScript\" : \"openshift-template\" }, { \"id\" : 2 , \"name\" : \"app02\" , \"language\" : \"java\" , \"build_tool\" : \"maven\" , \"framework\" : \"springboot\" , \"strategy\" : \"create\" , \"git_url\" : \"\" , \"route_site\" : \"app\" , \"route_path\" : \"/\" , \"type\" : \"application\" , \"status\" : \"failed\" , \"testReportFramework\" : \"\" , \"description\" : \"\" , \"codebase_branch\" : [ { \"id\" : 2 , \"branchName\" : \"master\" , \"from_commit\" : \"\" , \"status\" : \"inactive\" , \"branchLink\" : \"\" , \"jenkinsLink\" : \"\" , \"appName\" : \"\" , \"codebaseDockerStream\" : [ { \"id\" : 2 , \"ocImageStreamName\" : \"app02-master\" , \"imageLink\" : \"\" , \"jenkinsLink\" : \"\" } ] } ], \"gitServer\" : \"gerrit\" , \"gitProjectPath\" : null , \"jenkinsSlave\" : \"maven\" , \"jobProvisioning\" : \"\" , \"deploymentScript\" : \"openshift-template\" } ] Create CD Pipeline Entity \u2693\ufe0e Request \u2693\ufe0e POST /api/v1/edp/cd-pipeline { \"name\":\"pipe1\", \"applications\":[ { \"appName\":\"app01\", \"inputDockerStream\":\"app01-master\" } ], \"stages\":[ { \"name\":\"sit\", \"description\":\"description-sit\", \"qualityGateType\":\"manual\", \"stepName\":\"approve\", \"triggerType\":\"manual\", \"order\":0, \"qualityGates\": [ { \"qualityGateType\":\"manual\", \"stepName\":\"step-one-one\", \"autotestName\": null, \"branchName\": null }, { \"qualityGateType\":\"manual\", \"stepName\":\"step-two-two\", \"autotestName\": null, \"branchName\": null } ] } ] } Response \u2693\ufe0e Status 200 OK Get CD Pipeline Entity by Name \u2693\ufe0e Request \u2693\ufe0e GET /api/v1/edp/cd-pipeline/{cdPipelineName} example: localhost/api/v1/edp/cd-pipeline/pipe1 Response \u2693\ufe0e Status 200 OK { \"id\": 1, \"name\": \"pipe1\", \"status\": \"active\", \"jenkinsLink\": \"\", \"codebaseBranches\": [ { \"id\": 1, \"branchName\": \"master\", \"from_commit\": \"\", \"status\": \"active\", \"branchLink\": \"\", \"jenkinsLink\": \"\", \"appName\": \"java-springboot-helloworld\", \"codebaseDockerStream\": [ { \"id\": 1, \"ocImageStreamName\": \"java-springboot-helloworld-master\", \"imageLink\": \"\", \"jenkinsLink\": \"\" } ] } ], \"stages\": [ { \"id\": 1, \"name\": \"sit\", \"description\": \"sit\", \"triggerType\": \"manual\", \"order\": 0, \"platformProjectLink\": \"\", \"platformProjectName\": env-am-test-deploy-sit\", \"qualityGates\": [ { \"id\": 1, \"qualityGateType\": \"manual\", \"stepName\": \"manual\", \"cdStageId\": 1, \"autotest\": null, \"codebaseBranch\": null } ], \"source\": { \"type\": \"library\", \"library\": { \"name\": \"lib01\", \"branch\": \"master\" } } } ], \"services\": [], \"applicationsToPromote\": [ \"java-springboot-helloworld\" ] } Get CD Stage Entity by Pipeline and Stage Names \u2693\ufe0e Request \u2693\ufe0e GET /api/v1/edp/cd-pipeline/{cdPipelineName}/stage/{stageName} example: `localhost/api/v1/edp/cd-pipeline/pipe1/stage/sit Response \u2693\ufe0e { \"name\": \"sit\", \"cdPipeline\": \"pipe1\", \"description\": \"sit\", \"triggerType\": \"manual\", \"order\": \"0\", \"applications\": [ { \"name\": \"java-springboot-helloworld\", \"branchName\": \"master\", \"inputIs\": \"java-springboot-helloworld-master\", \"outputIs\": \"am-test-deploy-sit-java-springboot-helloworld-verified\" } ], \"qualityGates\": [ { \"id\": 1, \"qualityGateType\": \"manual\", \"stepName\": \"manual\", \"cdStageId\": 1, \"autotest\": null, \"codebaseBranch\": null } ] } Update CD Pipeline Entity \u2693\ufe0e Request \u2693\ufe0e PUT /api/v1/edp/cd-pipeline/{cdPipelineName}/update example: localhost/api/v1/edp/cd-pipeline/pipe1/update Change Set of Applications \u2693\ufe0e { \"applications\":[ { \"appName\":\"app01\", \"inputDockerStream\":\"app01-master\" }, { \"appName\":\"app02\", \"inputDockerStream\":\"app02\" } ] } Response \u2693\ufe0e 204 No Cont ent Change Set of Stages \u2693\ufe0e { \"stages\": [ { \"name\": \"sit\", \"description\": \"sit\", \"triggerType\": \"manual\", \"order\": 0, \"platformProjectLink\": \"\", \"platformProjectName\": env-deploy-sit\", \"qualityGates\": [ { \"id\": 1, \"qualityGateType\": \"manual\", \"stepName\": \"manual\", \"cdStageId\": 1, \"autotest\": null, \"codebaseBranch\": null } ], \"source\": { \"type\": \"library\", \"library\": { \"name\": \"lib01\", \"branch\": \"master\" } } } ] } Response \u2693\ufe0e 204 No Cont ent","title":"EDP API"},{"location":"developer-guide/rest-api/#edp-api","text":"","title":"EDP API"},{"location":"developer-guide/rest-api/#create-codebase-entity","text":"EDP allows you to create three codebase types: Application, Autotest and Library. There are also several strategy types for each codebase: Create, Clone and Import. Depending on the selected codebase type and the respective strategy, you should specify a different set of fields in a request. Note The Route, Database and VCS are optional fields. In accordance with the necessary deploy set, you have to add the necessary fields into request","title":"Create Codebase Entity"},{"location":"developer-guide/rest-api/#request","text":"POST /api/v1/edp/codebase","title":"Request"},{"location":"developer-guide/rest-api/#application-create","text":"{ \"name\": \"app01\", \"type\": \"application\", \"strategy\": \"create\", \"lang\": \"java\", \"framework\": \"springboot\", \"buildTool\": \"maven\", \"multiModule\": false, \"route\": { \"site\": \"api\", \"path\": \"/\" }, \"database\": { \"kind\": \"postgresql\", \"version\": \"postgres:9.6\", \"capacity\": \"1Gi\", \"storage\": \"efs\" }, \"description\": \"Description\", \"gitServer\": \"gerrit\", \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\", \"deploymentScript\": \"openshift-template\" }","title":"Application (Create)"},{"location":"developer-guide/rest-api/#application-clone","text":"{ \" name \" : \" app01 \" , \" type \" : \" application \" , \" strategy \" : \" clone \" , \" lang \" : \" java \" , \" framework \" : \" springboot \" , \" buildTool \" : \" maven \" , \" multiModule \" : false , \" repository \" : { \" url \" : \" http(s)://git.sample.com/sample.git \" , // login and password are required only if repo is private \" login \" : \" login \" , \" password \" : \" password \" }, \" description \" : \" Description \" , \" gitServer \" : \" gerrit \" , \" jenkinsSlave \" : \" maven \" , \" jobProvisioning \" : \" default \" , \" deploymentScript \" : \" openshift-template \" }","title":"Application (Clone)"},{"location":"developer-guide/rest-api/#application-import","text":"{ \"type\": \"application\", \"strategy\": \"import\", \"lang\": \"java\", \"framework\": \"springboot\", \"buildTool\": \"maven\", \"multiModule\": false, \"description\": \"Description\", \"gitServer\": \"git-epam\", \"gitUrlPath\": \"/relative/path/to/repo\", \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\", \"deploymentScript\": \"openshift-template\" }","title":"Application (Import)"},{"location":"developer-guide/rest-api/#autotests-clone","text":"{ \" name \" : \" aut01 \" , \" type \" : \" autotests \" , \" strategy \" : \" clone \" , \" lang \" : \" java \" , \" framework \" : \" springboot \" , \" buildTool \" : \" maven \" , \" testReportFramework \" : \" allure \" , \" repository \" : { \" url \" : \" http(s)://git.sample.com/sample.git \" , // login and password are required only if repo is private \" login \" : \" login \" , \" password \" : \" password \" }, \" description \" : \" Description \" , \" jenkinsSlave \" : \" maven \" , \" jobProvisioning \" : \" default \" }","title":"Autotests (Clone)"},{"location":"developer-guide/rest-api/#autotests-import","text":"{ \"type\": \"autotests\", \"strategy\": \"import\", \"lang\": \"java\", \"framework\": \"springboot\", \"buildTool\": \"maven\", \"testReportFramework\": \"allure\", \"description\": \"Description\", \"gitServer\": \"git-epam\", \"gitRelativePath\": \"/relative/path/to/repo\", \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\" }","title":"Autotests (Import)"},{"location":"developer-guide/rest-api/#library-create","text":"{ \"name\": \"lib01\", \"type\": \"library\", \"strategy\": \"create\", \"lang\": \"java\", \"buildTool\": \"maven\", \"multiModule\": false, \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\", }","title":"Library (Create)"},{"location":"developer-guide/rest-api/#library-clone","text":"{ \" name \" : \" lib01 \" , \" type \" : \" library \" , \" strategy \" : \" clone \" , \" lang \" : \" java \" , \" buildTool \" : \" maven \" , \" multiModule \" : false , \" repository \" : { \" url \" : \" http(s)://git.sample.com/sample.git \" , // login and password are required only if repo is private \" login \" : \" login \" , \" password \" : \" password \" }, \" vcs \" : null , \" jenkinsSlave \" : \" maven \" , \" jobProvisioning \" : \" default \" , }","title":"Library (Clone)"},{"location":"developer-guide/rest-api/#library-import","text":"{ \"type\": \"library\", \"strategy\": \"import\", \"lang\": \"java\", \"buildTool\": \"maven\", \"multiModule\": false, \"gitServer\": \"git-epam\", \"gitUrlPath\": \"/relative/path/to/repo\", \"jenkinsSlave\": \"maven\", \"jobProvisioning\": \"default\", }","title":"Library (Import)"},{"location":"developer-guide/rest-api/#response","text":"Status 200 OK","title":"Response"},{"location":"developer-guide/rest-api/#get-codebase-by-name","text":"","title":"Get Codebase by Name"},{"location":"developer-guide/rest-api/#request_1","text":"GET /api/v1/edp/codebase/{codebaseName} example: localhost/api/v1/edp/codebase/app01","title":"Request"},{"location":"developer-guide/rest-api/#response_1","text":"Status 200 OK { \"id\" : 1 , \"name\" : \"app01\" , \"language\" : \"java\" , \"build_tool\" : \"maven\" , \"framework\" : \"springboot\" , \"strategy\" : \"create\" , \"git_url\" : \"\" , \"route_site\" : \"api\" , \"route_path\" : \"/\" , \"type\" : \"application\" , \"status\" : \"active\" , \"testReportFramework\" : \"\" , \"description\" : \"Description\" , \"codebase_branch\" : [ { \"id\" : 1 , \"branchName\" : \"master\" , \"from_commit\" : \"\" , \"status\" : \"active\" , \"branchLink\" : \"\" , \"jenkinsLink\" : \"\" , \"appName\" : \"\" , \"codebaseDockerStream\" : null } ], \"gitServer\" : \"gerrit\" , \"gitProjectPath\" : null , \"jenkinsSlave\" : \"maven\" , \"jobProvisioning\" : \"default\" , \"deploymentScript\" : \"openshift-template\" }","title":"Response"},{"location":"developer-guide/rest-api/#get-all-codebases","text":"","title":"Get All Codebases"},{"location":"developer-guide/rest-api/#request_2","text":"GET /api/v1/edp/codebase?type={codebaseType} example: localhost/api/v1/edp/codebase?type=application","title":"Request"},{"location":"developer-guide/rest-api/#response_2","text":"Status 200 OK [ { \"id\" : 1 , \"name\" : \"app01\" , \"language\" : \"java\" , \"build_tool\" : \"maven\" , \"framework\" : \"springboot\" , \"strategy\" : \"create\" , \"git_url\" : \"\" , \"route_site\" : \"api\" , \"route_path\" : \"/\" , \"type\" : \"application\" , \"status\" : \"active\" , \"testReportFramework\" : \"\" , \"description\" : \"Description\" , \"codebase_branch\" : [ { \"id\" : 1 , \"branchName\" : \"master\" , \"from_commit\" : \"\" , \"status\" : \"active\" , \"branchLink\" : \"\" , \"jenkinsLink\" : \"\" , \"appName\" : \"\" , \"codebaseDockerStream\" : [ { \"id\" : 1 , \"ocImageStreamName\" : \"app01-master\" , \"imageLink\" : \"\" , \"jenkinsLink\" : \"\" } ] } ], \"gitServer\" : \"gerrit\" , \"gitProjectPath\" : null , \"jenkinsSlave\" : \"maven\" , \"jobProvisioning\" : \"\" , \"deploymentScript\" : \"openshift-template\" }, { \"id\" : 2 , \"name\" : \"app02\" , \"language\" : \"java\" , \"build_tool\" : \"maven\" , \"framework\" : \"springboot\" , \"strategy\" : \"create\" , \"git_url\" : \"\" , \"route_site\" : \"app\" , \"route_path\" : \"/\" , \"type\" : \"application\" , \"status\" : \"failed\" , \"testReportFramework\" : \"\" , \"description\" : \"\" , \"codebase_branch\" : [ { \"id\" : 2 , \"branchName\" : \"master\" , \"from_commit\" : \"\" , \"status\" : \"inactive\" , \"branchLink\" : \"\" , \"jenkinsLink\" : \"\" , \"appName\" : \"\" , \"codebaseDockerStream\" : [ { \"id\" : 2 , \"ocImageStreamName\" : \"app02-master\" , \"imageLink\" : \"\" , \"jenkinsLink\" : \"\" } ] } ], \"gitServer\" : \"gerrit\" , \"gitProjectPath\" : null , \"jenkinsSlave\" : \"maven\" , \"jobProvisioning\" : \"\" , \"deploymentScript\" : \"openshift-template\" } ]","title":"Response"},{"location":"developer-guide/rest-api/#create-cd-pipeline-entity","text":"","title":"Create CD Pipeline Entity"},{"location":"developer-guide/rest-api/#request_3","text":"POST /api/v1/edp/cd-pipeline { \"name\":\"pipe1\", \"applications\":[ { \"appName\":\"app01\", \"inputDockerStream\":\"app01-master\" } ], \"stages\":[ { \"name\":\"sit\", \"description\":\"description-sit\", \"qualityGateType\":\"manual\", \"stepName\":\"approve\", \"triggerType\":\"manual\", \"order\":0, \"qualityGates\": [ { \"qualityGateType\":\"manual\", \"stepName\":\"step-one-one\", \"autotestName\": null, \"branchName\": null }, { \"qualityGateType\":\"manual\", \"stepName\":\"step-two-two\", \"autotestName\": null, \"branchName\": null } ] } ] }","title":"Request"},{"location":"developer-guide/rest-api/#response_3","text":"Status 200 OK","title":"Response"},{"location":"developer-guide/rest-api/#get-cd-pipeline-entity-by-name","text":"","title":"Get CD Pipeline Entity by Name"},{"location":"developer-guide/rest-api/#request_4","text":"GET /api/v1/edp/cd-pipeline/{cdPipelineName} example: localhost/api/v1/edp/cd-pipeline/pipe1","title":"Request"},{"location":"developer-guide/rest-api/#response_4","text":"Status 200 OK { \"id\": 1, \"name\": \"pipe1\", \"status\": \"active\", \"jenkinsLink\": \"\", \"codebaseBranches\": [ { \"id\": 1, \"branchName\": \"master\", \"from_commit\": \"\", \"status\": \"active\", \"branchLink\": \"\", \"jenkinsLink\": \"\", \"appName\": \"java-springboot-helloworld\", \"codebaseDockerStream\": [ { \"id\": 1, \"ocImageStreamName\": \"java-springboot-helloworld-master\", \"imageLink\": \"\", \"jenkinsLink\": \"\" } ] } ], \"stages\": [ { \"id\": 1, \"name\": \"sit\", \"description\": \"sit\", \"triggerType\": \"manual\", \"order\": 0, \"platformProjectLink\": \"\", \"platformProjectName\": env-am-test-deploy-sit\", \"qualityGates\": [ { \"id\": 1, \"qualityGateType\": \"manual\", \"stepName\": \"manual\", \"cdStageId\": 1, \"autotest\": null, \"codebaseBranch\": null } ], \"source\": { \"type\": \"library\", \"library\": { \"name\": \"lib01\", \"branch\": \"master\" } } } ], \"services\": [], \"applicationsToPromote\": [ \"java-springboot-helloworld\" ] }","title":"Response"},{"location":"developer-guide/rest-api/#get-cd-stage-entity-by-pipeline-and-stage-names","text":"","title":"Get CD Stage Entity by Pipeline and Stage Names"},{"location":"developer-guide/rest-api/#request_5","text":"GET /api/v1/edp/cd-pipeline/{cdPipelineName}/stage/{stageName} example: `localhost/api/v1/edp/cd-pipeline/pipe1/stage/sit","title":"Request"},{"location":"developer-guide/rest-api/#response_5","text":"{ \"name\": \"sit\", \"cdPipeline\": \"pipe1\", \"description\": \"sit\", \"triggerType\": \"manual\", \"order\": \"0\", \"applications\": [ { \"name\": \"java-springboot-helloworld\", \"branchName\": \"master\", \"inputIs\": \"java-springboot-helloworld-master\", \"outputIs\": \"am-test-deploy-sit-java-springboot-helloworld-verified\" } ], \"qualityGates\": [ { \"id\": 1, \"qualityGateType\": \"manual\", \"stepName\": \"manual\", \"cdStageId\": 1, \"autotest\": null, \"codebaseBranch\": null } ] }","title":"Response"},{"location":"developer-guide/rest-api/#update-cd-pipeline-entity","text":"","title":"Update CD Pipeline Entity"},{"location":"developer-guide/rest-api/#request_6","text":"PUT /api/v1/edp/cd-pipeline/{cdPipelineName}/update example: localhost/api/v1/edp/cd-pipeline/pipe1/update","title":"Request"},{"location":"developer-guide/rest-api/#change-set-of-applications","text":"{ \"applications\":[ { \"appName\":\"app01\", \"inputDockerStream\":\"app01-master\" }, { \"appName\":\"app02\", \"inputDockerStream\":\"app02\" } ] }","title":"Change Set of Applications"},{"location":"developer-guide/rest-api/#response_6","text":"204 No Cont ent","title":"Response"},{"location":"developer-guide/rest-api/#change-set-of-stages","text":"{ \"stages\": [ { \"name\": \"sit\", \"description\": \"sit\", \"triggerType\": \"manual\", \"order\": 0, \"platformProjectLink\": \"\", \"platformProjectName\": env-deploy-sit\", \"qualityGates\": [ { \"id\": 1, \"qualityGateType\": \"manual\", \"stepName\": \"manual\", \"cdStageId\": 1, \"autotest\": null, \"codebaseBranch\": null } ], \"source\": { \"type\": \"library\", \"library\": { \"name\": \"lib01\", \"branch\": \"master\" } } } ] }","title":"Change Set of Stages"},{"location":"developer-guide/rest-api/#response_7","text":"204 No Cont ent","title":"Response"},{"location":"operator-guide/","text":"Overview \u2693\ufe0e The EDP Operator guide is intended for DevOps and provides information on EDP installation, configuration and customization, as well as the platform support. Inspect the documentation to adjust the EPAM Delivery Platform according to your business needs: The Installation section provides the prerequisites for EDP installation, including Kubernetes or OpenShift cluster setup, Keycloak , Kiosk and Ingress-nginx setup and the subsequent deployment of EPAM Delivery Platform . The Configuration section indicates the options to set the project with adding a code language , backup , VCS import strategy , managing Jenkins pipelines , and logging . The Integration section comprises the AWS , GitHub , GitLab , and Jira integration options. The Tutorials section provides information on working with various aspects, for example, deploying AWS EKS cluster , managing Jenkins agent , etc.","title":"Overview"},{"location":"operator-guide/#overview","text":"The EDP Operator guide is intended for DevOps and provides information on EDP installation, configuration and customization, as well as the platform support. Inspect the documentation to adjust the EPAM Delivery Platform according to your business needs: The Installation section provides the prerequisites for EDP installation, including Kubernetes or OpenShift cluster setup, Keycloak , Kiosk and Ingress-nginx setup and the subsequent deployment of EPAM Delivery Platform . The Configuration section indicates the options to set the project with adding a code language , backup , VCS import strategy , managing Jenkins pipelines , and logging . The Integration section comprises the AWS , GitHub , GitLab , and Jira integration options. The Tutorials section provides information on working with various aspects, for example, deploying AWS EKS cluster , managing Jenkins agent , etc.","title":"Overview"},{"location":"operator-guide/add-jenkins-agent/","text":"Manage Jenkins Agent \u2693\ufe0e Inspect the main steps to add and update Jenkins agent. Create/Update Jenkins Agent \u2693\ufe0e Every Jenkins agent is based on epamedp/edp-jenkins-base-agent. Check DockerHub for the latest version. Use it to create a new agent (or update an old one). See the example with Dockerfile of gradle-java11-agent below: View: Dockerfile # Copyright 2021 EPAM Systems . # Licensed under the Apache License , Version 2 . 0 ( the \" License \" ) ; # you may not use this file except in compliance with the License . # You may obtain a copy of the License at # http : // www . apache . org / licenses / LICENSE - 2 . 0 # Unless required by applicable law or agreed to in writing , software # distributed under the License is distributed on an \" AS IS \" BASIS , # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . # See the License for the specific language governing permissions and # limitations under the License . FROM epamedp / edp - jenkins - base - agent : 1 . 0 . 1 SHELL [ \" /bin/bash \" , \" -o \" , \" pipefail \" , \" -c \" ] ENV GRADLE_VERSION = 7 . 1 \\ PATH = $ PATH : / opt / gradle / bin # Install Gradle RUN curl - skL - o / tmp / gradle - bin . zip https : // services . gradle . org / distributions / gradle - $ GRADLE_VERSION - bin . zip && \\ mkdir - p / opt / gradle && \\ unzip - q / tmp / gradle - bin . zip - d / opt / gradle && \\ ln - sf / opt / gradle / gradle - $ GRADLE_VERSION / bin / gradle / usr / local / bin / gradle RUN yum install java - 11 - openjdk - devel . x86_64 - y && \\ rpm - V java - 11 - openjdk - devel . x86_64 && \\ yum clean all - y WORKDIR $ HOME / . gradle RUN chown - R \" 1001:0 \" \" $HOME \" && \\ chmod - R \" g+rw \" \" $HOME \" USER 1001 After the Docker agent update/creation, build and load the image into the project registry (e.g. DockerHub , AWS ECR , etc.). Add Jenkins Agent Configuration \u2693\ufe0e To add a new Jenkins agent, take the steps below: Run the following command. Please be aware that \u2039edp-project\u203a is the name of the EDP tenant. kubectl edit configmap jenkins-slaves -n <edp-project> Note On an OpenShift cluster, run the oc command instead of kubectl one. Add new agent template. View: ConfigMap jenkins-slaves data: docker-template: |- <org.csanchez.jenkins.plugins.kubernetes.PodTemplate> <inheritFrom></inheritFrom> <name> docker </name> <namespace></namespace> <privileged> false </privileged> <alwaysPullImage> false </alwaysPullImage> <instanceCap> 2147483647 </instanceCap> <slaveConnectTimeout> 100 </slaveConnectTimeout> <idleMinutes> 5 </idleMinutes> <activeDeadlineSeconds> 0 </activeDeadlineSeconds> <label> docker </label> <serviceAccount> jenkins </serviceAccount> <nodeSelector> beta.kubernetes.io/os=linux </nodeSelector> <nodeUsageMode> NORMAL </nodeUsageMode> <workspaceVolume class= \"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\" > <memory> false </memory> </workspaceVolume> <volumes/> <containers> <org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> <name> jnlp </name> <image> IMAGE_NAME:IMAGE_TAG </image> <privileged> false </privileged> <alwaysPullImage> false </alwaysPullImage> <workingDir> /tmp </workingDir> <command></command> <args> ${ computer . jnlpmac } ${ computer . name } </args> <ttyEnabled> false </ttyEnabled> <resourceRequestCpu></resourceRequestCpu> <resourceRequestMemory></resourceRequestMemory> <resourceLimitCpu></resourceLimitCpu> <resourceLimitMemory></resourceLimitMemory> <envVars> <org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> <key> JAVA_TOOL_OPTIONS </key> <value> -XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true </value> </org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> </envVars> <ports/> </org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> </containers> <envVars/> <annotations/> <imagePullSecrets/> <podRetention class= \"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/ > </org.csanchez.jenkins.plugins.kubernetes.PodTemplate> Note The name and label properties should be unique( docker in the example above). Insert image name and tag instead of IMAGE_NAME:IMAGE_TAG . Open Jenkins to ensure that everything is added correctly. Click the Manage Jenkins option, navigate to the Manage Nodes and Clouds -> Configure Clouds -> Kubernetes -> Pod Templates... , and scroll down to find new Jenkins agent Pod Template details... : As a result, the newly added Jenkins agent will be available in the Advanced Settings block of the Admin Console tool during the codebase creation: Modify Existing Agent Configuration \u2693\ufe0e If your application is integrated with EDP, take the steps below to change an existing agent configuration: Run the following command. Please be aware that \u2039edp-project\u203a is the name of the EDP tenant. kubectl edit configmap jenkins-slaves -n <edp-project> Note On an OpenShift cluster, run the oc command instead of kubectl one. Find the agent template in use and change and change the parameters. Open Jenkins and check the correct addition. Click the Manage Jenkins option, navigate to the Manage Nodes and Clouds -> Configure Clouds -> Kubernetes -> Pod Templates... , and scroll down to Pod Template details... with the necessary data.","title":"Manage Jenkins Agent"},{"location":"operator-guide/add-jenkins-agent/#manage-jenkins-agent","text":"Inspect the main steps to add and update Jenkins agent.","title":"Manage Jenkins Agent"},{"location":"operator-guide/add-jenkins-agent/#createupdate-jenkins-agent","text":"Every Jenkins agent is based on epamedp/edp-jenkins-base-agent. Check DockerHub for the latest version. Use it to create a new agent (or update an old one). See the example with Dockerfile of gradle-java11-agent below: View: Dockerfile # Copyright 2021 EPAM Systems . # Licensed under the Apache License , Version 2 . 0 ( the \" License \" ) ; # you may not use this file except in compliance with the License . # You may obtain a copy of the License at # http : // www . apache . org / licenses / LICENSE - 2 . 0 # Unless required by applicable law or agreed to in writing , software # distributed under the License is distributed on an \" AS IS \" BASIS , # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . # See the License for the specific language governing permissions and # limitations under the License . FROM epamedp / edp - jenkins - base - agent : 1 . 0 . 1 SHELL [ \" /bin/bash \" , \" -o \" , \" pipefail \" , \" -c \" ] ENV GRADLE_VERSION = 7 . 1 \\ PATH = $ PATH : / opt / gradle / bin # Install Gradle RUN curl - skL - o / tmp / gradle - bin . zip https : // services . gradle . org / distributions / gradle - $ GRADLE_VERSION - bin . zip && \\ mkdir - p / opt / gradle && \\ unzip - q / tmp / gradle - bin . zip - d / opt / gradle && \\ ln - sf / opt / gradle / gradle - $ GRADLE_VERSION / bin / gradle / usr / local / bin / gradle RUN yum install java - 11 - openjdk - devel . x86_64 - y && \\ rpm - V java - 11 - openjdk - devel . x86_64 && \\ yum clean all - y WORKDIR $ HOME / . gradle RUN chown - R \" 1001:0 \" \" $HOME \" && \\ chmod - R \" g+rw \" \" $HOME \" USER 1001 After the Docker agent update/creation, build and load the image into the project registry (e.g. DockerHub , AWS ECR , etc.).","title":"Create/Update Jenkins Agent"},{"location":"operator-guide/add-jenkins-agent/#add-jenkins-agent-configuration","text":"To add a new Jenkins agent, take the steps below: Run the following command. Please be aware that \u2039edp-project\u203a is the name of the EDP tenant. kubectl edit configmap jenkins-slaves -n <edp-project> Note On an OpenShift cluster, run the oc command instead of kubectl one. Add new agent template. View: ConfigMap jenkins-slaves data: docker-template: |- <org.csanchez.jenkins.plugins.kubernetes.PodTemplate> <inheritFrom></inheritFrom> <name> docker </name> <namespace></namespace> <privileged> false </privileged> <alwaysPullImage> false </alwaysPullImage> <instanceCap> 2147483647 </instanceCap> <slaveConnectTimeout> 100 </slaveConnectTimeout> <idleMinutes> 5 </idleMinutes> <activeDeadlineSeconds> 0 </activeDeadlineSeconds> <label> docker </label> <serviceAccount> jenkins </serviceAccount> <nodeSelector> beta.kubernetes.io/os=linux </nodeSelector> <nodeUsageMode> NORMAL </nodeUsageMode> <workspaceVolume class= \"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\" > <memory> false </memory> </workspaceVolume> <volumes/> <containers> <org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> <name> jnlp </name> <image> IMAGE_NAME:IMAGE_TAG </image> <privileged> false </privileged> <alwaysPullImage> false </alwaysPullImage> <workingDir> /tmp </workingDir> <command></command> <args> ${ computer . jnlpmac } ${ computer . name } </args> <ttyEnabled> false </ttyEnabled> <resourceRequestCpu></resourceRequestCpu> <resourceRequestMemory></resourceRequestMemory> <resourceLimitCpu></resourceLimitCpu> <resourceLimitMemory></resourceLimitMemory> <envVars> <org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> <key> JAVA_TOOL_OPTIONS </key> <value> -XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true </value> </org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> </envVars> <ports/> </org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> </containers> <envVars/> <annotations/> <imagePullSecrets/> <podRetention class= \"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/ > </org.csanchez.jenkins.plugins.kubernetes.PodTemplate> Note The name and label properties should be unique( docker in the example above). Insert image name and tag instead of IMAGE_NAME:IMAGE_TAG . Open Jenkins to ensure that everything is added correctly. Click the Manage Jenkins option, navigate to the Manage Nodes and Clouds -> Configure Clouds -> Kubernetes -> Pod Templates... , and scroll down to find new Jenkins agent Pod Template details... : As a result, the newly added Jenkins agent will be available in the Advanced Settings block of the Admin Console tool during the codebase creation:","title":"Add Jenkins Agent Configuration"},{"location":"operator-guide/add-jenkins-agent/#modify-existing-agent-configuration","text":"If your application is integrated with EDP, take the steps below to change an existing agent configuration: Run the following command. Please be aware that \u2039edp-project\u203a is the name of the EDP tenant. kubectl edit configmap jenkins-slaves -n <edp-project> Note On an OpenShift cluster, run the oc command instead of kubectl one. Find the agent template in use and change and change the parameters. Open Jenkins and check the correct addition. Click the Manage Jenkins option, navigate to the Manage Nodes and Clouds -> Configure Clouds -> Kubernetes -> Pod Templates... , and scroll down to Pod Template details... with the necessary data.","title":"Modify Existing Agent Configuration"},{"location":"operator-guide/add-other-code-language/","text":"Add Other Code Language \u2693\ufe0e There is an ability to extend the default code languages when creating a codebase with the Clone or Import strategy. Warning The Create strategy does not allow to customize the default code language set. To customize the Build Tool list, perform the following: Edit the edp-admin-console deployment by adding the necessary code language into the BUILD TOOLS field: kubectl edit deployment edp-admin-console -n <edp-project> Note Using an OpenShift cluster, run the oc command instead of kubectl one. Info \u2039edp-project\u203a is the name of the EDP tenant here and in all the following steps. View: edp-admin-console deployment ... spec : containers : - env : ... - name : BUILD_TOOLS value : docker # List of custom build tools in Admin Console, e.g. 'docker,helm'; ... ... Add the Jenkins agent by following the instruction . Add the Custom CI pipeline provisioner by following the instruction . As a result, the newly added Jenkins agent will be available in the Select Jenkins Slave dropdown list of the Advanced Settings block during the codebase creation: If it is necessary to create Code Review and Build pipelines, add corresponding entries (e.g. stages[Build-application-docker], [Code-review-application-docker]). See the example below: ... stages [ ' Code - review - application - docker ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"sonar\" } ] ' stages [ ' Build - application - docker ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"sonar\" }, ' + ' { \"name\" : \"build-image-kaniko\" } ' + ' ,{ \"name\" : \"git-tag\" } ] ' ... Note Application is one of the available options. Another option might be to add a library. Please refer to the Add Library page for details. Related Articles \u2693\ufe0e Add Application Add Library Manage Jenkins Agent Manage Jenkins CI Pipeline Job Provisioner","title":"Add Other Code Language"},{"location":"operator-guide/add-other-code-language/#add-other-code-language","text":"There is an ability to extend the default code languages when creating a codebase with the Clone or Import strategy. Warning The Create strategy does not allow to customize the default code language set. To customize the Build Tool list, perform the following: Edit the edp-admin-console deployment by adding the necessary code language into the BUILD TOOLS field: kubectl edit deployment edp-admin-console -n <edp-project> Note Using an OpenShift cluster, run the oc command instead of kubectl one. Info \u2039edp-project\u203a is the name of the EDP tenant here and in all the following steps. View: edp-admin-console deployment ... spec : containers : - env : ... - name : BUILD_TOOLS value : docker # List of custom build tools in Admin Console, e.g. 'docker,helm'; ... ... Add the Jenkins agent by following the instruction . Add the Custom CI pipeline provisioner by following the instruction . As a result, the newly added Jenkins agent will be available in the Select Jenkins Slave dropdown list of the Advanced Settings block during the codebase creation: If it is necessary to create Code Review and Build pipelines, add corresponding entries (e.g. stages[Build-application-docker], [Code-review-application-docker]). See the example below: ... stages [ ' Code - review - application - docker ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"sonar\" } ] ' stages [ ' Build - application - docker ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"sonar\" }, ' + ' { \"name\" : \"build-image-kaniko\" } ' + ' ,{ \"name\" : \"git-tag\" } ] ' ... Note Application is one of the available options. Another option might be to add a library. Please refer to the Add Library page for details.","title":"Add Other Code Language"},{"location":"operator-guide/add-other-code-language/#related-articles","text":"Add Application Add Library Manage Jenkins Agent Manage Jenkins CI Pipeline Job Provisioner","title":"Related Articles"},{"location":"operator-guide/delete-jenkins-job-provision/","text":"Delete Jenkins Job Provision \u2693\ufe0e To delete the job provisioner, take the following steps: Delete the job provisioner from Jenkins. Navigate to Admin Console->Jenkins->jobs->job-provisions folder, select the necessary provisioner and click the drop-down right to the provisioner name. Select Delete project . Run the commands below in the 'edp-db' pod: psql edp-db admin # Replace admin with the admin login from the db-admin-console secrets SET search_path to <NAMESPACE_NAME>; SELECT * FROM job_provisioning; Check the id of the necessary provisioner. Run the deletion command: DELETE FROM job_provisioning WHERE id=<PROVISIONER_ID>;","title":"Delete Jenkins Job Provision"},{"location":"operator-guide/delete-jenkins-job-provision/#delete-jenkins-job-provision","text":"To delete the job provisioner, take the following steps: Delete the job provisioner from Jenkins. Navigate to Admin Console->Jenkins->jobs->job-provisions folder, select the necessary provisioner and click the drop-down right to the provisioner name. Select Delete project . Run the commands below in the 'edp-db' pod: psql edp-db admin # Replace admin with the admin login from the db-admin-console secrets SET search_path to <NAMESPACE_NAME>; SELECT * FROM job_provisioning; Check the id of the necessary provisioner. Run the deletion command: DELETE FROM job_provisioning WHERE id=<PROVISIONER_ID>;","title":"Delete Jenkins Job Provision"},{"location":"operator-guide/deploy-aws-eks/","text":"Deploy AWS EKS Cluster \u2693\ufe0e This instruction provides detailed information on the Amazon Elastic Kubernetes Service cluster deployment and contains the additional setup necessary for the managed infrastructure. Prerequisites \u2693\ufe0e Before the EKS cluster deployment and configuration, make sure to check the prerequisites. Required Tools \u2693\ufe0e Install the required tools listed below: Git tfenv AWS CLI kubectl helm lens (optional) To check the correct tools installation, run the following commands: $ git --version $ tfenv --version $ aws --version $ kubectl version $ helm version AWS Account and IAM Roles \u2693\ufe0e Make sure the AWS account is active. Create the AWS IAM role: EKSDeployerRole to deploy EKS cluster on the project side. The provided resources will allow to use cross-account deployment by assuming created EKSDeployerRole from the root AWS account. Take the following steps: Clone git repo with ism-deployer project edp-terraform-aws-platform.git , rename it corresponding to the project name. clone project $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git $ mv edp-terraform-aws-platform edp-terraform-aws-platform-<PROJECT_NAME> $ cd edp-terraform-aws-platform-<PROJECT_NAME>/iam-deployer where: \u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc. Fill the input variables for Terraform run in the \u2039iam-deployer/terraform.tfvars\u203a file, refer to the iam-deployer/template.tfvars as an example. terraform.tfvars file example aws_profile = \"aws_user\" region = \"eu-central-1\" tags = { \"SysName\" = \"EKS\" \"SysOwner\" = \"owner@example.com\" \"Environment\" = \"EKS-TEST-CLUSTER\" \"CostCenter\" = \"0000\" \"BusinessUnit\" = \"BU\" \"Department\" = \"DEPARTMENT\" } Find the detailed description of the variables in the iam-deployer/variables.tf file. Run Terraform apply. Initialize the backend and apply the changes. apply the changes $ terraform init $ terraform apply ... Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_iam_role.deployer: Creating... aws_iam_role.deployer: Creation complete after 4s [ id = EKSDeployerRole ] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Outputs: deployer_iam_role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\" deployer_iam_role_id = \"EKSDeployerRole\" deployer_iam_role_name = \"EKSDeployerRole\" Commit the local state. At this run Terraform will use the local backend to store state on the local filesystem, locks that state using system APIs, and performs operations locally. There is no strong requirements to store the resulted state file in the git, but it's possible at will since there is no sensitive data. On your choice, commit the state of the s3-backend project or not. $ git add iam-deployer/terraform.tfstate iam-deployer/terraform.tfvars $ git commit -m \"Terraform state for IAM deployer role\" Configure AWS profile for deployment from the local node. Please, refer to the AWS documentation for detailed guide to configure profiles. Create AWS Key pair for EKS cluster nodes access. Please refer to the AWS documentation for detailed guide to create a Key pair. Create a public Hosted Zone if there is no any to provide for EKS cluster deployment. Please, refer to the AWS documentation for detailed guide to create a Hosted zone. Terraform Backend \u2693\ufe0e Configure Terraform backend. The Terraform configuration for EKS cluster deployment has a backend block, which defines where and how operations are performed, where state snapshots are stored, etc. Currently, the best practice is to store the state as a given key in a given bucket on Amazon S3. This backend also supports state locking and consistency checking via Dynamo DB, which can be enabled by setting the dynamodb_table field to an existing DynamoDB table name. In the following configuration a single DynamoDB table can be used to lock multiple remote state files. Terraform generates key names that include the values of the bucket and key variables. In the edp-terraform-aws-platform.git repo an optional project is provided to create initial resources to start using Terraform from the scratch. The provided resources will allow to use the following Terraform options : to store Terraform states remotely in the Amazon S3 bucket; to manage remote state access with S3 bucket policy; to support state locking and consistency checking via DynamoDB. After Terraform run the following AWS resources will be created: S3 bucket: terraform-states-\u2039AWS_ACCOUNT_ID\u203a S3 bucket policy: terraform-states-\u2039AWS_ACCOUNT_ID\u203a DynamoDB lock table: terraform_locks Please, skip this section if you already have the listed resources for further Terraform remote backend usage. To create the required resources, do the following: Clone git repo with s3-backend project edp-terraform-aws-platform.git , rename it in the correspondence with project name. clone project $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git $ mv edp-terraform-aws-platform tedp-terraform-aws-platform-<PROJECT_NAME> $ cd edp-terraform-aws-platform-<PROJECT_NAME>/s3-backend where: \u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc. Fill the input variables for Terraform run in the \u2039s3-backend/terraform.tfvars\u203a file, refer to the s3-backend/template.tfvars as an example. terraform.tfvars file example aws_profile = \"aws_user\" region = \"eu-central-1\" s3_states_bucket_name = \"terraform-states\" table_name = \"terraform_locks\" tags = { \"SysName\" = \"EKS\" \"SysOwner\" = \"owner@example.com\" \"Environment\" = \"EKS-TEST-CLUSTER\" \"CostCenter\" = \"0000\" \"BusinessUnit\" = \"BU\" \"Department\" = \"DEPARTMENT\" } Find the detailed description of the variables in the s3-backend/variables.tf file. Run Terraform apply. Initialize the backend and apply the changes. apply the changes $ terraform init $ terraform apply ... Do you want to perform these actions ? Terraform will perform the actions described above . Only ' yes ' will be accepted to approve . Enter a value : yes aws_dynamodb_table . terraform_lock_table : Creating ... aws_s3_bucket . terraform_states : Creating ... aws_dynamodb_table . terraform_lock_table : Creation complete after 27 s [ id = terraform - locks - test ] aws_s3_bucket . terraform_states : Creation complete after 1 m10s [ id = terraform - states - test - 012345678910 ] aws_s3_bucket_policy . terraform_states : Creating ... aws_s3_bucket_policy . terraform_states : Creation complete after 1 s [ id = terraform - states - test - 012345678910 ] Apply complete ! Resources : 3 added , 0 changed , 0 destroyed . Outputs : terraform_lock_table_dynamodb_id = \" terraform_locks \" terraform_states_s3_bucket_name = \" terraform-states-012345678910 \" Commit the local state. At this run Terraform will use the local backend to store state on the local filesystem, locks that state using system APIs, and performs operations locally. There is no strong requirements to store the resulted state file in the git, but it's possible at will since there is no sensitive data. On your choice, commit the state of the s3-backend project or not. $ git add s3 - backend / terraform . tfstate $ git commit - m \" Terraform state for s3-backend \" As a result, the projects that run Terraform can use the following definition for remote state configuration: providers.tf - terraform backend configuration block terraform { backend \"s3\" { bucket = \"terraform-states-<AWS_ACCOUNT_ID>\" key = \"<PROJECT_NAME>/<REGION>/terraform/terraform.tfstate\" region = \"<REGION>\" acl = \"bucket-owner-full-control\" dynamodb_table = \"terraform_locks\" encrypt = true } } where: AWS_ACCOUNT_ID - is AWS account id, e.g. 012345678910, REGION - is AWS region, e.g. eu-central-1, PROJECT_NAME - is a project name, a unique platform identifier, e.g. shared, test-eks etc. View: providers.tf - terraform backend configuration example terraform { backend \"s3\" { bucket = \"terraform-states-012345678910\" key = \"test-eks/eu-central-1/terraform/terraform.tfstate\" region = \"eu-central-1\" acl = \"bucket-owner-full-control\" dynamodb_table = \"terraform_locks\" encrypt = true } } Note At the moment, it is recommended to use common s3 bucket and Dynamo DB in the root EDP account both for Shared and Standalone clusters deployment. Deploy EKS Cluster \u2693\ufe0e To deploy the EKS cluster, make sure that all the above-mentioned Prerequisites are ready to be used. EKS Cluster Deployment with Terraform \u2693\ufe0e Clone git repo with the Terraform project for EKS infrastructure edp-terraform-aws-platform.git and rename it in the correspondence with project name if not yet. clone project $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git $ mv edp-terraform-aws-platform edp-terraform-aws-platform-<PROJECT_NAME> $ cd edp-terraform-aws-platform-<PROJECT_NAME> where: \u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc. Configure Terraform backend according to your project needs or use instructions from the Configure Terraform backend section. Fill the input variables for Terraform run in the \u2039terraform.tfvars\u203a file, refer to the template.tfvars file and apply the changes. See details below. Be sure to put the correct values of the variables created in the Prerequisites section. Find the detailed description of the variables in the variables.tf file. Warning Please, do not use upper case in the input variables. It can lead to unexpected issues. template.tfvars file template # Check out all the inputs based on the comments below and fill the gaps instead <...> # More details on each variable can be found in the variables.tf file create_vpc = true # set to true if you'd like to create a new VPC or false if use existing create_cluster = true # set to false if there are any additional manual steps required between VPC and EKS cluster deployment create_elb = true # set to true if you'd like to create ELB for Gerrit usage region = \"<REGION>\" profile = \"<AWS_PROFILE>\" role_arn = \"<ROLE_ARN>\" platform_name = \"<PLATFORM_NAME>\" # the name of the cluster and AWS resources platform_domain_name = \"<PLATFORM_DOMAIN_NAME>\" # must be created as a prerequisite wait_for_validation = true # set to false for use in an automated pipeline to avoid waiting for validation to complete or error after a 45 minute timeout. # The following will be created or used existing depending on the create_vpc value subnet_azs = [ \"<SUBNET_AZS1>\" , \"<SUBNET_AZS2>\" ] platform_cidr = \"<PLATFORM_CIDR>\" private_cidrs = [ \"<PRIVATE_CIDRS1>\" , \"<PRIVATE_CIDRS2>\" ] public_cidrs = [ \"<PUBLIC_CIDRS1>\" , \"<PUBLIC_CIDRS2>\" ] # Define the following only if you're going to use existing VPC and create_vpc is set to false vpc_id = \"<VPC_ID>\" private_subnets_id = [ \"<PRIVATE_SUBNETS_ID1>\" , \"<PRIVATE_SUBNETS_ID2>\" ] # \"<SUBNET_AZS1>\", \"<SUBNET_AZS2>\" public_subnets_id = [ \"<PUBLIC_SUBNETS_ID1>\" , \"<PUBLIC_SUBNETS_ID2>\" ] # \"<SUBNET_AZS1>\", \"<SUBNET_AZS2>\" nat_public_ips = [ \"<NAT_PUBLIC_IP>\" ] # Define CIDR blocks and/or prefix lists if any to whitelist for public access on LBs ingress_cidr_blocks = [ \"<PUBLIC_CIDR>\" ] ingress_prefix_list_ids = [ { description = \"<SHORT_DESCRIPTION1\" public_prefix_id = \"<PREFIX_LIST_ID1>\" }, { description = \"<SHORT_DESCRIPTION2\" public_prefix_id = \"<PREFIX_LIST_ID2>\" }, ] # Define existing security groups ids if any in order to whitelist for public access on LBs. Makes sense with create_vpc = true only. public_security_group_ids = [ \"<PUBLIC_SECURITY_GROUP_IDS1>\" , \"<PUBLIC_SECURITY_GROUP_IDS2>\" , ] # EKS cluster configuration cluster_version = \"1.18\" key_name = \"<AWS_KEY_PAIR_NAME>\" # must be created as a prerequisite enable_irsa = true manage_cluster_iam_resources = false # if set to false, cluster_iam_role_name must be specified manage_worker_iam_resources = false # if set to false, worker_iam_instance_profile_name must be specified for workers cluster_iam_role_name = \"<SERVICE_ROLE_FOR_EKS>\" worker_iam_instance_profile_name = \"<SERVICE_ROLE_FOR_EKS_WORKER_NODE\" # Uncomment if your AWS CLI version is 1.16.156 or later kubeconfig_aws_authenticator_command = \"aws\" # Environment varibles to put into kubeconfig file to use when executing the authentication, such as AWS profile of IAM user for authentication kubeconfig_aws_authenticator_env_variables = { AWS_PROFILE = \"<AWS_PROFILE>\" } add_userdata = << EOF export TOKEN =$ ( aws ssm get - parameter -- name edprobot -- query 'Parameter.Value' -- region eu - central - 1 -- output text ) cat << DATA > / var / lib / kubelet / config . json { \"auths\" :{ \"https://index.docker.io/v1/\" :{ \"auth\" : \"$TOKEN\" } } } DATA EOF map_users = [ { \"userarn\" : \"<IAM_USER_ARN1>\" , \"username\" : \"<IAM_USER_NAME1>\" , \"groups\" : [ \"system:masters\" ] }, { \"userarn\" : \"<IAM_USER_ARN2>\" , \"username\" : \"<IAM_USER_NAME2>\" , \"groups\" : [ \"system:masters\" ] } ] map_roles = [ { \"rolearn\" : \"<IAM_ROLE_ARN1>\" , \"username\" : \"<IAM_ROLE_NAME1>\" , \"groups\" : [ \"system:masters\" ] }, ] tags = { \"SysName\" = \"<SYS_NAME>\" \"SysOwner\" = \"<SYSTEM_OWNER>\" \"Environment\" = \"<ENVIRONMENT>\" \"CostCenter\" = \"<COST_CENTER>\" \"BusinessUnit\" = \"<BUSINESS_UNIT>\" \"Department\" = \"<DEPARTMENT>\" \"user:tag\" = \"<PLATFORM_NAME>\" } demand_instance_types = [ \"r5.large\" ] spot_instance_types = [ \"r5.large\" , \"r4.large\" ] # need to ensure we use nodes with more memory Note The file above is an example. Please find the latest version in the project repo in the terraform.tfvars file. There are the following possible scenarios to deploy the EKS cluster: Case 1: Create new VPC and deploy the EKS cluster, terraform.tfvars file example create_vpc = true # set to true if you'd like to create a new VPC or false if use existing create_cluster = true # set to false if there are any additional manual steps required between VPC and EKS cluster deployment create_elb = true # set to true if you'd like to create ELB for Gerrit usage region = \"eu-central-1\" profile = \"aws_user\" role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\" platform_name = \"test-eks\" platform_domain_name = \"example.com\" # must be created as a prerequisite wait_for_validation = false # set to false for use in an automated pipeline to avoid waiting for validation to complete or error after a 45 minute timeout. # The following will be created or used existing depending on the create_vpc value subnet_azs = [ \"eu-central-1a\" , \"eu-central-1b\" ] platform_cidr = \"172.31.0.0/16\" private_cidrs = [ \"172.31.0.0/20\" , \"172.31.16.0/20\" ] public_cidrs = [ \"172.31.32.0/20\" , \"172.31.48.0/20\" ] # Define CIDR blocks and/or prefix lists if any to whitelist for public access on LBs. Use short description ingress_cidr_blocks = [ \"192.168.64.0/24\" ] ingress_prefix_list_ids = [ { description = \"europe\" public_prefix_id = \"pl-00000000000000002\" }, { description = \"world\" public_prefix_id = \"pl-00000000000000003\" } ] # EKS cluster configuration cluster_version = \"1.18\" key_name = \"test-kn\" # must be created as a prerequisite enable_irsa = true # Define if IAM roles should be created during the deployment or used existing ones manage_cluster_iam_resources = false # if set to false, cluster_iam_role_name must be specified manage_worker_iam_resources = false # if set to false, worker_iam_instance_profile_name must be specified for workers cluster_iam_role_name = \"ServiceRoleForEKSShared\" worker_iam_instance_profile_name = \"ServiceRoleForEksSharedWorkerNode\" # Uncomment if your AWS CLI version is 1.16.156 or later kubeconfig_aws_authenticator_command = \"aws\" # Environment varibles to put into kubeconfig file to use when executing the authentication, such as AWS profile of IAM user for authentication kubeconfig_aws_authenticator_env_variables = { AWS_PROFILE = \"aws_user\" } add_userdata = << EOF export TOKEN =$ ( aws ssm get - parameter -- name edprobot -- query 'Parameter.Value' -- region eu - central - 1 -- output text ) cat << DATA > / var / lib / kubelet / config . json { \"auths\" :{ \"https://index.docker.io/v1/\" :{ \"auth\" : \"$TOKEN\" } } } DATA EOF map_users = [ { \"userarn\" : \"arn:aws:iam::012345678910:user/user_name1@example.com\" , \"username\" : \"user_name1@example.com\" , \"groups\" : [ \"system:masters\" ] }, { \"userarn\" : \"arn:aws:iam::012345678910:user/user_name2@example.com\" , \"username\" : \"user_name2@example.com\" , \"groups\" : [ \"system:masters\" ] } ] map_roles = [ { \"rolearn\" : \"arn:aws:iam::012345678910:role/EKSClusterAdminRole\" , \"username\" : \"eksadminrole\" , \"groups\" : [ \"system:masters\" ] }, ] tags = { \"SysName\" = \"EKS\" \"SysOwner\" = \"owner@example.com\" \"Environment\" = \"EKS-TEST-CLUSTER\" \"CostCenter\" = \"2020\" \"BusinessUnit\" = \"BU\" \"Department\" = \"DEPARTMENT\" \"user:tag\" = \"test-eks\" } demand_instance_types = [ \"r5.large\" ] spot_instance_types = [ \"r5.large\" , \"r4.large\" ] # need to ensure we use nodes with more memory Case 2: Use existing VPC to deploy EKS cluster, terraform.tfvars file example create_vpc = false # set to true if you'd like to create a new VPC or false if use existing create_cluster = true # set to false if there are any additional manual steps required between VPC and EKS cluster deployment create_elb = true # set to true if you'd like to create ELB for Gerrit usage region = \"eu-central-1\" profile = \"aws_user\" role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\" platform_name = \"test-eks\" platform_domain_name = \"example.com\" # must be created as a prerequisite wait_for_validation = false # set to false for use in an automated pipeline to avoid waiting for validation to complete or error after a 45 minute timeout. # The following will be created or used existing depending on the create_vpc value subnet_azs = [ \"eu-central-1a\" , \"eu-central-1b\" ] platform_cidr = \"172.31.0.0/16\" private_cidrs = [ \"172.31.0.0/20\" , \"172.31.16.0/20\" ] public_cidrs = [ \"172.31.32.0/20\" , \"172.31.48.0/20\" ] # Define the following only if you're going to use existing VPC and create_vpc is set to false vpc_id = \"vpc-00000000000000000\" private_subnets_id = [ \"subnet-00000000000000001\" , \"subnet-00000000000000002\" ] # eu-central-1a, eu-central-1b public_subnets_id = [ \"subnet-00000000000000003\" , \"subnet-00000000000000004\" ] # eu-central-1a, eu-central-1b nat_public_cidrs = [ \"10.11.12.13/32\" ] # Define CIDR blocks and/or prefix lists if any to whitelist for public access on LBs. Use short description ingress_cidr_blocks = [ \"192.168.64.0/24\" ] ingress_prefix_list_ids = [ { description = \"europe\" public_prefix_id = \"pl-00000000000000002\" }, { description = \"world\" public_prefix_id = \"pl-00000000000000003\" } ] # Define existing security groups ids if any in order to whitelist for public access on LBs. Makes sense with create_vpc = false only. public_security_group_ids = [ \"sg-00000000000000001\" , # Europe \"sg-00000000000000002\" , # Global ] # EKS cluster configuration cluster_version = \"1.18\" key_name = \"test-kn\" # must be created as a prerequisite enable_irsa = true # Define if IAM roles should be created during the deployment or used existing ones manage_cluster_iam_resources = false # if set to false, cluster_iam_role_name must be specified manage_worker_iam_resources = false # if set to false, worker_iam_instance_profile_name must be specified for workers cluster_iam_role_name = \"ServiceRoleForEKSShared\" worke # Uncomment if your AWS CLI version is 1.16.156 or later kubeconfig_aws_authenticator_command = \"aws\" # Environment varibles to put into kubeconfig file to use when executing the authentication, such as AWS profile of IAM user for authentication kubeconfig_aws_authenticator_env_variables = { AWS_PROFILE = \"aws_user\" } add_userdata = << EOF export TOKEN =$ ( aws ssm get - parameter -- name edprobot -- query 'Parameter.Value' -- region eu - central - 1 -- output text ) cat << DATA > / var / lib / kubelet / config . json { \"auths\" :{ \"https://index.docker.io/v1/\" :{ \"auth\" : \"$TOKEN\" } } } DATA EOF map_users = [ { \"userarn\" : \"arn:aws:iam::012345678910:user/user_name1@example.com\" , \"username\" : \"user_name1@example.com\" , \"groups\" : [ \"system:masters\" ] }, { \"userarn\" : \"arn:aws:iam::012345678910:user/user_name2@example.com\" , \"username\" : \"user_name2@example.com\" , \"groups\" : [ \"system:masters\" ] } ] map_roles = [ { \"rolearn\" : \"arn:aws:iam::012345678910:role/EKSClusterAdminRole\" , \"username\" : \"eksadminrole\" , \"groups\" : [ \"system:masters\" ] }, ] tags = { \"SysName\" = \"EKS\" \"SysOwner\" = \"owner@example.com\" \"Environment\" = \"EKS-TEST-CLUSTER\" \"CostCenter\" = \"2020\" \"BusinessUnit\" = \"BU\" \"Department\" = \"DEPARTMENT\" \"user:tag\" = \"test-eks\" } demand_instance_types = [ \"r5.large\" ] spot_instance_types = [ \"r5.large\" , \"r4.large\" ] # need to ensure we use nodes with more memory Run Terraform apply. Initialize the backend and apply the changes. apply the changes $ terraform init $ terraform apply ... Do you want to perform these actions ? Terraform will perform the actions described above . Only ' yes ' will be accepted to approve . Enter a value : yes ... Check EKS cluster deployment \u2693\ufe0e As a result, the \u2039PLATFORM_NAME\u203a EKS cluster is deployed to the specified AWS account. Make sure you have all required tools listed in the Install required tools section. To connect to the cluster find the kubeconfig _ file in the project folder which is output of the last Terraform apply run. Move it to the ~/.kube/ folder. $ mv kubeconfig_<PLATFORM_NAME> ~/.kube/ Run the following commands to ensure the EKS cluster is up and has required nodes count: $ kubectl config get-contexts $ kubectl get nodes Note If the there are any authorisation issues, make sure the users section in the kubeconfig_ file has all required parameters based on you AWS CLI version. Find more details in the create kubeconfig AWS user guide. And pay attention on the kubeconfig_aws_authenticator terraform input variables. Optionally, a Lens tool can be installed and used for further work with Kubernetes cluster. Refer to the original documentation to add and process the cluster.","title":"Deploy AWS EKS Cluster"},{"location":"operator-guide/deploy-aws-eks/#deploy-aws-eks-cluster","text":"This instruction provides detailed information on the Amazon Elastic Kubernetes Service cluster deployment and contains the additional setup necessary for the managed infrastructure.","title":"Deploy AWS EKS Cluster"},{"location":"operator-guide/deploy-aws-eks/#prerequisites","text":"Before the EKS cluster deployment and configuration, make sure to check the prerequisites.","title":"Prerequisites"},{"location":"operator-guide/deploy-aws-eks/#required-tools","text":"Install the required tools listed below: Git tfenv AWS CLI kubectl helm lens (optional) To check the correct tools installation, run the following commands: $ git --version $ tfenv --version $ aws --version $ kubectl version $ helm version","title":"Required Tools"},{"location":"operator-guide/deploy-aws-eks/#aws-account-and-iam-roles","text":"Make sure the AWS account is active. Create the AWS IAM role: EKSDeployerRole to deploy EKS cluster on the project side. The provided resources will allow to use cross-account deployment by assuming created EKSDeployerRole from the root AWS account. Take the following steps: Clone git repo with ism-deployer project edp-terraform-aws-platform.git , rename it corresponding to the project name. clone project $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git $ mv edp-terraform-aws-platform edp-terraform-aws-platform-<PROJECT_NAME> $ cd edp-terraform-aws-platform-<PROJECT_NAME>/iam-deployer where: \u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc. Fill the input variables for Terraform run in the \u2039iam-deployer/terraform.tfvars\u203a file, refer to the iam-deployer/template.tfvars as an example. terraform.tfvars file example aws_profile = \"aws_user\" region = \"eu-central-1\" tags = { \"SysName\" = \"EKS\" \"SysOwner\" = \"owner@example.com\" \"Environment\" = \"EKS-TEST-CLUSTER\" \"CostCenter\" = \"0000\" \"BusinessUnit\" = \"BU\" \"Department\" = \"DEPARTMENT\" } Find the detailed description of the variables in the iam-deployer/variables.tf file. Run Terraform apply. Initialize the backend and apply the changes. apply the changes $ terraform init $ terraform apply ... Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_iam_role.deployer: Creating... aws_iam_role.deployer: Creation complete after 4s [ id = EKSDeployerRole ] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Outputs: deployer_iam_role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\" deployer_iam_role_id = \"EKSDeployerRole\" deployer_iam_role_name = \"EKSDeployerRole\" Commit the local state. At this run Terraform will use the local backend to store state on the local filesystem, locks that state using system APIs, and performs operations locally. There is no strong requirements to store the resulted state file in the git, but it's possible at will since there is no sensitive data. On your choice, commit the state of the s3-backend project or not. $ git add iam-deployer/terraform.tfstate iam-deployer/terraform.tfvars $ git commit -m \"Terraform state for IAM deployer role\" Configure AWS profile for deployment from the local node. Please, refer to the AWS documentation for detailed guide to configure profiles. Create AWS Key pair for EKS cluster nodes access. Please refer to the AWS documentation for detailed guide to create a Key pair. Create a public Hosted Zone if there is no any to provide for EKS cluster deployment. Please, refer to the AWS documentation for detailed guide to create a Hosted zone.","title":"AWS Account and IAM Roles"},{"location":"operator-guide/deploy-aws-eks/#terraform-backend","text":"Configure Terraform backend. The Terraform configuration for EKS cluster deployment has a backend block, which defines where and how operations are performed, where state snapshots are stored, etc. Currently, the best practice is to store the state as a given key in a given bucket on Amazon S3. This backend also supports state locking and consistency checking via Dynamo DB, which can be enabled by setting the dynamodb_table field to an existing DynamoDB table name. In the following configuration a single DynamoDB table can be used to lock multiple remote state files. Terraform generates key names that include the values of the bucket and key variables. In the edp-terraform-aws-platform.git repo an optional project is provided to create initial resources to start using Terraform from the scratch. The provided resources will allow to use the following Terraform options : to store Terraform states remotely in the Amazon S3 bucket; to manage remote state access with S3 bucket policy; to support state locking and consistency checking via DynamoDB. After Terraform run the following AWS resources will be created: S3 bucket: terraform-states-\u2039AWS_ACCOUNT_ID\u203a S3 bucket policy: terraform-states-\u2039AWS_ACCOUNT_ID\u203a DynamoDB lock table: terraform_locks Please, skip this section if you already have the listed resources for further Terraform remote backend usage. To create the required resources, do the following: Clone git repo with s3-backend project edp-terraform-aws-platform.git , rename it in the correspondence with project name. clone project $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git $ mv edp-terraform-aws-platform tedp-terraform-aws-platform-<PROJECT_NAME> $ cd edp-terraform-aws-platform-<PROJECT_NAME>/s3-backend where: \u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc. Fill the input variables for Terraform run in the \u2039s3-backend/terraform.tfvars\u203a file, refer to the s3-backend/template.tfvars as an example. terraform.tfvars file example aws_profile = \"aws_user\" region = \"eu-central-1\" s3_states_bucket_name = \"terraform-states\" table_name = \"terraform_locks\" tags = { \"SysName\" = \"EKS\" \"SysOwner\" = \"owner@example.com\" \"Environment\" = \"EKS-TEST-CLUSTER\" \"CostCenter\" = \"0000\" \"BusinessUnit\" = \"BU\" \"Department\" = \"DEPARTMENT\" } Find the detailed description of the variables in the s3-backend/variables.tf file. Run Terraform apply. Initialize the backend and apply the changes. apply the changes $ terraform init $ terraform apply ... Do you want to perform these actions ? Terraform will perform the actions described above . Only ' yes ' will be accepted to approve . Enter a value : yes aws_dynamodb_table . terraform_lock_table : Creating ... aws_s3_bucket . terraform_states : Creating ... aws_dynamodb_table . terraform_lock_table : Creation complete after 27 s [ id = terraform - locks - test ] aws_s3_bucket . terraform_states : Creation complete after 1 m10s [ id = terraform - states - test - 012345678910 ] aws_s3_bucket_policy . terraform_states : Creating ... aws_s3_bucket_policy . terraform_states : Creation complete after 1 s [ id = terraform - states - test - 012345678910 ] Apply complete ! Resources : 3 added , 0 changed , 0 destroyed . Outputs : terraform_lock_table_dynamodb_id = \" terraform_locks \" terraform_states_s3_bucket_name = \" terraform-states-012345678910 \" Commit the local state. At this run Terraform will use the local backend to store state on the local filesystem, locks that state using system APIs, and performs operations locally. There is no strong requirements to store the resulted state file in the git, but it's possible at will since there is no sensitive data. On your choice, commit the state of the s3-backend project or not. $ git add s3 - backend / terraform . tfstate $ git commit - m \" Terraform state for s3-backend \" As a result, the projects that run Terraform can use the following definition for remote state configuration: providers.tf - terraform backend configuration block terraform { backend \"s3\" { bucket = \"terraform-states-<AWS_ACCOUNT_ID>\" key = \"<PROJECT_NAME>/<REGION>/terraform/terraform.tfstate\" region = \"<REGION>\" acl = \"bucket-owner-full-control\" dynamodb_table = \"terraform_locks\" encrypt = true } } where: AWS_ACCOUNT_ID - is AWS account id, e.g. 012345678910, REGION - is AWS region, e.g. eu-central-1, PROJECT_NAME - is a project name, a unique platform identifier, e.g. shared, test-eks etc. View: providers.tf - terraform backend configuration example terraform { backend \"s3\" { bucket = \"terraform-states-012345678910\" key = \"test-eks/eu-central-1/terraform/terraform.tfstate\" region = \"eu-central-1\" acl = \"bucket-owner-full-control\" dynamodb_table = \"terraform_locks\" encrypt = true } } Note At the moment, it is recommended to use common s3 bucket and Dynamo DB in the root EDP account both for Shared and Standalone clusters deployment.","title":"Terraform Backend"},{"location":"operator-guide/deploy-aws-eks/#deploy-eks-cluster","text":"To deploy the EKS cluster, make sure that all the above-mentioned Prerequisites are ready to be used.","title":"Deploy EKS Cluster"},{"location":"operator-guide/deploy-aws-eks/#eks-cluster-deployment-with-terraform","text":"Clone git repo with the Terraform project for EKS infrastructure edp-terraform-aws-platform.git and rename it in the correspondence with project name if not yet. clone project $ git clone https://github.com/epmd-edp/edp-terraform-aws-platform.git $ mv edp-terraform-aws-platform edp-terraform-aws-platform-<PROJECT_NAME> $ cd edp-terraform-aws-platform-<PROJECT_NAME> where: \u2039PROJECT_NAME\u203a - is a project name, a unique platform identifier, e.g. shared, test-eks etc. Configure Terraform backend according to your project needs or use instructions from the Configure Terraform backend section. Fill the input variables for Terraform run in the \u2039terraform.tfvars\u203a file, refer to the template.tfvars file and apply the changes. See details below. Be sure to put the correct values of the variables created in the Prerequisites section. Find the detailed description of the variables in the variables.tf file. Warning Please, do not use upper case in the input variables. It can lead to unexpected issues. template.tfvars file template # Check out all the inputs based on the comments below and fill the gaps instead <...> # More details on each variable can be found in the variables.tf file create_vpc = true # set to true if you'd like to create a new VPC or false if use existing create_cluster = true # set to false if there are any additional manual steps required between VPC and EKS cluster deployment create_elb = true # set to true if you'd like to create ELB for Gerrit usage region = \"<REGION>\" profile = \"<AWS_PROFILE>\" role_arn = \"<ROLE_ARN>\" platform_name = \"<PLATFORM_NAME>\" # the name of the cluster and AWS resources platform_domain_name = \"<PLATFORM_DOMAIN_NAME>\" # must be created as a prerequisite wait_for_validation = true # set to false for use in an automated pipeline to avoid waiting for validation to complete or error after a 45 minute timeout. # The following will be created or used existing depending on the create_vpc value subnet_azs = [ \"<SUBNET_AZS1>\" , \"<SUBNET_AZS2>\" ] platform_cidr = \"<PLATFORM_CIDR>\" private_cidrs = [ \"<PRIVATE_CIDRS1>\" , \"<PRIVATE_CIDRS2>\" ] public_cidrs = [ \"<PUBLIC_CIDRS1>\" , \"<PUBLIC_CIDRS2>\" ] # Define the following only if you're going to use existing VPC and create_vpc is set to false vpc_id = \"<VPC_ID>\" private_subnets_id = [ \"<PRIVATE_SUBNETS_ID1>\" , \"<PRIVATE_SUBNETS_ID2>\" ] # \"<SUBNET_AZS1>\", \"<SUBNET_AZS2>\" public_subnets_id = [ \"<PUBLIC_SUBNETS_ID1>\" , \"<PUBLIC_SUBNETS_ID2>\" ] # \"<SUBNET_AZS1>\", \"<SUBNET_AZS2>\" nat_public_ips = [ \"<NAT_PUBLIC_IP>\" ] # Define CIDR blocks and/or prefix lists if any to whitelist for public access on LBs ingress_cidr_blocks = [ \"<PUBLIC_CIDR>\" ] ingress_prefix_list_ids = [ { description = \"<SHORT_DESCRIPTION1\" public_prefix_id = \"<PREFIX_LIST_ID1>\" }, { description = \"<SHORT_DESCRIPTION2\" public_prefix_id = \"<PREFIX_LIST_ID2>\" }, ] # Define existing security groups ids if any in order to whitelist for public access on LBs. Makes sense with create_vpc = true only. public_security_group_ids = [ \"<PUBLIC_SECURITY_GROUP_IDS1>\" , \"<PUBLIC_SECURITY_GROUP_IDS2>\" , ] # EKS cluster configuration cluster_version = \"1.18\" key_name = \"<AWS_KEY_PAIR_NAME>\" # must be created as a prerequisite enable_irsa = true manage_cluster_iam_resources = false # if set to false, cluster_iam_role_name must be specified manage_worker_iam_resources = false # if set to false, worker_iam_instance_profile_name must be specified for workers cluster_iam_role_name = \"<SERVICE_ROLE_FOR_EKS>\" worker_iam_instance_profile_name = \"<SERVICE_ROLE_FOR_EKS_WORKER_NODE\" # Uncomment if your AWS CLI version is 1.16.156 or later kubeconfig_aws_authenticator_command = \"aws\" # Environment varibles to put into kubeconfig file to use when executing the authentication, such as AWS profile of IAM user for authentication kubeconfig_aws_authenticator_env_variables = { AWS_PROFILE = \"<AWS_PROFILE>\" } add_userdata = << EOF export TOKEN =$ ( aws ssm get - parameter -- name edprobot -- query 'Parameter.Value' -- region eu - central - 1 -- output text ) cat << DATA > / var / lib / kubelet / config . json { \"auths\" :{ \"https://index.docker.io/v1/\" :{ \"auth\" : \"$TOKEN\" } } } DATA EOF map_users = [ { \"userarn\" : \"<IAM_USER_ARN1>\" , \"username\" : \"<IAM_USER_NAME1>\" , \"groups\" : [ \"system:masters\" ] }, { \"userarn\" : \"<IAM_USER_ARN2>\" , \"username\" : \"<IAM_USER_NAME2>\" , \"groups\" : [ \"system:masters\" ] } ] map_roles = [ { \"rolearn\" : \"<IAM_ROLE_ARN1>\" , \"username\" : \"<IAM_ROLE_NAME1>\" , \"groups\" : [ \"system:masters\" ] }, ] tags = { \"SysName\" = \"<SYS_NAME>\" \"SysOwner\" = \"<SYSTEM_OWNER>\" \"Environment\" = \"<ENVIRONMENT>\" \"CostCenter\" = \"<COST_CENTER>\" \"BusinessUnit\" = \"<BUSINESS_UNIT>\" \"Department\" = \"<DEPARTMENT>\" \"user:tag\" = \"<PLATFORM_NAME>\" } demand_instance_types = [ \"r5.large\" ] spot_instance_types = [ \"r5.large\" , \"r4.large\" ] # need to ensure we use nodes with more memory Note The file above is an example. Please find the latest version in the project repo in the terraform.tfvars file. There are the following possible scenarios to deploy the EKS cluster: Case 1: Create new VPC and deploy the EKS cluster, terraform.tfvars file example create_vpc = true # set to true if you'd like to create a new VPC or false if use existing create_cluster = true # set to false if there are any additional manual steps required between VPC and EKS cluster deployment create_elb = true # set to true if you'd like to create ELB for Gerrit usage region = \"eu-central-1\" profile = \"aws_user\" role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\" platform_name = \"test-eks\" platform_domain_name = \"example.com\" # must be created as a prerequisite wait_for_validation = false # set to false for use in an automated pipeline to avoid waiting for validation to complete or error after a 45 minute timeout. # The following will be created or used existing depending on the create_vpc value subnet_azs = [ \"eu-central-1a\" , \"eu-central-1b\" ] platform_cidr = \"172.31.0.0/16\" private_cidrs = [ \"172.31.0.0/20\" , \"172.31.16.0/20\" ] public_cidrs = [ \"172.31.32.0/20\" , \"172.31.48.0/20\" ] # Define CIDR blocks and/or prefix lists if any to whitelist for public access on LBs. Use short description ingress_cidr_blocks = [ \"192.168.64.0/24\" ] ingress_prefix_list_ids = [ { description = \"europe\" public_prefix_id = \"pl-00000000000000002\" }, { description = \"world\" public_prefix_id = \"pl-00000000000000003\" } ] # EKS cluster configuration cluster_version = \"1.18\" key_name = \"test-kn\" # must be created as a prerequisite enable_irsa = true # Define if IAM roles should be created during the deployment or used existing ones manage_cluster_iam_resources = false # if set to false, cluster_iam_role_name must be specified manage_worker_iam_resources = false # if set to false, worker_iam_instance_profile_name must be specified for workers cluster_iam_role_name = \"ServiceRoleForEKSShared\" worker_iam_instance_profile_name = \"ServiceRoleForEksSharedWorkerNode\" # Uncomment if your AWS CLI version is 1.16.156 or later kubeconfig_aws_authenticator_command = \"aws\" # Environment varibles to put into kubeconfig file to use when executing the authentication, such as AWS profile of IAM user for authentication kubeconfig_aws_authenticator_env_variables = { AWS_PROFILE = \"aws_user\" } add_userdata = << EOF export TOKEN =$ ( aws ssm get - parameter -- name edprobot -- query 'Parameter.Value' -- region eu - central - 1 -- output text ) cat << DATA > / var / lib / kubelet / config . json { \"auths\" :{ \"https://index.docker.io/v1/\" :{ \"auth\" : \"$TOKEN\" } } } DATA EOF map_users = [ { \"userarn\" : \"arn:aws:iam::012345678910:user/user_name1@example.com\" , \"username\" : \"user_name1@example.com\" , \"groups\" : [ \"system:masters\" ] }, { \"userarn\" : \"arn:aws:iam::012345678910:user/user_name2@example.com\" , \"username\" : \"user_name2@example.com\" , \"groups\" : [ \"system:masters\" ] } ] map_roles = [ { \"rolearn\" : \"arn:aws:iam::012345678910:role/EKSClusterAdminRole\" , \"username\" : \"eksadminrole\" , \"groups\" : [ \"system:masters\" ] }, ] tags = { \"SysName\" = \"EKS\" \"SysOwner\" = \"owner@example.com\" \"Environment\" = \"EKS-TEST-CLUSTER\" \"CostCenter\" = \"2020\" \"BusinessUnit\" = \"BU\" \"Department\" = \"DEPARTMENT\" \"user:tag\" = \"test-eks\" } demand_instance_types = [ \"r5.large\" ] spot_instance_types = [ \"r5.large\" , \"r4.large\" ] # need to ensure we use nodes with more memory Case 2: Use existing VPC to deploy EKS cluster, terraform.tfvars file example create_vpc = false # set to true if you'd like to create a new VPC or false if use existing create_cluster = true # set to false if there are any additional manual steps required between VPC and EKS cluster deployment create_elb = true # set to true if you'd like to create ELB for Gerrit usage region = \"eu-central-1\" profile = \"aws_user\" role_arn = \"arn:aws:iam::012345678910:role/EKSDeployerRole\" platform_name = \"test-eks\" platform_domain_name = \"example.com\" # must be created as a prerequisite wait_for_validation = false # set to false for use in an automated pipeline to avoid waiting for validation to complete or error after a 45 minute timeout. # The following will be created or used existing depending on the create_vpc value subnet_azs = [ \"eu-central-1a\" , \"eu-central-1b\" ] platform_cidr = \"172.31.0.0/16\" private_cidrs = [ \"172.31.0.0/20\" , \"172.31.16.0/20\" ] public_cidrs = [ \"172.31.32.0/20\" , \"172.31.48.0/20\" ] # Define the following only if you're going to use existing VPC and create_vpc is set to false vpc_id = \"vpc-00000000000000000\" private_subnets_id = [ \"subnet-00000000000000001\" , \"subnet-00000000000000002\" ] # eu-central-1a, eu-central-1b public_subnets_id = [ \"subnet-00000000000000003\" , \"subnet-00000000000000004\" ] # eu-central-1a, eu-central-1b nat_public_cidrs = [ \"10.11.12.13/32\" ] # Define CIDR blocks and/or prefix lists if any to whitelist for public access on LBs. Use short description ingress_cidr_blocks = [ \"192.168.64.0/24\" ] ingress_prefix_list_ids = [ { description = \"europe\" public_prefix_id = \"pl-00000000000000002\" }, { description = \"world\" public_prefix_id = \"pl-00000000000000003\" } ] # Define existing security groups ids if any in order to whitelist for public access on LBs. Makes sense with create_vpc = false only. public_security_group_ids = [ \"sg-00000000000000001\" , # Europe \"sg-00000000000000002\" , # Global ] # EKS cluster configuration cluster_version = \"1.18\" key_name = \"test-kn\" # must be created as a prerequisite enable_irsa = true # Define if IAM roles should be created during the deployment or used existing ones manage_cluster_iam_resources = false # if set to false, cluster_iam_role_name must be specified manage_worker_iam_resources = false # if set to false, worker_iam_instance_profile_name must be specified for workers cluster_iam_role_name = \"ServiceRoleForEKSShared\" worke # Uncomment if your AWS CLI version is 1.16.156 or later kubeconfig_aws_authenticator_command = \"aws\" # Environment varibles to put into kubeconfig file to use when executing the authentication, such as AWS profile of IAM user for authentication kubeconfig_aws_authenticator_env_variables = { AWS_PROFILE = \"aws_user\" } add_userdata = << EOF export TOKEN =$ ( aws ssm get - parameter -- name edprobot -- query 'Parameter.Value' -- region eu - central - 1 -- output text ) cat << DATA > / var / lib / kubelet / config . json { \"auths\" :{ \"https://index.docker.io/v1/\" :{ \"auth\" : \"$TOKEN\" } } } DATA EOF map_users = [ { \"userarn\" : \"arn:aws:iam::012345678910:user/user_name1@example.com\" , \"username\" : \"user_name1@example.com\" , \"groups\" : [ \"system:masters\" ] }, { \"userarn\" : \"arn:aws:iam::012345678910:user/user_name2@example.com\" , \"username\" : \"user_name2@example.com\" , \"groups\" : [ \"system:masters\" ] } ] map_roles = [ { \"rolearn\" : \"arn:aws:iam::012345678910:role/EKSClusterAdminRole\" , \"username\" : \"eksadminrole\" , \"groups\" : [ \"system:masters\" ] }, ] tags = { \"SysName\" = \"EKS\" \"SysOwner\" = \"owner@example.com\" \"Environment\" = \"EKS-TEST-CLUSTER\" \"CostCenter\" = \"2020\" \"BusinessUnit\" = \"BU\" \"Department\" = \"DEPARTMENT\" \"user:tag\" = \"test-eks\" } demand_instance_types = [ \"r5.large\" ] spot_instance_types = [ \"r5.large\" , \"r4.large\" ] # need to ensure we use nodes with more memory Run Terraform apply. Initialize the backend and apply the changes. apply the changes $ terraform init $ terraform apply ... Do you want to perform these actions ? Terraform will perform the actions described above . Only ' yes ' will be accepted to approve . Enter a value : yes ...","title":"EKS Cluster Deployment with Terraform"},{"location":"operator-guide/deploy-aws-eks/#check-eks-cluster-deployment","text":"As a result, the \u2039PLATFORM_NAME\u203a EKS cluster is deployed to the specified AWS account. Make sure you have all required tools listed in the Install required tools section. To connect to the cluster find the kubeconfig _ file in the project folder which is output of the last Terraform apply run. Move it to the ~/.kube/ folder. $ mv kubeconfig_<PLATFORM_NAME> ~/.kube/ Run the following commands to ensure the EKS cluster is up and has required nodes count: $ kubectl config get-contexts $ kubectl get nodes Note If the there are any authorisation issues, make sure the users section in the kubeconfig_ file has all required parameters based on you AWS CLI version. Find more details in the create kubeconfig AWS user guide. And pay attention on the kubeconfig_aws_authenticator terraform input variables. Optionally, a Lens tool can be installed and used for further work with Kubernetes cluster. Refer to the original documentation to add and process the cluster.","title":"Check EKS cluster deployment"},{"location":"operator-guide/edp-kiosk-usage/","text":"EDP Kiosk Usage \u2693\ufe0e Explore the way Kiosk, a multi-tenancy extension for Kubernetes , is used in EDP. Prerequisites \u2693\ufe0e Installed Kiosk v.0.2.9. Diagram of using Kiosk by EDP \u2693\ufe0e Agenda blue - created by Helm chart; grey - created manually Usage \u2693\ufe0e EDP installation area on a diagram is described by following link ; Once the above step is executed, edp-cd-pipeline-operator service account will be linked to kiosk-edit ClusterRole to get an ability for leveraging Kiosk specific resources (e.g. Space); Newly created stage in \u2039edp-project\u203a installation of EDP generates new Kiosk Space resource that is linked to Kiosk Account; According to Kiosk doc the Space resource creates namespace with RoleBinding that contains relation between service account which is linked to Kiosk Account and kiosk-space-admin ClusterRole. As cd-pipeline-operator ServiceAccount is linked to Account, it has admin permissions in all generated by him namespaces. Related Articles \u2693\ufe0e Install EDP Set Up Kiosk","title":"EDP Kiosk Usage"},{"location":"operator-guide/edp-kiosk-usage/#edp-kiosk-usage","text":"Explore the way Kiosk, a multi-tenancy extension for Kubernetes , is used in EDP.","title":"EDP Kiosk Usage"},{"location":"operator-guide/edp-kiosk-usage/#prerequisites","text":"Installed Kiosk v.0.2.9.","title":"Prerequisites"},{"location":"operator-guide/edp-kiosk-usage/#diagram-of-using-kiosk-by-edp","text":"Agenda blue - created by Helm chart; grey - created manually","title":"Diagram of using Kiosk by EDP"},{"location":"operator-guide/edp-kiosk-usage/#usage","text":"EDP installation area on a diagram is described by following link ; Once the above step is executed, edp-cd-pipeline-operator service account will be linked to kiosk-edit ClusterRole to get an ability for leveraging Kiosk specific resources (e.g. Space); Newly created stage in \u2039edp-project\u203a installation of EDP generates new Kiosk Space resource that is linked to Kiosk Account; According to Kiosk doc the Space resource creates namespace with RoleBinding that contains relation between service account which is linked to Kiosk Account and kiosk-space-admin ClusterRole. As cd-pipeline-operator ServiceAccount is linked to Account, it has admin permissions in all generated by him namespaces.","title":"Usage"},{"location":"operator-guide/edp-kiosk-usage/#related-articles","text":"Install EDP Set Up Kiosk","title":"Related Articles"},{"location":"operator-guide/enable-irsa/","text":"Associate IAM Roles With Service Accounts \u2693\ufe0e This page contains accurate information on how to associate an IAM role with the service account (IRSA) in EPAM Delivery Platform. Get acquainted with the AWS Official Documentation on the subject before proceeding. Common Configuration of IAM Roles With Service Accounts \u2693\ufe0e To successfully associate the IAM role with the service account, follow the steps below: Create an IAM role that will further be associated with the service account. This role must have the following trust policy: IAM Role { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/<OIDC_PROVIDER>\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"<OIDC_PROVIDER>:sub\": \"system:serviceaccount:<SERVICE_ACCOUNT_NAMESPACE>:<SERVICE_ACCOUNT_NAME>\" } } } ] } View cluster's \u2039OIDC_PROVIDER\u203a URL. aws eks describe-cluster --name <CLUSTER_NAME> --query \"cluster.identity.oidc.issuer\" --output text Example output: https://oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E \u2039OIDC_PROVIDER\u203a in this example will be: oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E Deploy the amazon-eks-pod-identity-webhook v0.2.0 as described below: 2.1. Provide the stable (ed8c41f) version of the Docker image in the deploy/deployment-base.yaml file. 2.2. Provide ${CA_BUNDLE}_in the_deploy/mutatingwebhook.yaml file: secret_name=$(kubectl -n default get sa default -o jsonpath='{.secrets[0].name}') \\ CA_BUNDLE=$(kubectl -n default get secret/$secret_name -o jsonpath='{.data.ca\\.crt}' | tr -d '\\n') 2.3. Deploy the Webhook: kubectl apply -f deploy/ 2.4. Approve the csr : csr_name=$(kubectl get csr -o jsonpath='{.items[?(@.spec.username==\"system:serviceaccount:default:pod-identity-webhook\")].metadata.name}') kubectl certificate approve $csr_name Annotate the created service account with the IAM role: Service Account apiVersion: v1 kind: ServiceAccount metadata: name: <SERVICE_ACCOUNT_NAME> namespace: <NAMESPACE> annotations: eks.amazonaws.com/role-arn: \"arn:aws:iam::<AWS_ACCOUNT_ID>:role/<IAM_ROLE_NAME>\" All newly launched pods with this service account will be modified and then use the associated IAM role. Find below the pod specification template: Pod Template apiVersion: v1 kind: Pod metadata: name: irsa-test namespace: <POD_NAMESPACE> spec: serviceAccountName: <SERVICE_ACCOUNT_NAME> securityContext: fsGroup: 65534 containers: - name: terraform image: epamedp/edp-jenkins-terraform-agent:2.0.4 command: ['sh', '-c', 'awscliv2 sts \"get-caller-identity\" && sleep 3600'] Check the logs of the created pod from the template above. Example output: { \"UserId\": \"XXXXXXXXXXXXXXXXXXXXX:botocore-session-XXXXXXXXXX\", \"Account\": \"XXXXXXXXXXXX\", \"Arn\": \"arn:aws:sts::XXXXXXXXXXXX:assumed-role/AWSIRSATestRole/botocore-session-XXXXXXXXXX\" } As a result, it is possible to perform actions in AWS under the AWSIRSATestRole role. Related Articles \u2693\ufe0e Use Terraform Library in EDP","title":"Associate IAM Roles With Service Accounts"},{"location":"operator-guide/enable-irsa/#associate-iam-roles-with-service-accounts","text":"This page contains accurate information on how to associate an IAM role with the service account (IRSA) in EPAM Delivery Platform. Get acquainted with the AWS Official Documentation on the subject before proceeding.","title":"Associate IAM Roles With Service Accounts"},{"location":"operator-guide/enable-irsa/#common-configuration-of-iam-roles-with-service-accounts","text":"To successfully associate the IAM role with the service account, follow the steps below: Create an IAM role that will further be associated with the service account. This role must have the following trust policy: IAM Role { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/<OIDC_PROVIDER>\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"<OIDC_PROVIDER>:sub\": \"system:serviceaccount:<SERVICE_ACCOUNT_NAMESPACE>:<SERVICE_ACCOUNT_NAME>\" } } } ] } View cluster's \u2039OIDC_PROVIDER\u203a URL. aws eks describe-cluster --name <CLUSTER_NAME> --query \"cluster.identity.oidc.issuer\" --output text Example output: https://oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E \u2039OIDC_PROVIDER\u203a in this example will be: oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E Deploy the amazon-eks-pod-identity-webhook v0.2.0 as described below: 2.1. Provide the stable (ed8c41f) version of the Docker image in the deploy/deployment-base.yaml file. 2.2. Provide ${CA_BUNDLE}_in the_deploy/mutatingwebhook.yaml file: secret_name=$(kubectl -n default get sa default -o jsonpath='{.secrets[0].name}') \\ CA_BUNDLE=$(kubectl -n default get secret/$secret_name -o jsonpath='{.data.ca\\.crt}' | tr -d '\\n') 2.3. Deploy the Webhook: kubectl apply -f deploy/ 2.4. Approve the csr : csr_name=$(kubectl get csr -o jsonpath='{.items[?(@.spec.username==\"system:serviceaccount:default:pod-identity-webhook\")].metadata.name}') kubectl certificate approve $csr_name Annotate the created service account with the IAM role: Service Account apiVersion: v1 kind: ServiceAccount metadata: name: <SERVICE_ACCOUNT_NAME> namespace: <NAMESPACE> annotations: eks.amazonaws.com/role-arn: \"arn:aws:iam::<AWS_ACCOUNT_ID>:role/<IAM_ROLE_NAME>\" All newly launched pods with this service account will be modified and then use the associated IAM role. Find below the pod specification template: Pod Template apiVersion: v1 kind: Pod metadata: name: irsa-test namespace: <POD_NAMESPACE> spec: serviceAccountName: <SERVICE_ACCOUNT_NAME> securityContext: fsGroup: 65534 containers: - name: terraform image: epamedp/edp-jenkins-terraform-agent:2.0.4 command: ['sh', '-c', 'awscliv2 sts \"get-caller-identity\" && sleep 3600'] Check the logs of the created pod from the template above. Example output: { \"UserId\": \"XXXXXXXXXXXXXXXXXXXXX:botocore-session-XXXXXXXXXX\", \"Account\": \"XXXXXXXXXXXX\", \"Arn\": \"arn:aws:sts::XXXXXXXXXXXX:assumed-role/AWSIRSATestRole/botocore-session-XXXXXXXXXX\" } As a result, it is possible to perform actions in AWS under the AWSIRSATestRole role.","title":"Common Configuration of IAM Roles With Service Accounts"},{"location":"operator-guide/enable-irsa/#related-articles","text":"Use Terraform Library in EDP","title":"Related Articles"},{"location":"operator-guide/github-debug-webhooks/","text":"Debug GitHub Webhooks in Jenkins \u2693\ufe0e A webhook enables third-party services like GitHub to send real-time updates to an application. Updates are triggered by an event or an action by the webhook provider (for example, a push to a repository, a Pull Request creation), and pushed to the application via HTTP requests (namely, Jenkins). The GitHub Jenkins job provisioner creates a webhook in the GitHub repository during the Create release pipeline once the VCS Import Strategy is enabled and the GitHub Integration is completed. The Jenkins setup in EDP uses two following plugins responsible for listening on GitHub webhooks: GitHub plugin is configured to listen on Push events. GitHub Pull Request Builder is configured to listen on Pull Request events. In case of any sort of issues with webhooks, make sure that: The job ran at least once before the hook will work (once an application is created in EDP, the build job should be run automatically in Jenkins). Both webhooks ( Push and issue comment and Pull Request ) are created on the GitHub side (GitHub does not need separate webhooks for each branch unlike GitLab): Go to the GitHub repository - > Settings -> Webhooks. Click each webhook and check if the event delivery is successful. The URL payload should be as follows: https://jenkins-the-host.com/github-webhook/ is for the GitHub plugin and https://jenkins-the-host.com/ghprbhook/ is for the GitHub Pull Request Builder. The content type should be application/json for Push events and application/x-www-form-urlencoded for Pull Request events. The html_url in the Payload request should match the repository URL. The event can also be redelivered by clicking the Redeliver button. Note It may be convenient to debug webhooks with tools like Postman. Make sure to add all the headers to Postman from the webhook Request -> Headers field and send the payload (Request body) using the appropriate content type. Examples for Push and Pull Request events : The response in the Jenkins log: Jan 17, 2022 8:51:14 AM INFO org.jenkinsci.plugins.github.webhook.subscriber.PingGHEventSubscriber onEvent PING webhook received from repo <https://github.com/user-profile/user-repo>! The response in the Jenkins log: Jan 17, 2022 8:17:53 AM FINE org.jenkinsci.plugins.ghprb.GhprbRootAction Got payload event: ping The repo pushing to Jenkins, the GitHub project URL in the project configuration, and the repo(s) in the pipeline Job have to line up. GitHub hook trigger for GITScm polling is enabled for the Build job. GitHub Pull Request Builder is enabled for the Code Review job. It is convenient to filter through Jenkins log by using Jenkins custom Log Recorder . Go to Manage Jenkins -> System Log -> Add new log recorder The Push events for the GitHub: Logger Log Level org.jenkinsci.plugins.github.webhook.subscriber.DefaultPushGHEventSubscriber ALL com.cloudbees.jenkins.GitHubPushTrigger ALL com.cloudbees.jenkins.GitHubWebHook ALL org.jenkinsci.plugins.github.webhook.WebhookManager ALL org.jenkinsci.plugins.github.webhook.subscriber.PingGHEventSubscriber ALL The Pull Request events for the GitHub Pull Request Builder: Logger Log Level org.jenkinsci.plugins.ghprb.GhprbRootAction ALL org.jenkinsci.plugins.ghprb.GhprbTrigger ALL org.jenkinsci.plugins.ghprb.GhprbPullRequest ALL org.jenkinsci.plugins.ghprb.GhprbRepository ALL Note Here is a small example on how to use Pipeline script with webhooks for the GitHub plugin (it is already implemented in the EDP pipelines): properties([pipelineTriggers([githubPush()])]) node { git credentialsId: 'github-sshkey', url: 'https://github.com/someone/something.git', branch: 'master' } Push events may not work correctly with the Job Pipeline script from SCM option in the current version of the GitHub plugin 1.34.1 Related Articles \u2693\ufe0e Enable VCS Import Strategy GitHub Integration Manage Jenkins CI Pipeline Job Provision GitHub plugin GitHub Pull Request Builder","title":"Debug GitHub Webhooks in Jenkins"},{"location":"operator-guide/github-debug-webhooks/#debug-github-webhooks-in-jenkins","text":"A webhook enables third-party services like GitHub to send real-time updates to an application. Updates are triggered by an event or an action by the webhook provider (for example, a push to a repository, a Pull Request creation), and pushed to the application via HTTP requests (namely, Jenkins). The GitHub Jenkins job provisioner creates a webhook in the GitHub repository during the Create release pipeline once the VCS Import Strategy is enabled and the GitHub Integration is completed. The Jenkins setup in EDP uses two following plugins responsible for listening on GitHub webhooks: GitHub plugin is configured to listen on Push events. GitHub Pull Request Builder is configured to listen on Pull Request events. In case of any sort of issues with webhooks, make sure that: The job ran at least once before the hook will work (once an application is created in EDP, the build job should be run automatically in Jenkins). Both webhooks ( Push and issue comment and Pull Request ) are created on the GitHub side (GitHub does not need separate webhooks for each branch unlike GitLab): Go to the GitHub repository - > Settings -> Webhooks. Click each webhook and check if the event delivery is successful. The URL payload should be as follows: https://jenkins-the-host.com/github-webhook/ is for the GitHub plugin and https://jenkins-the-host.com/ghprbhook/ is for the GitHub Pull Request Builder. The content type should be application/json for Push events and application/x-www-form-urlencoded for Pull Request events. The html_url in the Payload request should match the repository URL. The event can also be redelivered by clicking the Redeliver button. Note It may be convenient to debug webhooks with tools like Postman. Make sure to add all the headers to Postman from the webhook Request -> Headers field and send the payload (Request body) using the appropriate content type. Examples for Push and Pull Request events : The response in the Jenkins log: Jan 17, 2022 8:51:14 AM INFO org.jenkinsci.plugins.github.webhook.subscriber.PingGHEventSubscriber onEvent PING webhook received from repo <https://github.com/user-profile/user-repo>! The response in the Jenkins log: Jan 17, 2022 8:17:53 AM FINE org.jenkinsci.plugins.ghprb.GhprbRootAction Got payload event: ping The repo pushing to Jenkins, the GitHub project URL in the project configuration, and the repo(s) in the pipeline Job have to line up. GitHub hook trigger for GITScm polling is enabled for the Build job. GitHub Pull Request Builder is enabled for the Code Review job. It is convenient to filter through Jenkins log by using Jenkins custom Log Recorder . Go to Manage Jenkins -> System Log -> Add new log recorder The Push events for the GitHub: Logger Log Level org.jenkinsci.plugins.github.webhook.subscriber.DefaultPushGHEventSubscriber ALL com.cloudbees.jenkins.GitHubPushTrigger ALL com.cloudbees.jenkins.GitHubWebHook ALL org.jenkinsci.plugins.github.webhook.WebhookManager ALL org.jenkinsci.plugins.github.webhook.subscriber.PingGHEventSubscriber ALL The Pull Request events for the GitHub Pull Request Builder: Logger Log Level org.jenkinsci.plugins.ghprb.GhprbRootAction ALL org.jenkinsci.plugins.ghprb.GhprbTrigger ALL org.jenkinsci.plugins.ghprb.GhprbPullRequest ALL org.jenkinsci.plugins.ghprb.GhprbRepository ALL Note Here is a small example on how to use Pipeline script with webhooks for the GitHub plugin (it is already implemented in the EDP pipelines): properties([pipelineTriggers([githubPush()])]) node { git credentialsId: 'github-sshkey', url: 'https://github.com/someone/something.git', branch: 'master' } Push events may not work correctly with the Job Pipeline script from SCM option in the current version of the GitHub plugin 1.34.1","title":"Debug GitHub Webhooks in Jenkins"},{"location":"operator-guide/github-debug-webhooks/#related-articles","text":"Enable VCS Import Strategy GitHub Integration Manage Jenkins CI Pipeline Job Provision GitHub plugin GitHub Pull Request Builder","title":"Related Articles"},{"location":"operator-guide/github-integration/","text":"GitHub Integration \u2693\ufe0e Discover the steps below to apply the GitHub integration correctly. Note Before applying the GitHub integration, make sure to enable VCS Import strategy. For details, please refer to the Enable VCS Import Strategy section. Create a new Job Provision by following the instruction . The job provisioner will create a job suite for an application added to EDP. It will also create webhooks for the project in GitHub. Note The steps below are required in order to automatically create and integrate Jenkins with GitHub webhooks. Create access token for GitHub: Click the profile account and navigate to Settings; Go to Developer Settings; Select Personal access token and generate a new one with the following parameters Note The access is required for the GitHub Pull Request Builder plugin to get Pull Request commits, their status, and author info. Warning Make sure to copy a new personal access token right at this moment because there will not be any ability to see it again. Navigate to Jenkins -> Credentials -> System -> Global credentials -> Add credentials , and create new credentials with the Secret text kind. In the Secret field, provide the GitHub API token, fill in the ID field with the github-access-token value: Navigate to Jenkins -> Manage Jenkins -> Configure system -> GitHub , and configure the GitHub server: Note Keep the Manage hooks check box clear since the Job Provisioner automatically creates webhooks in the repository regardless of the check box selection. Configure the GitHub Pull Request Builder plugin (this plugin is responsible for listening on Pull Request webhook events and triggering Code Review jobs): Note The Secret field is optional, for details, please refer to the official GitHub pull request builder plugin documentation . Related Articles \u2693\ufe0e Enable VCS Import Strategy Adjust Jira Integration Manage Jenkins CI Pipeline Job Provision","title":"GitHub Integration"},{"location":"operator-guide/github-integration/#github-integration","text":"Discover the steps below to apply the GitHub integration correctly. Note Before applying the GitHub integration, make sure to enable VCS Import strategy. For details, please refer to the Enable VCS Import Strategy section. Create a new Job Provision by following the instruction . The job provisioner will create a job suite for an application added to EDP. It will also create webhooks for the project in GitHub. Note The steps below are required in order to automatically create and integrate Jenkins with GitHub webhooks. Create access token for GitHub: Click the profile account and navigate to Settings; Go to Developer Settings; Select Personal access token and generate a new one with the following parameters Note The access is required for the GitHub Pull Request Builder plugin to get Pull Request commits, their status, and author info. Warning Make sure to copy a new personal access token right at this moment because there will not be any ability to see it again. Navigate to Jenkins -> Credentials -> System -> Global credentials -> Add credentials , and create new credentials with the Secret text kind. In the Secret field, provide the GitHub API token, fill in the ID field with the github-access-token value: Navigate to Jenkins -> Manage Jenkins -> Configure system -> GitHub , and configure the GitHub server: Note Keep the Manage hooks check box clear since the Job Provisioner automatically creates webhooks in the repository regardless of the check box selection. Configure the GitHub Pull Request Builder plugin (this plugin is responsible for listening on Pull Request webhook events and triggering Code Review jobs): Note The Secret field is optional, for details, please refer to the official GitHub pull request builder plugin documentation .","title":"GitHub Integration"},{"location":"operator-guide/github-integration/#related-articles","text":"Enable VCS Import Strategy Adjust Jira Integration Manage Jenkins CI Pipeline Job Provision","title":"Related Articles"},{"location":"operator-guide/gitlab-debug-webhooks/","text":"Debug GitLab Webhooks in Jenkins \u2693\ufe0e A webhook enables third-party services like GitLab to send real-time updates to the application. Updates are triggered by some event or action by the webhook provider (for example, a push to a repository, a Merge Request creation), and pushed to the application via HTTP requests (namely, Jenkins). The GitLab Jenkins job provisioner creates a webhook in the GitLab repository during the Create release pipeline once the VCS Import Strategy is enabled and the GitLab Integration is completed. The Jenkins setup in EDP uses the GitLab plugin responsible for listening on GitLab webhook Push and Merge Request events. In case of any sort of issues with webhooks, make sure that: The job ran at least once before the hook will work (once an application is created in EDP, the build job should be run automatically in Jenkins). Both webhooks ( Push Events, Note Events and Merge Requests Events, Note Events ) are created on the GitLab side for each branch (GitLab should have separate webhooks for each branch unlike GitHub). Go to the GitLab repository - > Settings -> Webhooks Click Edit next to each webhook and check if the event delivery is successful. If the webhook is sent, the Recent Deliveries list becomes available. Click View details . The URL payload should be similar to the job URL on Jenkins. For example: https://jenkins-server.com/project/the-project-name/MAIN-Build-the-job is for the Push events and https://jenkins-server.com/project/the-project-name/MAIN-Code-review-the-job is the Merge Request events. The content type should be application/json for both events. The web_url in the Request body should match the repository URL. The event can also be redelivered by clicking the Resend Request button. Note It may be convenient to debug webhooks with tools like Postman. Make sure to add all the headers to Postman from the webhook Request headers field and send the payload (Request body) using the appropriate content type. Examples for Push and Merge Request events: The response in the Jenkins log: Jan 17, 2022 11:26:34 AM INFO com.dabsquared.gitlabjenkins.webhook.GitLabWebHook getDynamic WebHook called with url: /project/the-project-name/MAIN-Build-the-job Jan 17, 2022 11:26:34 AM INFO com.dabsquared.gitlabjenkins.trigger.handler.AbstractWebHookTriggerHandler handle the-project-name/MAIN-Build-the-job triggered for push. The response in the Jenkins log: Jan 17, 2022 11:14:58 AM INFO com.dabsquared.gitlabjenkins.webhook.GitLabWebHook getDynamic WebHook called with url: /project/the-project-name/MAIN-Code-review-the-job The repository pushing to Jenkins and the repository(ies) in the pipeline Job have to line up. GitLab Connection should be present in the job settings. The settings in Build Triggers for the Build job should be as follows: The settings in Build Triggers for the Code Review job should be as follows: It will be convenient to filter through Jenkins log by using Jenkins custom Log Recorder . Go to Manage Jenkins -> System Log -> Add new log recorder. The Push and Merge Request events for the GitLab: Logger Log Level com.dabsquared.gitlabjenkins.webhook.GitLabWebHook ALL com.dabsquared.gitlabjenkins.trigger.handler.AbstractWebHookTriggerHandler ALL com.dabsquared.gitlabjenkins.trigger.handler.merge.MergeRequestHookTriggerHandlerImpl ALL com.dabsquared.gitlabjenkins.util.CommitStatusUpdater ALL Related Articles \u2693\ufe0e Enable VCS Import Strategy Jenkins integration with GitLab GitLab Integration Manage Jenkins CI Pipeline Job Provision GitLab plugin","title":"Debug GitLab Webhooks in Jenkins"},{"location":"operator-guide/gitlab-debug-webhooks/#debug-gitlab-webhooks-in-jenkins","text":"A webhook enables third-party services like GitLab to send real-time updates to the application. Updates are triggered by some event or action by the webhook provider (for example, a push to a repository, a Merge Request creation), and pushed to the application via HTTP requests (namely, Jenkins). The GitLab Jenkins job provisioner creates a webhook in the GitLab repository during the Create release pipeline once the VCS Import Strategy is enabled and the GitLab Integration is completed. The Jenkins setup in EDP uses the GitLab plugin responsible for listening on GitLab webhook Push and Merge Request events. In case of any sort of issues with webhooks, make sure that: The job ran at least once before the hook will work (once an application is created in EDP, the build job should be run automatically in Jenkins). Both webhooks ( Push Events, Note Events and Merge Requests Events, Note Events ) are created on the GitLab side for each branch (GitLab should have separate webhooks for each branch unlike GitHub). Go to the GitLab repository - > Settings -> Webhooks Click Edit next to each webhook and check if the event delivery is successful. If the webhook is sent, the Recent Deliveries list becomes available. Click View details . The URL payload should be similar to the job URL on Jenkins. For example: https://jenkins-server.com/project/the-project-name/MAIN-Build-the-job is for the Push events and https://jenkins-server.com/project/the-project-name/MAIN-Code-review-the-job is the Merge Request events. The content type should be application/json for both events. The web_url in the Request body should match the repository URL. The event can also be redelivered by clicking the Resend Request button. Note It may be convenient to debug webhooks with tools like Postman. Make sure to add all the headers to Postman from the webhook Request headers field and send the payload (Request body) using the appropriate content type. Examples for Push and Merge Request events: The response in the Jenkins log: Jan 17, 2022 11:26:34 AM INFO com.dabsquared.gitlabjenkins.webhook.GitLabWebHook getDynamic WebHook called with url: /project/the-project-name/MAIN-Build-the-job Jan 17, 2022 11:26:34 AM INFO com.dabsquared.gitlabjenkins.trigger.handler.AbstractWebHookTriggerHandler handle the-project-name/MAIN-Build-the-job triggered for push. The response in the Jenkins log: Jan 17, 2022 11:14:58 AM INFO com.dabsquared.gitlabjenkins.webhook.GitLabWebHook getDynamic WebHook called with url: /project/the-project-name/MAIN-Code-review-the-job The repository pushing to Jenkins and the repository(ies) in the pipeline Job have to line up. GitLab Connection should be present in the job settings. The settings in Build Triggers for the Build job should be as follows: The settings in Build Triggers for the Code Review job should be as follows: It will be convenient to filter through Jenkins log by using Jenkins custom Log Recorder . Go to Manage Jenkins -> System Log -> Add new log recorder. The Push and Merge Request events for the GitLab: Logger Log Level com.dabsquared.gitlabjenkins.webhook.GitLabWebHook ALL com.dabsquared.gitlabjenkins.trigger.handler.AbstractWebHookTriggerHandler ALL com.dabsquared.gitlabjenkins.trigger.handler.merge.MergeRequestHookTriggerHandlerImpl ALL com.dabsquared.gitlabjenkins.util.CommitStatusUpdater ALL","title":"Debug GitLab Webhooks in Jenkins"},{"location":"operator-guide/gitlab-debug-webhooks/#related-articles","text":"Enable VCS Import Strategy Jenkins integration with GitLab GitLab Integration Manage Jenkins CI Pipeline Job Provision GitLab plugin","title":"Related Articles"},{"location":"operator-guide/gitlab-integration/","text":"GitLab Integration \u2693\ufe0e Discover the steps below to apply the GitLab integration correctly. Note Before applying the GitLab integration, make sure to enable VCS Import strategy. For details, please refer to the Enable VCS Import Strategy section. Create a new Job Provision by following the instruction .The job provisioner will create a job suite for an application added to EDP. It will also create webhooks for the project in GitLab. Note The steps below are required in order to automatically create and integrate Jenkins GitLab webhooks. Create access token in Gitlab : Log in to GitLab ; In the top-right corner, click the avatar and select Settings ; On the User Settings menu, select Access Tokens ; Choose a name and an optional expiry date for the token; In the Scopes block, select the api scope for the token; Click the Create personal access token button. Note Make sure to save the access token as there will not be any ability to access it once again. Create Jenkins Credential ID by navigating to Jenkins -> Credentials -> System -> Global Credentials -> Add Credentials : Select Kind Secret text ; Select Global scope; Secret - the Access Token that was created earlier; ID - the gitlab-access-token ID; Description - the description of the current Credential ID; Warning Using the GitLab integration, a webhook is automatically created. After the removal of the application, the webhook stops working but not deleted. If necessary, it must be deleted manually. Note The next step is necessary if it is needed to see the status of Jenkins Merge Requests builds in the GitLab CI/CD Pipelines section. Configure Gitlab plugin by navigating to Manage Jenkins -> Configure System and fill in the GitLab plugin settings: Connection name - gitlab; Gitlab host URL - a host URL to GitLab; Credentials - credentials with Access Token to GitLab ( gitlab-access-token ); This is how the Merge Requests build statuses look like in the GitLab CI/CD Pipelines section: Related Articles \u2693\ufe0e Adjust Jira Integration Enable VCS Import Strategy Jenkins integration with GitLab Manage Jenkins CI Pipeline Job Provision","title":"GitLab Integration"},{"location":"operator-guide/gitlab-integration/#gitlab-integration","text":"Discover the steps below to apply the GitLab integration correctly. Note Before applying the GitLab integration, make sure to enable VCS Import strategy. For details, please refer to the Enable VCS Import Strategy section. Create a new Job Provision by following the instruction .The job provisioner will create a job suite for an application added to EDP. It will also create webhooks for the project in GitLab. Note The steps below are required in order to automatically create and integrate Jenkins GitLab webhooks. Create access token in Gitlab : Log in to GitLab ; In the top-right corner, click the avatar and select Settings ; On the User Settings menu, select Access Tokens ; Choose a name and an optional expiry date for the token; In the Scopes block, select the api scope for the token; Click the Create personal access token button. Note Make sure to save the access token as there will not be any ability to access it once again. Create Jenkins Credential ID by navigating to Jenkins -> Credentials -> System -> Global Credentials -> Add Credentials : Select Kind Secret text ; Select Global scope; Secret - the Access Token that was created earlier; ID - the gitlab-access-token ID; Description - the description of the current Credential ID; Warning Using the GitLab integration, a webhook is automatically created. After the removal of the application, the webhook stops working but not deleted. If necessary, it must be deleted manually. Note The next step is necessary if it is needed to see the status of Jenkins Merge Requests builds in the GitLab CI/CD Pipelines section. Configure Gitlab plugin by navigating to Manage Jenkins -> Configure System and fill in the GitLab plugin settings: Connection name - gitlab; Gitlab host URL - a host URL to GitLab; Credentials - credentials with Access Token to GitLab ( gitlab-access-token ); This is how the Merge Requests build statuses look like in the GitLab CI/CD Pipelines section:","title":"GitLab Integration"},{"location":"operator-guide/gitlab-integration/#related-articles","text":"Adjust Jira Integration Enable VCS Import Strategy Jenkins integration with GitLab Manage Jenkins CI Pipeline Job Provision","title":"Related Articles"},{"location":"operator-guide/gitlabci-integration/","text":"Adjust GitLab CI Tool \u2693\ufe0e EDP allows selecting one of two available CI (Continuous Integration) tools, namely: Jenkins or GitLab. The Jenkins tool is available by default. To use the GitLab CI tool, it is required to make it available first. Follow the steps below to adjust the GitLab CI tool: In GitLab, add the environment variables to the project. To add variables, navigate to Settings -> CI/CD -> Expand Variables -> Add Variable : Apply the necessary variables as they differ in accordance with the cluster OpenShift / Kubernetes, see below: OpenShift Environment Variables Description DOCKER_REGISTRY_URL URL to OpenShift docker registry DOCKER_REGISTRY_PASSWORD Service Account token that has an access to registry DOCKER_REGISTRY_USER user name OPENSHIFT_SA_TOKEN token that can be used to log in to OpenShift Info In order to get access to the Docker registry and OpenShift, use the gitlab-ci ServiceAccount; pay attention that SA description contains the credentials and secrets: Kubernetes Environment Variables Description DOCKER_REGISTRY_URL URL to Amazon ECR AWS_ACCESS_KEY_ID auto IAM user access key AWS_SECRET_ACCESS_KEY auto IAM user secret access key K8S_SA_TOKEN token that can be used to log in to Kubernetes Note To get the access to ECR , it is required to have an auto IAM user that has rights to push/create a repository. In Admin Console, select the CI tool in the Advanced Settings menu during the codebase creation: Note The selection of the CI tool is available only with the Import strategy. As soon as the codebase is provisioned, the .gitlab-ci.yml file will be created in the repository that describes the pipeline's stages and logic:","title":"Adjust GitLab CI Tool"},{"location":"operator-guide/gitlabci-integration/#adjust-gitlab-ci-tool","text":"EDP allows selecting one of two available CI (Continuous Integration) tools, namely: Jenkins or GitLab. The Jenkins tool is available by default. To use the GitLab CI tool, it is required to make it available first. Follow the steps below to adjust the GitLab CI tool: In GitLab, add the environment variables to the project. To add variables, navigate to Settings -> CI/CD -> Expand Variables -> Add Variable : Apply the necessary variables as they differ in accordance with the cluster OpenShift / Kubernetes, see below: OpenShift Environment Variables Description DOCKER_REGISTRY_URL URL to OpenShift docker registry DOCKER_REGISTRY_PASSWORD Service Account token that has an access to registry DOCKER_REGISTRY_USER user name OPENSHIFT_SA_TOKEN token that can be used to log in to OpenShift Info In order to get access to the Docker registry and OpenShift, use the gitlab-ci ServiceAccount; pay attention that SA description contains the credentials and secrets: Kubernetes Environment Variables Description DOCKER_REGISTRY_URL URL to Amazon ECR AWS_ACCESS_KEY_ID auto IAM user access key AWS_SECRET_ACCESS_KEY auto IAM user secret access key K8S_SA_TOKEN token that can be used to log in to Kubernetes Note To get the access to ECR , it is required to have an auto IAM user that has rights to push/create a repository. In Admin Console, select the CI tool in the Advanced Settings menu during the codebase creation: Note The selection of the CI tool is available only with the Import strategy. As soon as the codebase is provisioned, the .gitlab-ci.yml file will be created in the repository that describes the pipeline's stages and logic:","title":"Adjust GitLab CI Tool"},{"location":"operator-guide/import-strategy/","text":"Enable VCS Import Strategy \u2693\ufe0e Note Enabling the VCS Import strategy is a prerequisite to integrate EDP with GitLab or GitHub. In order to use the Import strategy, it is required to add a Secret with SSH key, GitServer Custom Resource, and Jenkins credentials by taking the steps below. Generate an SSH key pair and add a public key to GitLab or GitHub account. ssh - keygen - t ed25519 - C \"email@example.com\" Create a Secret in the \u2039edp-project\u203a namespace for the Git account with the id_rsa , id_rsa.pub , and username fields. As a sample, it is possible to use the following command (use github-sshkey instead of gitlab-sshkey for GitHub): kubectl create secret generic gitlab - sshkey - n < edp - project > \\ -- from - file = id_rsa = id_rsa \\ -- from - file = id_rsa . pub = id_rsa . pub \\ --from-literal=username=user@example.com Create GitServer Custom Resource in the project namespace with the gitHost , gitUser , httpsPort , sshPort , nameSshKeySecret , and createCodeReviewPipeline fields. As a sample, it is possible to use the following template: apiVersion : v2 . edp . epam . com / v1alpha1 kind : GitServer metadata : name : < git - server - name > namespace : < edp - project > spec : createCodeReviewPipeline : false gitHost : git . sample . com gitUser : git httpsPort : 443 nameSshKeySecret : gitlab - sshkey sshPort : 22 Note The value of the nameSshKeySecret property is the name of the Secret that is indicated in the first point above. Create Jenkinsserviceaccount Custom Resource with the credentials field that corresponds to the nameSshKeySecret property above. apiVersion : v2 . edp . epam . com / v1alpha1 kind : JenkinsServiceAccount metadata : name : gitlab - sshkey namespace : < edp - project > spec : credentials : gitlab - sshkey ownerName : '' type : ssh Double-check if the credentials are created in Jenkins correctly. Navigate to Jenkins -> Credentials -> System -> Global Credentials -> Add Credentials : Make sure that the value of INTEGRATION_STRATEGIES variable is set to Import in the edp-admin-console deployment (should be by default). You can check it here: spec : containers : - name : edp - admin - console .... env : - name : INTEGRATION_STRATEGIES value : 'Create,Clone,Import' Note The default values can be found in the deployment templates for edp-admin-console-operator in edp-install umbrella chart Note The Import strategy can be found on the Applications page of the Admin Console. For details, please refer to the Add Applications page. The next step is to integrate Jenkins with GitHub or GitLab . Related Articles \u2693\ufe0e Add Application GitHub Integration GitLab Integration","title":"Enable VCS Import Strategy"},{"location":"operator-guide/import-strategy/#enable-vcs-import-strategy","text":"Note Enabling the VCS Import strategy is a prerequisite to integrate EDP with GitLab or GitHub. In order to use the Import strategy, it is required to add a Secret with SSH key, GitServer Custom Resource, and Jenkins credentials by taking the steps below. Generate an SSH key pair and add a public key to GitLab or GitHub account. ssh - keygen - t ed25519 - C \"email@example.com\" Create a Secret in the \u2039edp-project\u203a namespace for the Git account with the id_rsa , id_rsa.pub , and username fields. As a sample, it is possible to use the following command (use github-sshkey instead of gitlab-sshkey for GitHub): kubectl create secret generic gitlab - sshkey - n < edp - project > \\ -- from - file = id_rsa = id_rsa \\ -- from - file = id_rsa . pub = id_rsa . pub \\ --from-literal=username=user@example.com Create GitServer Custom Resource in the project namespace with the gitHost , gitUser , httpsPort , sshPort , nameSshKeySecret , and createCodeReviewPipeline fields. As a sample, it is possible to use the following template: apiVersion : v2 . edp . epam . com / v1alpha1 kind : GitServer metadata : name : < git - server - name > namespace : < edp - project > spec : createCodeReviewPipeline : false gitHost : git . sample . com gitUser : git httpsPort : 443 nameSshKeySecret : gitlab - sshkey sshPort : 22 Note The value of the nameSshKeySecret property is the name of the Secret that is indicated in the first point above. Create Jenkinsserviceaccount Custom Resource with the credentials field that corresponds to the nameSshKeySecret property above. apiVersion : v2 . edp . epam . com / v1alpha1 kind : JenkinsServiceAccount metadata : name : gitlab - sshkey namespace : < edp - project > spec : credentials : gitlab - sshkey ownerName : '' type : ssh Double-check if the credentials are created in Jenkins correctly. Navigate to Jenkins -> Credentials -> System -> Global Credentials -> Add Credentials : Make sure that the value of INTEGRATION_STRATEGIES variable is set to Import in the edp-admin-console deployment (should be by default). You can check it here: spec : containers : - name : edp - admin - console .... env : - name : INTEGRATION_STRATEGIES value : 'Create,Clone,Import' Note The default values can be found in the deployment templates for edp-admin-console-operator in edp-install umbrella chart Note The Import strategy can be found on the Applications page of the Admin Console. For details, please refer to the Add Applications page. The next step is to integrate Jenkins with GitHub or GitLab .","title":"Enable VCS Import Strategy"},{"location":"operator-guide/import-strategy/#related-articles","text":"Add Application GitHub Integration GitLab Integration","title":"Related Articles"},{"location":"operator-guide/install-edp/","text":"Install EDP \u2693\ufe0e Inspect the main steps to install EPAM Delivery Platform. Please check the prerequisites section before starting installation. Note The installation process below is given for a Kubernetes cluster. The steps that differ for an OpenShift cluster are indicated in the notes. Note \u2039edp-project\u203a is the name of the EDP tenant in all the following steps. Create an \u2039edp-project\u203a namespace or a Kiosk space depending on whether Kiosk is used or not. Without Kiosk, create a namespace: kubectl create namespace <edp-project> Note For an OpenShift cluster, run the oc command instead of kubectl one. With Kiosk, create a relevant space: apiVersion : tenancy . kiosk . sh / v1alpha1 kind : Space metadata : name : < edp - project > spec : account : < edp - project >- admin Note Kiosk is mandatory for EDP v.2.8.x. It is not implemented for the previous versions, and is optional for EDP since v.2.9.x. To store EDP data, use any existing Postgres database or create one during the installation. Additionally, create two secrets in the \u2039edp-project\u203a namespace: one with administrative credentials and another with credentials for the EDP tenant (database schema). Create a secret for administrative access to the database: kubectl -n <edp-project> create secret generic super-admin-db \\ --from-literal=username=<super_admin_db_username> \\ --from-literal=password=<super_admin_db_password> Warning Do not use the admin username here since admin is a reserved name. Create a secret for an EDP tenant database user. kubectl -n <edp-project> create secret generic db-admin-console \\ --from-literal=username=<tenant_db_username> \\ --from-literal=password=<tenant_db_password> Warning Do not use the admin username here since admin is a reserved name. For EDP, it is required to have Keycloak access to perform the integration. Create a secret with user and password provisioned in the step 2 of the Keycloak Configuration section. kubectl -n <edp-project> create secret generic keycloak \\ --from-literal=username=<username> \\ --from-literal=password=<password> Add the Helm EPAMEDP Charts for local client. helm repo add epamedp https://chartmuseum.demo.edp-epam.com/ Choose the required Helm chart version: helm search repo epamedp / edp - install NAME CHART VERSION APP VERSION DESCRIPTION epamedp / edp - install 2 . 9 . 0 2 . 9 . 0 A Helm chart for EDP Install Note It is highly recommended to use the latest released version. Check the parameters in the EDP installation chart. For details, please refer to the values.yaml file. With the external database, set the global.database.host value to the database DNS name accessible from the \u2039edp-project\u203a namespace. Install EDP in the \u2039edp-project\u203a namespace with the helm tool. helm install edp epamedp / edp - install -- wait -- timeout = 900 s \\ -- version < edp_version > \\ -- values values . yaml \\ -- namespace < edp - project > See the details on parameters below: View: values.yaml global : # Name of the <edp-project> EDP namespace that was previously defined; edpName : <edp-project> # DNS wildcard for routing in the Kubernetes cluster; dnsWildCard : <DNS_wilcdard> # Enable or disable integration with Kiosk (by default the value is true) kioskEnabled : <true/false> # Kubernetes API server; webConsole : url : <kubeconfig.clusters.cluster.server> # set platform type: OpenShift or Kubernetes; platform : <platform_type> # Administrators of the tenant separated by comma (,) e.g. user@example.com; admins : [ user1@example.com , user2@example.com ] # Developers of the tenant separated by comma (,) e.g. user@example.com; developers : [ user1@example.com , user2@example.com ] keycloak-operator : keycloak : # URL to Keycloak; url : <keycloak_endpoint> dockerRegistry : enabled : true # URL to Docker registry e.g. <aws_account_id>.dkr.ecr.<region>.amazonaws.com; url : <aws_account_id>.dkr.ecr.<region>.amazonaws.com gerrit-operator : gerrit : # Gerrit SSH node port; sshPort : <gerrit_ssh_port> Note Set global.platform=openshift while deploying EDP in OpenShift. Info The full installation with integration between tools will take at least 10 minutes. Next Steps \u2693\ufe0e Consult VCS integration section, if it is necessary to integrate GitLab or GitHub with EDP. Related Articles \u2693\ufe0e Enable VCS Import Strategy GitHub Integration GitLab Integration Install Keycloak Set Up Kubernetes Set Up OpenShift","title":"Install EDP"},{"location":"operator-guide/install-edp/#install-edp","text":"Inspect the main steps to install EPAM Delivery Platform. Please check the prerequisites section before starting installation. Note The installation process below is given for a Kubernetes cluster. The steps that differ for an OpenShift cluster are indicated in the notes. Note \u2039edp-project\u203a is the name of the EDP tenant in all the following steps. Create an \u2039edp-project\u203a namespace or a Kiosk space depending on whether Kiosk is used or not. Without Kiosk, create a namespace: kubectl create namespace <edp-project> Note For an OpenShift cluster, run the oc command instead of kubectl one. With Kiosk, create a relevant space: apiVersion : tenancy . kiosk . sh / v1alpha1 kind : Space metadata : name : < edp - project > spec : account : < edp - project >- admin Note Kiosk is mandatory for EDP v.2.8.x. It is not implemented for the previous versions, and is optional for EDP since v.2.9.x. To store EDP data, use any existing Postgres database or create one during the installation. Additionally, create two secrets in the \u2039edp-project\u203a namespace: one with administrative credentials and another with credentials for the EDP tenant (database schema). Create a secret for administrative access to the database: kubectl -n <edp-project> create secret generic super-admin-db \\ --from-literal=username=<super_admin_db_username> \\ --from-literal=password=<super_admin_db_password> Warning Do not use the admin username here since admin is a reserved name. Create a secret for an EDP tenant database user. kubectl -n <edp-project> create secret generic db-admin-console \\ --from-literal=username=<tenant_db_username> \\ --from-literal=password=<tenant_db_password> Warning Do not use the admin username here since admin is a reserved name. For EDP, it is required to have Keycloak access to perform the integration. Create a secret with user and password provisioned in the step 2 of the Keycloak Configuration section. kubectl -n <edp-project> create secret generic keycloak \\ --from-literal=username=<username> \\ --from-literal=password=<password> Add the Helm EPAMEDP Charts for local client. helm repo add epamedp https://chartmuseum.demo.edp-epam.com/ Choose the required Helm chart version: helm search repo epamedp / edp - install NAME CHART VERSION APP VERSION DESCRIPTION epamedp / edp - install 2 . 9 . 0 2 . 9 . 0 A Helm chart for EDP Install Note It is highly recommended to use the latest released version. Check the parameters in the EDP installation chart. For details, please refer to the values.yaml file. With the external database, set the global.database.host value to the database DNS name accessible from the \u2039edp-project\u203a namespace. Install EDP in the \u2039edp-project\u203a namespace with the helm tool. helm install edp epamedp / edp - install -- wait -- timeout = 900 s \\ -- version < edp_version > \\ -- values values . yaml \\ -- namespace < edp - project > See the details on parameters below: View: values.yaml global : # Name of the <edp-project> EDP namespace that was previously defined; edpName : <edp-project> # DNS wildcard for routing in the Kubernetes cluster; dnsWildCard : <DNS_wilcdard> # Enable or disable integration with Kiosk (by default the value is true) kioskEnabled : <true/false> # Kubernetes API server; webConsole : url : <kubeconfig.clusters.cluster.server> # set platform type: OpenShift or Kubernetes; platform : <platform_type> # Administrators of the tenant separated by comma (,) e.g. user@example.com; admins : [ user1@example.com , user2@example.com ] # Developers of the tenant separated by comma (,) e.g. user@example.com; developers : [ user1@example.com , user2@example.com ] keycloak-operator : keycloak : # URL to Keycloak; url : <keycloak_endpoint> dockerRegistry : enabled : true # URL to Docker registry e.g. <aws_account_id>.dkr.ecr.<region>.amazonaws.com; url : <aws_account_id>.dkr.ecr.<region>.amazonaws.com gerrit-operator : gerrit : # Gerrit SSH node port; sshPort : <gerrit_ssh_port> Note Set global.platform=openshift while deploying EDP in OpenShift. Info The full installation with integration between tools will take at least 10 minutes.","title":"Install EDP"},{"location":"operator-guide/install-edp/#next-steps","text":"Consult VCS integration section, if it is necessary to integrate GitLab or GitHub with EDP.","title":"Next Steps"},{"location":"operator-guide/install-edp/#related-articles","text":"Enable VCS Import Strategy GitHub Integration GitLab Integration Install Keycloak Set Up Kubernetes Set Up OpenShift","title":"Related Articles"},{"location":"operator-guide/install-ingress-nginx/","text":"Install Ingress-nginx \u2693\ufe0e Inspect the prerequisites and the main steps to perform for installing ingress-nginx on Kubernetes. Prerequisites \u2693\ufe0e Kubectl version 1.20.0 is installed. Please refer to the Kubernetes official website for details. Helm version 3.6.0 is installed. Please refer to the Helm page on GitHub for details. Installation \u2693\ufe0e To install ingress-nginx, follow the steps below: Create ingress-nginx namespace: kubectl create namespace ingress-nginx Add a chart repository: helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx helm repo update Install Ingress-nginx: helm install ingress ingress-nginx/ingress-nginx \\ --version 3.23.0 \\ --values values.yaml \\ --namespace ingress-nginx Check out the values.yaml file sample of the Ingress-nginx customization: View: values.yaml controller : addHeaders : X-Content-Type-Options : nosniff X-Frame-Options : SAMEORIGIN resources : limits : memory : \"256Mi\" requests : cpu : \"50m\" memory : \"128M\" config : ssl-redirect : 'true' client-header-buffer-size : '64k' http2-max-field-size : '64k' http2-max-header-size : '64k' large-client-header-buffers : '4 64k' upstream-keepalive-timeout : '120' keep-alive : '10' use-forwarded-headers : 'true' proxy-real-ip-cidr : '172.32.0.0/16' proxy-buffer-size : '8k' service : type : NodePort nodePorts : http : 32080 https : 32443 updateStrategy : rollingUpdate : maxUnavailable : 1 type : RollingUpdate metrics : enabled : true defaultBackend : enabled : true serviceAccount : create : true name : nginx-ingress-service-account Note Align value controller.config.proxy-real-ip-cidr with AWS VPC CIDR .","title":"Install Ingress-nginx"},{"location":"operator-guide/install-ingress-nginx/#install-ingress-nginx","text":"Inspect the prerequisites and the main steps to perform for installing ingress-nginx on Kubernetes.","title":"Install Ingress-nginx"},{"location":"operator-guide/install-ingress-nginx/#prerequisites","text":"Kubectl version 1.20.0 is installed. Please refer to the Kubernetes official website for details. Helm version 3.6.0 is installed. Please refer to the Helm page on GitHub for details.","title":"Prerequisites"},{"location":"operator-guide/install-ingress-nginx/#installation","text":"To install ingress-nginx, follow the steps below: Create ingress-nginx namespace: kubectl create namespace ingress-nginx Add a chart repository: helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx helm repo update Install Ingress-nginx: helm install ingress ingress-nginx/ingress-nginx \\ --version 3.23.0 \\ --values values.yaml \\ --namespace ingress-nginx Check out the values.yaml file sample of the Ingress-nginx customization: View: values.yaml controller : addHeaders : X-Content-Type-Options : nosniff X-Frame-Options : SAMEORIGIN resources : limits : memory : \"256Mi\" requests : cpu : \"50m\" memory : \"128M\" config : ssl-redirect : 'true' client-header-buffer-size : '64k' http2-max-field-size : '64k' http2-max-header-size : '64k' large-client-header-buffers : '4 64k' upstream-keepalive-timeout : '120' keep-alive : '10' use-forwarded-headers : 'true' proxy-real-ip-cidr : '172.32.0.0/16' proxy-buffer-size : '8k' service : type : NodePort nodePorts : http : 32080 https : 32443 updateStrategy : rollingUpdate : maxUnavailable : 1 type : RollingUpdate metrics : enabled : true defaultBackend : enabled : true serviceAccount : create : true name : nginx-ingress-service-account Note Align value controller.config.proxy-real-ip-cidr with AWS VPC CIDR .","title":"Installation"},{"location":"operator-guide/install-keycloak/","text":"Install Keycloak \u2693\ufe0e Inspect the prerequisites and the main steps to perform for installing Keycloak. Note The installation process below is given for a Kubernetes cluster. The steps that differ for an OpenShift cluster are indicated in the notes. Prerequisites \u2693\ufe0e Kubectl version 1.18.0 is installed. Please refer to the Kubernetes official website for details. Helm version 3.6.0 is installed. Please refer to the Helm page on GitHub for details. Note EDP team is using a helm chart from the codecentric repository, but other repositories can be used as well (e.g. bitnami ). Installation \u2693\ufe0e To install Keycloak, follow the steps below: Check that a security namespace is created. If not, run the following command to create it: kubectl create namespace security Note On an OpenShift cluster, run the oc command instead of kubectl one. Add a chart repository: helm repo add codecentric https://codecentric.github.io/helm-charts helm repo update Create Keycloak admin secret: kubectl -n security create secret generic keycloak-admin-creds \\ --from-literal=username=<keycloak_admin_username> \\ --from-literal=password=<keycloak_admin_password> Create PostgreSQL admin secret: kubectl -n security create secret generic keycloak-postgresql \\ --from-literal=postgresql-password=<postgresql_password> \\ --from-literal=postgresql-postgres-password=<postgresql_postgres_password> Install Keycloak v.15.0.2 which is included in the codecentric/keycloak Helm chart v.15.1.0: Info The Keycloak can be deployed in a production ready mode (e.g. it can include multiple replicas, persistent storage, autoscaling, monitoring, etc.). For details, please refer to the Official Chart Documentation . helm install keycloak codecentric/keycloak \\ --version 15.1.0 \\ --values values.yaml \\ --namespace security Check out the values.yaml file sample of the Keycloak customization: View: values.yaml replicas : 1 # start: create OpenShift realm which is required by EDP extraInitContainers : | - name: realm-provider image: busybox imagePullPolicy: IfNotPresent command: - sh args: - -c - | echo '{\"realm\": \"openshift\",\"enabled\": true}' > /realm/openshift.json volumeMounts: - name: realm mountPath: /realm extraVolumeMounts : | - name: realm mountPath: /realm extraVolumes : | - name: realm emptyDir: {} extraEnv : | - name: PROXY_ADDRESS_FORWARDING value: \"true\" - name: KEYCLOAK_USER valueFrom: secretKeyRef: name: keycloak-admin-creds key: username - name: KEYCLOAK_PASSWORD valueFrom: secretKeyRef: name: keycloak-admin-creds key: password - name: KEYCLOAK_IMPORT value: /realm/openshift.json # This block should be uncommented if you install Keycloak on Kubernetes ingress : enabled : true annotations : kubernetes.io/ingress.class : nginx ingress.kubernetes.io/affinity : cookie rules : - host : keycloak.<ROOT_DOMAIN> paths : - path : \"/\" pathType : Prefix # This block should be uncommented if you set Keycloak to OpenShift and change the host field # route: # enabled: true # host: \"keycloak.<ROOT_DOMAIN>\" resources : limits : memory : \"2048Mi\" requests : cpu : \"50m\" memory : \"512Mi\" # Use PostgreSQL deployed in a container persistence : deployPostgres : true dbVendor : postgres postgresql : postgresqlUsername : admin postgresqlDatabase : keycloak existingSecret : keycloak-postgresql persistence : enabled : true size : \"3Gi\" # If the StorageClass with reclaimPolicy: Retain is used, install an additional StorageClass before installing Keycloak # (the code is given below). # If the default StorageClass will be used - change \"gp2-retain\" to \"gp2\" storageClass : \"gp2-retain\" Install an additional StorageClass (optional): Note If the Keycloak installation uses a StorageClass with reclaimPolicy: Retain , install additional StorageClass storageclass.yaml . View: storageclass.yaml kind : StorageClass apiVersion : storage.k8s.io/v1 metadata : name : gp2-retain provisioner : kubernetes.io/aws-ebs parameters : fsType : ext4 type : gp2 reclaimPolicy : Retain volumeBindingMode : WaitForFirstConsumer Install the custom SecurityContextConstraints (only for OpenShift): Note If you use OpenShift as your deployment platform, add customsecuritycontextconstraints.yaml . View: customsecuritycontextconstraints.yaml allowHostDirVolumePlugin : false allowHostIPC : false allowHostNetwork : false allowHostPID : false allowHostPorts : false allowPrivilegeEscalation : true allowPrivilegedContainer : false allowedCapabilities : null apiVersion : security.openshift.io/v1 defaultAddCapabilities : null allowedCapabilities : [] allowedFlexVolumes : [] defaultAddCapabilities : [] fsGroup : type : MustRunAs ranges : - min : 999 max : 65543 groups : [] kind : SecurityContextConstraints metadata : annotations : \"helm.sh/hook\" : \"pre-install\" name : customscc priority : 1 readOnlyRootFilesystem : false requiredDropCapabilities : - KILL - MKNOD - SETUID - SETGID runAsUser : type : MustRunAsRange uidRangeMin : 1 uidRangeMax : 65543 seLinuxContext : type : MustRunAs supplementalGroups : type : RunAsAny users : - system:serviceaccount:security:keycloak - system:serviceaccount:security:default volumes : - configMap - downwardAPI - emptyDir - persistentVolumeClaim - projected - secret Configuration \u2693\ufe0e To prepare Keycloak for integration with EDP, follow the steps below: Ensure that the \"openshift\" realm is created. Create a user edp_\u2039EDP_PROJECT\u203a in \"Master\" realm. Note This user should be used by EDP to access Keycloak. Please refer to the Install EDP section for details. In the \"Role Mappings\" tab, assign the proper roles to user: Realm Roles: create-realm, offline_access, uma_authorization Client Roles \"openshift-realm\": impersonation, manage-authorization, manage-clients, manage-users","title":"Install Keycloak"},{"location":"operator-guide/install-keycloak/#install-keycloak","text":"Inspect the prerequisites and the main steps to perform for installing Keycloak. Note The installation process below is given for a Kubernetes cluster. The steps that differ for an OpenShift cluster are indicated in the notes.","title":"Install Keycloak"},{"location":"operator-guide/install-keycloak/#prerequisites","text":"Kubectl version 1.18.0 is installed. Please refer to the Kubernetes official website for details. Helm version 3.6.0 is installed. Please refer to the Helm page on GitHub for details. Note EDP team is using a helm chart from the codecentric repository, but other repositories can be used as well (e.g. bitnami ).","title":"Prerequisites"},{"location":"operator-guide/install-keycloak/#installation","text":"To install Keycloak, follow the steps below: Check that a security namespace is created. If not, run the following command to create it: kubectl create namespace security Note On an OpenShift cluster, run the oc command instead of kubectl one. Add a chart repository: helm repo add codecentric https://codecentric.github.io/helm-charts helm repo update Create Keycloak admin secret: kubectl -n security create secret generic keycloak-admin-creds \\ --from-literal=username=<keycloak_admin_username> \\ --from-literal=password=<keycloak_admin_password> Create PostgreSQL admin secret: kubectl -n security create secret generic keycloak-postgresql \\ --from-literal=postgresql-password=<postgresql_password> \\ --from-literal=postgresql-postgres-password=<postgresql_postgres_password> Install Keycloak v.15.0.2 which is included in the codecentric/keycloak Helm chart v.15.1.0: Info The Keycloak can be deployed in a production ready mode (e.g. it can include multiple replicas, persistent storage, autoscaling, monitoring, etc.). For details, please refer to the Official Chart Documentation . helm install keycloak codecentric/keycloak \\ --version 15.1.0 \\ --values values.yaml \\ --namespace security Check out the values.yaml file sample of the Keycloak customization: View: values.yaml replicas : 1 # start: create OpenShift realm which is required by EDP extraInitContainers : | - name: realm-provider image: busybox imagePullPolicy: IfNotPresent command: - sh args: - -c - | echo '{\"realm\": \"openshift\",\"enabled\": true}' > /realm/openshift.json volumeMounts: - name: realm mountPath: /realm extraVolumeMounts : | - name: realm mountPath: /realm extraVolumes : | - name: realm emptyDir: {} extraEnv : | - name: PROXY_ADDRESS_FORWARDING value: \"true\" - name: KEYCLOAK_USER valueFrom: secretKeyRef: name: keycloak-admin-creds key: username - name: KEYCLOAK_PASSWORD valueFrom: secretKeyRef: name: keycloak-admin-creds key: password - name: KEYCLOAK_IMPORT value: /realm/openshift.json # This block should be uncommented if you install Keycloak on Kubernetes ingress : enabled : true annotations : kubernetes.io/ingress.class : nginx ingress.kubernetes.io/affinity : cookie rules : - host : keycloak.<ROOT_DOMAIN> paths : - path : \"/\" pathType : Prefix # This block should be uncommented if you set Keycloak to OpenShift and change the host field # route: # enabled: true # host: \"keycloak.<ROOT_DOMAIN>\" resources : limits : memory : \"2048Mi\" requests : cpu : \"50m\" memory : \"512Mi\" # Use PostgreSQL deployed in a container persistence : deployPostgres : true dbVendor : postgres postgresql : postgresqlUsername : admin postgresqlDatabase : keycloak existingSecret : keycloak-postgresql persistence : enabled : true size : \"3Gi\" # If the StorageClass with reclaimPolicy: Retain is used, install an additional StorageClass before installing Keycloak # (the code is given below). # If the default StorageClass will be used - change \"gp2-retain\" to \"gp2\" storageClass : \"gp2-retain\" Install an additional StorageClass (optional): Note If the Keycloak installation uses a StorageClass with reclaimPolicy: Retain , install additional StorageClass storageclass.yaml . View: storageclass.yaml kind : StorageClass apiVersion : storage.k8s.io/v1 metadata : name : gp2-retain provisioner : kubernetes.io/aws-ebs parameters : fsType : ext4 type : gp2 reclaimPolicy : Retain volumeBindingMode : WaitForFirstConsumer Install the custom SecurityContextConstraints (only for OpenShift): Note If you use OpenShift as your deployment platform, add customsecuritycontextconstraints.yaml . View: customsecuritycontextconstraints.yaml allowHostDirVolumePlugin : false allowHostIPC : false allowHostNetwork : false allowHostPID : false allowHostPorts : false allowPrivilegeEscalation : true allowPrivilegedContainer : false allowedCapabilities : null apiVersion : security.openshift.io/v1 defaultAddCapabilities : null allowedCapabilities : [] allowedFlexVolumes : [] defaultAddCapabilities : [] fsGroup : type : MustRunAs ranges : - min : 999 max : 65543 groups : [] kind : SecurityContextConstraints metadata : annotations : \"helm.sh/hook\" : \"pre-install\" name : customscc priority : 1 readOnlyRootFilesystem : false requiredDropCapabilities : - KILL - MKNOD - SETUID - SETGID runAsUser : type : MustRunAsRange uidRangeMin : 1 uidRangeMax : 65543 seLinuxContext : type : MustRunAs supplementalGroups : type : RunAsAny users : - system:serviceaccount:security:keycloak - system:serviceaccount:security:default volumes : - configMap - downwardAPI - emptyDir - persistentVolumeClaim - projected - secret","title":"Installation"},{"location":"operator-guide/install-keycloak/#configuration","text":"To prepare Keycloak for integration with EDP, follow the steps below: Ensure that the \"openshift\" realm is created. Create a user edp_\u2039EDP_PROJECT\u203a in \"Master\" realm. Note This user should be used by EDP to access Keycloak. Please refer to the Install EDP section for details. In the \"Role Mappings\" tab, assign the proper roles to user: Realm Roles: create-realm, offline_access, uma_authorization Client Roles \"openshift-realm\": impersonation, manage-authorization, manage-clients, manage-users","title":"Configuration"},{"location":"operator-guide/install-kiosk/","text":"Set Up Kiosk \u2693\ufe0e Kiosk is a multi-tenancy extension for managing tenants and namespaces in a shared Kubernetes cluster. Within EDP, Kiosk is used to separate resources and enables the following options (see more details ): Access to the EDP tenants in a Kubernetes cluster; Multi-tenancy access at the service account level for application deploy. Inspect the main steps to set up Kiosk for the proceeding EDP installation. Note Kiosk deploy is mandatory for EDP v.2.8.. In earlier versions, Kiosk is not implemented. Since EDP v.2.9.0, integration with Kiosk is an optional feature. You may not want to use it, so just skip those steps and disable in Helm parameters during EDP deploy . # global.kioskEnabled: <true/false> Prerequisites \u2693\ufe0e Kubectl version 1.18.0 is installed. Please refer to the Kubernetes official website for details. Helm version 3.6.0 is installed. Please refer to the Helm page on GitHub for details. Installation \u2693\ufe0e Deploy Kiosk version 0.2.9 in the cluster. To install it, run the following command: # Install kiosk with helm v3 helm repo add kiosk https://charts.devspace.sh/ kubectl create namespace kiosk helm install kiosk --version 0.2.9 kiosk/kiosk -n kiosk --atomic For more details, please refer to the Kiosk page on the GitHub. Configuration \u2693\ufe0e To provide access to the EDP tenant, follow the steps below. Check that a security namespace is created. If not, run the following command to create it: kubectl create namespace security Note On an OpenShift cluster, run the oc command instead of kubectl one. Add a service account to the security namespace. kubectl -n security create sa <edp-project> Info \u2039edp-project\u203a is the name of the EDP tenant here and in all the following steps. Apply the Account template to the cluster. Please check the sample below: apiVersion : tenancy.kiosk.sh/v1alpha1 kind : Account metadata : name : <edp-project>-admin spec : space : clusterRole : kiosk-space-admin subjects : - kind : ServiceAccount name : <edp-project> namespace : security Apply the ClusterRoleBinding to the 'kiosk-edit' cluster role (current role is added during installation of Kiosk). Please check the sample below: apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRoleBinding metadata : name : <edp-project>-kiosk-edit subjects : - kind : ServiceAccount name : <edp-project> namespace : security roleRef : kind : ClusterRole name : kiosk-edit apiGroup : rbac.authorization.k8s.io To provide access to the EDP tenant, generate kubeconfig with Service Account \u2039edp-project\u203a permission. The \u2039edp-project\u203a account created earlier is located in the security namespace.","title":"Set Up Kiosk"},{"location":"operator-guide/install-kiosk/#set-up-kiosk","text":"Kiosk is a multi-tenancy extension for managing tenants and namespaces in a shared Kubernetes cluster. Within EDP, Kiosk is used to separate resources and enables the following options (see more details ): Access to the EDP tenants in a Kubernetes cluster; Multi-tenancy access at the service account level for application deploy. Inspect the main steps to set up Kiosk for the proceeding EDP installation. Note Kiosk deploy is mandatory for EDP v.2.8.. In earlier versions, Kiosk is not implemented. Since EDP v.2.9.0, integration with Kiosk is an optional feature. You may not want to use it, so just skip those steps and disable in Helm parameters during EDP deploy . # global.kioskEnabled: <true/false>","title":"Set Up Kiosk"},{"location":"operator-guide/install-kiosk/#prerequisites","text":"Kubectl version 1.18.0 is installed. Please refer to the Kubernetes official website for details. Helm version 3.6.0 is installed. Please refer to the Helm page on GitHub for details.","title":"Prerequisites"},{"location":"operator-guide/install-kiosk/#installation","text":"Deploy Kiosk version 0.2.9 in the cluster. To install it, run the following command: # Install kiosk with helm v3 helm repo add kiosk https://charts.devspace.sh/ kubectl create namespace kiosk helm install kiosk --version 0.2.9 kiosk/kiosk -n kiosk --atomic For more details, please refer to the Kiosk page on the GitHub.","title":"Installation"},{"location":"operator-guide/install-kiosk/#configuration","text":"To provide access to the EDP tenant, follow the steps below. Check that a security namespace is created. If not, run the following command to create it: kubectl create namespace security Note On an OpenShift cluster, run the oc command instead of kubectl one. Add a service account to the security namespace. kubectl -n security create sa <edp-project> Info \u2039edp-project\u203a is the name of the EDP tenant here and in all the following steps. Apply the Account template to the cluster. Please check the sample below: apiVersion : tenancy.kiosk.sh/v1alpha1 kind : Account metadata : name : <edp-project>-admin spec : space : clusterRole : kiosk-space-admin subjects : - kind : ServiceAccount name : <edp-project> namespace : security Apply the ClusterRoleBinding to the 'kiosk-edit' cluster role (current role is added during installation of Kiosk). Please check the sample below: apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRoleBinding metadata : name : <edp-project>-kiosk-edit subjects : - kind : ServiceAccount name : <edp-project> namespace : security roleRef : kind : ClusterRole name : kiosk-edit apiGroup : rbac.authorization.k8s.io To provide access to the EDP tenant, generate kubeconfig with Service Account \u2039edp-project\u203a permission. The \u2039edp-project\u203a account created earlier is located in the security namespace.","title":"Configuration"},{"location":"operator-guide/install-loki/","text":"Install Grafana Loki \u2693\ufe0e EDP configures the logging with the help of Grafana Loki aggregation system. Installation \u2693\ufe0e To install Loki, follow the steps below: Create logging namespace: kubectl create namespace logging Note On the OpenShift cluster, run the oc command instead of the kubectl command. Add a chart repository: helm repo add grafana https://grafana.github.io/helm-charts helm repo update Note It is possible to use Amazon Simple Storage Service Amazon S3 as an object storage for Loki. To configure access, please refer to the IRSA for Loki documentation. Install Loki v.2.6.0 : helm install loki grafana/loki \\ --version 2.6.0 \\ --values values.yaml \\ --namespace logging Check out the values.yaml file sample of the Loki customization: View: values.yaml image : repository : grafana/loki tag : 2.3.0 config : auth_enabled : false schema_config : configs : - from : 2021-06-01 store : boltdb-shipper object_store : s3 schema : v11 index : prefix : loki_index_ period : 24h storage_config : aws : s3 : s3://<AWS_REGION>/loki-<CLUSTER_NAME> boltdb_shipper : active_index_directory : /data/loki/index cache_location : /data/loki/boltdb-cache shared_store : s3 chunk_store_config : max_look_back_period : 24h resources : limits : memory : \"128Mi\" requests : cpu : \"50m\" memory : \"128Mi\" serviceAccount : create : true name : edp-loki annotations : eks.amazonaws.com/role-arn : \"arn:aws:iam::<AWS_ACCOUNT_ID>:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki persistence: enabled: false Note In case of using cluster scheduling and amazon-eks-pod-identity-webhook , it is necessary to restart the Loki pod after the cluster is up and running. Please refer to the Schedule Pods Restart documentation. Configure custom bucket policy to delete the old data.","title":"Install Grafana Loki"},{"location":"operator-guide/install-loki/#install-grafana-loki","text":"EDP configures the logging with the help of Grafana Loki aggregation system.","title":"Install Grafana Loki"},{"location":"operator-guide/install-loki/#installation","text":"To install Loki, follow the steps below: Create logging namespace: kubectl create namespace logging Note On the OpenShift cluster, run the oc command instead of the kubectl command. Add a chart repository: helm repo add grafana https://grafana.github.io/helm-charts helm repo update Note It is possible to use Amazon Simple Storage Service Amazon S3 as an object storage for Loki. To configure access, please refer to the IRSA for Loki documentation. Install Loki v.2.6.0 : helm install loki grafana/loki \\ --version 2.6.0 \\ --values values.yaml \\ --namespace logging Check out the values.yaml file sample of the Loki customization: View: values.yaml image : repository : grafana/loki tag : 2.3.0 config : auth_enabled : false schema_config : configs : - from : 2021-06-01 store : boltdb-shipper object_store : s3 schema : v11 index : prefix : loki_index_ period : 24h storage_config : aws : s3 : s3://<AWS_REGION>/loki-<CLUSTER_NAME> boltdb_shipper : active_index_directory : /data/loki/index cache_location : /data/loki/boltdb-cache shared_store : s3 chunk_store_config : max_look_back_period : 24h resources : limits : memory : \"128Mi\" requests : cpu : \"50m\" memory : \"128Mi\" serviceAccount : create : true name : edp-loki annotations : eks.amazonaws.com/role-arn : \"arn:aws:iam::<AWS_ACCOUNT_ID>:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki persistence: enabled: false Note In case of using cluster scheduling and amazon-eks-pod-identity-webhook , it is necessary to restart the Loki pod after the cluster is up and running. Please refer to the Schedule Pods Restart documentation. Configure custom bucket policy to delete the old data.","title":"Installation"},{"location":"operator-guide/install-velero/","text":"Install Velero \u2693\ufe0e Velero is an open source tool to safely back up, recover, and migrate Kubernetes clusters and persistent volumes. It works both on premises and in a public cloud. Velero consists of a server process running as a deployment in your Kubernetes cluster and a command-line interface (CLI) with which DevOps teams and platform operators configure scheduled backups, trigger ad-hoc backups, perform restores, and more. Installation \u2693\ufe0e To install Velero, follow the steps below: Create velero namespace: kubectl create namespace velero Note On an OpenShift cluster, run the oc command instead of kubectl one. Add a chart repository: helm repo add vmware-tanzu https://vmware-tanzu.github.io/helm-charts helm repo update Note Velero AWS Plugin requires access to AWS resources. To configure access, please refer to the IRSA for Velero documentation. Install Velero v.2.14.13 : helm install velero vmware-tanzu/velero \\ --version 2.14.13 \\ --values values.yaml \\ --namespace velero Check out the values.yaml file sample of the Velero customization: View: values.yaml image : repository : velero/velero tag : v1.5.3 securityContext : fsGroup : 65534 restic : securityContext : fsGroup : 65534 serviceAccount : server : create : true name : edp-velero annotations : eks.amazonaws.com/role-arn : \"arn:aws:iam::<AWS_ACCOUNT_ID>:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" credentials : useSecret : false configuration : provider : aws backupStorageLocation : name : default bucket : velero-<CLUSTER_NAME> config : region : eu-central-1 volumeSnapshotLocation : name : default config : region : <AWS_REGION> initContainers : - name : velero-plugin-for-aws image : velero/velero-plugin-for-aws:v1.1.0 volumeMounts : - mountPath : /target name : plugins Note In case of using cluster scheduling and amazon-eks-pod-identity-webhook , it is necessary to restart the Velero pod after the cluster is up and running. Please refer to the Schedule Pods Restart documentation. Install the client side (velero cli) according to the official documentation . Configuration \u2693\ufe0e Create backup for all components in the namespace: velero backup create < BACKUP_NAME > -- include - namespaces < NAMESPACE > Create a daily backup of the namespace: velero schedule create < BACKUP_NAME > -- schedule \" 0 10 * * MON-FRI \" -- include - namespaces < NAMESPACE > -- ttl 120 h0m0s To restore from backup, use the following command: velero restore create <RESTORE_NAME> --from-backup <BACKUP_NAME>","title":"Install Velero"},{"location":"operator-guide/install-velero/#install-velero","text":"Velero is an open source tool to safely back up, recover, and migrate Kubernetes clusters and persistent volumes. It works both on premises and in a public cloud. Velero consists of a server process running as a deployment in your Kubernetes cluster and a command-line interface (CLI) with which DevOps teams and platform operators configure scheduled backups, trigger ad-hoc backups, perform restores, and more.","title":"Install Velero"},{"location":"operator-guide/install-velero/#installation","text":"To install Velero, follow the steps below: Create velero namespace: kubectl create namespace velero Note On an OpenShift cluster, run the oc command instead of kubectl one. Add a chart repository: helm repo add vmware-tanzu https://vmware-tanzu.github.io/helm-charts helm repo update Note Velero AWS Plugin requires access to AWS resources. To configure access, please refer to the IRSA for Velero documentation. Install Velero v.2.14.13 : helm install velero vmware-tanzu/velero \\ --version 2.14.13 \\ --values values.yaml \\ --namespace velero Check out the values.yaml file sample of the Velero customization: View: values.yaml image : repository : velero/velero tag : v1.5.3 securityContext : fsGroup : 65534 restic : securityContext : fsGroup : 65534 serviceAccount : server : create : true name : edp-velero annotations : eks.amazonaws.com/role-arn : \"arn:aws:iam::<AWS_ACCOUNT_ID>:role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" credentials : useSecret : false configuration : provider : aws backupStorageLocation : name : default bucket : velero-<CLUSTER_NAME> config : region : eu-central-1 volumeSnapshotLocation : name : default config : region : <AWS_REGION> initContainers : - name : velero-plugin-for-aws image : velero/velero-plugin-for-aws:v1.1.0 volumeMounts : - mountPath : /target name : plugins Note In case of using cluster scheduling and amazon-eks-pod-identity-webhook , it is necessary to restart the Velero pod after the cluster is up and running. Please refer to the Schedule Pods Restart documentation. Install the client side (velero cli) according to the official documentation .","title":"Installation"},{"location":"operator-guide/install-velero/#configuration","text":"Create backup for all components in the namespace: velero backup create < BACKUP_NAME > -- include - namespaces < NAMESPACE > Create a daily backup of the namespace: velero schedule create < BACKUP_NAME > -- schedule \" 0 10 * * MON-FRI \" -- include - namespaces < NAMESPACE > -- ttl 120 h0m0s To restore from backup, use the following command: velero restore create <RESTORE_NAME> --from-backup <BACKUP_NAME>","title":"Configuration"},{"location":"operator-guide/jira-gerrit-integration/","text":"Adjust VCS Integration With Jira \u2693\ufe0e In order to adjust the Version Control System integration with Jira Server, first make sure you have the following prerequisites: VCS Server Jira Crucible When checked the prerequisites, follow the steps below to proceed with the integration: Integrate every project in VCS Server with every project in Crucible by creating a corresponding request in EPAM Support Portal . Add the repositories links and fill in the Keep Informed field as this request must be approved. Provide additional details to the support team. If the VCS is Gerrit, inspect the sample below of its integration: 2.1 Create a new \"crucible- \" user in Gerrit with SSH key and add a new user to the \"Non-Interactive Users\" Gerrit group; 2.2 Create a new group in Gerrit \"crucible-watcher-group\" and add the \"crucible- \" user; 2.3 Provide access to All-Projects for the \"crucible-watcher-group\" group: To link commits with Jira ticket, being in Gerrit, enter a Jira ticket ID in a commit message using the specific format: [PROJECT-CODE-1234]: commit message where PROJECT-CODE is a specific code of a project, 1234 is an ID number, and a commit message. As a result, all Gerrit commits will be displayed on Crucible : Related Articles \u2693\ufe0e Adjust Jira Integration","title":"Adjust VCS Integration With Jira"},{"location":"operator-guide/jira-gerrit-integration/#adjust-vcs-integration-with-jira","text":"In order to adjust the Version Control System integration with Jira Server, first make sure you have the following prerequisites: VCS Server Jira Crucible When checked the prerequisites, follow the steps below to proceed with the integration: Integrate every project in VCS Server with every project in Crucible by creating a corresponding request in EPAM Support Portal . Add the repositories links and fill in the Keep Informed field as this request must be approved. Provide additional details to the support team. If the VCS is Gerrit, inspect the sample below of its integration: 2.1 Create a new \"crucible- \" user in Gerrit with SSH key and add a new user to the \"Non-Interactive Users\" Gerrit group; 2.2 Create a new group in Gerrit \"crucible-watcher-group\" and add the \"crucible- \" user; 2.3 Provide access to All-Projects for the \"crucible-watcher-group\" group: To link commits with Jira ticket, being in Gerrit, enter a Jira ticket ID in a commit message using the specific format: [PROJECT-CODE-1234]: commit message where PROJECT-CODE is a specific code of a project, 1234 is an ID number, and a commit message. As a result, all Gerrit commits will be displayed on Crucible :","title":"Adjust VCS Integration With Jira"},{"location":"operator-guide/jira-gerrit-integration/#related-articles","text":"Adjust Jira Integration","title":"Related Articles"},{"location":"operator-guide/jira-integration/","text":"Adjust Jira Integration \u2693\ufe0e In order to adjust the Jira server integration, first add JiraServer CR by performing the following: Create Secret in the OpenShift/Kubernetes namespace for Jira Server account with the username and password fields: apiVersion : v1 data : password : passwordInBase64 username : usernameInBase64 kind : Secret metadata : name : epam - jira - user type : kubernetes . io / basic - auth Create JiraServer CR in the OpenShift/Kubernetes namespace with the apiUrl , credentialName and rootUrl fields: apiVersion : v2 . edp . epam . com / v1alpha1 kind : JiraServer metadata : name : epam - jira spec : apiUrl : 'https://jira-api.example.com' credentialName : jira - user rootUrl : 'https://jira.example.com' status : available : true last_time_updated : '2021-04-05T10:51:07.042048633Z' Note The value of the credentialName property is the name of the Secret, which is indicated in the first point above. Being in Admin Console, navigate to the Advanced Settings menu to check that the Integrate with Jira Server check box appeared:","title":"Adjust Jira Integration"},{"location":"operator-guide/jira-integration/#adjust-jira-integration","text":"In order to adjust the Jira server integration, first add JiraServer CR by performing the following: Create Secret in the OpenShift/Kubernetes namespace for Jira Server account with the username and password fields: apiVersion : v1 data : password : passwordInBase64 username : usernameInBase64 kind : Secret metadata : name : epam - jira - user type : kubernetes . io / basic - auth Create JiraServer CR in the OpenShift/Kubernetes namespace with the apiUrl , credentialName and rootUrl fields: apiVersion : v2 . edp . epam . com / v1alpha1 kind : JiraServer metadata : name : epam - jira spec : apiUrl : 'https://jira-api.example.com' credentialName : jira - user rootUrl : 'https://jira.example.com' status : available : true last_time_updated : '2021-04-05T10:51:07.042048633Z' Note The value of the credentialName property is the name of the Secret, which is indicated in the first point above. Being in Admin Console, navigate to the Advanced Settings menu to check that the Integrate with Jira Server check box appeared:","title":"Adjust Jira Integration"},{"location":"operator-guide/kaniko-irsa/","text":"IAM Roles for Kaniko Service Accounts \u2693\ufe0e Note The information below is relevant in case ECR is used as Docker container registry. Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation. The \"build-image-kaniko\" stage manages ECR through IRSA that should be available on the cluster. Follow the steps below to create a required role: Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko_policy\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"ecr:*\", \"cloudtrail:LookupEvents\" ], \"Resource\": \"arn:aws:ecr:<AWS_REGION>:<AWS_ACCOUNT_ID>:repository/<EDP_NAMESPACE>/*\" }, { \"Effect\": \"Allow\", \"Action\": \"ecr:GetAuthorizationToken\", \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": [ \"ecr:DescribeRepositories\", \"ecr:CreateRepository\" ], \"Resource\": \"arn:aws:ecr:<AWS_REGION>:<AWS_ACCOUNT_ID>:repository/*\" } ] } Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\" with trust relationships: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/<OIDC_PROVIDER>\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"<OIDC_PROVIDER>:sub\": \"system:serviceaccount:<EDP_NAMESPACE>:edp-kaniko\" } } } ] } Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\" role. Define the resulted arn role value into the kanikoRoleArn parameter in values.yaml during the EDP installation . Related Articles \u2693\ufe0e Associate IAM Roles With Service Accounts Install EDP","title":"IAM Roles for Kaniko Service Accounts"},{"location":"operator-guide/kaniko-irsa/#iam-roles-for-kaniko-service-accounts","text":"Note The information below is relevant in case ECR is used as Docker container registry. Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation. The \"build-image-kaniko\" stage manages ECR through IRSA that should be available on the cluster. Follow the steps below to create a required role: Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko_policy\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"ecr:*\", \"cloudtrail:LookupEvents\" ], \"Resource\": \"arn:aws:ecr:<AWS_REGION>:<AWS_ACCOUNT_ID>:repository/<EDP_NAMESPACE>/*\" }, { \"Effect\": \"Allow\", \"Action\": \"ecr:GetAuthorizationToken\", \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": [ \"ecr:DescribeRepositories\", \"ecr:CreateRepository\" ], \"Resource\": \"arn:aws:ecr:<AWS_REGION>:<AWS_ACCOUNT_ID>:repository/*\" } ] } Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\" with trust relationships: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/<OIDC_PROVIDER>\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"<OIDC_PROVIDER>:sub\": \"system:serviceaccount:<EDP_NAMESPACE>:edp-kaniko\" } } } ] } Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039EDP_NAMESPACE\u203aKaniko\" role. Define the resulted arn role value into the kanikoRoleArn parameter in values.yaml during the EDP installation .","title":"IAM Roles for Kaniko Service Accounts"},{"location":"operator-guide/kaniko-irsa/#related-articles","text":"Associate IAM Roles With Service Accounts Install EDP","title":"Related Articles"},{"location":"operator-guide/kubernetes-cluster-settings/","text":"Set Up Kubernetes \u2693\ufe0e Make sure the cluster meets the following conditions: Kubernetes cluster is installed with minimum 2 worker nodes with total capacity 32 Cores and 8Gb RAM; Machine with kubectl is installed with a cluster-admin access to the Kubernetes cluster; Ingress controller is installed in a cluster, for example ingress-nginx ; Ingress controller is configured with the disabled HTTP/2 protocol and header size of 64k support; Example of Config Map for Nginx ingress controller: kind : ConfigMap apiVersion : v1 metadata : name : nginx - configuration namespace : ingress - nginx labels : app . kubernetes . io / name : ingress - nginx app . kubernetes . io / part - of : ingress - nginx data : client - header - buffer - size : 64 k large - client - header - buffers : 4 64 k use - http2 : \"false\" Load balancer (if any exists in front of ingress controller) is configured with session stickiness, disabled HTTP/2 protocol and header size of 32k support; Cluster nodes and pods have access to the cluster via external URLs. For instance, add in AWS the VPC NAT gateway elastic IP to the cluster external load balancers security group); Keycloak instance is installed. To get accurate information on how to install Keycloak, please refer to the Install Keycloak instruction; Helm 3.1 or higher is installed on the installation machine with the help of the Installing Helm instruction; A storage class is used with the Retain Reclaim Policy . See the example below. Storage class template with the Retain Reclaim Policy: kind: StorageClass apiVersion: storage.k8s.io/v1 metadata: name: gp2-retain provisioner: kubernetes.io/aws-ebs parameters: fsType: ext4 type: gp2 reclaimPolicy: Retain volumeBindingMode: WaitForFirstConsumer Related Articles \u2693\ufe0e Install Ingress-nginx Install Keycloak","title":"Set Up Kubernetes"},{"location":"operator-guide/kubernetes-cluster-settings/#set-up-kubernetes","text":"Make sure the cluster meets the following conditions: Kubernetes cluster is installed with minimum 2 worker nodes with total capacity 32 Cores and 8Gb RAM; Machine with kubectl is installed with a cluster-admin access to the Kubernetes cluster; Ingress controller is installed in a cluster, for example ingress-nginx ; Ingress controller is configured with the disabled HTTP/2 protocol and header size of 64k support; Example of Config Map for Nginx ingress controller: kind : ConfigMap apiVersion : v1 metadata : name : nginx - configuration namespace : ingress - nginx labels : app . kubernetes . io / name : ingress - nginx app . kubernetes . io / part - of : ingress - nginx data : client - header - buffer - size : 64 k large - client - header - buffers : 4 64 k use - http2 : \"false\" Load balancer (if any exists in front of ingress controller) is configured with session stickiness, disabled HTTP/2 protocol and header size of 32k support; Cluster nodes and pods have access to the cluster via external URLs. For instance, add in AWS the VPC NAT gateway elastic IP to the cluster external load balancers security group); Keycloak instance is installed. To get accurate information on how to install Keycloak, please refer to the Install Keycloak instruction; Helm 3.1 or higher is installed on the installation machine with the help of the Installing Helm instruction; A storage class is used with the Retain Reclaim Policy . See the example below. Storage class template with the Retain Reclaim Policy: kind: StorageClass apiVersion: storage.k8s.io/v1 metadata: name: gp2-retain provisioner: kubernetes.io/aws-ebs parameters: fsType: ext4 type: gp2 reclaimPolicy: Retain volumeBindingMode: WaitForFirstConsumer","title":"Set Up Kubernetes"},{"location":"operator-guide/kubernetes-cluster-settings/#related-articles","text":"Install Ingress-nginx Install Keycloak","title":"Related Articles"},{"location":"operator-guide/loki-irsa/","text":"IAM Roles for Loki Service Accounts \u2693\ufe0e Note Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation. It is possible to use Amazon Simple Storage Service Amazon S3 as object storage for Loki. In this case Loki requires access to AWS resources. Follow the steps below to create a required role: Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki_policy\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"s3:ListObjects\", \"s3:ListBucket\", \"s3:PutObject\", \"s3:GetObject\", \"s3:DeleteObject\" ], \"Resource\": [ \"arn:aws:s3:::loki-*\" ] }, { \"Effect\": \"Allow\", \"Action\": [ \"s3:ListBucket\" ], \"Resource\": [ \"arn:aws:s3:::loki-*\" ] } ] } Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" with trust relationships: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/<OIDC_PROVIDER>\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"<OIDC_PROVIDER>:sub\": \"system:serviceaccount:<LOKI_NAMESPACE>:edp-loki\" } } } ] } Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" role. Make sure that Amazon S3 bucket with name loki-\u2039CLUSTER_NAME\u203a exists. Provide key value eks.amazonaws.com/role-arn: \"arn:aws:iam:: :role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" into the serviceAccount.annotations parameter in values.yaml during the Loki Installation . Related Articles \u2693\ufe0e Associate IAM Roles With Service Accounts Install Grafana Loki","title":"IAM Roles for Loki Service Accounts"},{"location":"operator-guide/loki-irsa/#iam-roles-for-loki-service-accounts","text":"Note Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation. It is possible to use Amazon Simple Storage Service Amazon S3 as object storage for Loki. In this case Loki requires access to AWS resources. Follow the steps below to create a required role: Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki_policy\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"s3:ListObjects\", \"s3:ListBucket\", \"s3:PutObject\", \"s3:GetObject\", \"s3:DeleteObject\" ], \"Resource\": [ \"arn:aws:s3:::loki-*\" ] }, { \"Effect\": \"Allow\", \"Action\": [ \"s3:ListBucket\" ], \"Resource\": [ \"arn:aws:s3:::loki-*\" ] } ] } Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" with trust relationships: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/<OIDC_PROVIDER>\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"<OIDC_PROVIDER>:sub\": \"system:serviceaccount:<LOKI_NAMESPACE>:edp-loki\" } } } ] } Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" role. Make sure that Amazon S3 bucket with name loki-\u2039CLUSTER_NAME\u203a exists. Provide key value eks.amazonaws.com/role-arn: \"arn:aws:iam:: :role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039LOKI_NAMESPACE\u203aLoki\" into the serviceAccount.annotations parameter in values.yaml during the Loki Installation .","title":"IAM Roles for Loki Service Accounts"},{"location":"operator-guide/loki-irsa/#related-articles","text":"Associate IAM Roles With Service Accounts Install Grafana Loki","title":"Related Articles"},{"location":"operator-guide/manage-jenkins-cd-job-provision/","text":"Manage Jenkins CD Pipeline Job Provisioner \u2693\ufe0e The Jenkins CD job provisioner (or seed-job) is used to create and manage the cd-pipeline folder, and its Deploy pipelines . There is a special job-provisions/cd folder in Jenkins for these provisioners. Explore the steps for managing different provisioner types below. Default \u2693\ufe0e During the EDP deployment, a default provisioner is created to deploy application with container and custom deployment type. Find the configuration in job-provisions/cd/default . Default template is presented below: View: Default template /* Copyright 2021 EPAM Systems. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ import groovy.json.* import jenkins.model.Jenkins Jenkins jenkins = Jenkins . instance def pipelineName = \"${PIPELINE_NAME}-cd-pipeline\" def stageName = \"${STAGE_NAME}\" def qgStages = \"${QG_STAGES}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID}\" def sourceType = \"${SOURCE_TYPE}\" def libraryURL = \"${LIBRARY_URL}\" def libraryBranch = \"${LIBRARY_BRANCH}\" def autodeploy = \"${AUTODEPLOY}\" def scriptPath = \"Jenkinsfile\" def containerDeploymentType = \"container\" def deploymentType = \"${DEPLOYMENT_TYPE}\" def stages = buildStages ( deploymentType , containerDeploymentType , qgStages ) def codebaseFolder = jenkins . getItem ( pipelineName ) if ( codebaseFolder == null ) { folder ( pipelineName ) } if ( deploymentType == containerDeploymentType ) { createContainerizedCdPipeline ( pipelineName , stageName , stages , scriptPath , sourceType , libraryURL , libraryBranch , gitCredentialsId , gitServerCrVersion , autodeploy ) } else { createCustomCdPipeline ( pipelineName , stageName ) } def buildStages ( deploymentType , containerDeploymentType , qgStages ) { return deploymentType == containerDeploymentType ? ' [ { \"name\" : \"init\" , \"step_name\" : \"init\" },{ \"name\" : \"deploy\" , \"step_name\" : \"deploy\" }, ' + qgStages + ' ,{ \"name\" : \"promote-images-ecr\" , \"step_name\" : \"promote-images\" } ] ' : '' } def createContainerizedCdPipeline ( pipelineName , stageName , stages , pipelineScript , sourceType , libraryURL , libraryBranch , libraryCredId , gitServerCrVersion , autodeploy ) { pipelineJob ( \"${pipelineName}/${stageName}\" ) { if ( sourceType == \"library\" ) { definition { cpsScm { scm { git { remote { url ( libraryURL ) credentials ( libraryCredId ) } branches ( \"${libraryBranch}\" ) scriptPath ( \"${pipelineScript}\" ) } } } } } else { definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nDeploy()\" ) sandbox ( true ) } } } properties { disableConcurrentBuilds () } parameters { stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${stages}\" , \"Consequence of stages in JSON format to be run during execution\" ) if ( autodeploy ? . trim () && autodeploy . toBoolean ()) { stringParam ( \"AUTODEPLOY\" , \"${autodeploy}\" , \"Is autodeploy enabled?\" ) stringParam ( \"CODEBASE_VERSION\" , null , \"Codebase versions to deploy.\" ) } } } } def createCustomCdPipeline ( pipelineName , stageName ) { pipelineJob ( \"${pipelineName}/${stageName}\" ) { properties { disableConcurrentBuilds () } } } Custom \u2693\ufe0e In some cases, it is necessary to modify or update the job provisioner logic. For example, when adding a new stage requires a custom job provisioner created on the basis of an existing one out of the box. Take the steps below to add a custom job provision. Navigate to the Jenkins main page and open the job-provisions/cd folder, click New Item and type the name of job provisions, for example - custom. Scroll down to the Copy from field, enter \"/job-provisions/cd/default\", and click OK: Update the required parameters in the new provisioner. For example, if it is necessary to implement a new stage clean , add the following code to the provisioner: def buildStages ( deploymentType , containerDeploymentType , qgStages ) { return deploymentType == containerDeploymentType ? ' [{\"name\":\"init\",\"step_name\":\"init\"},{\"name\":\"clean\",\"step_name\":\"clean\"},{\"name\":\"deploy\",\"step_name\":\"deploy\"}, ' + qgStages + ' ,{\"name\":\"promote-images-ecr\",\"step_name\":\"promote-images\"}] ' : '' } Note Make sure the support for the above mentioned logic is implemented. Please refer to the How to Redefine or Extend the EDP Pipeline Stages Library section of the guide. After the steps above are performed, the new custom job-provision will be available in Adding Stage during the CD pipeline creation in Admin Console.","title":"Manage Jenkins CD Pipeline Job Provisioner"},{"location":"operator-guide/manage-jenkins-cd-job-provision/#manage-jenkins-cd-pipeline-job-provisioner","text":"The Jenkins CD job provisioner (or seed-job) is used to create and manage the cd-pipeline folder, and its Deploy pipelines . There is a special job-provisions/cd folder in Jenkins for these provisioners. Explore the steps for managing different provisioner types below.","title":"Manage Jenkins CD Pipeline Job Provisioner"},{"location":"operator-guide/manage-jenkins-cd-job-provision/#default","text":"During the EDP deployment, a default provisioner is created to deploy application with container and custom deployment type. Find the configuration in job-provisions/cd/default . Default template is presented below: View: Default template /* Copyright 2021 EPAM Systems. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ import groovy.json.* import jenkins.model.Jenkins Jenkins jenkins = Jenkins . instance def pipelineName = \"${PIPELINE_NAME}-cd-pipeline\" def stageName = \"${STAGE_NAME}\" def qgStages = \"${QG_STAGES}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID}\" def sourceType = \"${SOURCE_TYPE}\" def libraryURL = \"${LIBRARY_URL}\" def libraryBranch = \"${LIBRARY_BRANCH}\" def autodeploy = \"${AUTODEPLOY}\" def scriptPath = \"Jenkinsfile\" def containerDeploymentType = \"container\" def deploymentType = \"${DEPLOYMENT_TYPE}\" def stages = buildStages ( deploymentType , containerDeploymentType , qgStages ) def codebaseFolder = jenkins . getItem ( pipelineName ) if ( codebaseFolder == null ) { folder ( pipelineName ) } if ( deploymentType == containerDeploymentType ) { createContainerizedCdPipeline ( pipelineName , stageName , stages , scriptPath , sourceType , libraryURL , libraryBranch , gitCredentialsId , gitServerCrVersion , autodeploy ) } else { createCustomCdPipeline ( pipelineName , stageName ) } def buildStages ( deploymentType , containerDeploymentType , qgStages ) { return deploymentType == containerDeploymentType ? ' [ { \"name\" : \"init\" , \"step_name\" : \"init\" },{ \"name\" : \"deploy\" , \"step_name\" : \"deploy\" }, ' + qgStages + ' ,{ \"name\" : \"promote-images-ecr\" , \"step_name\" : \"promote-images\" } ] ' : '' } def createContainerizedCdPipeline ( pipelineName , stageName , stages , pipelineScript , sourceType , libraryURL , libraryBranch , libraryCredId , gitServerCrVersion , autodeploy ) { pipelineJob ( \"${pipelineName}/${stageName}\" ) { if ( sourceType == \"library\" ) { definition { cpsScm { scm { git { remote { url ( libraryURL ) credentials ( libraryCredId ) } branches ( \"${libraryBranch}\" ) scriptPath ( \"${pipelineScript}\" ) } } } } } else { definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nDeploy()\" ) sandbox ( true ) } } } properties { disableConcurrentBuilds () } parameters { stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${stages}\" , \"Consequence of stages in JSON format to be run during execution\" ) if ( autodeploy ? . trim () && autodeploy . toBoolean ()) { stringParam ( \"AUTODEPLOY\" , \"${autodeploy}\" , \"Is autodeploy enabled?\" ) stringParam ( \"CODEBASE_VERSION\" , null , \"Codebase versions to deploy.\" ) } } } } def createCustomCdPipeline ( pipelineName , stageName ) { pipelineJob ( \"${pipelineName}/${stageName}\" ) { properties { disableConcurrentBuilds () } } }","title":"Default"},{"location":"operator-guide/manage-jenkins-cd-job-provision/#custom","text":"In some cases, it is necessary to modify or update the job provisioner logic. For example, when adding a new stage requires a custom job provisioner created on the basis of an existing one out of the box. Take the steps below to add a custom job provision. Navigate to the Jenkins main page and open the job-provisions/cd folder, click New Item and type the name of job provisions, for example - custom. Scroll down to the Copy from field, enter \"/job-provisions/cd/default\", and click OK: Update the required parameters in the new provisioner. For example, if it is necessary to implement a new stage clean , add the following code to the provisioner: def buildStages ( deploymentType , containerDeploymentType , qgStages ) { return deploymentType == containerDeploymentType ? ' [{\"name\":\"init\",\"step_name\":\"init\"},{\"name\":\"clean\",\"step_name\":\"clean\"},{\"name\":\"deploy\",\"step_name\":\"deploy\"}, ' + qgStages + ' ,{\"name\":\"promote-images-ecr\",\"step_name\":\"promote-images\"}] ' : '' } Note Make sure the support for the above mentioned logic is implemented. Please refer to the How to Redefine or Extend the EDP Pipeline Stages Library section of the guide. After the steps above are performed, the new custom job-provision will be available in Adding Stage during the CD pipeline creation in Admin Console.","title":"Custom"},{"location":"operator-guide/manage-jenkins-ci-job-provision/","text":"Manage Jenkins CI Pipeline Job Provisioner \u2693\ufe0e The Jenkins CI job provisioner (or seed-job) is used to create and manage the application folder, and its Code Review, Build and Create Release pipelines . Depending on the version control system, different job provisioners are used. EDP supports integration with the following version control systems: Gerrit (default) GitHub (github) GitLab (gitlab) By default, the Jenkins operator creates a pipeline for several types of application and libraries . There is a special job-provisions/ci folder in Jenkins for these provisioners. During the EDP deployment, a default provisioner is created for integration with Gerrit version control system. To configure integration with other version control systems, you need to add the required job provisioners to job-provisions/ci folder in Jenkins. Custom (custom-default/github/gitlab) \u2693\ufe0e In some cases it is necessary to modify or update the job provisioner logic, for example when an added other code language needs to create a custom job provisioner on the basis of an existing one out of the box. Take the steps below to add a custom job provision: Navigate to the Jenkins main page and open the job-provisions/ci folder, click New Item and type the name of job-provisions, for example - custom-github. Scroll down to the Copy from field and enter \"/job-provisions/ci/github\", and click OK: Update the required parameters in the new provisioner. For example, if it is necessary to implement a new build tool docker , several parameters are to be updated. Add the following stages to the docker Code Review and Build pipelines for docker application: stages [ ' Code-review-application-docker ' ] = ' [{\"name\": \"checkout\"},{\"name\": \"lint\"},{\"name\": \"build\"}] ' ... stages [ ' Build-application-docker ' ] = ' [{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"lint\"},{\"name\": \"build\"},{\"name\": \"push\"},{\"name\": \"git-tag\"}] ' ... def getStageKeyName ( buildTool ) { ... if ( buildTool . toString () . equalsIgnoreCase ( ' docker ' )) { return \" Code-review-application-docker \" } ... } Note Make sure the support for the above mentioned logic is implemented. Please refer to the How to Redefine or Extend the EDP Pipeline Stages Library section of the guide. Note The default template should be changed if there is another creation logic for the Code Review, Build and Create Release pipelines. Furthermore, all pipeline types should have the necessary stages as well. After the steps above are performed, the new custom job provision will be available in Advanced Settings during the application creation in Admin Console. Gerrit (default) \u2693\ufe0e During the EDP deployment, a default provisioner is created for integration with Gerrit version control system. Find the configuration in job-provisions/ci/default . Default template is presented below: View: Default template /* Copyright 2021 EPAM Systems. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ import groovy.json.* import jenkins.model.Jenkins import hudson.model.* Jenkins jenkins = Jenkins . instance def stages = [:] def jiraIntegrationEnabled = Boolean . parseBoolean ( \"${JIRA_INTEGRATION_ENABLED}\" as String ) def commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : '' def createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : '' def buildTool = \"${BUILD_TOOL}\" def goBuildStage = buildTool . toString () == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}' stages [ 'Code-review-application' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + goBuildStage + ',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]' stages [ 'Code-review-library' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"compile\"},{\"name\": \"tests\"},' + '{\"name\": \"sonar\"}]' stages [ 'Code-review-autotests' ] = '[{\"name\": \"gerrit-checkout\"},{\"name\": \"get-version\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${createJIMStage}\" + ']' stages [ 'Code-review-default' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ']' stages [ 'Code-review-library-terraform' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"terraform-lint\"}]' stages [ 'Code-review-library-opa' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"}]' stages [ 'Code-review-library-codenarc' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"sonar\"},{\"name\": \"build\"}]' stages [ 'Build-library-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-npm' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-gradle' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-terraform' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' + ',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-opa' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + ',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-codenarc' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},[{\"name\": \"sonar\"}],{\"name\": \"build\"},{\"name\": \"build-image-kaniko\"},' + '{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-npm' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-gradle' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},[{\"name\": \"sonar\"}],{\"name\": \"build-image-kaniko\"},' + '{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-go' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' + '{\"name\": \"build\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},' + '{\"name\": \"build-image-kaniko\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Create-release' ] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]' def defaultBuild = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']' def codebaseName = \"${NAME}\" def gitServerCrName = \"${GIT_SERVER_CR_NAME}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\" def repositoryPath = \"${REPOSITORY_PATH}\" def defaultBranch = \"${DEFAULT_BRANCH}\" def codebaseFolder = jenkins . getItem ( codebaseName ) if ( codebaseFolder == null ) { folder ( codebaseName ) } createListView ( codebaseName , \"Releases\" ) createReleasePipeline ( \"Create-release-${codebaseName}\" , codebaseName , stages [ \"Create-release\" ], \"CreateRelease\" , repositoryPath , gitCredentialsId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , defaultBranch ) if ( buildTool . toString (). equalsIgnoreCase ( 'none' )) { return true } if ( BRANCH ) { def branch = \"${BRANCH}\" def formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \" - \")}\" createListView ( codebaseName , formattedBranch ) def type = \"${TYPE}\" def crKey = getStageKeyName ( buildTool ) createCiPipeline ( \"Code-review-${codebaseName}\" , codebaseName , stages [ crKey ], \"CodeReview\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) def buildKey = \"Build-${type}-${buildTool.toLowerCase()}\" . toString () if ( type . equalsIgnoreCase ( 'application' ) || type . equalsIgnoreCase ( 'library' )) { def jobExists = false if ( \"${formattedBranch}-Build-${codebaseName}\" . toString () in Jenkins . instance . getAllItems (). collect { it . name }) jobExists = true createCiPipeline ( \"Build-${codebaseName}\" , codebaseName , stages . get ( buildKey , defaultBuild ), \"Build\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) if (! jobExists ) queue ( \"${codebaseName}/${formattedBranch}-Build-${codebaseName}\" ) } } def createCiPipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , watchBranch , gitServerCrName , gitServerCrVersion ) { pipelineJob ( \"${codebaseName}/${watchBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } triggers { gerrit { events { if ( pipelineName . contains ( \"Build\" )) changeMerged () else patchsetCreated () } project ( \"plain:${codebaseName}\" , [ \"plain:${watchBranch}\" ]) } } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) stringParam ( \"BRANCH\" , \"${watchBranch}\" , \"Branch to build artifact from\" ) } } } } def getStageKeyName ( buildTool ) { if ( buildTool . toString (). equalsIgnoreCase ( 'terraform' )) { return \"Code-review-library-terraform\" } if ( buildTool . toString (). equalsIgnoreCase ( 'opa' )) { return \"Code-review-library-opa\" } if ( buildTool . toString (). equalsIgnoreCase ( 'codenarc' )) { return \"Code-review-library-codenarc\" } def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) return supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\" } def createReleasePipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , defaultBranch ) { pipelineJob ( \"${codebaseName}/${pipelineName}\" ) { logRotator { numToKeep ( 14 ) daysToKeep ( 30 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"\" ) if ( pipelineName . contains ( \"Create-release\" )) { stringParam ( \"JIRA_INTEGRATION_ENABLED\" , \"${jiraIntegrationEnabled}\" , \"Is Jira integration enabled\" ) stringParam ( \"GERRIT_PROJECT\" , \"${codebaseName}\" , \"\" ) stringParam ( \"RELEASE_NAME\" , \"\" , \"Name of the release(branch to be created)\" ) stringParam ( \"COMMIT_ID\" , \"\" , \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\" ) stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"REPOSITORY_PATH\" , \"${repository}\" , \"Full repository path\" ) stringParam ( \"DEFAULT_BRANCH\" , \"${defaultBranch}\" , \"Default repository branch\" ) } } } } } def createListView ( codebaseName , branchName ) { listView ( \"${codebaseName}/${branchName}\" ) { if ( branchName . toLowerCase () == \"releases\" ) { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^Create-release.*\" ) } } } else { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^${branchName}-(Code-review|Build).*\" ) } } } columns { status () weather () name () lastSuccess () lastFailure () lastDuration () buildButton () } } } Job Provision Pipeline Parameters The job-provisions pipeline consists of the following parameters: NAME - the application name; TYPE - the codebase type (the application / library / autotest); BUILD_TOOL - a tool that is used to build the application; BRANCH - a branch name; GIT_SERVER_CR_NAME - the name of the application Git server custom resource; GIT_SERVER_CR_VERSION - the version of the application Git server custom resource; GIT_CREDENTIALS_ID - the secret name where Git server credentials are stored (default 'gerrit-ciuser-sshkey'); REPOSITORY_PATH - the full repository path; JIRA_INTEGRATION_ENABLED - the Jira integration is enabled or not; DEFAULT_BRANCH - the default repository branch. GitHub (github) \u2693\ufe0e To create a new job provision for work with GitHub, take the following steps: Navigate to the Jenkins main page and open the job-provisions/ci folder. Click New Item and type the name of job-provisions - github . Select the Freestyle project option and click OK. Select the Discard old builds check box and configure a few parameters: Strategy: Log Rotation Days to keep builds: 10 Max # of builds to keep: 10 Select the This project is parameterized check box and add a few input parameters: NAME; TYPE; BUILD_TOOL; BRANCH; GIT_SERVER_CR_NAME; GIT_SERVER_CR_VERSION; GIT_CREDENTIALS_ID; REPOSITORY_PATH; JIRA_INTEGRATION_ENABLED; PLATFORM_TYPE; DEFAULT_BRANCH. Check the Execute concurrent builds if necessary option. Check the Restrict where this project can be run option. Fill in the Label Expression field by typing master to ensure job runs on Jenkins Master. In the Build section, perform the following: Select DSL Script ; Select the Use the provided DSL script check box: As soon as all the steps above are performed, insert the code: View: Template import groovy.json.* import jenkins.model.Jenkins import javaposse.jobdsl.plugin.* import com.cloudbees.hudson.plugins.folder.* Jenkins jenkins = Jenkins . instance def stages = [:] def jiraIntegrationEnabled = Boolean . parseBoolean ( \"${JIRA_INTEGRATION_ENABLED}\" as String ) def commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : '' def createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : '' def platformType = \"${PLATFORM_TYPE}\" def buildStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}' def buildTool = \"${BUILD_TOOL}\" def goBuildStage = buildTool . toString () == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}' stages [ 'Code-review-application' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + goBuildStage + ',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]' stages [ 'Code-review-library' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"compile\"},{\"name\": \"tests\"},' + '{\"name\": \"sonar\"}]' stages [ 'Code-review-autotests' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${createJIMStage}\" + ']' stages [ 'Code-review-default' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ']' stages [ 'Code-review-library-terraform' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"terraform-lint\"}]' stages [ 'Code-review-library-opa' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"}]' stages [ 'Code-review-library-codenarc' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"sonar\"},{\"name\": \"build\"}]' stages [ 'Build-library-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-npm' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-gradle' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-terraform' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' + ',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-opa' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + ',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-codenarc' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" + ',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-npm' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-gradle' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildStage}\" + ',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-go' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' + '{\"name\": \"build\"}' + \"${buildStage}\" + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildStage}\" + ',{\"name\":\"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Create-release' ] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]' def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def defaultStages = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']' def codebaseName = \"${NAME}\" def gitServerCrName = \"${GIT_SERVER_CR_NAME}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\" def repositoryPath = \"${REPOSITORY_PATH.replaceAll(~/:\\d+\\\\//,\" /\")}\" def githubRepository = \"https://${repositoryPath.split(\"@\")[1]}\" def defaultBranch = \"${DEFAULT_BRANCH}\" def codebaseFolder = jenkins.getItem(codebaseName) if (codebaseFolder == null) { folder(codebaseName) } createListView(codebaseName, \"Releases\") createReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"CreateRelease\", repositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch) if (buildTool.toString().equalsIgnoreCase('none')) { return true } if (BRANCH) { def branch = \"${BRANCH}\" def formattedBranch = \"${branch.toUpperCase().replaceAll(/ \\\\ //, \"-\")}\" createListView ( codebaseName , formattedBranch ) def type = \"${TYPE}\" def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) def crKey = getStageKeyName ( buildTool ). toString () createCodeReviewPipeline ( \"Code-review-${codebaseName}\" , codebaseName , stages . get ( crKey , defaultStages ), \"CodeReview\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion , githubRepository ) registerWebHook ( repositoryPath ) def buildKey = \"Build-${type}-${buildTool.toLowerCase()}\" . toString () if ( type . equalsIgnoreCase ( 'application' ) || type . equalsIgnoreCase ( 'library' )) { def jobExists = false if ( \"${formattedBranch}-Build-${codebaseName}\" . toString () in Jenkins . instance . getAllItems (). collect { it . name }) jobExists = true createBuildPipeline ( \"Build-${codebaseName}\" , codebaseName , stages . get ( buildKey , defaultStages ), \"Build\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion , githubRepository ) registerWebHook ( repositoryPath , 'build' ) if (! jobExists ) queue ( \"${codebaseName}/${formattedBranch}-Build-${codebaseName}\" ) } } def getStageKeyName ( buildTool ) { if ( buildTool . toString (). equalsIgnoreCase ( 'terraform' )) { return \"Code-review-library-terraform\" } if ( buildTool . toString (). equalsIgnoreCase ( 'opa' )) { return \"Code-review-library-opa\" } if ( buildTool . toString (). equalsIgnoreCase ( 'codenarc' )) { return \"Code-review-library-codenarc\" } def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) return supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\" } def createCodeReviewPipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , defaultBranch , gitServerCrName , gitServerCrVersion , githubRepository ) { pipelineJob ( \"${codebaseName}/${defaultBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) if ( pipelineName . contains ( \"Build\" )) stringParam ( \"BRANCH\" , \"${defaultBranch}\" , \"Branch to build artifact from\" ) else stringParam ( \"BRANCH\" , \"\\${ghprbActualCommit}\" , \"Branch to build artifact from\" ) } } triggers { githubPullRequest { cron ( '' ) onlyTriggerPhrase ( false ) useGitHubHooks ( true ) permitAll ( true ) autoCloseFailedPullRequests ( false ) displayBuildErrorsOnDownstreamBuilds ( false ) whiteListTargetBranches ([ defaultBranch . toString ()]) extensions { commitStatus { context ( 'Jenkins Code-Review' ) triggeredStatus ( 'Build is Triggered' ) startedStatus ( 'Build is Started' ) addTestResults ( true ) completedStatus ( 'SUCCESS' , 'Verified' ) completedStatus ( 'FAILURE' , 'Failed' ) completedStatus ( 'PENDING' , 'Penging' ) completedStatus ( 'ERROR' , 'Error' ) } } } } properties { githubProjectProperty { projectUrlStr ( \"${githubRepository}\" ) } } } } def createBuildPipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , defaultBranch , gitServerCrName , gitServerCrVersion , githubRepository ) { pipelineJob ( \"${codebaseName}/${defaultBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nnode {\\n git credentialsId: \\'${credId}\\', url: \\'${repository}\\', branch: \\'${BRANCH}\\'\\n}\\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) stringParam ( \"BRANCH\" , \"${defaultBranch}\" , \"Branch to run from\" ) } } triggers { gitHubPushTrigger () } properties { githubProjectProperty { projectUrlStr ( \"${githubRepository}\" ) } } } } def createListView ( codebaseName , branchName ) { listView ( \"${codebaseName}/${branchName}\" ) { if ( branchName . toLowerCase () == \"releases\" ) { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^Create-release.*\" ) } } } else { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^${branchName}-(Code-review|Build).*\" ) } } } columns { status () weather () name () lastSuccess () lastFailure () lastDuration () buildButton () } } } def createReleasePipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , platformType , defaultBranch ) { pipelineJob ( \"${codebaseName}/${pipelineName}\" ) { logRotator { numToKeep ( 14 ) daysToKeep ( 30 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"\" ) if ( pipelineName . contains ( \"Create-release\" )) { stringParam ( \"JIRA_INTEGRATION_ENABLED\" , \"${jiraIntegrationEnabled}\" , \"Is Jira integration enabled\" ) stringParam ( \"PLATFORM_TYPE\" , \"${platformType}\" , \"Platform type\" ) stringParam ( \"GERRIT_PROJECT\" , \"${codebaseName}\" , \"\" ) stringParam ( \"RELEASE_NAME\" , \"\" , \"Name of the release(branch to be created)\" ) stringParam ( \"COMMIT_ID\" , \"\" , \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\" ) stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"REPOSITORY_PATH\" , \"${repository}\" , \"Full repository path\" ) stringParam ( \"DEFAULT_BRANCH\" , \"${defaultBranch}\" , \"Default repository branch\" ) } } } } } def registerWebHook ( repositoryPath , type = 'code-review' ) { def url = repositoryPath . split ( '@' )[ 1 ]. split ( '/' )[ 0 ] def owner = repositoryPath . split ( '@' )[ 1 ]. split ( '/' )[ 1 ] def repo = repositoryPath . split ( '@' )[ 1 ]. split ( '/' )[ 2 ] def apiUrl = 'https://api.' + url + '/repos/' + owner + '/' + repo + '/hooks' def webhookUrl = '' def webhookConfig = [:] def config = [:] def events = [] if ( type . equalsIgnoreCase ( 'build' )) { webhookUrl = System . getenv ( 'JENKINS_UI_URL' ) + \"/github-webhook/\" events = [ \"push\" ] config [ \"url\" ] = webhookUrl config [ \"content_type\" ] = \"json\" config [ \"insecure_ssl\" ] = 0 webhookConfig [ \"name\" ] = \"web\" webhookConfig [ \"config\" ] = config webhookConfig [ \"events\" ] = events webhookConfig [ \"active\" ] = true } else { webhookUrl = System . getenv ( 'JENKINS_UI_URL' ) + \"/ghprbhook/\" events = [ \"issue_comment\" , \"pull_request\" ] config [ \"url\" ] = webhookUrl config [ \"content_type\" ] = \"form\" config [ \"insecure_ssl\" ] = 0 webhookConfig [ \"name\" ] = \"web\" webhookConfig [ \"config\" ] = config webhookConfig [ \"events\" ] = events webhookConfig [ \"active\" ] = true } def requestBody = JsonOutput . toJson ( webhookConfig ) def http = new URL ( apiUrl ). openConnection () as HttpURLConnection http . setRequestMethod ( 'POST' ) http . setDoOutput ( true ) println ( apiUrl ) http . setRequestProperty ( \"Accept\" , 'application/json' ) http . setRequestProperty ( \"Content-Type\" , 'application/json' ) http . setRequestProperty ( \"Authorization\" , \"token ${getSecretValue('github-access-token')}\" ) http . outputStream . write ( requestBody . getBytes ( \"UTF-8\" )) http . connect () println ( http . responseCode ) if ( http . responseCode == 201 ) { response = new JsonSlurper (). parseText ( http . inputStream . getText ( 'UTF-8' )) } else { response = new JsonSlurper (). parseText ( http . errorStream . getText ( 'UTF-8' )) } println \"response: ${response}\" } def getSecretValue ( name ) { def creds = com . cloudbees . plugins . credentials . CredentialsProvider . lookupCredentials ( com . cloudbees . plugins . credentials . common . StandardCredentials . class , Jenkins . instance , null , null ) def secret = creds . find { it . properties [ 'id' ] == name } return secret != null ? secret [ 'secret' ] : null } After the steps above are performed, the new custom job-provision will be available in Advanced Settings during the application creation in Admin Console. GitLab (gitlab) \u2693\ufe0e To create a new job provision for work with GitLab, take the following steps: Navigate to the Jenkins main page and open the job-provisions/ci folder. Click New Item and type the name of job-provisions - gitlab . Select the Freestyle project option and click OK. Select the Discard old builds check box and configure a few parameters: Strategy: Log Rotation Days to keep builds: 10 Max # of builds to keep: 10 Select the This project is parameterized check box and add a few input parameters as the following strings: NAME; TYPE; BUILD_TOOL; BRANCH; GIT_SERVER_CR_NAME; GIT_SERVER_CR_VERSION; GIT_SERVER; GIT_SSH_PORT; GIT_USERNAME; GIT_CREDENTIALS_ID; REPOSITORY_PATH; JIRA_INTEGRATION_ENABLED; PLATFORM_TYPE; DEFAULT_BRANCH; Check the Execute concurrent builds if necessary option. Check the Restrict where this project can be run option. Fill in the Label Expression field by typing master to ensure job runs on Jenkins Master. In the Build section, perform the following: Select DSL Script ; Select the Use the provided DSL script check box: As soon as all the steps above are performed, insert the code: View: Template import groovy.json.* import jenkins.model.Jenkins Jenkins jenkins = Jenkins . instance def stages = [:] def jiraIntegrationEnabled = Boolean . parseBoolean ( \"${JIRA_INTEGRATION_ENABLED}\" as String ) def commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : '' def createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : '' def platformType = \"${PLATFORM_TYPE}\" def buildTool = \"${BUILD_TOOL}\" def buildImageStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"},' : ',{\"name\": \"build-image-from-dockerfile\"},' def goBuildImageStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}' def goBuildStage = buildTool . toString () == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}' stages [ 'Code-review-application' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + goBuildStage + ',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]' stages [ 'Code-review-library' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"compile\"},{\"name\": \"tests\"},' + '{\"name\": \"sonar\"}]' stages [ 'Code-review-autotests' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${createJIMStage}\" + ']' stages [ 'Code-review-default' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ']' stages [ 'Code-review-library-terraform' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"terraform-lint\"}]' stages [ 'Code-review-library-opa' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"}]' stages [ 'Code-review-library-codenarc' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"sonar\"},{\"name\": \"build\"}]' stages [ 'Build-library-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-npm' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-gradle' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-terraform' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' + ',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-opa' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + ',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-codenarc' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildImageStage}\" + '{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildImageStage}\" + '{\"name\":\"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-npm' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-gradle' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildImageStage}\" + '{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-terraform' ] = '[{\"name\": \"checkout\"},{\"name\": \"tool-init\"},' + '{\"name\": \"lint\"},{\"name\": \"git-tag\"}]' stages [ 'Build-application-helm' ] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"}]' stages [ 'Build-application-docker' ] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"}]' stages [ 'Build-application-go' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' + '{\"name\": \"build\"}' + \"${goBuildImageStage}\" + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Create-release' ] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]' def defaultStages = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']' def codebaseName = \"${NAME}\" def gitServerCrName = \"${GIT_SERVER_CR_NAME}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitServer = \"${GIT_SERVER ? GIT_SERVER : 'gerrit'}\" def gitSshPort = \"${GIT_SSH_PORT ? GIT_SSH_PORT : '29418'}\" def gitUsername = \"${GIT_USERNAME ? GIT_USERNAME : 'jenkins'}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\" def defaultRepoPath = \"ssh://${gitUsername}@${gitServer}:${gitSshPort}/${codebaseName}\" def repositoryPath = \"${REPOSITORY_PATH ? REPOSITORY_PATH : defaultRepoPath}\" def defaultBranch = \"${DEFAULT_BRANCH}\" def codebaseFolder = jenkins . getItem ( codebaseName ) if ( codebaseFolder == null ) { folder ( codebaseName ) } createListView ( codebaseName , \"Releases\" ) createReleasePipeline ( \"Create-release-${codebaseName}\" , codebaseName , stages [ \"Create-release\" ], \"CreateRelease\" , repositoryPath , gitCredentialsId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , platformType , defaultBranch ) if ( BRANCH ) { def branch = \"${BRANCH}\" def formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \" - \")}\" createListView ( codebaseName , formattedBranch ) def type = \"${TYPE}\" def crKey = getStageKeyName ( buildTool ). toString () createCiPipeline ( \"Code-review-${codebaseName}\" , codebaseName , stages . get ( crKey , defaultStages ), \"CodeReview\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) def buildKey = \"Build-${type}-${buildTool.toLowerCase()}\" . toString () if ( type . equalsIgnoreCase ( 'application' ) || type . equalsIgnoreCase ( 'library' )) { def jobExists = false if ( \"${formattedBranch}-Build-${codebaseName}\" . toString () in Jenkins . instance . getAllItems (). collect { it . name }) { jobExists = true } createCiPipeline ( \"Build-${codebaseName}\" , codebaseName , stages . get ( buildKey , defaultStages ), \"Build\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) if (! jobExists ) { queue ( \"${codebaseName}/${formattedBranch}-Build-${codebaseName}\" ) } } } def createCiPipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , defaultBranch , gitServerCrName , gitServerCrVersion ) { def jobName = \"${defaultBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" def existingJob = Jenkins . getInstance (). getItemByFullName ( \"${codebaseName}/${jobName}\" ) def webhookToken = null if ( existingJob ) { def triggersMap = existingJob . getTriggers () triggersMap . each { key , value -> webhookToken = value . getSecretToken () } } else { def random = new byte [ 16 ] new java . security . SecureRandom (). nextBytes ( random ) webhookToken = random . encodeHex (). toString () } pipelineJob ( \"${codebaseName}/${jobName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } properties { gitLabConnection { gitLabConnection ( 'gitlab' ) } } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) if ( pipelineName . contains ( \"Build\" )) stringParam ( \"BRANCH\" , \"${defaultBranch}\" , \"Branch to build artifact from\" ) else stringParam ( \"BRANCH\" , \"\\${gitlabMergeRequestLastCommit}\" , \"Branch to build artifact from\" ) } } triggers { gitlabPush { buildOnMergeRequestEvents ( pipelineName . contains ( \"Build\" ) ? false : true ) buildOnPushEvents ( pipelineName . contains ( \"Build\" ) ? true : false ) enableCiSkip ( false ) setBuildDescription ( true ) rebuildOpenMergeRequest ( pipelineName . contains ( \"Build\" ) ? 'never' : 'source' ) commentTrigger ( \"Build it please\" ) skipWorkInProgressMergeRequest ( true ) targetBranchRegex ( \"${defaultBranch}\" ) } } configure { it / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' << secretToken ( webhookToken ) it / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' << triggerOnApprovedMergeRequest ( pipelineName . contains ( \"Build\" ) ? false : true ) it / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' << pendingBuildName ( pipelineName . contains ( \"Build\" ) ? \"\" : \"Jenkins\" ) } } registerWebHook ( repository , codebaseName , jobName , webhookToken ) } def getStageKeyName ( buildTool ) { if ( buildTool . toString (). equalsIgnoreCase ( 'terraform' )) { return \"Code-review-library-terraform\" } if ( buildTool . toString (). equalsIgnoreCase ( 'opa' )) { return \"Code-review-library-opa\" } if ( buildTool . toString (). equalsIgnoreCase ( 'codenarc' )) { return \"Code-review-library-codenarc\" } def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) return supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\" } def createReleasePipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , platformType , defaultBranch ) { pipelineJob ( \"${codebaseName}/${pipelineName}\" ) { logRotator { numToKeep ( 14 ) daysToKeep ( 30 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"\" ) if ( pipelineName . contains ( \"Create-release\" )) { stringParam ( \"JIRA_INTEGRATION_ENABLED\" , \"${jiraIntegrationEnabled}\" , \"Is Jira integration enabled\" ) stringParam ( \"PLATFORM_TYPE\" , \"${platformType}\" , \"Platform type\" ) stringParam ( \"GERRIT_PROJECT\" , \"${codebaseName}\" , \"\" ) stringParam ( \"RELEASE_NAME\" , \"\" , \"Name of the release(branch to be created)\" ) stringParam ( \"COMMIT_ID\" , \"\" , \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\" ) stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"REPOSITORY_PATH\" , \"${repository}\" , \"Full repository path\" ) stringParam ( \"DEFAULT_BRANCH\" , \"${defaultBranch}\" , \"Default repository branch\" ) } } } } } def createListView ( codebaseName , branchName ) { listView ( \"${codebaseName}/${branchName}\" ) { if ( branchName . toLowerCase () == \"releases\" ) { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^Create-release.*\" ) } } } else { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^${branchName}-(Code-review|Build).*\" ) } } } columns { status () weather () name () lastSuccess () lastFailure () lastDuration () buildButton () } } } def registerWebHook ( repositoryPath , codebaseName , jobName , webhookToken ) { def apiUrl = 'https://' + repositoryPath . replaceAll ( \"ssh://\" , \"\" ). split ( '@' )[ 1 ]. replace ( '/' , \"%2F\" ). replaceAll (~ /:\\d+%2F/ , '/api/v4/projects/' ) + '/hooks' def jobWebhookUrl = \"${System.getenv('JENKINS_UI_URL')}/project/${codebaseName}/${jobName}\" def gitlabToken = getSecretValue ( 'gitlab-access-token' ) if ( checkWebHookExist ( apiUrl , jobWebhookUrl , gitlabToken )) { println ( \"[JENKINS][DEBUG] Webhook for job ${jobName} is already exist\\r\\n\" ) return } println ( \"[JENKINS][DEBUG] Creating webhook for job ${jobName}\" ) def webhookConfig = [:] webhookConfig [ \"url\" ] = jobWebhookUrl webhookConfig [ \"push_events\" ] = jobName . contains ( \"Build\" ) ? \"true\" : \"false\" webhookConfig [ \"merge_requests_events\" ] = jobName . contains ( \"Build\" ) ? \"false\" : \"true\" webhookConfig [ \"issues_events\" ] = \"false\" webhookConfig [ \"confidential_issues_events\" ] = \"false\" webhookConfig [ \"tag_push_events\" ] = \"false\" webhookConfig [ \"note_events\" ] = \"true\" webhookConfig [ \"job_events\" ] = \"false\" webhookConfig [ \"pipeline_events\" ] = \"false\" webhookConfig [ \"wiki_page_events\" ] = \"false\" webhookConfig [ \"enable_ssl_verification\" ] = \"true\" webhookConfig [ \"token\" ] = webhookToken def requestBody = JsonOutput . toJson ( webhookConfig ) def httpConnector = new URL ( apiUrl ). openConnection () as HttpURLConnection httpConnector . setRequestMethod ( 'POST' ) httpConnector . setDoOutput ( true ) httpConnector . setRequestProperty ( \"Accept\" , 'application/json' ) httpConnector . setRequestProperty ( \"Content-Type\" , 'application/json' ) httpConnector . setRequestProperty ( \"PRIVATE-TOKEN\" , \"${gitlabToken}\" ) httpConnector . outputStream . write ( requestBody . getBytes ( \"UTF-8\" )) httpConnector . connect () if ( httpConnector . responseCode == 201 ) println ( \"[JENKINS][DEBUG] Webhook for job ${jobName} has been created\\r\\n\" ) else { println ( \"[JENKINS][ERROR] Responce code - ${httpConnector.responseCode}\" ) def response = new JsonSlurper (). parseText ( httpConnector . errorStream . getText ( 'UTF-8' )) println ( \"[JENKINS][ERROR] Failed to create webhook for job ${jobName}. Response - ${response}\" ) } } def checkWebHookExist ( apiUrl , jobWebhookUrl , gitlabToken ) { println ( \"[JENKINS][DEBUG] Checking if webhook ${jobWebhookUrl} exists\" ) def httpConnector = new URL ( apiUrl ). openConnection () as HttpURLConnection httpConnector . setRequestMethod ( 'GET' ) httpConnector . setDoOutput ( true ) httpConnector . setRequestProperty ( \"Accept\" , 'application/json' ) httpConnector . setRequestProperty ( \"Content-Type\" , 'application/json' ) httpConnector . setRequestProperty ( \"PRIVATE-TOKEN\" , \"${gitlabToken}\" ) httpConnector . connect () if ( httpConnector . responseCode == 200 ) { def response = new JsonSlurper (). parseText ( httpConnector . inputStream . getText ( 'UTF-8' )) return response . find { it . url == jobWebhookUrl } ? true : false } } def getSecretValue ( name ) { def creds = com . cloudbees . plugins . credentials . CredentialsProvider . lookupCredentials ( com . cloudbees . plugins . credentials . common . StandardCredentials . class , Jenkins . instance , null , null ) def secret = creds . find { it . properties [ 'id' ] == name } return secret != null ? secret [ 'secret' ] : null } Create Secret, GitServer CR and Jenkins credentials with the \"gitlab\" ID by following the instruction: Adjust Import Strategy . After the steps above are performed, the new custom job-provision will be available in Advanced Settings during the application creation in Admin Console.","title":"Manage Jenkins CI Pipeline Job Provisioner"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#manage-jenkins-ci-pipeline-job-provisioner","text":"The Jenkins CI job provisioner (or seed-job) is used to create and manage the application folder, and its Code Review, Build and Create Release pipelines . Depending on the version control system, different job provisioners are used. EDP supports integration with the following version control systems: Gerrit (default) GitHub (github) GitLab (gitlab) By default, the Jenkins operator creates a pipeline for several types of application and libraries . There is a special job-provisions/ci folder in Jenkins for these provisioners. During the EDP deployment, a default provisioner is created for integration with Gerrit version control system. To configure integration with other version control systems, you need to add the required job provisioners to job-provisions/ci folder in Jenkins.","title":"Manage Jenkins CI Pipeline Job Provisioner"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#custom-custom-defaultgithubgitlab","text":"In some cases it is necessary to modify or update the job provisioner logic, for example when an added other code language needs to create a custom job provisioner on the basis of an existing one out of the box. Take the steps below to add a custom job provision: Navigate to the Jenkins main page and open the job-provisions/ci folder, click New Item and type the name of job-provisions, for example - custom-github. Scroll down to the Copy from field and enter \"/job-provisions/ci/github\", and click OK: Update the required parameters in the new provisioner. For example, if it is necessary to implement a new build tool docker , several parameters are to be updated. Add the following stages to the docker Code Review and Build pipelines for docker application: stages [ ' Code-review-application-docker ' ] = ' [{\"name\": \"checkout\"},{\"name\": \"lint\"},{\"name\": \"build\"}] ' ... stages [ ' Build-application-docker ' ] = ' [{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"lint\"},{\"name\": \"build\"},{\"name\": \"push\"},{\"name\": \"git-tag\"}] ' ... def getStageKeyName ( buildTool ) { ... if ( buildTool . toString () . equalsIgnoreCase ( ' docker ' )) { return \" Code-review-application-docker \" } ... } Note Make sure the support for the above mentioned logic is implemented. Please refer to the How to Redefine or Extend the EDP Pipeline Stages Library section of the guide. Note The default template should be changed if there is another creation logic for the Code Review, Build and Create Release pipelines. Furthermore, all pipeline types should have the necessary stages as well. After the steps above are performed, the new custom job provision will be available in Advanced Settings during the application creation in Admin Console.","title":"Custom (custom-default/github/gitlab)"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#gerrit-default","text":"During the EDP deployment, a default provisioner is created for integration with Gerrit version control system. Find the configuration in job-provisions/ci/default . Default template is presented below: View: Default template /* Copyright 2021 EPAM Systems. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ import groovy.json.* import jenkins.model.Jenkins import hudson.model.* Jenkins jenkins = Jenkins . instance def stages = [:] def jiraIntegrationEnabled = Boolean . parseBoolean ( \"${JIRA_INTEGRATION_ENABLED}\" as String ) def commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : '' def createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : '' def buildTool = \"${BUILD_TOOL}\" def goBuildStage = buildTool . toString () == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}' stages [ 'Code-review-application' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + goBuildStage + ',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]' stages [ 'Code-review-library' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"compile\"},{\"name\": \"tests\"},' + '{\"name\": \"sonar\"}]' stages [ 'Code-review-autotests' ] = '[{\"name\": \"gerrit-checkout\"},{\"name\": \"get-version\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${createJIMStage}\" + ']' stages [ 'Code-review-default' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ']' stages [ 'Code-review-library-terraform' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"terraform-lint\"}]' stages [ 'Code-review-library-opa' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"}]' stages [ 'Code-review-library-codenarc' ] = '[{\"name\": \"gerrit-checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"sonar\"},{\"name\": \"build\"}]' stages [ 'Build-library-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-npm' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-gradle' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-terraform' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' + ',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-opa' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + ',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-codenarc' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},[{\"name\": \"sonar\"}],{\"name\": \"build\"},{\"name\": \"build-image-kaniko\"},' + '{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-npm' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-gradle' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},[{\"name\": \"sonar\"}],{\"name\": \"build-image-kaniko\"},' + '{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-go' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' + '{\"name\": \"build\"},{\"name\": \"build-image-kaniko\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},' + '{\"name\": \"build-image-kaniko\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Create-release' ] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]' def defaultBuild = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']' def codebaseName = \"${NAME}\" def gitServerCrName = \"${GIT_SERVER_CR_NAME}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\" def repositoryPath = \"${REPOSITORY_PATH}\" def defaultBranch = \"${DEFAULT_BRANCH}\" def codebaseFolder = jenkins . getItem ( codebaseName ) if ( codebaseFolder == null ) { folder ( codebaseName ) } createListView ( codebaseName , \"Releases\" ) createReleasePipeline ( \"Create-release-${codebaseName}\" , codebaseName , stages [ \"Create-release\" ], \"CreateRelease\" , repositoryPath , gitCredentialsId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , defaultBranch ) if ( buildTool . toString (). equalsIgnoreCase ( 'none' )) { return true } if ( BRANCH ) { def branch = \"${BRANCH}\" def formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \" - \")}\" createListView ( codebaseName , formattedBranch ) def type = \"${TYPE}\" def crKey = getStageKeyName ( buildTool ) createCiPipeline ( \"Code-review-${codebaseName}\" , codebaseName , stages [ crKey ], \"CodeReview\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) def buildKey = \"Build-${type}-${buildTool.toLowerCase()}\" . toString () if ( type . equalsIgnoreCase ( 'application' ) || type . equalsIgnoreCase ( 'library' )) { def jobExists = false if ( \"${formattedBranch}-Build-${codebaseName}\" . toString () in Jenkins . instance . getAllItems (). collect { it . name }) jobExists = true createCiPipeline ( \"Build-${codebaseName}\" , codebaseName , stages . get ( buildKey , defaultBuild ), \"Build\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) if (! jobExists ) queue ( \"${codebaseName}/${formattedBranch}-Build-${codebaseName}\" ) } } def createCiPipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , watchBranch , gitServerCrName , gitServerCrVersion ) { pipelineJob ( \"${codebaseName}/${watchBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } triggers { gerrit { events { if ( pipelineName . contains ( \"Build\" )) changeMerged () else patchsetCreated () } project ( \"plain:${codebaseName}\" , [ \"plain:${watchBranch}\" ]) } } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) stringParam ( \"BRANCH\" , \"${watchBranch}\" , \"Branch to build artifact from\" ) } } } } def getStageKeyName ( buildTool ) { if ( buildTool . toString (). equalsIgnoreCase ( 'terraform' )) { return \"Code-review-library-terraform\" } if ( buildTool . toString (). equalsIgnoreCase ( 'opa' )) { return \"Code-review-library-opa\" } if ( buildTool . toString (). equalsIgnoreCase ( 'codenarc' )) { return \"Code-review-library-codenarc\" } def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) return supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\" } def createReleasePipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , defaultBranch ) { pipelineJob ( \"${codebaseName}/${pipelineName}\" ) { logRotator { numToKeep ( 14 ) daysToKeep ( 30 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"\" ) if ( pipelineName . contains ( \"Create-release\" )) { stringParam ( \"JIRA_INTEGRATION_ENABLED\" , \"${jiraIntegrationEnabled}\" , \"Is Jira integration enabled\" ) stringParam ( \"GERRIT_PROJECT\" , \"${codebaseName}\" , \"\" ) stringParam ( \"RELEASE_NAME\" , \"\" , \"Name of the release(branch to be created)\" ) stringParam ( \"COMMIT_ID\" , \"\" , \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\" ) stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"REPOSITORY_PATH\" , \"${repository}\" , \"Full repository path\" ) stringParam ( \"DEFAULT_BRANCH\" , \"${defaultBranch}\" , \"Default repository branch\" ) } } } } } def createListView ( codebaseName , branchName ) { listView ( \"${codebaseName}/${branchName}\" ) { if ( branchName . toLowerCase () == \"releases\" ) { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^Create-release.*\" ) } } } else { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^${branchName}-(Code-review|Build).*\" ) } } } columns { status () weather () name () lastSuccess () lastFailure () lastDuration () buildButton () } } } Job Provision Pipeline Parameters The job-provisions pipeline consists of the following parameters: NAME - the application name; TYPE - the codebase type (the application / library / autotest); BUILD_TOOL - a tool that is used to build the application; BRANCH - a branch name; GIT_SERVER_CR_NAME - the name of the application Git server custom resource; GIT_SERVER_CR_VERSION - the version of the application Git server custom resource; GIT_CREDENTIALS_ID - the secret name where Git server credentials are stored (default 'gerrit-ciuser-sshkey'); REPOSITORY_PATH - the full repository path; JIRA_INTEGRATION_ENABLED - the Jira integration is enabled or not; DEFAULT_BRANCH - the default repository branch.","title":"Gerrit (default)"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#github-github","text":"To create a new job provision for work with GitHub, take the following steps: Navigate to the Jenkins main page and open the job-provisions/ci folder. Click New Item and type the name of job-provisions - github . Select the Freestyle project option and click OK. Select the Discard old builds check box and configure a few parameters: Strategy: Log Rotation Days to keep builds: 10 Max # of builds to keep: 10 Select the This project is parameterized check box and add a few input parameters: NAME; TYPE; BUILD_TOOL; BRANCH; GIT_SERVER_CR_NAME; GIT_SERVER_CR_VERSION; GIT_CREDENTIALS_ID; REPOSITORY_PATH; JIRA_INTEGRATION_ENABLED; PLATFORM_TYPE; DEFAULT_BRANCH. Check the Execute concurrent builds if necessary option. Check the Restrict where this project can be run option. Fill in the Label Expression field by typing master to ensure job runs on Jenkins Master. In the Build section, perform the following: Select DSL Script ; Select the Use the provided DSL script check box: As soon as all the steps above are performed, insert the code: View: Template import groovy.json.* import jenkins.model.Jenkins import javaposse.jobdsl.plugin.* import com.cloudbees.hudson.plugins.folder.* Jenkins jenkins = Jenkins . instance def stages = [:] def jiraIntegrationEnabled = Boolean . parseBoolean ( \"${JIRA_INTEGRATION_ENABLED}\" as String ) def commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : '' def createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : '' def platformType = \"${PLATFORM_TYPE}\" def buildStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}' def buildTool = \"${BUILD_TOOL}\" def goBuildStage = buildTool . toString () == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}' stages [ 'Code-review-application' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + goBuildStage + ',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]' stages [ 'Code-review-library' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"compile\"},{\"name\": \"tests\"},' + '{\"name\": \"sonar\"}]' stages [ 'Code-review-autotests' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${createJIMStage}\" + ']' stages [ 'Code-review-default' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ']' stages [ 'Code-review-library-terraform' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"terraform-lint\"}]' stages [ 'Code-review-library-opa' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"}]' stages [ 'Code-review-library-codenarc' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"sonar\"},{\"name\": \"build\"}]' stages [ 'Build-library-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-npm' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-gradle' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-terraform' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' + ',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-opa' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + ',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-codenarc' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildStage}\" + ',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-npm' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-gradle' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildStage}\" + ',{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-go' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' + '{\"name\": \"build\"}' + \"${buildStage}\" + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildStage}\" + ',{\"name\":\"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Create-release' ] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]' def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def defaultStages = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']' def codebaseName = \"${NAME}\" def gitServerCrName = \"${GIT_SERVER_CR_NAME}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\" def repositoryPath = \"${REPOSITORY_PATH.replaceAll(~/:\\d+\\\\//,\" /\")}\" def githubRepository = \"https://${repositoryPath.split(\"@\")[1]}\" def defaultBranch = \"${DEFAULT_BRANCH}\" def codebaseFolder = jenkins.getItem(codebaseName) if (codebaseFolder == null) { folder(codebaseName) } createListView(codebaseName, \"Releases\") createReleasePipeline(\"Create-release-${codebaseName}\", codebaseName, stages[\"Create-release\"], \"CreateRelease\", repositoryPath, gitCredentialsId, gitServerCrName, gitServerCrVersion, jiraIntegrationEnabled, platformType, defaultBranch) if (buildTool.toString().equalsIgnoreCase('none')) { return true } if (BRANCH) { def branch = \"${BRANCH}\" def formattedBranch = \"${branch.toUpperCase().replaceAll(/ \\\\ //, \"-\")}\" createListView ( codebaseName , formattedBranch ) def type = \"${TYPE}\" def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) def crKey = getStageKeyName ( buildTool ). toString () createCodeReviewPipeline ( \"Code-review-${codebaseName}\" , codebaseName , stages . get ( crKey , defaultStages ), \"CodeReview\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion , githubRepository ) registerWebHook ( repositoryPath ) def buildKey = \"Build-${type}-${buildTool.toLowerCase()}\" . toString () if ( type . equalsIgnoreCase ( 'application' ) || type . equalsIgnoreCase ( 'library' )) { def jobExists = false if ( \"${formattedBranch}-Build-${codebaseName}\" . toString () in Jenkins . instance . getAllItems (). collect { it . name }) jobExists = true createBuildPipeline ( \"Build-${codebaseName}\" , codebaseName , stages . get ( buildKey , defaultStages ), \"Build\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion , githubRepository ) registerWebHook ( repositoryPath , 'build' ) if (! jobExists ) queue ( \"${codebaseName}/${formattedBranch}-Build-${codebaseName}\" ) } } def getStageKeyName ( buildTool ) { if ( buildTool . toString (). equalsIgnoreCase ( 'terraform' )) { return \"Code-review-library-terraform\" } if ( buildTool . toString (). equalsIgnoreCase ( 'opa' )) { return \"Code-review-library-opa\" } if ( buildTool . toString (). equalsIgnoreCase ( 'codenarc' )) { return \"Code-review-library-codenarc\" } def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) return supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\" } def createCodeReviewPipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , defaultBranch , gitServerCrName , gitServerCrVersion , githubRepository ) { pipelineJob ( \"${codebaseName}/${defaultBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) if ( pipelineName . contains ( \"Build\" )) stringParam ( \"BRANCH\" , \"${defaultBranch}\" , \"Branch to build artifact from\" ) else stringParam ( \"BRANCH\" , \"\\${ghprbActualCommit}\" , \"Branch to build artifact from\" ) } } triggers { githubPullRequest { cron ( '' ) onlyTriggerPhrase ( false ) useGitHubHooks ( true ) permitAll ( true ) autoCloseFailedPullRequests ( false ) displayBuildErrorsOnDownstreamBuilds ( false ) whiteListTargetBranches ([ defaultBranch . toString ()]) extensions { commitStatus { context ( 'Jenkins Code-Review' ) triggeredStatus ( 'Build is Triggered' ) startedStatus ( 'Build is Started' ) addTestResults ( true ) completedStatus ( 'SUCCESS' , 'Verified' ) completedStatus ( 'FAILURE' , 'Failed' ) completedStatus ( 'PENDING' , 'Penging' ) completedStatus ( 'ERROR' , 'Error' ) } } } } properties { githubProjectProperty { projectUrlStr ( \"${githubRepository}\" ) } } } } def createBuildPipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , defaultBranch , gitServerCrName , gitServerCrVersion , githubRepository ) { pipelineJob ( \"${codebaseName}/${defaultBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nnode {\\n git credentialsId: \\'${credId}\\', url: \\'${repository}\\', branch: \\'${BRANCH}\\'\\n}\\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) stringParam ( \"BRANCH\" , \"${defaultBranch}\" , \"Branch to run from\" ) } } triggers { gitHubPushTrigger () } properties { githubProjectProperty { projectUrlStr ( \"${githubRepository}\" ) } } } } def createListView ( codebaseName , branchName ) { listView ( \"${codebaseName}/${branchName}\" ) { if ( branchName . toLowerCase () == \"releases\" ) { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^Create-release.*\" ) } } } else { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^${branchName}-(Code-review|Build).*\" ) } } } columns { status () weather () name () lastSuccess () lastFailure () lastDuration () buildButton () } } } def createReleasePipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , platformType , defaultBranch ) { pipelineJob ( \"${codebaseName}/${pipelineName}\" ) { logRotator { numToKeep ( 14 ) daysToKeep ( 30 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"\" ) if ( pipelineName . contains ( \"Create-release\" )) { stringParam ( \"JIRA_INTEGRATION_ENABLED\" , \"${jiraIntegrationEnabled}\" , \"Is Jira integration enabled\" ) stringParam ( \"PLATFORM_TYPE\" , \"${platformType}\" , \"Platform type\" ) stringParam ( \"GERRIT_PROJECT\" , \"${codebaseName}\" , \"\" ) stringParam ( \"RELEASE_NAME\" , \"\" , \"Name of the release(branch to be created)\" ) stringParam ( \"COMMIT_ID\" , \"\" , \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\" ) stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"REPOSITORY_PATH\" , \"${repository}\" , \"Full repository path\" ) stringParam ( \"DEFAULT_BRANCH\" , \"${defaultBranch}\" , \"Default repository branch\" ) } } } } } def registerWebHook ( repositoryPath , type = 'code-review' ) { def url = repositoryPath . split ( '@' )[ 1 ]. split ( '/' )[ 0 ] def owner = repositoryPath . split ( '@' )[ 1 ]. split ( '/' )[ 1 ] def repo = repositoryPath . split ( '@' )[ 1 ]. split ( '/' )[ 2 ] def apiUrl = 'https://api.' + url + '/repos/' + owner + '/' + repo + '/hooks' def webhookUrl = '' def webhookConfig = [:] def config = [:] def events = [] if ( type . equalsIgnoreCase ( 'build' )) { webhookUrl = System . getenv ( 'JENKINS_UI_URL' ) + \"/github-webhook/\" events = [ \"push\" ] config [ \"url\" ] = webhookUrl config [ \"content_type\" ] = \"json\" config [ \"insecure_ssl\" ] = 0 webhookConfig [ \"name\" ] = \"web\" webhookConfig [ \"config\" ] = config webhookConfig [ \"events\" ] = events webhookConfig [ \"active\" ] = true } else { webhookUrl = System . getenv ( 'JENKINS_UI_URL' ) + \"/ghprbhook/\" events = [ \"issue_comment\" , \"pull_request\" ] config [ \"url\" ] = webhookUrl config [ \"content_type\" ] = \"form\" config [ \"insecure_ssl\" ] = 0 webhookConfig [ \"name\" ] = \"web\" webhookConfig [ \"config\" ] = config webhookConfig [ \"events\" ] = events webhookConfig [ \"active\" ] = true } def requestBody = JsonOutput . toJson ( webhookConfig ) def http = new URL ( apiUrl ). openConnection () as HttpURLConnection http . setRequestMethod ( 'POST' ) http . setDoOutput ( true ) println ( apiUrl ) http . setRequestProperty ( \"Accept\" , 'application/json' ) http . setRequestProperty ( \"Content-Type\" , 'application/json' ) http . setRequestProperty ( \"Authorization\" , \"token ${getSecretValue('github-access-token')}\" ) http . outputStream . write ( requestBody . getBytes ( \"UTF-8\" )) http . connect () println ( http . responseCode ) if ( http . responseCode == 201 ) { response = new JsonSlurper (). parseText ( http . inputStream . getText ( 'UTF-8' )) } else { response = new JsonSlurper (). parseText ( http . errorStream . getText ( 'UTF-8' )) } println \"response: ${response}\" } def getSecretValue ( name ) { def creds = com . cloudbees . plugins . credentials . CredentialsProvider . lookupCredentials ( com . cloudbees . plugins . credentials . common . StandardCredentials . class , Jenkins . instance , null , null ) def secret = creds . find { it . properties [ 'id' ] == name } return secret != null ? secret [ 'secret' ] : null } After the steps above are performed, the new custom job-provision will be available in Advanced Settings during the application creation in Admin Console.","title":"GitHub (github)"},{"location":"operator-guide/manage-jenkins-ci-job-provision/#gitlab-gitlab","text":"To create a new job provision for work with GitLab, take the following steps: Navigate to the Jenkins main page and open the job-provisions/ci folder. Click New Item and type the name of job-provisions - gitlab . Select the Freestyle project option and click OK. Select the Discard old builds check box and configure a few parameters: Strategy: Log Rotation Days to keep builds: 10 Max # of builds to keep: 10 Select the This project is parameterized check box and add a few input parameters as the following strings: NAME; TYPE; BUILD_TOOL; BRANCH; GIT_SERVER_CR_NAME; GIT_SERVER_CR_VERSION; GIT_SERVER; GIT_SSH_PORT; GIT_USERNAME; GIT_CREDENTIALS_ID; REPOSITORY_PATH; JIRA_INTEGRATION_ENABLED; PLATFORM_TYPE; DEFAULT_BRANCH; Check the Execute concurrent builds if necessary option. Check the Restrict where this project can be run option. Fill in the Label Expression field by typing master to ensure job runs on Jenkins Master. In the Build section, perform the following: Select DSL Script ; Select the Use the provided DSL script check box: As soon as all the steps above are performed, insert the code: View: Template import groovy.json.* import jenkins.model.Jenkins Jenkins jenkins = Jenkins . instance def stages = [:] def jiraIntegrationEnabled = Boolean . parseBoolean ( \"${JIRA_INTEGRATION_ENABLED}\" as String ) def commitValidateStage = jiraIntegrationEnabled ? ',{\"name\": \"commit-validate\"}' : '' def createJIMStage = jiraIntegrationEnabled ? ',{\"name\": \"create-jira-issue-metadata\"}' : '' def platformType = \"${PLATFORM_TYPE}\" def buildTool = \"${BUILD_TOOL}\" def buildImageStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"},' : ',{\"name\": \"build-image-from-dockerfile\"},' def goBuildImageStage = platformType == \"kubernetes\" ? ',{\"name\": \"build-image-kaniko\"}' : ',{\"name\": \"build-image-from-dockerfile\"}' def goBuildStage = buildTool . toString () == \"go\" ? ',{\"name\": \"build\"}' : ',{\"name\": \"compile\"}' stages [ 'Code-review-application' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + goBuildStage + ',{\"name\": \"tests\"},[{\"name\": \"sonar\"},{\"name\": \"dockerfile-lint\"},{\"name\": \"helm-lint\"}]]' stages [ 'Code-review-library' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"compile\"},{\"name\": \"tests\"},' + '{\"name\": \"sonar\"}]' stages [ 'Code-review-autotests' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${createJIMStage}\" + ']' stages [ 'Code-review-default' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ']' stages [ 'Code-review-library-terraform' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"terraform-lint\"}]' stages [ 'Code-review-library-opa' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"tests\"}]' stages [ 'Code-review-library-codenarc' ] = '[{\"name\": \"checkout\"}' + \"${commitValidateStage}\" + ',{\"name\": \"sonar\"},{\"name\": \"build\"}]' stages [ 'Build-library-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-npm' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-gradle' ] = stages [ 'Build-library-maven' ] stages [ 'Build-library-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-terraform' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"terraform-lint\"}' + ',{\"name\": \"terraform-plan\"},{\"name\": \"terraform-apply\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-opa' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"}' + ',{\"name\": \"tests\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-library-codenarc' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-maven' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"},{\"name\": \"build\"}' + \"${buildImageStage}\" + '{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-python' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildImageStage}\" + '{\"name\":\"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-npm' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-gradle' ] = stages [ 'Build-application-maven' ] stages [ 'Build-application-dotnet' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"compile\"},' + '{\"name\": \"tests\"},{\"name\": \"sonar\"}' + \"${buildImageStage}\" + '{\"name\": \"push\"}' + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Build-application-terraform' ] = '[{\"name\": \"checkout\"},{\"name\": \"tool-init\"},' + '{\"name\": \"lint\"},{\"name\": \"git-tag\"}]' stages [ 'Build-application-helm' ] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"}]' stages [ 'Build-application-docker' ] = '[{\"name\": \"checkout\"},{\"name\": \"lint\"}]' stages [ 'Build-application-go' ] = '[{\"name\": \"checkout\"},{\"name\": \"get-version\"},{\"name\": \"tests\"},{\"name\": \"sonar\"},' + '{\"name\": \"build\"}' + \"${goBuildImageStage}\" + \"${createJIMStage}\" + ',{\"name\": \"git-tag\"}]' stages [ 'Create-release' ] = '[{\"name\": \"checkout\"},{\"name\": \"create-branch\"},{\"name\": \"trigger-job\"}]' def defaultStages = '[{\"name\": \"checkout\"}' + \"${createJIMStage}\" + ']' def codebaseName = \"${NAME}\" def gitServerCrName = \"${GIT_SERVER_CR_NAME}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitServer = \"${GIT_SERVER ? GIT_SERVER : 'gerrit'}\" def gitSshPort = \"${GIT_SSH_PORT ? GIT_SSH_PORT : '29418'}\" def gitUsername = \"${GIT_USERNAME ? GIT_USERNAME : 'jenkins'}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\" def defaultRepoPath = \"ssh://${gitUsername}@${gitServer}:${gitSshPort}/${codebaseName}\" def repositoryPath = \"${REPOSITORY_PATH ? REPOSITORY_PATH : defaultRepoPath}\" def defaultBranch = \"${DEFAULT_BRANCH}\" def codebaseFolder = jenkins . getItem ( codebaseName ) if ( codebaseFolder == null ) { folder ( codebaseName ) } createListView ( codebaseName , \"Releases\" ) createReleasePipeline ( \"Create-release-${codebaseName}\" , codebaseName , stages [ \"Create-release\" ], \"CreateRelease\" , repositoryPath , gitCredentialsId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , platformType , defaultBranch ) if ( BRANCH ) { def branch = \"${BRANCH}\" def formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \" - \")}\" createListView ( codebaseName , formattedBranch ) def type = \"${TYPE}\" def crKey = getStageKeyName ( buildTool ). toString () createCiPipeline ( \"Code-review-${codebaseName}\" , codebaseName , stages . get ( crKey , defaultStages ), \"CodeReview\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) def buildKey = \"Build-${type}-${buildTool.toLowerCase()}\" . toString () if ( type . equalsIgnoreCase ( 'application' ) || type . equalsIgnoreCase ( 'library' )) { def jobExists = false if ( \"${formattedBranch}-Build-${codebaseName}\" . toString () in Jenkins . instance . getAllItems (). collect { it . name }) { jobExists = true } createCiPipeline ( \"Build-${codebaseName}\" , codebaseName , stages . get ( buildKey , defaultStages ), \"Build\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) if (! jobExists ) { queue ( \"${codebaseName}/${formattedBranch}-Build-${codebaseName}\" ) } } } def createCiPipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , defaultBranch , gitServerCrName , gitServerCrVersion ) { def jobName = \"${defaultBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" def existingJob = Jenkins . getInstance (). getItemByFullName ( \"${codebaseName}/${jobName}\" ) def webhookToken = null if ( existingJob ) { def triggersMap = existingJob . getTriggers () triggersMap . each { key , value -> webhookToken = value . getSecretToken () } } else { def random = new byte [ 16 ] new java . security . SecureRandom (). nextBytes ( random ) webhookToken = random . encodeHex (). toString () } pipelineJob ( \"${codebaseName}/${jobName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } properties { gitLabConnection { gitLabConnection ( 'gitlab' ) } } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) if ( pipelineName . contains ( \"Build\" )) stringParam ( \"BRANCH\" , \"${defaultBranch}\" , \"Branch to build artifact from\" ) else stringParam ( \"BRANCH\" , \"\\${gitlabMergeRequestLastCommit}\" , \"Branch to build artifact from\" ) } } triggers { gitlabPush { buildOnMergeRequestEvents ( pipelineName . contains ( \"Build\" ) ? false : true ) buildOnPushEvents ( pipelineName . contains ( \"Build\" ) ? true : false ) enableCiSkip ( false ) setBuildDescription ( true ) rebuildOpenMergeRequest ( pipelineName . contains ( \"Build\" ) ? 'never' : 'source' ) commentTrigger ( \"Build it please\" ) skipWorkInProgressMergeRequest ( true ) targetBranchRegex ( \"${defaultBranch}\" ) } } configure { it / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' << secretToken ( webhookToken ) it / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' << triggerOnApprovedMergeRequest ( pipelineName . contains ( \"Build\" ) ? false : true ) it / triggers / 'com.dabsquared.gitlabjenkins.GitLabPushTrigger' << pendingBuildName ( pipelineName . contains ( \"Build\" ) ? \"\" : \"Jenkins\" ) } } registerWebHook ( repository , codebaseName , jobName , webhookToken ) } def getStageKeyName ( buildTool ) { if ( buildTool . toString (). equalsIgnoreCase ( 'terraform' )) { return \"Code-review-library-terraform\" } if ( buildTool . toString (). equalsIgnoreCase ( 'opa' )) { return \"Code-review-library-opa\" } if ( buildTool . toString (). equalsIgnoreCase ( 'codenarc' )) { return \"Code-review-library-codenarc\" } def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) return supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\" } def createReleasePipeline ( pipelineName , codebaseName , codebaseStages , pipelineType , repository , credId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , platformType , defaultBranch ) { pipelineJob ( \"${codebaseName}/${pipelineName}\" ) { logRotator { numToKeep ( 14 ) daysToKeep ( 30 ) } definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\n${pipelineType}()\" ) sandbox ( true ) } parameters { stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"\" ) if ( pipelineName . contains ( \"Create-release\" )) { stringParam ( \"JIRA_INTEGRATION_ENABLED\" , \"${jiraIntegrationEnabled}\" , \"Is Jira integration enabled\" ) stringParam ( \"PLATFORM_TYPE\" , \"${platformType}\" , \"Platform type\" ) stringParam ( \"GERRIT_PROJECT\" , \"${codebaseName}\" , \"\" ) stringParam ( \"RELEASE_NAME\" , \"\" , \"Name of the release(branch to be created)\" ) stringParam ( \"COMMIT_ID\" , \"\" , \"Commit ID that will be used to create branch from for new release. If empty, DEFAULT_BRANCH will be used\" ) stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"REPOSITORY_PATH\" , \"${repository}\" , \"Full repository path\" ) stringParam ( \"DEFAULT_BRANCH\" , \"${defaultBranch}\" , \"Default repository branch\" ) } } } } } def createListView ( codebaseName , branchName ) { listView ( \"${codebaseName}/${branchName}\" ) { if ( branchName . toLowerCase () == \"releases\" ) { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^Create-release.*\" ) } } } else { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^${branchName}-(Code-review|Build).*\" ) } } } columns { status () weather () name () lastSuccess () lastFailure () lastDuration () buildButton () } } } def registerWebHook ( repositoryPath , codebaseName , jobName , webhookToken ) { def apiUrl = 'https://' + repositoryPath . replaceAll ( \"ssh://\" , \"\" ). split ( '@' )[ 1 ]. replace ( '/' , \"%2F\" ). replaceAll (~ /:\\d+%2F/ , '/api/v4/projects/' ) + '/hooks' def jobWebhookUrl = \"${System.getenv('JENKINS_UI_URL')}/project/${codebaseName}/${jobName}\" def gitlabToken = getSecretValue ( 'gitlab-access-token' ) if ( checkWebHookExist ( apiUrl , jobWebhookUrl , gitlabToken )) { println ( \"[JENKINS][DEBUG] Webhook for job ${jobName} is already exist\\r\\n\" ) return } println ( \"[JENKINS][DEBUG] Creating webhook for job ${jobName}\" ) def webhookConfig = [:] webhookConfig [ \"url\" ] = jobWebhookUrl webhookConfig [ \"push_events\" ] = jobName . contains ( \"Build\" ) ? \"true\" : \"false\" webhookConfig [ \"merge_requests_events\" ] = jobName . contains ( \"Build\" ) ? \"false\" : \"true\" webhookConfig [ \"issues_events\" ] = \"false\" webhookConfig [ \"confidential_issues_events\" ] = \"false\" webhookConfig [ \"tag_push_events\" ] = \"false\" webhookConfig [ \"note_events\" ] = \"true\" webhookConfig [ \"job_events\" ] = \"false\" webhookConfig [ \"pipeline_events\" ] = \"false\" webhookConfig [ \"wiki_page_events\" ] = \"false\" webhookConfig [ \"enable_ssl_verification\" ] = \"true\" webhookConfig [ \"token\" ] = webhookToken def requestBody = JsonOutput . toJson ( webhookConfig ) def httpConnector = new URL ( apiUrl ). openConnection () as HttpURLConnection httpConnector . setRequestMethod ( 'POST' ) httpConnector . setDoOutput ( true ) httpConnector . setRequestProperty ( \"Accept\" , 'application/json' ) httpConnector . setRequestProperty ( \"Content-Type\" , 'application/json' ) httpConnector . setRequestProperty ( \"PRIVATE-TOKEN\" , \"${gitlabToken}\" ) httpConnector . outputStream . write ( requestBody . getBytes ( \"UTF-8\" )) httpConnector . connect () if ( httpConnector . responseCode == 201 ) println ( \"[JENKINS][DEBUG] Webhook for job ${jobName} has been created\\r\\n\" ) else { println ( \"[JENKINS][ERROR] Responce code - ${httpConnector.responseCode}\" ) def response = new JsonSlurper (). parseText ( httpConnector . errorStream . getText ( 'UTF-8' )) println ( \"[JENKINS][ERROR] Failed to create webhook for job ${jobName}. Response - ${response}\" ) } } def checkWebHookExist ( apiUrl , jobWebhookUrl , gitlabToken ) { println ( \"[JENKINS][DEBUG] Checking if webhook ${jobWebhookUrl} exists\" ) def httpConnector = new URL ( apiUrl ). openConnection () as HttpURLConnection httpConnector . setRequestMethod ( 'GET' ) httpConnector . setDoOutput ( true ) httpConnector . setRequestProperty ( \"Accept\" , 'application/json' ) httpConnector . setRequestProperty ( \"Content-Type\" , 'application/json' ) httpConnector . setRequestProperty ( \"PRIVATE-TOKEN\" , \"${gitlabToken}\" ) httpConnector . connect () if ( httpConnector . responseCode == 200 ) { def response = new JsonSlurper (). parseText ( httpConnector . inputStream . getText ( 'UTF-8' )) return response . find { it . url == jobWebhookUrl } ? true : false } } def getSecretValue ( name ) { def creds = com . cloudbees . plugins . credentials . CredentialsProvider . lookupCredentials ( com . cloudbees . plugins . credentials . common . StandardCredentials . class , Jenkins . instance , null , null ) def secret = creds . find { it . properties [ 'id' ] == name } return secret != null ? secret [ 'secret' ] : null } Create Secret, GitServer CR and Jenkins credentials with the \"gitlab\" ID by following the instruction: Adjust Import Strategy . After the steps above are performed, the new custom job-provision will be available in Advanced Settings during the application creation in Admin Console.","title":"GitLab (gitlab)"},{"location":"operator-guide/openshift-cluster-settings/","text":"Set Up OpenShift \u2693\ufe0e Make sure the cluster meets the following conditions: OpenShift cluster is installed with minimum 2 worker nodes with total capacity 32 Cores and 8Gb RAM; Load balancer (if any exists in front of OpenShift router or ingress controller) is configured with session stickiness, disabled HTTP/2 protocol and header size of 64k support; Example of Config Map for Nginx ingress controller: kind : ConfigMap apiVersion : v1 metadata : name : nginx - configuration namespace : ingress - nginx labels : app . kubernetes . io / name : ingress - nginx app . kubernetes . io / part - of : ingress - nginx data : client - header - buffer - size : 64 k large - client - header - buffers : 4 64 k use - http2 : \"false\" Cluster nodes and pods have access to the cluster via external URLs. For instance, add in AWS the VPC NAT gateway elastic IP to the cluster external load balancers security group); Keycloak instance is installed. To get accurate information on how to install Keycloak, please refer to the Install Keycloak instruction; The installation machine with oc is installed with the cluster-admin access to the OpenShift cluster; Helm 3.1 is installed on the installation machine with the help of the Installing Helm instruction. A storage class is used with the Retain Reclaim Policy : Storage class template with Retain Reclaim Policy: kind : StorageClass apiVersion : storage . k8s . io / v1 metadata : name : gp2 - retain provisioner : kubernetes . io / aws - ebs parameters : fsType : ext4 type : gp2 reclaimPolicy : Retain volumeBindingMode : WaitForFirstConsumer Related Articles \u2693\ufe0e Install Keycloak","title":"Set Up OpenShift"},{"location":"operator-guide/openshift-cluster-settings/#set-up-openshift","text":"Make sure the cluster meets the following conditions: OpenShift cluster is installed with minimum 2 worker nodes with total capacity 32 Cores and 8Gb RAM; Load balancer (if any exists in front of OpenShift router or ingress controller) is configured with session stickiness, disabled HTTP/2 protocol and header size of 64k support; Example of Config Map for Nginx ingress controller: kind : ConfigMap apiVersion : v1 metadata : name : nginx - configuration namespace : ingress - nginx labels : app . kubernetes . io / name : ingress - nginx app . kubernetes . io / part - of : ingress - nginx data : client - header - buffer - size : 64 k large - client - header - buffers : 4 64 k use - http2 : \"false\" Cluster nodes and pods have access to the cluster via external URLs. For instance, add in AWS the VPC NAT gateway elastic IP to the cluster external load balancers security group); Keycloak instance is installed. To get accurate information on how to install Keycloak, please refer to the Install Keycloak instruction; The installation machine with oc is installed with the cluster-admin access to the OpenShift cluster; Helm 3.1 is installed on the installation machine with the help of the Installing Helm instruction. A storage class is used with the Retain Reclaim Policy : Storage class template with Retain Reclaim Policy: kind : StorageClass apiVersion : storage . k8s . io / v1 metadata : name : gp2 - retain provisioner : kubernetes . io / aws - ebs parameters : fsType : ext4 type : gp2 reclaimPolicy : Retain volumeBindingMode : WaitForFirstConsumer","title":"Set Up OpenShift"},{"location":"operator-guide/openshift-cluster-settings/#related-articles","text":"Install Keycloak","title":"Related Articles"},{"location":"operator-guide/overview-manage-jenkins-pipelines/","text":"Overview \u2693\ufe0e Jenkins job provisioners are responsible for creating and managing pipelines in Jenkins. In other words, provisioners configure all Jenkins pipelines and bring them to the state described in the provisioners code. Two types of provisioners are available in EDP: CI-provisioner - manages the application folder, and its Code Review, Build and Create Release pipelines. CD-provisioner - manages the Deploy pipelines. The subsections describe the creation/update process of provisioners and their content depending on EDP customization.","title":"Overview"},{"location":"operator-guide/overview-manage-jenkins-pipelines/#overview","text":"Jenkins job provisioners are responsible for creating and managing pipelines in Jenkins. In other words, provisioners configure all Jenkins pipelines and bring them to the state described in the provisioners code. Two types of provisioners are available in EDP: CI-provisioner - manages the application folder, and its Code Review, Build and Create Release pipelines. CD-provisioner - manages the Deploy pipelines. The subsections describe the creation/update process of provisioners and their content depending on EDP customization.","title":"Overview"},{"location":"operator-guide/perf-integration/","text":"Perf Server Integration \u2693\ufe0e Integration with Perf Server allows connecting to the PERF Board (Project Performance Board) and monitoring the overall team performance as well as setting up necessary metrics. Note To adjust the PERF Server integration, make sure that PERF Operator is deployed. To get more information about the PERF Operator installation and architecture, please refer to the PERF Operator page. For integration, take the following steps: Create Secret in the OpenShift/Kubernetes namespace for Perf Server account with the username and password fields: apiVersion : v1 data : password : passwordInBase64 username : usernameInBase64 kind : Secret metadata : name : epam - perf - user type : kubernetes . io / basic - auth In the edp-config config map, enable the perf_integration flag and click Save : perf_integration_enabled: 'true' Being in Admin Console, navigate to the Advanced Settings menu to check that the Integrate with Perf Server check box appeared: Related Articles \u2693\ufe0e Add Application Add Autotest Add Library","title":"Perf Server Integration"},{"location":"operator-guide/perf-integration/#perf-server-integration","text":"Integration with Perf Server allows connecting to the PERF Board (Project Performance Board) and monitoring the overall team performance as well as setting up necessary metrics. Note To adjust the PERF Server integration, make sure that PERF Operator is deployed. To get more information about the PERF Operator installation and architecture, please refer to the PERF Operator page. For integration, take the following steps: Create Secret in the OpenShift/Kubernetes namespace for Perf Server account with the username and password fields: apiVersion : v1 data : password : passwordInBase64 username : usernameInBase64 kind : Secret metadata : name : epam - perf - user type : kubernetes . io / basic - auth In the edp-config config map, enable the perf_integration flag and click Save : perf_integration_enabled: 'true' Being in Admin Console, navigate to the Advanced Settings menu to check that the Integrate with Perf Server check box appeared:","title":"Perf Server Integration"},{"location":"operator-guide/perf-integration/#related-articles","text":"Add Application Add Autotest Add Library","title":"Related Articles"},{"location":"operator-guide/restore-edp-with-velero/","text":"Restore EDP Tenant With Velero \u2693\ufe0e You can use the Velero tool to restore a EDP tenant. Explore the main steps for backup and restoring below. Delete all related entities in Keycloak : realm and clients from master/openshift realms. Navigate to the entitities list in the Keycloak, select the necessary ones, and click the deletion icon on the entitiy overview page. If there are customized configs in Keycloak, save them before making backup. To restore EDP, install and configure the Velero tool. Please refer to the Install Velero documentation for details. Remove all locks for operators. Delete all config maps that have \u2039OPERATOR_NAME\u203a-operator-lock names. Then restart all pods with operators, or simply run the following command: kubectl -n <EDP_NAMESPACE> delete cm $(kubectl -n <EDP_NAMESPACE> get cm | grep 'operator-lock' | awk '{print $1}') Recreate the admin password and delete the Jenkins pod. Or change the script to update the admin password in Jenkins every time when the pod is updated.","title":"Restore EDP Tenant With Velero"},{"location":"operator-guide/restore-edp-with-velero/#restore-edp-tenant-with-velero","text":"You can use the Velero tool to restore a EDP tenant. Explore the main steps for backup and restoring below. Delete all related entities in Keycloak : realm and clients from master/openshift realms. Navigate to the entitities list in the Keycloak, select the necessary ones, and click the deletion icon on the entitiy overview page. If there are customized configs in Keycloak, save them before making backup. To restore EDP, install and configure the Velero tool. Please refer to the Install Velero documentation for details. Remove all locks for operators. Delete all config maps that have \u2039OPERATOR_NAME\u203a-operator-lock names. Then restart all pods with operators, or simply run the following command: kubectl -n <EDP_NAMESPACE> delete cm $(kubectl -n <EDP_NAMESPACE> get cm | grep 'operator-lock' | awk '{print $1}') Recreate the admin password and delete the Jenkins pod. Or change the script to update the admin password in Jenkins every time when the pod is updated.","title":"Restore EDP Tenant With Velero"},{"location":"operator-guide/schedule-pods-restart/","text":"Schedule Pods Restart \u2693\ufe0e In case it is necessary to restart pods, use a CronJob according to the following template: View: template --- kind : Role apiVersion : rbac.authorization.k8s.io/v1 metadata : namespace : <NAMESPACE> name : apps-restart rules : - apiGroups : [ \"apps\" ] resources : - deployments - statefulsets verbs : - 'get' - 'list' - 'patch' --- kind : RoleBinding apiVersion : rbac.authorization.k8s.io/v1 metadata : name : apps-restart namespace : <NAMESPACE> subjects : - kind : ServiceAccount name : apps-restart-sa namespace : <NAMESPACE> roleRef : kind : Role name : apps-restart apiGroup : \"\" --- apiVersion : v1 kind : ServiceAccount metadata : name : apps-restart-sa namespace : <NAMESPACE> --- apiVersion : batch/v1beta1 kind : CronJob metadata : name : apps-rollout-restart namespace : <NAMESPACE> spec : schedule : \"0 9 * * MON-FRI\" jobTemplate : spec : template : spec : serviceAccountName : apps-restart-sa containers : - name : kubectl-runner image : bitnami/kubectl command : - /bin/sh - -c - kubectl get -n <NAMESPACE> -o name deployment,statefulset | grep <NAME_PATTERN>| xargs kubectl -n <NAMESPACE> rollout restart restartPolicy : Never Modify the Cron expression in the CronJob manifest if needed.","title":"Schedule Pods Restart"},{"location":"operator-guide/schedule-pods-restart/#schedule-pods-restart","text":"In case it is necessary to restart pods, use a CronJob according to the following template: View: template --- kind : Role apiVersion : rbac.authorization.k8s.io/v1 metadata : namespace : <NAMESPACE> name : apps-restart rules : - apiGroups : [ \"apps\" ] resources : - deployments - statefulsets verbs : - 'get' - 'list' - 'patch' --- kind : RoleBinding apiVersion : rbac.authorization.k8s.io/v1 metadata : name : apps-restart namespace : <NAMESPACE> subjects : - kind : ServiceAccount name : apps-restart-sa namespace : <NAMESPACE> roleRef : kind : Role name : apps-restart apiGroup : \"\" --- apiVersion : v1 kind : ServiceAccount metadata : name : apps-restart-sa namespace : <NAMESPACE> --- apiVersion : batch/v1beta1 kind : CronJob metadata : name : apps-rollout-restart namespace : <NAMESPACE> spec : schedule : \"0 9 * * MON-FRI\" jobTemplate : spec : template : spec : serviceAccountName : apps-restart-sa containers : - name : kubectl-runner image : bitnami/kubectl command : - /bin/sh - -c - kubectl get -n <NAMESPACE> -o name deployment,statefulset | grep <NAME_PATTERN>| xargs kubectl -n <NAMESPACE> rollout restart restartPolicy : Never Modify the Cron expression in the CronJob manifest if needed.","title":"Schedule Pods Restart"},{"location":"operator-guide/upgrade-edp-2.7.8-to-2.8.4/","text":"Upgrade EDP v.2.7.8 to v.2.8.4 \u2693\ufe0e This section provides the details on the EDP upgrade from the v.2.7.8 to the v.2.8.4. Explore the actions and requirements below. Note Kiosk is implemented and mandatory for EDP v.2.8.4 and is optional for EDP v.2.9.0 and higher. To upgrade EDP v.2.7.8 to the v.2.8.4, take the following steps: Deploy and configure Kiosk (create a Service Account, Account, and ClusterRoleBinging) according to the Set Up Kiosk documentation. Update the spec field in the Kiosk space: apiVersion : tenancy . kiosk . sh / v1alpha1 kind : Space metadata : name : < edp - project > spec : account : < edp - project >- admin Create RoleBinding (required for namespaces created before using Kiosk): Note In the uid field under the ownerReferences in the Kubernetes manifest, indicate the Account Custom Resource ID from accounts.config.kiosk.sh kubectl get account <edp-project>-admin -o=custom-columns=NAME:.metadata.uid --no-headers=true View: rolebinding-kiosk.yaml apiVersion : rbac . authorization . k8s . io / v1 kind : RoleBinding metadata : generateName : < edp - project >- admin - namespace : < edp - project > ownerReferences : - apiVersion : config . kiosk . sh / v1alpha1 blockOwnerDeletion : true controller : true kind : Account name : < edp - project >- admin uid : '' roleRef : apiGroup : rbac . authorization . k8s . io kind : ClusterRole name : kiosk - space - admin subjects : - kind : ServiceAccount name : < edp - project > namespace : security kubectl create -f rolebinding-kiosk.yaml With Amazon Elastic Container Registry to store the images, there are two options: Enable IRSA and create AWS IAM Role for Kaniko image builder. Please refer to the IAM Roles for Kaniko Service Accounts section for the details. The Amazon Elastic Container Registry Roles can be stored in an instance profile . Update Custom Resource Definitions by applying all the necessary CRD to the cluster with the command below: kubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_cdpipeline_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_codebase_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_cd_stage_deploy_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_jenkinsjobbuildrun_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_cdstagejenkinsdeployment_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_jenkinsjob_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.8/deploy-templates/crds/v1_v1alpha1_keycloakauthflow_crd.yaml With Amazon Elastic Container Registry to store and Kaniko to build the images, add the kanikoRoleArn parameter to the values before starting the update process. This parameter is indicated in AWS Roles once IRSA is enabled and AWS IAM Role is created for Kaniko. The value should look as follows: kanikoRoleArn : arn : aws : iam ::< AWS_ACCOUNT_ID >: role / AWSIRSA \u2039 CLUSTER_NAME \u203a\u2039 EDP_NAMESPACE \u203a Kaniko To upgrade EDP to the v.2.8.4, run the following command: helm upgrade edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.8.4 Note To verify the installation, it is possible to test the deployment before applying it to the cluster with: helm upgrade edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.8.4 --dry-run Remove the following Kubernetes resources left from the previous EDP installation (it is optional): kubectl delete cm luminatesec-conf -n <edp-namespace> kubectl delete sa edp edp-perf-operator -n <edp-namespace> kubectl delete deployment perf-operator -n <edp-namespace> kubectl delete clusterrole edp-<edp-namespace> edp-perf-operator-<edp-namespace> kubectl delete clusterrolebinding edp-<edp-namespace> edp-perf-operator-<edp-namespace> kubectl delete rolebinding edp-<edp-namespace> edp-perf-operator-<edp-namespace>-admin -n <edp-namespace> kubectl delete perfserver epam-perf -n <edp-namespace> kubectl delete services.v2.edp.epam.com postgres rabbit-mq -n <edp-namespace> Update the CI and CD Jenkins job provisioners: Note Please refer to the Manage Jenkins CI Pipeline Job Provisioner section for the details. View: Default CI provisioner template for EDP 2.8.4 /* Copyright 2021 EPAM Systems. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ import groovy.json.* import jenkins.model.Jenkins import hudson.model.* Jenkins jenkins = Jenkins . instance def stages = [ : ] def jiraIntegrationEnabled = Boolean . parseBoolean ( \"${JIRA_INTEGRATION_ENABLED}\" as String ) def commitValidateStage = jiraIntegrationEnabled ? ' ,{ \"name\" : \"commit-validate\" } ' : '' def createJIMStage = jiraIntegrationEnabled ? ' ,{ \"name\" : \"create-jira-issue-metadata\" } ' : '' def buildTool = \"${BUILD_TOOL}\" def goBuildStage = buildTool . toString () == \"go\" ? ' ,{ \"name\" : \"build\" } ' : ' ,{ \"name\" : \"compile\" } ' stages [ ' Code - review - application ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + goBuildStage + ' ,{ \"name\" : \"tests\" }, [ { \"name\" : \"sonar\" },{ \"name\" : \"dockerfile-lint\" },{ \"name\" : \"helm-lint\" } ]] ' stages [ ' Code - review - library ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"compile\" },{ \"name\" : \"tests\" }, ' + ' { \"name\" : \"sonar\" } ] ' stages [ ' Code - review - autotests ' ] = ' [ { \"name\" : \"gerrit-checkout\" },{ \"name\" : \"get-version\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"tests\" },{ \"name\" : \"sonar\" } ' + \"${createJIMStage}\" + ']' stages [ ' Code - review - default ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ']' stages [ ' Code - review - library - terraform ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"terraform-lint\" } ] ' stages [ ' Code - review - library - opa ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"tests\" } ] ' stages [ ' Code - review - library - codenarc ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"sonar\" },{ \"name\" : \"build\" } ] ' stages [ ' Build - library - maven ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" },{ \"name\" : \"sonar\" },{ \"name\" : \"build\" },{ \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - npm ' ] = stages [ ' Build - library - maven ' ] stages [ ' Build - library - gradle ' ] = stages [ ' Build - library - maven ' ] stages [ ' Build - library - dotnet ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" },{ \"name\" : \"sonar\" },{ \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - python ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" },{ \"name\" : \"sonar\" },{ \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - terraform ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"terraform-lint\" } ' + ' ,{ \"name\" : \"terraform-plan\" },{ \"name\" : \"terraform-apply\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - opa ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" } ' + ' ,{ \"name\" : \"tests\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - codenarc ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"sonar\" },{ \"name\" : \"build\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - application - maven ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" }, [ { \"name\" : \"sonar\" } ] ,{ \"name\" : \"build\" },{ \"name\" : \"build-image-kaniko\" }, ' + ' { \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - application - npm ' ] = stages [ ' Build - application - maven ' ] stages [ ' Build - application - gradle ' ] = stages [ ' Build - application - maven ' ] stages [ ' Build - application - dotnet ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" }, [ { \"name\" : \"sonar\" } ] ,{ \"name\" : \"build-image-kaniko\" }, ' + ' { \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - application - go ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"tests\" },{ \"name\" : \"sonar\" }, ' + ' { \"name\" : \"build\" },{ \"name\" : \"build-image-kaniko\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - application - python ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" },{ \"name\" : \"sonar\" }, ' + ' { \"name\" : \"build-image-kaniko\" },{ \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Create - release ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"create-branch\" },{ \"name\" : \"trigger-job\" } ] ' def defaultBuild = ' [ { \"name\" : \"checkout\" } ' + \"${createJIMStage}\" + ']' def codebaseName = \"${NAME}\" def gitServerCrName = \"${GIT_SERVER_CR_NAME}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\" def repositoryPath = \"${REPOSITORY_PATH}\" def defaultBranch = \"${DEFAULT_BRANCH}\" def codebaseFolder = jenkins . getItem ( codebaseName ) if ( codebaseFolder == null ) { folder ( codebaseName ) } createListView ( codebaseName , \"Releases\" ) createReleasePipeline ( \"Create-release-${codebaseName}\" , codebaseName , stages [ \"Create-release\" ] , \"create-release.groovy\" , repositoryPath , gitCredentialsId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , defaultBranch ) if ( buildTool . toString (). equalsIgnoreCase ( ' none ' )) { return true } if ( BRANCH ) { def branch = \"${BRANCH}\" def formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \" - \")}\" createListView ( codebaseName , formattedBranch ) def type = \"${TYPE}\" def crKey = getStageKeyName ( buildTool ) createCiPipeline ( \"Code-review-${codebaseName}\" , codebaseName , stages [ crKey ] , \"code-review.groovy\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) def buildKey = \"Build-${type}-${buildTool.toLowerCase()}\" . toString () if ( type . equalsIgnoreCase ( ' application ' ) || type . equalsIgnoreCase ( ' library ' )) { def jobExists = false if ( \"${formattedBranch}-Build-${codebaseName}\" . toString () in Jenkins . instance . getAllItems (). collect { it . name }) jobExists = true createCiPipeline ( \"Build-${codebaseName}\" , codebaseName , stages . get ( buildKey , defaultBuild ), \"build.groovy\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) if ( ! jobExists ) queue ( \"${codebaseName}/${formattedBranch}-Build-${codebaseName}\" ) } } def createCiPipeline ( pipelineName , codebaseName , codebaseStages , pipelineScript , repository , credId , watchBranch , gitServerCrName , gitServerCrVersion ) { pipelineJob ( \"${codebaseName}/${watchBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } triggers { gerrit { events { if ( pipelineName . contains ( \"Build\" )) changeMerged () else patchsetCreated () } project ( \"plain:${codebaseName}\" , [ \"plain:${watchBranch}\" ] ) } } definition { cpsScm { scm { git { remote { url ( repository ) credentials ( credId ) } branches ( \"${watchBranch}\" ) scriptPath ( \"${pipelineScript}\" ) } } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) stringParam ( \"BRANCH\" , \"${watchBranch}\" , \"Branch to build artifact from\" ) } } } } } def getStageKeyName ( buildTool ) { if ( buildTool . toString (). equalsIgnoreCase ( ' terraform ' )) { return \"Code-review-library-terraform\" } if ( buildTool . toString (). equalsIgnoreCase ( ' opa ' )) { return \"Code-review-library-opa\" } if ( buildTool . toString (). equalsIgnoreCase ( ' codenarc ' )) { return \"Code-review-library-codenarc\" } def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) return supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\" } def createReleasePipeline ( pipelineName , codebaseName , codebaseStages , pipelineScript , repository , credId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , defaultBranch ) { pipelineJob ( \"${codebaseName}/${pipelineName}\" ) { logRotator { numToKeep ( 14 ) daysToKeep ( 30 ) } definition { cpsScm { scm { git { remote { url ( repository ) credentials ( credId ) } branches ( \"${defaultBranch}\" ) scriptPath ( \"${pipelineScript}\" ) } } parameters { stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"\" ) if ( pipelineName . contains ( \"Create-release\" )) { stringParam ( \"JIRA_INTEGRATION_ENABLED\" , \"${jiraIntegrationEnabled}\" , \"Is Jira integration enabled\" ) stringParam ( \"GERRIT_PROJECT\" , \"${codebaseName}\" , \"\" ) stringParam ( \"RELEASE_NAME\" , \"\" , \"Name of the release(branch to be created)\" ) stringParam ( \"COMMIT_ID\" , \"\" , \"Commit ID that will be used to create branch from for new release. If empty, HEAD of master will be used\" ) stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"REPOSITORY_PATH\" , \"${repository}\" , \"Full repository path\" ) stringParam ( \"DEFAULT_BRANCH\" , \"${defaultBranch}\" , \"Default repository branch\" ) } } } } } } def createListView ( codebaseName , branchName ) { listView ( \"${codebaseName}/${branchName}\" ) { if ( branchName . toLowerCase () == \"releases\" ) { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^Create-release.*\" ) } } } else { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^${branchName}-(Code-review|Build).*\" ) } } } columns { status () weather () name () lastSuccess () lastFailure () lastDuration () buildButton () } } } Note Please refer to the Manage Jenkins CD Pipeline Job Provisioner page for the details. View: Default CD provisioner template for EDP 2.8.4 /* Copyright 2021 EPAM Systems. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ import groovy.json.* import jenkins.model.Jenkins Jenkins jenkins = Jenkins . instance def pipelineName = \"${PIPELINE_NAME}-cd-pipeline\" def stageName = \"${STAGE_NAME}\" def qgStages = \"${QG_STAGES}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID}\" def sourceType = \"${SOURCE_TYPE}\" def libraryURL = \"${LIBRARY_URL}\" def libraryBranch = \"${LIBRARY_BRANCH}\" def autodeploy = \"${AUTODEPLOY}\" def scriptPath = \"Jenkinsfile\" def containerDeploymentType = \"container\" def deploymentType = \"${DEPLOYMENT_TYPE}\" def stages = buildStages ( deploymentType , containerDeploymentType , qgStages ) def codebaseFolder = jenkins . getItem ( pipelineName ) if ( codebaseFolder == null ) { folder ( pipelineName ) } if ( deploymentType == containerDeploymentType ) { createContainerizedCdPipeline ( pipelineName , stageName , stages , scriptPath , sourceType , libraryURL , libraryBranch , gitCredentialsId , gitServerCrVersion , autodeploy ) } else { createCustomCdPipeline ( pipelineName , stageName ) } def buildStages ( deploymentType , containerDeploymentType , qgStages ) { return deploymentType == containerDeploymentType ? ' [ { \"name\" : \"init\" , \"step_name\" : \"init\" },{ \"name\" : \"deploy\" , \"step_name\" : \"deploy\" }, ' + qgStages + ' ,{ \"name\" : \"promote-images-ecr\" , \"step_name\" : \"promote-images\" } ] ' : '' } def createContainerizedCdPipeline ( pipelineName , stageName , stages , pipelineScript , sourceType , libraryURL , libraryBranch , libraryCredId , gitServerCrVersion , autodeploy ) { pipelineJob ( \"${pipelineName}/${stageName}\" ) { if ( sourceType == \"library\" ) { definition { cpsScm { scm { git { remote { url ( libraryURL ) credentials ( libraryCredId ) } branches ( \"${libraryBranch}\" ) scriptPath ( \"${pipelineScript}\" ) } } } } } else { definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nDeploy()\" ) sandbox ( true ) } } } properties { disableConcurrentBuilds () } parameters { stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${stages}\" , \"Consequence of stages in JSON format to be run during execution\" ) if ( autodeploy ? . trim () && autodeploy . toBoolean ()) { stringParam ( \"AUTODEPLOY\" , \"${autodeploy}\" , \"Is autodeploy enabled?\" ) stringParam ( \"CODEBASE_VERSION\" , null , \"Codebase versions to deploy.\" ) } } } } def createCustomCdPipeline ( pipelineName , stageName ) { pipelineJob ( \"${pipelineName}/${stageName}\" ) { properties { disableConcurrentBuilds () } } } It is also necessary to add the string parameter DEPLOYMENT_TYPE to the CD provisioner: Go to job-provisions - > cd -> default -> configure ; Add Parameter - > String parameter ; Name -> DEPLOYMENT_TYPE Update Jenkins pipelines and stages to the new release tag: In Jenkins, go to Manage Jenkins -> Configure system -> Find the Global Pipeline Libraries menu. Change the Default version for edp-library-stages from build/2.8.0-RC.6 to build/2.9.0-RC.5 Change the Default version for edp-library-pipelines from build/2.8.0-RC.4 to build/2.9.0-RC.3 Update the edp-admin-console Custom Resource in the KeycloakClient Custom Resource Definition: View: keycloakclient.yaml kind : KeycloakClient apiVersion : v1.edp.epam.com/v1alpha1 metadata : name : edp-admin-console namespace : <edp-namespace> spec : advancedProtocolMappers : false attributes : null audRequired : true clientId : admin-console-client directAccess : true public : false secret : admin-console-client serviceAccount : enabled : true realmRoles : - developer targetRealm : <keycloak-edp-realm> webUrl : >- https://edp-admin-console-example.com kubectl apply -f keycloakclient.yaml Remove the admin-console-client client ID in the edp-namespace-main realm in Keycloak, restart the keycloak-operator pod and check that the new KeycloakClient is created with the confidential access type. Note If \"Internal error\" occurs, regenerate the admin-console-client secret in the Credentials tab in Keycloak and update the admin-console-client secret key \"clientSecret\" and \"password\". Update image versions for the Jenkins agents in the ConfigMap : kubectl edit configmap jenkins-slaves -n <edp-namespace> The versions of the images should be: epamedp / edp - jenkins - dotnet - 21 - agent : 1.0.2 epamedp / edp - jenkins - dotnet - 31 - agent : 1.0.2 epamedp / edp - jenkins - go - agent : 1.0.3 epamedp / edp - jenkins - gradle - java11 - agent : 2.0.2 epamedp / edp - jenkins - gradle - java8 - agent : 1.0.2 epamedp / edp - jenkins - helm - agent : 1.0.6 epamedp / edp - jenkins - maven - java11 - agent : 2.0.3 epamedp / edp - jenkins - maven - java8 - agent : 1.0.2 epamedp / edp - jenkins - npm - agent : 2.0.2 epamedp / edp - jenkins - python - 38 - agent : 2.0.3 epamedp / edp - jenkins - terraform - agent : 2.0.4 Add new Jenkins agents under the data field: View data : codenarc-template : |- <org.csanchez.jenkins.plugins.kubernetes.PodTemplate> <inheritFrom></inheritFrom> <name>codenarc</name> <namespace></namespace> <privileged>false</privileged> <alwaysPullImage>false</alwaysPullImage> <instanceCap>2147483647</instanceCap> <slaveConnectTimeout>100</slaveConnectTimeout> <idleMinutes>5</idleMinutes> <activeDeadlineSeconds>0</activeDeadlineSeconds> <label>codenarc</label> <serviceAccount>jenkins</serviceAccount> <nodeSelector>beta.kubernetes.io/os=linux</nodeSelector> <nodeUsageMode>NORMAL</nodeUsageMode> <workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"> <memory>false</memory> </workspaceVolume> <volumes/> <containers> <org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> <name>jnlp</name> <image>epamedp/edp-jenkins-codenarc-agent:1.0.0</image> <privileged>false</privileged> <alwaysPullImage>false</alwaysPullImage> <workingDir>/tmp</workingDir> <command></command> <args>${computer.jnlpmac} ${computer.name}</args> <ttyEnabled>false</ttyEnabled> <resourceRequestCpu></resourceRequestCpu> <resourceRequestMemory></resourceRequestMemory> <resourceLimitCpu></resourceLimitCpu> <resourceLimitMemory></resourceLimitMemory> <envVars> <org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> <key>JAVA_TOOL_OPTIONS</key> <value>-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true</value> </org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> </envVars> <ports/> </org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> </containers> <envVars/> <annotations/> <imagePullSecrets/> <podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/> </org.csanchez.jenkins.plugins.kubernetes.PodTemplate> opa-template : |- <org.csanchez.jenkins.plugins.kubernetes.PodTemplate> <inheritFrom></inheritFrom> <name>opa</name> <namespace></namespace> <privileged>false</privileged> <alwaysPullImage>false</alwaysPullImage> <instanceCap>2147483647</instanceCap> <slaveConnectTimeout>100</slaveConnectTimeout> <idleMinutes>5</idleMinutes> <activeDeadlineSeconds>0</activeDeadlineSeconds> <label>opa</label> <serviceAccount>jenkins</serviceAccount> <nodeSelector>beta.kubernetes.io/os=linux</nodeSelector> <nodeUsageMode>NORMAL</nodeUsageMode> <workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"> <memory>false</memory> </workspaceVolume> <volumes/> <containers> <org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> <name>jnlp</name> <image>epamedp/edp-jenkins-opa-agent:1.0.1</image> <privileged>false</privileged> <alwaysPullImage>false</alwaysPullImage> <workingDir>/tmp</workingDir> <command></command> <args>${computer.jnlpmac} ${computer.name}</args> <ttyEnabled>false</ttyEnabled> <resourceRequestCpu></resourceRequestCpu> <resourceRequestMemory></resourceRequestMemory> <resourceLimitCpu></resourceLimitCpu> <resourceLimitMemory></resourceLimitMemory> <envVars> <org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> <key>JAVA_TOOL_OPTIONS</key> <value>-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true</value> </org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> </envVars> <ports/> </org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> </containers> <envVars/> <annotations/> <imagePullSecrets/> <podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/> </org.csanchez.jenkins.plugins.kubernetes.PodTemplate> Restart the Jenkins pod. Update compatible plugins in Jenkins and install additional plugins: Go to Manage Jenkins -> Manage Plugins -> Select Compatible -> Click Download now and install after restart Install the following additional plugins (click the Available plugins tab in Jenkins): Groovy Postbuild CloudBees AWS Credentials Badge Timestamper Add the annotation deploy.edp.epam.com/previous-stage-name: '' (it should be empty if the CD pipeline contains one stage) to each Custom Resource in the Custom Resource Definition Stage , for example: List all Custom Resources in Stage : kubectl get stages.v2.edp.epam.com -n <edp-namespace> Edit resources: kubectl edit stages.v2.edp.epam.com <cd-stage-name> -n <edp-namespace> apiVersion : v2 . edp . epam . com / v1alpha1 kind : Stage metadata : annotations : deploy . edp . epam . com / previous - stage - name : '' Note If a pipeline contains several stages, add a previous stage name indicated in the EDP Admin Console to the annotation, for example: deploy.edp.epam.com/previous-stage-name: 'dev' . Execute script to align CDPipeline resources to the new API ( jq command-line JSON processor is required): pipelines = $ ( kubectl get cdpipelines - n < edp - namespace > - ojson | jq - c ' .items[] ' ) for p in $ pipelines ; do echo \" $p \" | \\ jq ' . | .spec.inputDockerStreams = .spec.input_docker_streams | del(.spec.input_docker_streams) | .spec += { \"deploymentType\": \"container\" } ' | \\ kubectl apply - f - done Update the database in the edp-db pod in the edp-namespace: Log in to the pod: kubectl exec - i - t - n < edp - namespace > edp - db -< pod > - c edp - db \" -- \" sh - c \" (bash || ash || sh) \" Log in to the Postgress DB (where \"admin\" is the user the secret was created for): psql edp-db <admin>; SET search_path to '<edp-namespace>'; UPDATE cd_pipeline SET deployment_type = 'container'; Add \"AUTODEPLOY\":\"true/false\",\"DEPLOYMENT_TYPE\":\"container\" to every Custom Resource in jenkinsjobs.v2.edp.epam.com : Edit Kubernetes resources: kubectl get jenkinsjobs.v2.edp.epam.com -n <edp-namespace> kubectl edit jenkinsjobs.v2.edp.epam.com <cd-pipeline-name> -n <edp-namespace> Alternatively, use this script to update all the necessary jenkinsjobs Custom Resources: edp_namespace =< epd_namespace > for stages in $ ( kubectl get jenkinsjobs - o = name - n $ed p_namespace ) ; do kubectl get $stages -n $edp_namespace -o yaml | grep -q \"container\" && echo -e \"\\n$stages is already updated\" || kubectl get $stages -n $edp_namespace -o yaml | sed 's/\"GIT_SERVER_CR_VERSION\"/\"AUTODEPLOY\":\"false\",\"DEPLOYMENT_TYPE\":\"container\",\"GIT_SERVER_CR_VERSION\"/g' | kubectl apply -f -; done Make sure the edited resource looks as follows: job : config : '{\"AUTODEPLOY\":\"false\",\"DEPLOYMENT_TYPE\":\"container\",\"GIT_SERVER_CR_VERSION\":\"v2\",\"PIPELINE_NAME\":\"your-pipeline-name\",\"QG_STAGES\":\"{\\\"name\\\":\\\"manual\\\",\\\"step_name\\\":\\\"your-step-name\\\"}\",\"SOURCE_TYPE\":\"default\",\"STAGE_NAME\":\"your-stage-name\"}' name : job - provisions /job/cd/job/ default Restart the Jenkins operator pod and wait until the CD job provisioner in Jenkins creates the updated pipelines. Possible Issues \u2693\ufe0e SonarQube fails during the CI pipeline run. The previous builds of SonarQube used the latest version of the OpenID Connect Authentication for SonarQube plugin. Version 2.1.0 of this plugin may have issues with the connection, so it is necessary to downgrade it in order to get rid of errors in the pipeline. Take the following steps: Log in to the Sonar pod: kubectl exec - i - t - n < edp - namespace > sonar -< pod > - c sonar \" -- \" sh - c \" (bash || ash || sh) \" Run the command in the Sonar container: rm extensions/plugins/sonar-auth-oidc-plugin* Install the OpenID Connect Authentication for SonarQube plugin v2.0.0: curl - L https : // github . com / vaulttec / sonar - auth - oidc / releases / download / v2 . 0.0 / sonar - auth - oidc - plugin - 2.0 . 0.j ar -- output extensions / plugins / sonar - auth - oidc - plugin - 2.0 . 0.j ar Restart the SonarQube pod; The Helm lint checker in EDP 2.8.4 has some additional rules. There can be issues with it during the Code Review pipeline in Jenkins for applications that were transferred from previous EDP versions to EDP 2.8.4. To fix this, add the following annotation to the Chart.yaml file: Go to the Git repository -> Choose the application -> Edit the deploy-templates/Chart.yaml file. It is necessary to add the following lines to the bottom of the Chart.yaml file: home : https :// github . com / your - repo . git sources : - https :// github . com / your - repo . git maintainers : - name : DEV Team Add a new line character at the end of the last line. Please be aware it is important. Related Articles \u2693\ufe0e Set Up Kiosk IAM Roles for Kaniko Service Accounts Manage Jenkins CI Pipeline Job Provisioner Manage Jenkins CD Pipeline Job Provisioner","title":"Upgrade EDP v.2.7.8 to v.2.8.4"},{"location":"operator-guide/upgrade-edp-2.7.8-to-2.8.4/#upgrade-edp-v278-to-v284","text":"This section provides the details on the EDP upgrade from the v.2.7.8 to the v.2.8.4. Explore the actions and requirements below. Note Kiosk is implemented and mandatory for EDP v.2.8.4 and is optional for EDP v.2.9.0 and higher. To upgrade EDP v.2.7.8 to the v.2.8.4, take the following steps: Deploy and configure Kiosk (create a Service Account, Account, and ClusterRoleBinging) according to the Set Up Kiosk documentation. Update the spec field in the Kiosk space: apiVersion : tenancy . kiosk . sh / v1alpha1 kind : Space metadata : name : < edp - project > spec : account : < edp - project >- admin Create RoleBinding (required for namespaces created before using Kiosk): Note In the uid field under the ownerReferences in the Kubernetes manifest, indicate the Account Custom Resource ID from accounts.config.kiosk.sh kubectl get account <edp-project>-admin -o=custom-columns=NAME:.metadata.uid --no-headers=true View: rolebinding-kiosk.yaml apiVersion : rbac . authorization . k8s . io / v1 kind : RoleBinding metadata : generateName : < edp - project >- admin - namespace : < edp - project > ownerReferences : - apiVersion : config . kiosk . sh / v1alpha1 blockOwnerDeletion : true controller : true kind : Account name : < edp - project >- admin uid : '' roleRef : apiGroup : rbac . authorization . k8s . io kind : ClusterRole name : kiosk - space - admin subjects : - kind : ServiceAccount name : < edp - project > namespace : security kubectl create -f rolebinding-kiosk.yaml With Amazon Elastic Container Registry to store the images, there are two options: Enable IRSA and create AWS IAM Role for Kaniko image builder. Please refer to the IAM Roles for Kaniko Service Accounts section for the details. The Amazon Elastic Container Registry Roles can be stored in an instance profile . Update Custom Resource Definitions by applying all the necessary CRD to the cluster with the command below: kubectl apply -f https://raw.githubusercontent.com/epam/edp-cd-pipeline-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_cdpipeline_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_codebase_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-codebase-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_cd_stage_deploy_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_jenkinsjobbuildrun_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_cdstagejenkinsdeployment_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.8/deploy-templates/crds/v2_v1alpha1_jenkinsjob_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.8/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.8/deploy-templates/crds/v1_v1alpha1_keycloakauthflow_crd.yaml With Amazon Elastic Container Registry to store and Kaniko to build the images, add the kanikoRoleArn parameter to the values before starting the update process. This parameter is indicated in AWS Roles once IRSA is enabled and AWS IAM Role is created for Kaniko. The value should look as follows: kanikoRoleArn : arn : aws : iam ::< AWS_ACCOUNT_ID >: role / AWSIRSA \u2039 CLUSTER_NAME \u203a\u2039 EDP_NAMESPACE \u203a Kaniko To upgrade EDP to the v.2.8.4, run the following command: helm upgrade edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.8.4 Note To verify the installation, it is possible to test the deployment before applying it to the cluster with: helm upgrade edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.8.4 --dry-run Remove the following Kubernetes resources left from the previous EDP installation (it is optional): kubectl delete cm luminatesec-conf -n <edp-namespace> kubectl delete sa edp edp-perf-operator -n <edp-namespace> kubectl delete deployment perf-operator -n <edp-namespace> kubectl delete clusterrole edp-<edp-namespace> edp-perf-operator-<edp-namespace> kubectl delete clusterrolebinding edp-<edp-namespace> edp-perf-operator-<edp-namespace> kubectl delete rolebinding edp-<edp-namespace> edp-perf-operator-<edp-namespace>-admin -n <edp-namespace> kubectl delete perfserver epam-perf -n <edp-namespace> kubectl delete services.v2.edp.epam.com postgres rabbit-mq -n <edp-namespace> Update the CI and CD Jenkins job provisioners: Note Please refer to the Manage Jenkins CI Pipeline Job Provisioner section for the details. View: Default CI provisioner template for EDP 2.8.4 /* Copyright 2021 EPAM Systems. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ import groovy.json.* import jenkins.model.Jenkins import hudson.model.* Jenkins jenkins = Jenkins . instance def stages = [ : ] def jiraIntegrationEnabled = Boolean . parseBoolean ( \"${JIRA_INTEGRATION_ENABLED}\" as String ) def commitValidateStage = jiraIntegrationEnabled ? ' ,{ \"name\" : \"commit-validate\" } ' : '' def createJIMStage = jiraIntegrationEnabled ? ' ,{ \"name\" : \"create-jira-issue-metadata\" } ' : '' def buildTool = \"${BUILD_TOOL}\" def goBuildStage = buildTool . toString () == \"go\" ? ' ,{ \"name\" : \"build\" } ' : ' ,{ \"name\" : \"compile\" } ' stages [ ' Code - review - application ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + goBuildStage + ' ,{ \"name\" : \"tests\" }, [ { \"name\" : \"sonar\" },{ \"name\" : \"dockerfile-lint\" },{ \"name\" : \"helm-lint\" } ]] ' stages [ ' Code - review - library ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"compile\" },{ \"name\" : \"tests\" }, ' + ' { \"name\" : \"sonar\" } ] ' stages [ ' Code - review - autotests ' ] = ' [ { \"name\" : \"gerrit-checkout\" },{ \"name\" : \"get-version\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"tests\" },{ \"name\" : \"sonar\" } ' + \"${createJIMStage}\" + ']' stages [ ' Code - review - default ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ']' stages [ ' Code - review - library - terraform ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"terraform-lint\" } ] ' stages [ ' Code - review - library - opa ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"tests\" } ] ' stages [ ' Code - review - library - codenarc ' ] = ' [ { \"name\" : \"gerrit-checkout\" } ' + \"${commitValidateStage}\" + ' ,{ \"name\" : \"sonar\" },{ \"name\" : \"build\" } ] ' stages [ ' Build - library - maven ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" },{ \"name\" : \"sonar\" },{ \"name\" : \"build\" },{ \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - npm ' ] = stages [ ' Build - library - maven ' ] stages [ ' Build - library - gradle ' ] = stages [ ' Build - library - maven ' ] stages [ ' Build - library - dotnet ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" },{ \"name\" : \"sonar\" },{ \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - python ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" },{ \"name\" : \"sonar\" },{ \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - terraform ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"terraform-lint\" } ' + ' ,{ \"name\" : \"terraform-plan\" },{ \"name\" : \"terraform-apply\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - opa ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" } ' + ' ,{ \"name\" : \"tests\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - library - codenarc ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"sonar\" },{ \"name\" : \"build\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - application - maven ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" }, [ { \"name\" : \"sonar\" } ] ,{ \"name\" : \"build\" },{ \"name\" : \"build-image-kaniko\" }, ' + ' { \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - application - npm ' ] = stages [ ' Build - application - maven ' ] stages [ ' Build - application - gradle ' ] = stages [ ' Build - application - maven ' ] stages [ ' Build - application - dotnet ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" }, [ { \"name\" : \"sonar\" } ] ,{ \"name\" : \"build-image-kaniko\" }, ' + ' { \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - application - go ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"tests\" },{ \"name\" : \"sonar\" }, ' + ' { \"name\" : \"build\" },{ \"name\" : \"build-image-kaniko\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Build - application - python ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"get-version\" },{ \"name\" : \"compile\" }, ' + ' { \"name\" : \"tests\" },{ \"name\" : \"sonar\" }, ' + ' { \"name\" : \"build-image-kaniko\" },{ \"name\" : \"push\" } ' + \"${createJIMStage}\" + ' ,{ \"name\" : \"git-tag\" } ] ' stages [ ' Create - release ' ] = ' [ { \"name\" : \"checkout\" },{ \"name\" : \"create-branch\" },{ \"name\" : \"trigger-job\" } ] ' def defaultBuild = ' [ { \"name\" : \"checkout\" } ' + \"${createJIMStage}\" + ']' def codebaseName = \"${NAME}\" def gitServerCrName = \"${GIT_SERVER_CR_NAME}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID ? GIT_CREDENTIALS_ID : 'gerrit-ciuser-sshkey'}\" def repositoryPath = \"${REPOSITORY_PATH}\" def defaultBranch = \"${DEFAULT_BRANCH}\" def codebaseFolder = jenkins . getItem ( codebaseName ) if ( codebaseFolder == null ) { folder ( codebaseName ) } createListView ( codebaseName , \"Releases\" ) createReleasePipeline ( \"Create-release-${codebaseName}\" , codebaseName , stages [ \"Create-release\" ] , \"create-release.groovy\" , repositoryPath , gitCredentialsId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , defaultBranch ) if ( buildTool . toString (). equalsIgnoreCase ( ' none ' )) { return true } if ( BRANCH ) { def branch = \"${BRANCH}\" def formattedBranch = \"${branch.toUpperCase().replaceAll(/\\\\//, \" - \")}\" createListView ( codebaseName , formattedBranch ) def type = \"${TYPE}\" def crKey = getStageKeyName ( buildTool ) createCiPipeline ( \"Code-review-${codebaseName}\" , codebaseName , stages [ crKey ] , \"code-review.groovy\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) def buildKey = \"Build-${type}-${buildTool.toLowerCase()}\" . toString () if ( type . equalsIgnoreCase ( ' application ' ) || type . equalsIgnoreCase ( ' library ' )) { def jobExists = false if ( \"${formattedBranch}-Build-${codebaseName}\" . toString () in Jenkins . instance . getAllItems (). collect { it . name }) jobExists = true createCiPipeline ( \"Build-${codebaseName}\" , codebaseName , stages . get ( buildKey , defaultBuild ), \"build.groovy\" , repositoryPath , gitCredentialsId , branch , gitServerCrName , gitServerCrVersion ) if ( ! jobExists ) queue ( \"${codebaseName}/${formattedBranch}-Build-${codebaseName}\" ) } } def createCiPipeline ( pipelineName , codebaseName , codebaseStages , pipelineScript , repository , credId , watchBranch , gitServerCrName , gitServerCrVersion ) { pipelineJob ( \"${codebaseName}/${watchBranch.toUpperCase().replaceAll(/\\\\//, \" - \")}-${pipelineName}\" ) { logRotator { numToKeep ( 10 ) daysToKeep ( 7 ) } triggers { gerrit { events { if ( pipelineName . contains ( \"Build\" )) changeMerged () else patchsetCreated () } project ( \"plain:${codebaseName}\" , [ \"plain:${watchBranch}\" ] ) } } definition { cpsScm { scm { git { remote { url ( repository ) credentials ( credId ) } branches ( \"${watchBranch}\" ) scriptPath ( \"${pipelineScript}\" ) } } parameters { stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"Consequence of stages in JSON format to be run during execution\" ) stringParam ( \"GERRIT_PROJECT_NAME\" , \"${codebaseName}\" , \"Gerrit project name(Codebase name) to be build\" ) stringParam ( \"BRANCH\" , \"${watchBranch}\" , \"Branch to build artifact from\" ) } } } } } def getStageKeyName ( buildTool ) { if ( buildTool . toString (). equalsIgnoreCase ( ' terraform ' )) { return \"Code-review-library-terraform\" } if ( buildTool . toString (). equalsIgnoreCase ( ' opa ' )) { return \"Code-review-library-opa\" } if ( buildTool . toString (). equalsIgnoreCase ( ' codenarc ' )) { return \"Code-review-library-codenarc\" } def buildToolsOutOfTheBox = [ \"maven\" , \"npm\" , \"gradle\" , \"dotnet\" , \"none\" , \"go\" , \"python\" ] def supBuildTool = buildToolsOutOfTheBox . contains ( buildTool . toString ()) return supBuildTool ? \"Code-review-${TYPE}\" : \"Code-review-default\" } def createReleasePipeline ( pipelineName , codebaseName , codebaseStages , pipelineScript , repository , credId , gitServerCrName , gitServerCrVersion , jiraIntegrationEnabled , defaultBranch ) { pipelineJob ( \"${codebaseName}/${pipelineName}\" ) { logRotator { numToKeep ( 14 ) daysToKeep ( 30 ) } definition { cpsScm { scm { git { remote { url ( repository ) credentials ( credId ) } branches ( \"${defaultBranch}\" ) scriptPath ( \"${pipelineScript}\" ) } } parameters { stringParam ( \"STAGES\" , \"${codebaseStages}\" , \"\" ) if ( pipelineName . contains ( \"Create-release\" )) { stringParam ( \"JIRA_INTEGRATION_ENABLED\" , \"${jiraIntegrationEnabled}\" , \"Is Jira integration enabled\" ) stringParam ( \"GERRIT_PROJECT\" , \"${codebaseName}\" , \"\" ) stringParam ( \"RELEASE_NAME\" , \"\" , \"Name of the release(branch to be created)\" ) stringParam ( \"COMMIT_ID\" , \"\" , \"Commit ID that will be used to create branch from for new release. If empty, HEAD of master will be used\" ) stringParam ( \"GIT_SERVER_CR_NAME\" , \"${gitServerCrName}\" , \"Name of Git Server CR to generate link to Git server\" ) stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"REPOSITORY_PATH\" , \"${repository}\" , \"Full repository path\" ) stringParam ( \"DEFAULT_BRANCH\" , \"${defaultBranch}\" , \"Default repository branch\" ) } } } } } } def createListView ( codebaseName , branchName ) { listView ( \"${codebaseName}/${branchName}\" ) { if ( branchName . toLowerCase () == \"releases\" ) { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^Create-release.*\" ) } } } else { jobFilters { regex { matchType ( MatchType . INCLUDE_MATCHED ) matchValue ( RegexMatchValue . NAME ) regex ( \"^${branchName}-(Code-review|Build).*\" ) } } } columns { status () weather () name () lastSuccess () lastFailure () lastDuration () buildButton () } } } Note Please refer to the Manage Jenkins CD Pipeline Job Provisioner page for the details. View: Default CD provisioner template for EDP 2.8.4 /* Copyright 2021 EPAM Systems. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ import groovy.json.* import jenkins.model.Jenkins Jenkins jenkins = Jenkins . instance def pipelineName = \"${PIPELINE_NAME}-cd-pipeline\" def stageName = \"${STAGE_NAME}\" def qgStages = \"${QG_STAGES}\" def gitServerCrVersion = \"${GIT_SERVER_CR_VERSION}\" def gitCredentialsId = \"${GIT_CREDENTIALS_ID}\" def sourceType = \"${SOURCE_TYPE}\" def libraryURL = \"${LIBRARY_URL}\" def libraryBranch = \"${LIBRARY_BRANCH}\" def autodeploy = \"${AUTODEPLOY}\" def scriptPath = \"Jenkinsfile\" def containerDeploymentType = \"container\" def deploymentType = \"${DEPLOYMENT_TYPE}\" def stages = buildStages ( deploymentType , containerDeploymentType , qgStages ) def codebaseFolder = jenkins . getItem ( pipelineName ) if ( codebaseFolder == null ) { folder ( pipelineName ) } if ( deploymentType == containerDeploymentType ) { createContainerizedCdPipeline ( pipelineName , stageName , stages , scriptPath , sourceType , libraryURL , libraryBranch , gitCredentialsId , gitServerCrVersion , autodeploy ) } else { createCustomCdPipeline ( pipelineName , stageName ) } def buildStages ( deploymentType , containerDeploymentType , qgStages ) { return deploymentType == containerDeploymentType ? ' [ { \"name\" : \"init\" , \"step_name\" : \"init\" },{ \"name\" : \"deploy\" , \"step_name\" : \"deploy\" }, ' + qgStages + ' ,{ \"name\" : \"promote-images-ecr\" , \"step_name\" : \"promote-images\" } ] ' : '' } def createContainerizedCdPipeline ( pipelineName , stageName , stages , pipelineScript , sourceType , libraryURL , libraryBranch , libraryCredId , gitServerCrVersion , autodeploy ) { pipelineJob ( \"${pipelineName}/${stageName}\" ) { if ( sourceType == \"library\" ) { definition { cpsScm { scm { git { remote { url ( libraryURL ) credentials ( libraryCredId ) } branches ( \"${libraryBranch}\" ) scriptPath ( \"${pipelineScript}\" ) } } } } } else { definition { cps { script ( \"@Library(['edp-library-stages', 'edp-library-pipelines']) _ \\n\\nDeploy()\" ) sandbox ( true ) } } } properties { disableConcurrentBuilds () } parameters { stringParam ( \"GIT_SERVER_CR_VERSION\" , \"${gitServerCrVersion}\" , \"Version of GitServer CR Resource\" ) stringParam ( \"STAGES\" , \"${stages}\" , \"Consequence of stages in JSON format to be run during execution\" ) if ( autodeploy ? . trim () && autodeploy . toBoolean ()) { stringParam ( \"AUTODEPLOY\" , \"${autodeploy}\" , \"Is autodeploy enabled?\" ) stringParam ( \"CODEBASE_VERSION\" , null , \"Codebase versions to deploy.\" ) } } } } def createCustomCdPipeline ( pipelineName , stageName ) { pipelineJob ( \"${pipelineName}/${stageName}\" ) { properties { disableConcurrentBuilds () } } } It is also necessary to add the string parameter DEPLOYMENT_TYPE to the CD provisioner: Go to job-provisions - > cd -> default -> configure ; Add Parameter - > String parameter ; Name -> DEPLOYMENT_TYPE Update Jenkins pipelines and stages to the new release tag: In Jenkins, go to Manage Jenkins -> Configure system -> Find the Global Pipeline Libraries menu. Change the Default version for edp-library-stages from build/2.8.0-RC.6 to build/2.9.0-RC.5 Change the Default version for edp-library-pipelines from build/2.8.0-RC.4 to build/2.9.0-RC.3 Update the edp-admin-console Custom Resource in the KeycloakClient Custom Resource Definition: View: keycloakclient.yaml kind : KeycloakClient apiVersion : v1.edp.epam.com/v1alpha1 metadata : name : edp-admin-console namespace : <edp-namespace> spec : advancedProtocolMappers : false attributes : null audRequired : true clientId : admin-console-client directAccess : true public : false secret : admin-console-client serviceAccount : enabled : true realmRoles : - developer targetRealm : <keycloak-edp-realm> webUrl : >- https://edp-admin-console-example.com kubectl apply -f keycloakclient.yaml Remove the admin-console-client client ID in the edp-namespace-main realm in Keycloak, restart the keycloak-operator pod and check that the new KeycloakClient is created with the confidential access type. Note If \"Internal error\" occurs, regenerate the admin-console-client secret in the Credentials tab in Keycloak and update the admin-console-client secret key \"clientSecret\" and \"password\". Update image versions for the Jenkins agents in the ConfigMap : kubectl edit configmap jenkins-slaves -n <edp-namespace> The versions of the images should be: epamedp / edp - jenkins - dotnet - 21 - agent : 1.0.2 epamedp / edp - jenkins - dotnet - 31 - agent : 1.0.2 epamedp / edp - jenkins - go - agent : 1.0.3 epamedp / edp - jenkins - gradle - java11 - agent : 2.0.2 epamedp / edp - jenkins - gradle - java8 - agent : 1.0.2 epamedp / edp - jenkins - helm - agent : 1.0.6 epamedp / edp - jenkins - maven - java11 - agent : 2.0.3 epamedp / edp - jenkins - maven - java8 - agent : 1.0.2 epamedp / edp - jenkins - npm - agent : 2.0.2 epamedp / edp - jenkins - python - 38 - agent : 2.0.3 epamedp / edp - jenkins - terraform - agent : 2.0.4 Add new Jenkins agents under the data field: View data : codenarc-template : |- <org.csanchez.jenkins.plugins.kubernetes.PodTemplate> <inheritFrom></inheritFrom> <name>codenarc</name> <namespace></namespace> <privileged>false</privileged> <alwaysPullImage>false</alwaysPullImage> <instanceCap>2147483647</instanceCap> <slaveConnectTimeout>100</slaveConnectTimeout> <idleMinutes>5</idleMinutes> <activeDeadlineSeconds>0</activeDeadlineSeconds> <label>codenarc</label> <serviceAccount>jenkins</serviceAccount> <nodeSelector>beta.kubernetes.io/os=linux</nodeSelector> <nodeUsageMode>NORMAL</nodeUsageMode> <workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"> <memory>false</memory> </workspaceVolume> <volumes/> <containers> <org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> <name>jnlp</name> <image>epamedp/edp-jenkins-codenarc-agent:1.0.0</image> <privileged>false</privileged> <alwaysPullImage>false</alwaysPullImage> <workingDir>/tmp</workingDir> <command></command> <args>${computer.jnlpmac} ${computer.name}</args> <ttyEnabled>false</ttyEnabled> <resourceRequestCpu></resourceRequestCpu> <resourceRequestMemory></resourceRequestMemory> <resourceLimitCpu></resourceLimitCpu> <resourceLimitMemory></resourceLimitMemory> <envVars> <org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> <key>JAVA_TOOL_OPTIONS</key> <value>-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true</value> </org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> </envVars> <ports/> </org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> </containers> <envVars/> <annotations/> <imagePullSecrets/> <podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/> </org.csanchez.jenkins.plugins.kubernetes.PodTemplate> opa-template : |- <org.csanchez.jenkins.plugins.kubernetes.PodTemplate> <inheritFrom></inheritFrom> <name>opa</name> <namespace></namespace> <privileged>false</privileged> <alwaysPullImage>false</alwaysPullImage> <instanceCap>2147483647</instanceCap> <slaveConnectTimeout>100</slaveConnectTimeout> <idleMinutes>5</idleMinutes> <activeDeadlineSeconds>0</activeDeadlineSeconds> <label>opa</label> <serviceAccount>jenkins</serviceAccount> <nodeSelector>beta.kubernetes.io/os=linux</nodeSelector> <nodeUsageMode>NORMAL</nodeUsageMode> <workspaceVolume class=\"org.csanchez.jenkins.plugins.kubernetes.volumes.workspace.EmptyDirWorkspaceVolume\"> <memory>false</memory> </workspaceVolume> <volumes/> <containers> <org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> <name>jnlp</name> <image>epamedp/edp-jenkins-opa-agent:1.0.1</image> <privileged>false</privileged> <alwaysPullImage>false</alwaysPullImage> <workingDir>/tmp</workingDir> <command></command> <args>${computer.jnlpmac} ${computer.name}</args> <ttyEnabled>false</ttyEnabled> <resourceRequestCpu></resourceRequestCpu> <resourceRequestMemory></resourceRequestMemory> <resourceLimitCpu></resourceLimitCpu> <resourceLimitMemory></resourceLimitMemory> <envVars> <org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> <key>JAVA_TOOL_OPTIONS</key> <value>-XX:+UnlockExperimentalVMOptions -Dsun.zip.disableMemoryMapping=true</value> </org.csanchez.jenkins.plugins.kubernetes.model.KeyValueEnvVar> </envVars> <ports/> </org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate> </containers> <envVars/> <annotations/> <imagePullSecrets/> <podRetention class=\"org.csanchez.jenkins.plugins.kubernetes.pod.retention.Default\"/> </org.csanchez.jenkins.plugins.kubernetes.PodTemplate> Restart the Jenkins pod. Update compatible plugins in Jenkins and install additional plugins: Go to Manage Jenkins -> Manage Plugins -> Select Compatible -> Click Download now and install after restart Install the following additional plugins (click the Available plugins tab in Jenkins): Groovy Postbuild CloudBees AWS Credentials Badge Timestamper Add the annotation deploy.edp.epam.com/previous-stage-name: '' (it should be empty if the CD pipeline contains one stage) to each Custom Resource in the Custom Resource Definition Stage , for example: List all Custom Resources in Stage : kubectl get stages.v2.edp.epam.com -n <edp-namespace> Edit resources: kubectl edit stages.v2.edp.epam.com <cd-stage-name> -n <edp-namespace> apiVersion : v2 . edp . epam . com / v1alpha1 kind : Stage metadata : annotations : deploy . edp . epam . com / previous - stage - name : '' Note If a pipeline contains several stages, add a previous stage name indicated in the EDP Admin Console to the annotation, for example: deploy.edp.epam.com/previous-stage-name: 'dev' . Execute script to align CDPipeline resources to the new API ( jq command-line JSON processor is required): pipelines = $ ( kubectl get cdpipelines - n < edp - namespace > - ojson | jq - c ' .items[] ' ) for p in $ pipelines ; do echo \" $p \" | \\ jq ' . | .spec.inputDockerStreams = .spec.input_docker_streams | del(.spec.input_docker_streams) | .spec += { \"deploymentType\": \"container\" } ' | \\ kubectl apply - f - done Update the database in the edp-db pod in the edp-namespace: Log in to the pod: kubectl exec - i - t - n < edp - namespace > edp - db -< pod > - c edp - db \" -- \" sh - c \" (bash || ash || sh) \" Log in to the Postgress DB (where \"admin\" is the user the secret was created for): psql edp-db <admin>; SET search_path to '<edp-namespace>'; UPDATE cd_pipeline SET deployment_type = 'container'; Add \"AUTODEPLOY\":\"true/false\",\"DEPLOYMENT_TYPE\":\"container\" to every Custom Resource in jenkinsjobs.v2.edp.epam.com : Edit Kubernetes resources: kubectl get jenkinsjobs.v2.edp.epam.com -n <edp-namespace> kubectl edit jenkinsjobs.v2.edp.epam.com <cd-pipeline-name> -n <edp-namespace> Alternatively, use this script to update all the necessary jenkinsjobs Custom Resources: edp_namespace =< epd_namespace > for stages in $ ( kubectl get jenkinsjobs - o = name - n $ed p_namespace ) ; do kubectl get $stages -n $edp_namespace -o yaml | grep -q \"container\" && echo -e \"\\n$stages is already updated\" || kubectl get $stages -n $edp_namespace -o yaml | sed 's/\"GIT_SERVER_CR_VERSION\"/\"AUTODEPLOY\":\"false\",\"DEPLOYMENT_TYPE\":\"container\",\"GIT_SERVER_CR_VERSION\"/g' | kubectl apply -f -; done Make sure the edited resource looks as follows: job : config : '{\"AUTODEPLOY\":\"false\",\"DEPLOYMENT_TYPE\":\"container\",\"GIT_SERVER_CR_VERSION\":\"v2\",\"PIPELINE_NAME\":\"your-pipeline-name\",\"QG_STAGES\":\"{\\\"name\\\":\\\"manual\\\",\\\"step_name\\\":\\\"your-step-name\\\"}\",\"SOURCE_TYPE\":\"default\",\"STAGE_NAME\":\"your-stage-name\"}' name : job - provisions /job/cd/job/ default Restart the Jenkins operator pod and wait until the CD job provisioner in Jenkins creates the updated pipelines.","title":"Upgrade EDP v.2.7.8 to v.2.8.4"},{"location":"operator-guide/upgrade-edp-2.7.8-to-2.8.4/#possible-issues","text":"SonarQube fails during the CI pipeline run. The previous builds of SonarQube used the latest version of the OpenID Connect Authentication for SonarQube plugin. Version 2.1.0 of this plugin may have issues with the connection, so it is necessary to downgrade it in order to get rid of errors in the pipeline. Take the following steps: Log in to the Sonar pod: kubectl exec - i - t - n < edp - namespace > sonar -< pod > - c sonar \" -- \" sh - c \" (bash || ash || sh) \" Run the command in the Sonar container: rm extensions/plugins/sonar-auth-oidc-plugin* Install the OpenID Connect Authentication for SonarQube plugin v2.0.0: curl - L https : // github . com / vaulttec / sonar - auth - oidc / releases / download / v2 . 0.0 / sonar - auth - oidc - plugin - 2.0 . 0.j ar -- output extensions / plugins / sonar - auth - oidc - plugin - 2.0 . 0.j ar Restart the SonarQube pod; The Helm lint checker in EDP 2.8.4 has some additional rules. There can be issues with it during the Code Review pipeline in Jenkins for applications that were transferred from previous EDP versions to EDP 2.8.4. To fix this, add the following annotation to the Chart.yaml file: Go to the Git repository -> Choose the application -> Edit the deploy-templates/Chart.yaml file. It is necessary to add the following lines to the bottom of the Chart.yaml file: home : https :// github . com / your - repo . git sources : - https :// github . com / your - repo . git maintainers : - name : DEV Team Add a new line character at the end of the last line. Please be aware it is important.","title":"Possible Issues"},{"location":"operator-guide/upgrade-edp-2.7.8-to-2.8.4/#related-articles","text":"Set Up Kiosk IAM Roles for Kaniko Service Accounts Manage Jenkins CI Pipeline Job Provisioner Manage Jenkins CD Pipeline Job Provisioner","title":"Related Articles"},{"location":"operator-guide/upgrade-edp-2.8.4-to-2.9.0/","text":"Upgrade EDP v.2.8.4 to v.2.9.0 \u2693\ufe0e This section provides the details on the EDP upgrade from the v.2.8.4 to the v.2.9.0. Explore the actions and requirements below. Note Kiosk is optional for EDP v.2.9.0 and higher, and enabled by default. To disable it, add the following parameter to the values.yaml file: kioskEnabled: false . Please refer to the Set Up Kiosk documentation for the details. With Amazon Elastic Container Registry to store the images, there are two options: Enable IRSA and create AWS IAM Role for Kaniko image builder. Please refer to the IAM Roles for Kaniko Service Accounts section for the details. The Amazon Elastic Container Registry Roles can be stored in an instance profile . Before updating EDP from v.2.8.4 to v.2.9.0, update the gerrit-is-credentials secret by adding the new clientSecret key with the value from gerrit-is-credentials.client_secret : kubectl edit secret gerrit-is-credentials -n <edp-namespace> Make sure it looks as follows (replace with the necessary key value): data : client_secret : example clientSecret : example Update Custom Resource Definitions. This command will apply all the necessary CRDs to the cluster: kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritgroupmember_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritgroup_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritprojectaccess_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritproject_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkins_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsagent_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsauthorizationrolemapping_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsauthorizationrole_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.9/deploy-templates/crds/v1_v1alpha1_keycloakclientscope_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.9/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.9/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml With Amazon Elastic Container Registry to store and Kaniko to build the images, add the kanikoRoleArn parameter to the values before starting the update process. This parameter is indicated in AWS Roles once IRSA is enabled and AWS IAM Role is created for Kaniko.The value should look as follows: kanikoRoleArn : arn : aws : iam ::< AWS_ACCOUNT_ID >: role / AWSIRSA \u2039 CLUSTER_NAME \u203a\u2039 EDP_NAMESPACE \u203a Kaniko To upgrade EDP to the v.2.9.0, run the following command: helm upgrade --install edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.9.0 Note To verify the installation, it is possible to test the deployment before applying it to the cluster with: helm upgrade --install edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.9.0 --dry-run Remove the following Kubernetes resources left from the previous EDP installation (it is optional): kubectl delete rolebinding edp-cd-pipeline-operator-<edp-namespace>-admin -n <edp-namespace> After EDP update, please restart the 'sonar-operator' pod to address the proper Sonar plugin versioning. After 'sonar-operator' is restarted, check the list of installed plugins in the corresponding SonarQube menu. Update Jenkins pipelines and stages to the new release tag: Restart the Jenkins pod In Jenkins, go to Manage Jenkins -> Configure system -> Find the Global Pipeline Libraries menu Make sure that the Default version for edp-library-stages is build/2.10.0-RC.1 Make sure that the Default version for edp-library-pipelines is build/2.10.0-RC.1 Update image versions for the Jenkins agents in the ConfigMap : kubectl edit configmap jenkins-slaves -n <edp-namespace> The versions of the images should be: epamedp / edp - jenkins - codenarc - agent : 1.0.1 epamedp / edp - jenkins - dotnet - 21 - agent : 1.0.3 epamedp / edp - jenkins - dotnet - 31 - agent : 1.0.3 epamedp / edp - jenkins - go - agent : 1.0.4 epamedp / edp - jenkins - gradle - java8 - agent : 1.0.3 epamedp / edp - jenkins - gradle - java11 - agent : 2.0.3 epamedp / edp - jenkins - helm - agent : 1.0.7 epamedp / edp - jenkins - maven - java8 - agent : 1.0.3 epamedp / edp - jenkins - maven - java11 - agent : 2.0.4 epamedp / edp - jenkins - npm - agent : 2.0.3 epamedp / edp - jenkins - opa - agent : 1.0.2 epamedp / edp - jenkins - python - 38 - agent : 2.0.4 epamedp / edp - jenkins - terraform - agent : 2.0.5 Restart the Jenkins pod. Update the compatible plugins in Jenkins: Go to Manage Jenkins -> Manage Plugins -> Select Compatible -> Click Download now and install after restart Related Articles \u2693\ufe0e Set Up Kiosk IAM Roles for Kaniko Service Accounts","title":"Upgrade EDP v.2.8.4 to v.2.9.0"},{"location":"operator-guide/upgrade-edp-2.8.4-to-2.9.0/#upgrade-edp-v284-to-v290","text":"This section provides the details on the EDP upgrade from the v.2.8.4 to the v.2.9.0. Explore the actions and requirements below. Note Kiosk is optional for EDP v.2.9.0 and higher, and enabled by default. To disable it, add the following parameter to the values.yaml file: kioskEnabled: false . Please refer to the Set Up Kiosk documentation for the details. With Amazon Elastic Container Registry to store the images, there are two options: Enable IRSA and create AWS IAM Role for Kaniko image builder. Please refer to the IAM Roles for Kaniko Service Accounts section for the details. The Amazon Elastic Container Registry Roles can be stored in an instance profile . Before updating EDP from v.2.8.4 to v.2.9.0, update the gerrit-is-credentials secret by adding the new clientSecret key with the value from gerrit-is-credentials.client_secret : kubectl edit secret gerrit-is-credentials -n <edp-namespace> Make sure it looks as follows (replace with the necessary key value): data : client_secret : example clientSecret : example Update Custom Resource Definitions. This command will apply all the necessary CRDs to the cluster: kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritgroupmember_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritgroup_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritprojectaccess_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-gerrit-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_gerritproject_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkins_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsagent_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsauthorizationrolemapping_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.9/deploy-templates/crds/v2_v1alpha1_jenkinsauthorizationrole_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.9/deploy-templates/crds/v1_v1alpha1_keycloakclientscope_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.9/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.9/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml With Amazon Elastic Container Registry to store and Kaniko to build the images, add the kanikoRoleArn parameter to the values before starting the update process. This parameter is indicated in AWS Roles once IRSA is enabled and AWS IAM Role is created for Kaniko.The value should look as follows: kanikoRoleArn : arn : aws : iam ::< AWS_ACCOUNT_ID >: role / AWSIRSA \u2039 CLUSTER_NAME \u203a\u2039 EDP_NAMESPACE \u203a Kaniko To upgrade EDP to the v.2.9.0, run the following command: helm upgrade --install edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.9.0 Note To verify the installation, it is possible to test the deployment before applying it to the cluster with: helm upgrade --install edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.9.0 --dry-run Remove the following Kubernetes resources left from the previous EDP installation (it is optional): kubectl delete rolebinding edp-cd-pipeline-operator-<edp-namespace>-admin -n <edp-namespace> After EDP update, please restart the 'sonar-operator' pod to address the proper Sonar plugin versioning. After 'sonar-operator' is restarted, check the list of installed plugins in the corresponding SonarQube menu. Update Jenkins pipelines and stages to the new release tag: Restart the Jenkins pod In Jenkins, go to Manage Jenkins -> Configure system -> Find the Global Pipeline Libraries menu Make sure that the Default version for edp-library-stages is build/2.10.0-RC.1 Make sure that the Default version for edp-library-pipelines is build/2.10.0-RC.1 Update image versions for the Jenkins agents in the ConfigMap : kubectl edit configmap jenkins-slaves -n <edp-namespace> The versions of the images should be: epamedp / edp - jenkins - codenarc - agent : 1.0.1 epamedp / edp - jenkins - dotnet - 21 - agent : 1.0.3 epamedp / edp - jenkins - dotnet - 31 - agent : 1.0.3 epamedp / edp - jenkins - go - agent : 1.0.4 epamedp / edp - jenkins - gradle - java8 - agent : 1.0.3 epamedp / edp - jenkins - gradle - java11 - agent : 2.0.3 epamedp / edp - jenkins - helm - agent : 1.0.7 epamedp / edp - jenkins - maven - java8 - agent : 1.0.3 epamedp / edp - jenkins - maven - java11 - agent : 2.0.4 epamedp / edp - jenkins - npm - agent : 2.0.3 epamedp / edp - jenkins - opa - agent : 1.0.2 epamedp / edp - jenkins - python - 38 - agent : 2.0.4 epamedp / edp - jenkins - terraform - agent : 2.0.5 Restart the Jenkins pod. Update the compatible plugins in Jenkins: Go to Manage Jenkins -> Manage Plugins -> Select Compatible -> Click Download now and install after restart","title":"Upgrade EDP v.2.8.4 to v.2.9.0"},{"location":"operator-guide/upgrade-edp-2.8.4-to-2.9.0/#related-articles","text":"Set Up Kiosk IAM Roles for Kaniko Service Accounts","title":"Related Articles"},{"location":"operator-guide/upgrade-edp-2.9.0-to-2.10.1/","text":"Upgrade EDP v.2.9.0 to v.2.10.1 \u2693\ufe0e This section provides the details on the EDP upgrade from the v.2.9.0 to the v.2.10.1. Explore the actions and requirements below. Note Kiosk is optional for EDP v.2.9.0 and higher, and is enabled by default. To disable it, add the following parameter to the values.yaml file: global.kioskEnabled: false . Please refer to the Set Up Kiosk documentation for the details. Note In the process of updating the EDP, it is necessary to migrate the database for SonarQube, before performing the update procedure, please carefully read section 4 of this guide. Before updating EDP from v.2.9.0 to v.2.10.1, delete SonarQube plugins by executing the following command in SonarQube pod: rm -r /opt/sonarqube/extensions/plugins/* Update Custom Resource Definitions. Run the following command to apply all the necessary CRDs to the cluster: kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.10/deploy-templates/crds/v2_v1alpha1_jenkins_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakclient_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmcomponent_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmidentityprovider_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmrole_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloak_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.10/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml To upgrade EDP to the v.2.10.1, run the following command: helm upgrade edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.10.1 Note To verify the installation, it is possible to test the deployment before applying it to the cluster with: helm upgrade edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.10.1 --dry-run Migrate the database for SonarQube according to the official documentation . Note Please be aware of possible tables duplication for speeding up the migration process during the upgrade. Due to the duplication, the database disk usage can be temporarily increased to twice as the normal usage. Therefore, the recommended database disk usage is below 50% before the migration start. Navigate to the project http://SonarQubeServerURL/setup link and follow the setup instructions: Click the Upgrade button and wait for the end of the migration process. Remove the resources related to the deprecated Sonar Gerrit Plugin that is deleted in EDP 2.10.1: Remove Sonar Gerrit Plugin from Jenkins(go to Manage Jenkins -> Manage Plugins -> Installed -> Uninstall Sonar Gerrit Plugin ). In Gerrit, edit the project.config file in All-Project view and remove the Sonar-Verified label declaration: [label \"Sonar-Verified\"] function = MaxWithBlock value = -1 Issues found value = 0 No score value = +1 Verified defaultValue = 0 Save the project.config file. In Gerrit, edit the project.config file in All-Project view and remove the permissions for the Sonar-Verified label: label-Sonar-Verified = -1..+1 group Administrators label-Sonar-Verified = -1..+1 group Project Owners label-Sonar-Verified = -1..+1 group Service Users Save the project.config file. Update image versions for the Jenkins agents in the ConfigMap : kubectl edit configmap jenkins-slaves -n <edp-namespace> The versions of the images should be: epamedp / edp - jenkins - codenarc - agent : 1.0.1 epamedp / edp - jenkins - dotnet - 21 - agent : 1.0.5 epamedp / edp - jenkins - dotnet - 31 - agent : 1.0.4 epamedp / edp - jenkins - go - agent : 1.0.4 epamedp / edp - jenkins - gradle - java8 - agent : 1.0.3 epamedp / edp - jenkins - gradle - java11 - agent : 2.0.3 epamedp / edp - jenkins - helm - agent : 1.0.7 epamedp / edp - jenkins - maven - java8 - agent : 1.0.3 epamedp / edp - jenkins - maven - java11 - agent : 2.0.4 epamedp / edp - jenkins - npm - agent : 2.0.3 epamedp / edp - jenkins - opa - agent : 1.0.2 epamedp / edp - jenkins - python - 38 - agent : 2.0.4 epamedp / edp - jenkins - terraform - agent : 2.0.5 Restart the Jenkins pod. Since EDP version v.2.10.x, the create-release.groovy, code-review.groovy, and build.groovy files are deprecated ( pipeline script from SCM is replaced with pipeline script , see below). Pipeline script from SCM: Pipeline script: Update the job-provisioner code and restart the codebase-operator pod. Consult the default job-provisioners code section. Related Articles \u2693\ufe0e Manage Jenkins CI Pipeline Job Provisioner Set Up Kiosk SonarQube Upgrade Guide","title":"Upgrade EDP v.2.9.0 to v.2.10.1"},{"location":"operator-guide/upgrade-edp-2.9.0-to-2.10.1/#upgrade-edp-v290-to-v2101","text":"This section provides the details on the EDP upgrade from the v.2.9.0 to the v.2.10.1. Explore the actions and requirements below. Note Kiosk is optional for EDP v.2.9.0 and higher, and is enabled by default. To disable it, add the following parameter to the values.yaml file: global.kioskEnabled: false . Please refer to the Set Up Kiosk documentation for the details. Note In the process of updating the EDP, it is necessary to migrate the database for SonarQube, before performing the update procedure, please carefully read section 4 of this guide. Before updating EDP from v.2.9.0 to v.2.10.1, delete SonarQube plugins by executing the following command in SonarQube pod: rm -r /opt/sonarqube/extensions/plugins/* Update Custom Resource Definitions. Run the following command to apply all the necessary CRDs to the cluster: kubectl apply -f https://raw.githubusercontent.com/epam/edp-jenkins-operator/release/2.10/deploy-templates/crds/v2_v1alpha1_jenkins_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakclient_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmcomponent_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmidentityprovider_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmrole_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloakrealmuser_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-keycloak-operator/release/1.10/deploy-templates/crds/v1_v1alpha1_keycloak_crd.yaml kubectl apply -f https://raw.githubusercontent.com/epam/edp-nexus-operator/release/2.10/deploy-templates/crds/edp_v1alpha1_nexus_crd.yaml To upgrade EDP to the v.2.10.1, run the following command: helm upgrade edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.10.1 Note To verify the installation, it is possible to test the deployment before applying it to the cluster with: helm upgrade edp epamedp/edp-install -n <edp-namespace> --values values.yaml --version=2.10.1 --dry-run Migrate the database for SonarQube according to the official documentation . Note Please be aware of possible tables duplication for speeding up the migration process during the upgrade. Due to the duplication, the database disk usage can be temporarily increased to twice as the normal usage. Therefore, the recommended database disk usage is below 50% before the migration start. Navigate to the project http://SonarQubeServerURL/setup link and follow the setup instructions: Click the Upgrade button and wait for the end of the migration process. Remove the resources related to the deprecated Sonar Gerrit Plugin that is deleted in EDP 2.10.1: Remove Sonar Gerrit Plugin from Jenkins(go to Manage Jenkins -> Manage Plugins -> Installed -> Uninstall Sonar Gerrit Plugin ). In Gerrit, edit the project.config file in All-Project view and remove the Sonar-Verified label declaration: [label \"Sonar-Verified\"] function = MaxWithBlock value = -1 Issues found value = 0 No score value = +1 Verified defaultValue = 0 Save the project.config file. In Gerrit, edit the project.config file in All-Project view and remove the permissions for the Sonar-Verified label: label-Sonar-Verified = -1..+1 group Administrators label-Sonar-Verified = -1..+1 group Project Owners label-Sonar-Verified = -1..+1 group Service Users Save the project.config file. Update image versions for the Jenkins agents in the ConfigMap : kubectl edit configmap jenkins-slaves -n <edp-namespace> The versions of the images should be: epamedp / edp - jenkins - codenarc - agent : 1.0.1 epamedp / edp - jenkins - dotnet - 21 - agent : 1.0.5 epamedp / edp - jenkins - dotnet - 31 - agent : 1.0.4 epamedp / edp - jenkins - go - agent : 1.0.4 epamedp / edp - jenkins - gradle - java8 - agent : 1.0.3 epamedp / edp - jenkins - gradle - java11 - agent : 2.0.3 epamedp / edp - jenkins - helm - agent : 1.0.7 epamedp / edp - jenkins - maven - java8 - agent : 1.0.3 epamedp / edp - jenkins - maven - java11 - agent : 2.0.4 epamedp / edp - jenkins - npm - agent : 2.0.3 epamedp / edp - jenkins - opa - agent : 1.0.2 epamedp / edp - jenkins - python - 38 - agent : 2.0.4 epamedp / edp - jenkins - terraform - agent : 2.0.5 Restart the Jenkins pod. Since EDP version v.2.10.x, the create-release.groovy, code-review.groovy, and build.groovy files are deprecated ( pipeline script from SCM is replaced with pipeline script , see below). Pipeline script from SCM: Pipeline script: Update the job-provisioner code and restart the codebase-operator pod. Consult the default job-provisioners code section.","title":"Upgrade EDP v.2.9.0 to v.2.10.1"},{"location":"operator-guide/upgrade-edp-2.9.0-to-2.10.1/#related-articles","text":"Manage Jenkins CI Pipeline Job Provisioner Set Up Kiosk SonarQube Upgrade Guide","title":"Related Articles"},{"location":"operator-guide/velero-irsa/","text":"IAM Roles for Velero Service Accounts \u2693\ufe0e Note Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation. Velero AWS plugin requires access to AWS resources. Follow the steps below to create a required role: Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero_policy\": { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"ec2:DescribeVolumes\" , \"ec2:DescribeSnapshots\" , \"ec2:CreateTags\" , \"ec2:CreateVolume\" , \"ec2:CreateSnapshot\" , \"ec2:DeleteSnapshot\" ], \"Resource\" : \"*\" }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"s3:GetObject\" , \"s3:DeleteObject\" , \"s3:PutObject\" , \"s3:AbortMultipartUpload\" , \"s3:ListMultipartUploadParts\" ], \"Resource\" : [ \"arn:aws:s3:::velero-*/*\" ] }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"s3:ListBucket\" ], \"Resource\" : [ \"arn:aws:s3:::velero-*\" ] } ] } Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" with trust relationships: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/<OIDC_PROVIDER>\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"<OIDC_PROVIDER>:sub\": \"system:serviceaccount:<VELERO_NAMESPACE>:edp-velero\" } } } ] } Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" role. Make sure that Amazon S3 bucket with name velero-\u2039CLUSTER_NAME\u203a exists. Provide key value eks.amazonaws.com/role-arn: \"arn:aws:iam:: :role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" into the serviceAccount.server.annotations parameter in values.yaml during the Velero Installation . Related Articles \u2693\ufe0e Associate IAM Roles With Service Accounts Install Velero","title":"IAM Roles for Velero Service Accounts"},{"location":"operator-guide/velero-irsa/#iam-roles-for-velero-service-accounts","text":"Note Make sure that IRSA is enabled and amazon-eks-pod-identity-webhook is deployed according to the Associate IAM Roles With Service Accounts documentation. Velero AWS plugin requires access to AWS resources. Follow the steps below to create a required role: Create AWS IAM Policy \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero_policy\": { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"ec2:DescribeVolumes\" , \"ec2:DescribeSnapshots\" , \"ec2:CreateTags\" , \"ec2:CreateVolume\" , \"ec2:CreateSnapshot\" , \"ec2:DeleteSnapshot\" ], \"Resource\" : \"*\" }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"s3:GetObject\" , \"s3:DeleteObject\" , \"s3:PutObject\" , \"s3:AbortMultipartUpload\" , \"s3:ListMultipartUploadParts\" ], \"Resource\" : [ \"arn:aws:s3:::velero-*/*\" ] }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"s3:ListBucket\" ], \"Resource\" : [ \"arn:aws:s3:::velero-*\" ] } ] } Create AWS IAM Role \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" with trust relationships: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/<OIDC_PROVIDER>\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"<OIDC_PROVIDER>:sub\": \"system:serviceaccount:<VELERO_NAMESPACE>:edp-velero\" } } } ] } Attach the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero_policy\" policy to the \"AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" role. Make sure that Amazon S3 bucket with name velero-\u2039CLUSTER_NAME\u203a exists. Provide key value eks.amazonaws.com/role-arn: \"arn:aws:iam:: :role/AWSIRSA\u2039CLUSTER_NAME\u203a\u2039VELERO_NAMESPACE\u203aVelero\" into the serviceAccount.server.annotations parameter in values.yaml during the Velero Installation .","title":"IAM Roles for Velero Service Accounts"},{"location":"operator-guide/velero-irsa/#related-articles","text":"Associate IAM Roles With Service Accounts Install Velero","title":"Related Articles"},{"location":"use-cases/","text":"Overview \u2693\ufe0e The Use Cases section provides useful recommendations of how to operate with the EPAM Delivery Platform tools and manage the custom resources. Get acquainted with the description of technical scenarios and solutions. Autotest as Quality Gate Promote Application in CD Pipeline","title":"Overview"},{"location":"use-cases/#overview","text":"The Use Cases section provides useful recommendations of how to operate with the EPAM Delivery Platform tools and manage the custom resources. Get acquainted with the description of technical scenarios and solutions. Autotest as Quality Gate Promote Application in CD Pipeline","title":"Overview"},{"location":"use-cases/autotest-as-quality-gate/","text":"Autotest as a Quality Gate \u2693\ufe0e This use case describes the flow of adding an autotest as a quality gate to a newly created CD pipeline with a selected build version of an application to be promoted. Make sure an application is created. Please refer to the Add Application section for details. Create an autotest with the necessary parameters. Please refer to the Add Autotest section for details. Create a CD pipeline where the necessary application build version will be promoted and the autotest will be used as a quality gate. Please refer to the Add CD Pipeline section for details. In the Application menu, select the application to be promoted in the CD pipeline. In the Stages menu, add the necessary stage and indicate the Autotests quality gate. Note Please be aware that once created, the CD pipeline remains with the chosen quality gate type without possibility to edit it. Info To trigger the CD pipeline, first, make sure that all applications have passed the Build pipelines and autotests have passed the single Code Review pipelines. Navigate to Jenkins to see the autotest logs and Allure report. Related Articles \u2693\ufe0e Add Application Add Autotest Add CD Pipeline","title":"Autotest as Quality Gate"},{"location":"use-cases/autotest-as-quality-gate/#autotest-as-a-quality-gate","text":"This use case describes the flow of adding an autotest as a quality gate to a newly created CD pipeline with a selected build version of an application to be promoted. Make sure an application is created. Please refer to the Add Application section for details. Create an autotest with the necessary parameters. Please refer to the Add Autotest section for details. Create a CD pipeline where the necessary application build version will be promoted and the autotest will be used as a quality gate. Please refer to the Add CD Pipeline section for details. In the Application menu, select the application to be promoted in the CD pipeline. In the Stages menu, add the necessary stage and indicate the Autotests quality gate. Note Please be aware that once created, the CD pipeline remains with the chosen quality gate type without possibility to edit it. Info To trigger the CD pipeline, first, make sure that all applications have passed the Build pipelines and autotests have passed the single Code Review pipelines. Navigate to Jenkins to see the autotest logs and Allure report.","title":"Autotest as a Quality Gate"},{"location":"use-cases/autotest-as-quality-gate/#related-articles","text":"Add Application Add Autotest Add CD Pipeline","title":"Related Articles"},{"location":"use-cases/promotion-procedure/","text":"Promote Application in CD Pipeline \u2693\ufe0e This use case describes the promotion of the selected build versions of an application in the CD pipeline. Before the promotion, make sure the necessary applications are added to the Admin Console. Please refer to the Add Application section for the details. Navigate to the Continuous Delivery section on the left-side navigation bar and click the Create button. Please refer to the Add CD Pipeline section for the details. In the Application menu, select the applications to be deployed and promoted in the pipeline. If the application is selected without the promotion option, a new build version will be available for deploy at all the stages of the CD pipeline; If the promotion is selected, the build version will pass through the environments one by one through the quality gates. Info If there are several applications to be promoted, and some changes are made to one of them, only the application with the changes will be promoted to the next environments. In the Stages menu, set the manual trigger type to select an application for promotion. Navigate to Jenkins and start the CD pipeline. With the manual quality gate, click the OK button at the quality gate stage to promote the build to the next stage. Related Articles \u2693\ufe0e Add Application Add Autotest Add CD Pipeline Autotest as a Quality Gate","title":"Promote Application in CD Pipeline"},{"location":"use-cases/promotion-procedure/#promote-application-in-cd-pipeline","text":"This use case describes the promotion of the selected build versions of an application in the CD pipeline. Before the promotion, make sure the necessary applications are added to the Admin Console. Please refer to the Add Application section for the details. Navigate to the Continuous Delivery section on the left-side navigation bar and click the Create button. Please refer to the Add CD Pipeline section for the details. In the Application menu, select the applications to be deployed and promoted in the pipeline. If the application is selected without the promotion option, a new build version will be available for deploy at all the stages of the CD pipeline; If the promotion is selected, the build version will pass through the environments one by one through the quality gates. Info If there are several applications to be promoted, and some changes are made to one of them, only the application with the changes will be promoted to the next environments. In the Stages menu, set the manual trigger type to select an application for promotion. Navigate to Jenkins and start the CD pipeline. With the manual quality gate, click the OK button at the quality gate stage to promote the build to the next stage.","title":"Promote Application in CD Pipeline"},{"location":"use-cases/promotion-procedure/#related-articles","text":"Add Application Add Autotest Add CD Pipeline Autotest as a Quality Gate","title":"Related Articles"},{"location":"user-guide/","text":"Overview \u2693\ufe0e The EDP User guide is intended for developers and provides details on working with EDP Admin Console, different codebase types and EDP CI/CD flow. Admin Console \u2693\ufe0e Admin Console is a central management tool in the EDP ecosystem that provides the ability to define pipelines, project resources and new technologies in a simple way. Using Admin Console enables to manage business entities: Create such codebase types as Applications, Libraries and Autotests; Create/Update CD Pipelines; Note To interact with Admin Console via REST API, explore the Create Codebase Entity page. Navigation bar \u2013 consists of six sections: Overview, Continuous Delivery, Applications, Autotests, Libraries, and Delivery Dashboard Diagram. Click the necessary section to add an entity, open a home page or check the diagram. User name \u2013 displays the registered user name. Main links \u2013 displays the corresponding links to the major adjusted toolset, to the management tool and to the OpenShift cluster. Admin Console is a complete tool allowing to manage and control added to the environment codebases (applications, autotests, libraries) as well as to create a CD pipeline and check the visualization diagram. Inspect the main features available in Admin Console by following the corresponding link: Add Application Add Autotest Add Library Add CD Pipeline Delivery Dashboard Diagram","title":"Overview"},{"location":"user-guide/#overview","text":"The EDP User guide is intended for developers and provides details on working with EDP Admin Console, different codebase types and EDP CI/CD flow.","title":"Overview"},{"location":"user-guide/#admin-console","text":"Admin Console is a central management tool in the EDP ecosystem that provides the ability to define pipelines, project resources and new technologies in a simple way. Using Admin Console enables to manage business entities: Create such codebase types as Applications, Libraries and Autotests; Create/Update CD Pipelines; Note To interact with Admin Console via REST API, explore the Create Codebase Entity page. Navigation bar \u2013 consists of six sections: Overview, Continuous Delivery, Applications, Autotests, Libraries, and Delivery Dashboard Diagram. Click the necessary section to add an entity, open a home page or check the diagram. User name \u2013 displays the registered user name. Main links \u2013 displays the corresponding links to the major adjusted toolset, to the management tool and to the OpenShift cluster. Admin Console is a complete tool allowing to manage and control added to the environment codebases (applications, autotests, libraries) as well as to create a CD pipeline and check the visualization diagram. Inspect the main features available in Admin Console by following the corresponding link: Add Application Add Autotest Add Library Add CD Pipeline Delivery Dashboard Diagram","title":"Admin Console"},{"location":"user-guide/add-application/","text":"Add Application \u2693\ufe0e Admin Console allows to create, clone, import an application and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins. To add an application, navigate to the Applications section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear: The Codebase Info Menu The Application Info Menu The Advanced Settings Menu The Codebase Info Menu \u2693\ufe0e In the Codebase Integration Strategy field, select the necessary configuration strategy: Create \u2013 creates a project on the pattern in accordance with an application language, a build tool, and a framework. Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well. Import - allows configuring a replication from the Git server. While importing the existing repository, you have to select the Git server and define the respective path to the repository. Note In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page. The Import strategy is not applicable for Gerrit. In the Git Repository URL field, specify the link to the repository that is to be cloned. If the Import strategy is selected, specify the following fields: a. Git Server where the repository is located. b. Relative path to the repository on the server. With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields: Repository Login \u2013 enter your login data. Repository password (or API Token) \u2013 enter your password or indicate the API Token. Note The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials. Click the Proceed button to switch to the next menu. The Application Info Menu \u2693\ufe0e Type the name of the application in the Application Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes. Specify the name of the default branch where you want the development to be performed. Note The default branch cannot be deleted. To create an application with an empty repository in Gerrit, select the Empty project check box. Note The empty repository option is available only for the Create strategy. Select any of the supported application languages with its framework in the Application Code Language/framework field: Java \u2013 selecting Java allows using Java 8 or Java 11. JavaScript - selecting JavaScript allows using the React framework. DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1. Go - selecting Go allows using the Beego and Operator SDK frameworks. Python - selecting Python allows using the Python v.3.8. Other - selecting Other allows extending the default code languages when creating a codebase with the clone/import strategy. To add another code language, inspect the Add Other Code Language section. Note The Create strategy does not allow to customize the default code language set. Choose the necessary build tool in the Select Build Tool field: Java - selecting Java allows using the Gradle or Maven tool. JavaScript - selecting JavaScript allows using the NPM tool. .Net - selecting .Net allows using the .Net tool. Note The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language. Select the Multi-Module Project check box that becomes available if the Java code language and the Maven build tool are selected. Click the Proceed button to switch to the next menu. The Advanced Settings Menu \u2693\ufe0e Select CI pipeline provisioner that will be handling a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner. Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent. Select the necessary codebase versioning type: default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually . edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number that will be used for all the artifacts stored in artifactory: binaries, pom.xml, metadata, etc. The version stored in repository (e.g. pom.xml) will not be affected or used. Using this versioning overrides any version stored in the repository files without changing actual file. When selecting the edp versioning type, the extra field will appear: a. Type the version number from which you want the artifacts to be versioned. Note The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details. In the Select Deployment Script field, specify one of the available options: helm-chart / openshift-template that are predefined in case it is OpenShift or EKS. In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page. Note The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable. Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field. Note To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and setup the Adjust VCS Integration With Jira . Pay attention that the Jira integration feature is not available when using the GitLab CI tool. In the Select Jira Server field, select the Jira server. Indicate the pattern using any character, which is followed on the project, to validate a commit message. Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message. In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed. a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s , Component/s and Labels . b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value. For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT . Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira; For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator ; For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59 . c. Click the plus icon to add more Jira field names. d. Click the delete icon to remove the Jira field name. Select the Integrate with Perf Server check box to enable the integration with the PERF Board ( Project Performance Board ) for monitoring the overall team performance and setting up necessary metrics. Note If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu. In the Select Perf Server field, select the name of the Perf server with which the integration should be performed. Click the Proceed button to switch to the next menu. Select the necessary DataSource ( Jenkins, Sonar, GitLab ) from which the data should be transferred to the Project Performance Board. Click the Create button, check the CONFIRMATION summary, and click Continue to complete the application addition. Note After the complete adding of the application, inspect the Application Overview part. Related Articles \u2693\ufe0e Application Overview Delivery Dashboard Diagram Add CD Pipelines Add Other Code Language Adjust GitLab CI Tool Adjust Jira Integration Adjust VCS Integration With Jira Enable VCS Import Strategy Manage Jenkins CI Pipeline Job Provisioner Manage Jenkins Agent Perf Server Integration Promote Application in CD Pipeline","title":"Add Application"},{"location":"user-guide/add-application/#add-application","text":"Admin Console allows to create, clone, import an application and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins. To add an application, navigate to the Applications section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear: The Codebase Info Menu The Application Info Menu The Advanced Settings Menu","title":"Add Application"},{"location":"user-guide/add-application/#the-codebase-info-menu","text":"In the Codebase Integration Strategy field, select the necessary configuration strategy: Create \u2013 creates a project on the pattern in accordance with an application language, a build tool, and a framework. Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well. Import - allows configuring a replication from the Git server. While importing the existing repository, you have to select the Git server and define the respective path to the repository. Note In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page. The Import strategy is not applicable for Gerrit. In the Git Repository URL field, specify the link to the repository that is to be cloned. If the Import strategy is selected, specify the following fields: a. Git Server where the repository is located. b. Relative path to the repository on the server. With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields: Repository Login \u2013 enter your login data. Repository password (or API Token) \u2013 enter your password or indicate the API Token. Note The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials. Click the Proceed button to switch to the next menu.","title":"The Codebase Info Menu"},{"location":"user-guide/add-application/#the-application-info-menu","text":"Type the name of the application in the Application Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes. Specify the name of the default branch where you want the development to be performed. Note The default branch cannot be deleted. To create an application with an empty repository in Gerrit, select the Empty project check box. Note The empty repository option is available only for the Create strategy. Select any of the supported application languages with its framework in the Application Code Language/framework field: Java \u2013 selecting Java allows using Java 8 or Java 11. JavaScript - selecting JavaScript allows using the React framework. DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1. Go - selecting Go allows using the Beego and Operator SDK frameworks. Python - selecting Python allows using the Python v.3.8. Other - selecting Other allows extending the default code languages when creating a codebase with the clone/import strategy. To add another code language, inspect the Add Other Code Language section. Note The Create strategy does not allow to customize the default code language set. Choose the necessary build tool in the Select Build Tool field: Java - selecting Java allows using the Gradle or Maven tool. JavaScript - selecting JavaScript allows using the NPM tool. .Net - selecting .Net allows using the .Net tool. Note The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language. Select the Multi-Module Project check box that becomes available if the Java code language and the Maven build tool are selected. Click the Proceed button to switch to the next menu.","title":"The Application Info Menu"},{"location":"user-guide/add-application/#the-advanced-settings-menu","text":"Select CI pipeline provisioner that will be handling a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner. Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent. Select the necessary codebase versioning type: default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually . edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number that will be used for all the artifacts stored in artifactory: binaries, pom.xml, metadata, etc. The version stored in repository (e.g. pom.xml) will not be affected or used. Using this versioning overrides any version stored in the repository files without changing actual file. When selecting the edp versioning type, the extra field will appear: a. Type the version number from which you want the artifacts to be versioned. Note The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details. In the Select Deployment Script field, specify one of the available options: helm-chart / openshift-template that are predefined in case it is OpenShift or EKS. In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page. Note The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable. Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field. Note To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and setup the Adjust VCS Integration With Jira . Pay attention that the Jira integration feature is not available when using the GitLab CI tool. In the Select Jira Server field, select the Jira server. Indicate the pattern using any character, which is followed on the project, to validate a commit message. Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message. In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed. a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s , Component/s and Labels . b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value. For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT . Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira; For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator ; For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59 . c. Click the plus icon to add more Jira field names. d. Click the delete icon to remove the Jira field name. Select the Integrate with Perf Server check box to enable the integration with the PERF Board ( Project Performance Board ) for monitoring the overall team performance and setting up necessary metrics. Note If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu. In the Select Perf Server field, select the name of the Perf server with which the integration should be performed. Click the Proceed button to switch to the next menu. Select the necessary DataSource ( Jenkins, Sonar, GitLab ) from which the data should be transferred to the Project Performance Board. Click the Create button, check the CONFIRMATION summary, and click Continue to complete the application addition. Note After the complete adding of the application, inspect the Application Overview part.","title":"The Advanced Settings Menu"},{"location":"user-guide/add-application/#related-articles","text":"Application Overview Delivery Dashboard Diagram Add CD Pipelines Add Other Code Language Adjust GitLab CI Tool Adjust Jira Integration Adjust VCS Integration With Jira Enable VCS Import Strategy Manage Jenkins CI Pipeline Job Provisioner Manage Jenkins Agent Perf Server Integration Promote Application in CD Pipeline","title":"Related Articles"},{"location":"user-guide/add-autotest/","text":"Add Autotests \u2693\ufe0e Admin Console enables to clone or import an autotest, add it to the environment with its subsequent deployment in Gerrit (in case the Clone strategy is used) and building of the Code Review pipeline in Jenkins, as well as to use it for work with an application under development. It is also possible to use autotests as quality gates in a newly created CD pipeline. Info Please refer to the Add Application section for the details on how to add an application codebase type. For the details on how to use autotests as quality gates, please refer to the the Stages Menu section of the Add CD Pipeline documentation. Navigate to the Autotests section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear: The Codebase Info Menu The Autotest Info Menu The Advanced Settings Menu The Codebase Info Menu \u2693\ufe0e There are two available strategies: clone and import. The Clone strategy flow is displayed below: Clone - this strategy allows cloning the autotest from the indicated repository into EPAM Delivery Platform. While cloning the existing repository, you have to fill in the additional fields as well. In the Git Repository URL field, specify the link to the repository with the autotest. With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields: Repository Login \u2013 enter your login data. Repository password (or API Token) \u2013 enter your password or indicate the API Token. Note The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials. If there is a necessity to use the Import strategy that allows configuring a replication from the Git server, explore the steps below: a. Import - this strategy allows configuring a replication from the Git server. Note In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page. b. In the Git Server field, select the necessary Git server from the drop-down list. c. In the Relative path field, indicate the respective path to the repository, e.g. /epmd-edp/examples/basic/edp-auto-tests-simple-example . After completing the Codebase Info menu step, click the Proceed button to switch to the next menu. The Autotest Info Menu \u2693\ufe0e Fill in the Autotest Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes. Info The Import strategy does not have an Autotest Name field. Specify the name of the default branch where you want the development to be performed. Note The default branch cannot be deleted. Type the necessary description in the Description field. In the Autotest Code Language field, select the Java code language (specify Java 8 or Java 11 to be used) and get the default Maven build tool OR add another code language. Selecting Other allows extending the default code languages and get the necessary build tool, for details, inspect the Add Other Code Language section. Note Using the Create strategy does not allow to customize the default code language set. The Select Build Tool field can dispose of the default Maven tool, Gradle or other built tool in accordance with the selected code language. All the autotest reports will be created in the Allure framework that is available in the Autotest Report Framework field by default. Click the Proceed button to switch to the next menu. The Advanced Settings Menu \u2693\ufe0e Select CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner. Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent. Select the necessary codebase versioning type: default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually . edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml). When selecting the edp versioning type, the extra field will appear: a. Type the version number from which you want the artifacts to be versioned. Note The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details. In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page. Note The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable. Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field. Note To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira . Pay attention that the Jira integration feature is not available when using the GitLab CI tool. As soon as the Jira server is set, select it in the Select Jira Server field. Indicate the pattern using any character, which is followed on the project, to validate a commit message. Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message. In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed. a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s , Component/s and Labels . b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value. For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT . Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira; For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator ; For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59 . c. Click the plus icon to add more Jira field names. d. Click the delete icon to remove the Jira field name. Select the Integrate with Perf Server check box to enable the integration with the PERF Board ( Project Performance Board ) for monitoring the overall team performance and setting up necessary metrics. Note If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu. In the Select Perf Server field, select the name of the Perf server with which the integration should be performed and click the Proceed button to switch to the next menu. Select the necessary DataSource ( Jenkins/GitLab, Sonar ) from which the data should be transferred to the Project Performance Board. Click the Create button to create an autotest, check the CONFIRMATION summary, click Continue to add an autotest to the Autotests list. Note After the complete adding of the autotest, inspect the Autotest Overview part. Related Articles \u2693\ufe0e Autotest Overview Delivery Dashboard Diagram Add Application Add CD Pipelines Add Other Code Language Adjust GitLab CI Tool Adjust Jira Integration Adjust VCS Integration With Jira Enable VCS Import Strategy Manage Jenkins CI Pipeline Job Provisioner Manage Jenkins Agent Perf Server Integration","title":"Add Autotests"},{"location":"user-guide/add-autotest/#add-autotests","text":"Admin Console enables to clone or import an autotest, add it to the environment with its subsequent deployment in Gerrit (in case the Clone strategy is used) and building of the Code Review pipeline in Jenkins, as well as to use it for work with an application under development. It is also possible to use autotests as quality gates in a newly created CD pipeline. Info Please refer to the Add Application section for the details on how to add an application codebase type. For the details on how to use autotests as quality gates, please refer to the the Stages Menu section of the Add CD Pipeline documentation. Navigate to the Autotests section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear: The Codebase Info Menu The Autotest Info Menu The Advanced Settings Menu","title":"Add Autotests"},{"location":"user-guide/add-autotest/#the-codebase-info-menu","text":"There are two available strategies: clone and import. The Clone strategy flow is displayed below: Clone - this strategy allows cloning the autotest from the indicated repository into EPAM Delivery Platform. While cloning the existing repository, you have to fill in the additional fields as well. In the Git Repository URL field, specify the link to the repository with the autotest. With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields: Repository Login \u2013 enter your login data. Repository password (or API Token) \u2013 enter your password or indicate the API Token. Note The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials. If there is a necessity to use the Import strategy that allows configuring a replication from the Git server, explore the steps below: a. Import - this strategy allows configuring a replication from the Git server. Note In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page. b. In the Git Server field, select the necessary Git server from the drop-down list. c. In the Relative path field, indicate the respective path to the repository, e.g. /epmd-edp/examples/basic/edp-auto-tests-simple-example . After completing the Codebase Info menu step, click the Proceed button to switch to the next menu.","title":"The Codebase Info Menu"},{"location":"user-guide/add-autotest/#the-autotest-info-menu","text":"Fill in the Autotest Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes. Info The Import strategy does not have an Autotest Name field. Specify the name of the default branch where you want the development to be performed. Note The default branch cannot be deleted. Type the necessary description in the Description field. In the Autotest Code Language field, select the Java code language (specify Java 8 or Java 11 to be used) and get the default Maven build tool OR add another code language. Selecting Other allows extending the default code languages and get the necessary build tool, for details, inspect the Add Other Code Language section. Note Using the Create strategy does not allow to customize the default code language set. The Select Build Tool field can dispose of the default Maven tool, Gradle or other built tool in accordance with the selected code language. All the autotest reports will be created in the Allure framework that is available in the Autotest Report Framework field by default. Click the Proceed button to switch to the next menu.","title":"The Autotest Info Menu"},{"location":"user-guide/add-autotest/#the-advanced-settings-menu","text":"Select CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner. Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent. Select the necessary codebase versioning type: default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually . edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml). When selecting the edp versioning type, the extra field will appear: a. Type the version number from which you want the artifacts to be versioned. Note The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details. In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page. Note The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable. Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field. Note To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira . Pay attention that the Jira integration feature is not available when using the GitLab CI tool. As soon as the Jira server is set, select it in the Select Jira Server field. Indicate the pattern using any character, which is followed on the project, to validate a commit message. Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message. In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed. a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s , Component/s and Labels . b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value. For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT . Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira; For the Component/s field, select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator ; For the Labels field, select the EDP_GITTAG variable that defines a tag assigned to the commit in GitHub. For example, build/2.7.0-SNAPSHOT.59 . c. Click the plus icon to add more Jira field names. d. Click the delete icon to remove the Jira field name. Select the Integrate with Perf Server check box to enable the integration with the PERF Board ( Project Performance Board ) for monitoring the overall team performance and setting up necessary metrics. Note If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu. In the Select Perf Server field, select the name of the Perf server with which the integration should be performed and click the Proceed button to switch to the next menu. Select the necessary DataSource ( Jenkins/GitLab, Sonar ) from which the data should be transferred to the Project Performance Board. Click the Create button to create an autotest, check the CONFIRMATION summary, click Continue to add an autotest to the Autotests list. Note After the complete adding of the autotest, inspect the Autotest Overview part.","title":"The Advanced Settings Menu"},{"location":"user-guide/add-autotest/#related-articles","text":"Autotest Overview Delivery Dashboard Diagram Add Application Add CD Pipelines Add Other Code Language Adjust GitLab CI Tool Adjust Jira Integration Adjust VCS Integration With Jira Enable VCS Import Strategy Manage Jenkins CI Pipeline Job Provisioner Manage Jenkins Agent Perf Server Integration","title":"Related Articles"},{"location":"user-guide/add-cd-pipeline/","text":"Add CD Pipeline \u2693\ufe0e Admin Console provides the ability to deploy an environment on your own and specify the essential components as well. Navigate to the Continuous Delivery section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear: The Pipeline Menu The Applications Menu The Stages Menu The creation of the CD pipeline becomes available as soon as an application is created including its provisioning in a branch and the necessary entities for the environment. After the complete adding of the CD pipeline, inspect the Check CD Pipeline Availability part. The Pipeline Menu \u2693\ufe0e Type the name of the pipeline in the Pipeline Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes. Note The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name] . Please be aware that the namespace length should not exceed 63 symbols. Select the deployment type from the drop-down list: Container - the pipeline will be deployed in a Docker container; Custom - this mode allows to deploy non-container applications and customize the Init stage of CD pipeline. Click the Proceed button to switch to the next menu. The Applications Menu \u2693\ufe0e Select the check box of the necessary application in the Applications menu. Specify the necessary codebase Docker stream (the output for the branch and other stages from other CD pipelines) from the drop-down menu. Select the Promote in pipeline check box in order to transfer the application from one to another stage by the specified codebase Docker stream. If the Promote in pipeline check box is not selected, the same codebase Docker stream will be deployed regardless of the stage, i.e. the codebase Docker stream input, which was selected for the pipeline, will be always used. Note The newly created CD pipeline has the following pattern combination: [pipeline name]-[branch name]. If there is another deployed CD pipeline stage with the respective codebase Docker stream (= image stream as an OpenShift term), the pattern combination will be as follows: [pipeline name]-[stage name]-[application name]-[verified]. Click the Proceed button to switch to the next menu. The Stages Menu \u2693\ufe0e Click the plus sign icon in the Stages menu and fill in the necessary fields in the Adding Stage window : a. Type the stage name; Note The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name] . Please be aware that the namespace length should not exceed 63 symbols. b. Enter the description for this stage; c. Select the quality gate type: Manual - means that the promoting process should be confirmed in Jenkins manually; Autotests - means that the promoting process should be confirmed by the successful passing of the autotests. In the additional fields, select the previously created autotest name and specify its branch for the autotest that will be launched on the current stage. Note Please be aware that autotests used in the CD pipeline cannot be removed. For the details on how to create an autotest codebase, please refer to the Add Autotest section. d. Type the step name, which will be displayed in Jenkins, for every quality gate type; e. Add an unlimited number of quality gates by clicking a corresponding plus sign icon and remove them as well by clicking the recycle bin icon; f. Select the trigger type. The available trigger types are manual and auto . By selecting the auto trigger type, the CD pipeline will be launched automatically after the image is built. Note Execution sequence. The image promotion and execution of the pipelines depend on the sequence in which the environments are added. g. Select the groovy-pipeline library; h. Select the job provisioner. In case of working with non container-based applications, there is an option to use a custom job provisioner. Please refer to the Manage Jenkins CD Job Provision page for details. i. Click the Add button to display it in the Stages menu. Info Perform the same steps as described above if there is a necessity to add one more stage. Edit the stage by clicking its name and applying changes, and remove the added stage by clicking the recycle bin icon next to its name. Click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new project with the stage name will be created in OpenShift. Check CD Pipeline Availability \u2693\ufe0e As soon as the CD pipeline is provisioned and added to the CD Pipelines list, there is an ability to: Create another application by clicking the Create button and performing the same steps as described in the Add CD Pipeline section. Select a number of existing CD pipelines to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page. Sort the existing CD pipelines in a list by clicking the Name title. The CD pipelines will be displayed in alphabetical order. Search the necessary CD pipeline by entering the corresponding name, language or the build tool into the Search field. Navigate between pages if the number of CD pipelines exceeds the capacity of a single page. Edit CD Pipeline \u2693\ufe0e Edit the CD pipeline by clicking the pen icon next to its name in the CD Pipelines list: apply the necessary changes (the list of applications for deploy, image streams, and promotion in the pipeline) and click the Proceed button to confirm the editions: add new extra stages steps by clicking the plus sign icon and filling in the necessary fields in the Adding Stage window. Note The added stage will appear in the Stages menu allowing to review its details or delete. Check the CD pipeline data and details by clicking the CD pipeline name in the CD Pipelines list: the main link on the top of the details page refers to Jenkins; the pen icon refers to the same Edit CD Pipeline page as mentioned above and allows to apply the necessary changes; the Applications menu has the main information about the applications with the respective codebase Docker streams and links to Jenkins and Gerrit as well as the signification of the promotion in CD pipeline; the Stages menu includes the stages data that was previously mentioned, the direct links to the respective to every stage Kubernetes/OpenShift page, and the link to the Autotest details page in case there are added autotests. To enable or disable auto deployment of a specific stage, click the pen icon and select the necessary trigger type from the drop-down list. Note The deletion of stages is performed sequentially, starting from the latest created stage. In order to remove a stage , click the corresponding delete icon, type the CD pipeline name and confirm the deletion by clicking the Delete button. If you remove the last stage, the whole CD pipeline will be removed as the CD pipeline does not exist without stages. the Deployed Version menu indicates the applications and stages with the appropriate status. The status will be changed after stage deployment. the Status Info menu displays all the actions that were performed during the deployment process: Remove the added CD pipeline: Info If there is a necessity to create another CD pipeline, navigate to the Continuous Delivery section, click the Create button and perform the same steps as described above. Info In OpenShift, if the deployment fails with the ImagePullBackOff error, delete the POD. Related Articles \u2693\ufe0e Add Autotest EDP Admin Console Customize CD Pipeline Delivery Dashboard Diagram Promote Application in CD Pipeline Manage Jenkins CD Pipeline Job Provision","title":"Add CD Pipeline"},{"location":"user-guide/add-cd-pipeline/#add-cd-pipeline","text":"Admin Console provides the ability to deploy an environment on your own and specify the essential components as well. Navigate to the Continuous Delivery section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear: The Pipeline Menu The Applications Menu The Stages Menu The creation of the CD pipeline becomes available as soon as an application is created including its provisioning in a branch and the necessary entities for the environment. After the complete adding of the CD pipeline, inspect the Check CD Pipeline Availability part.","title":"Add CD Pipeline"},{"location":"user-guide/add-cd-pipeline/#the-pipeline-menu","text":"Type the name of the pipeline in the Pipeline Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes. Note The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name] . Please be aware that the namespace length should not exceed 63 symbols. Select the deployment type from the drop-down list: Container - the pipeline will be deployed in a Docker container; Custom - this mode allows to deploy non-container applications and customize the Init stage of CD pipeline. Click the Proceed button to switch to the next menu.","title":"The Pipeline Menu"},{"location":"user-guide/add-cd-pipeline/#the-applications-menu","text":"Select the check box of the necessary application in the Applications menu. Specify the necessary codebase Docker stream (the output for the branch and other stages from other CD pipelines) from the drop-down menu. Select the Promote in pipeline check box in order to transfer the application from one to another stage by the specified codebase Docker stream. If the Promote in pipeline check box is not selected, the same codebase Docker stream will be deployed regardless of the stage, i.e. the codebase Docker stream input, which was selected for the pipeline, will be always used. Note The newly created CD pipeline has the following pattern combination: [pipeline name]-[branch name]. If there is another deployed CD pipeline stage with the respective codebase Docker stream (= image stream as an OpenShift term), the pattern combination will be as follows: [pipeline name]-[stage name]-[application name]-[verified]. Click the Proceed button to switch to the next menu.","title":"The Applications Menu"},{"location":"user-guide/add-cd-pipeline/#the-stages-menu","text":"Click the plus sign icon in the Stages menu and fill in the necessary fields in the Adding Stage window : a. Type the stage name; Note The namespace created by the CD pipeline has the following pattern combination: [cluster name]-[cd pipeline name]-[stage name] . Please be aware that the namespace length should not exceed 63 symbols. b. Enter the description for this stage; c. Select the quality gate type: Manual - means that the promoting process should be confirmed in Jenkins manually; Autotests - means that the promoting process should be confirmed by the successful passing of the autotests. In the additional fields, select the previously created autotest name and specify its branch for the autotest that will be launched on the current stage. Note Please be aware that autotests used in the CD pipeline cannot be removed. For the details on how to create an autotest codebase, please refer to the Add Autotest section. d. Type the step name, which will be displayed in Jenkins, for every quality gate type; e. Add an unlimited number of quality gates by clicking a corresponding plus sign icon and remove them as well by clicking the recycle bin icon; f. Select the trigger type. The available trigger types are manual and auto . By selecting the auto trigger type, the CD pipeline will be launched automatically after the image is built. Note Execution sequence. The image promotion and execution of the pipelines depend on the sequence in which the environments are added. g. Select the groovy-pipeline library; h. Select the job provisioner. In case of working with non container-based applications, there is an option to use a custom job provisioner. Please refer to the Manage Jenkins CD Job Provision page for details. i. Click the Add button to display it in the Stages menu. Info Perform the same steps as described above if there is a necessity to add one more stage. Edit the stage by clicking its name and applying changes, and remove the added stage by clicking the recycle bin icon next to its name. Click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new project with the stage name will be created in OpenShift.","title":"The Stages Menu"},{"location":"user-guide/add-cd-pipeline/#check-cd-pipeline-availability","text":"As soon as the CD pipeline is provisioned and added to the CD Pipelines list, there is an ability to: Create another application by clicking the Create button and performing the same steps as described in the Add CD Pipeline section. Select a number of existing CD pipelines to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page. Sort the existing CD pipelines in a list by clicking the Name title. The CD pipelines will be displayed in alphabetical order. Search the necessary CD pipeline by entering the corresponding name, language or the build tool into the Search field. Navigate between pages if the number of CD pipelines exceeds the capacity of a single page.","title":"Check CD Pipeline Availability"},{"location":"user-guide/add-cd-pipeline/#edit-cd-pipeline","text":"Edit the CD pipeline by clicking the pen icon next to its name in the CD Pipelines list: apply the necessary changes (the list of applications for deploy, image streams, and promotion in the pipeline) and click the Proceed button to confirm the editions: add new extra stages steps by clicking the plus sign icon and filling in the necessary fields in the Adding Stage window. Note The added stage will appear in the Stages menu allowing to review its details or delete. Check the CD pipeline data and details by clicking the CD pipeline name in the CD Pipelines list: the main link on the top of the details page refers to Jenkins; the pen icon refers to the same Edit CD Pipeline page as mentioned above and allows to apply the necessary changes; the Applications menu has the main information about the applications with the respective codebase Docker streams and links to Jenkins and Gerrit as well as the signification of the promotion in CD pipeline; the Stages menu includes the stages data that was previously mentioned, the direct links to the respective to every stage Kubernetes/OpenShift page, and the link to the Autotest details page in case there are added autotests. To enable or disable auto deployment of a specific stage, click the pen icon and select the necessary trigger type from the drop-down list. Note The deletion of stages is performed sequentially, starting from the latest created stage. In order to remove a stage , click the corresponding delete icon, type the CD pipeline name and confirm the deletion by clicking the Delete button. If you remove the last stage, the whole CD pipeline will be removed as the CD pipeline does not exist without stages. the Deployed Version menu indicates the applications and stages with the appropriate status. The status will be changed after stage deployment. the Status Info menu displays all the actions that were performed during the deployment process: Remove the added CD pipeline: Info If there is a necessity to create another CD pipeline, navigate to the Continuous Delivery section, click the Create button and perform the same steps as described above. Info In OpenShift, if the deployment fails with the ImagePullBackOff error, delete the POD.","title":"Edit CD Pipeline"},{"location":"user-guide/add-cd-pipeline/#related-articles","text":"Add Autotest EDP Admin Console Customize CD Pipeline Delivery Dashboard Diagram Promote Application in CD Pipeline Manage Jenkins CD Pipeline Job Provision","title":"Related Articles"},{"location":"user-guide/add-custom-global-pipeline-lib/","text":"Add a Custom Global Pipeline Library \u2693\ufe0e In order to add a new custom global pipeline library, perform the steps below: Navigate to Jenkins and go to Manage Jenkins -> Configure System -> Global Pipeline Libraries . Note It is possible to configure as many libraries as necessary. Since these libraries will be globally usable, any pipeline in the system can utilize the functionality implemented in these libraries. Specify the following values: a - The name of a custom library; b - The version which can be branched, tagged or hashed of a commit; c - Allows pipelines the immediate using of classes or global variables defined by any libraries; d - Allows using the default version of the configured shared-library when the Load implicitly check box is selected; e - Allows using the default version of the configured shared-library if the pipeline references to the library only by the name, for example, @Library('my-shared-library') . Note If the Default version check box is not defined , the pipeline must specify a version, for example, @Library('my-shared-library@master') . If the Allow default version to be overridden check box is enabled in the Shared Library\u2019s configuration, a @Library annotation may also override the default version defined for the library. This also enables the library with the selected Load implicitly check box to be loaded from a different version if necessary. f - The URL of the repository; g - The credentials for the repository. Use the Custom Global Pipeline Libraries on the pipeline, for example: Pipeline @Library ( [ ' edp - library - stages ' , ' edp - library - pipelines ' , ' edp - custom - shared - library - name ' ] ) _ Build () Note edp-custom-shared-library-name is the name of the Custom Global Pipeline Library that should be added to the Jenkins Global Settings. Related Articles \u2693\ufe0e Jenkins Official Documentation: Extending with Shared Libraries","title":"Add Custom Pipeline Library"},{"location":"user-guide/add-custom-global-pipeline-lib/#add-a-custom-global-pipeline-library","text":"In order to add a new custom global pipeline library, perform the steps below: Navigate to Jenkins and go to Manage Jenkins -> Configure System -> Global Pipeline Libraries . Note It is possible to configure as many libraries as necessary. Since these libraries will be globally usable, any pipeline in the system can utilize the functionality implemented in these libraries. Specify the following values: a - The name of a custom library; b - The version which can be branched, tagged or hashed of a commit; c - Allows pipelines the immediate using of classes or global variables defined by any libraries; d - Allows using the default version of the configured shared-library when the Load implicitly check box is selected; e - Allows using the default version of the configured shared-library if the pipeline references to the library only by the name, for example, @Library('my-shared-library') . Note If the Default version check box is not defined , the pipeline must specify a version, for example, @Library('my-shared-library@master') . If the Allow default version to be overridden check box is enabled in the Shared Library\u2019s configuration, a @Library annotation may also override the default version defined for the library. This also enables the library with the selected Load implicitly check box to be loaded from a different version if necessary. f - The URL of the repository; g - The credentials for the repository. Use the Custom Global Pipeline Libraries on the pipeline, for example: Pipeline @Library ( [ ' edp - library - stages ' , ' edp - library - pipelines ' , ' edp - custom - shared - library - name ' ] ) _ Build () Note edp-custom-shared-library-name is the name of the Custom Global Pipeline Library that should be added to the Jenkins Global Settings.","title":"Add a Custom Global Pipeline Library"},{"location":"user-guide/add-custom-global-pipeline-lib/#related-articles","text":"Jenkins Official Documentation: Extending with Shared Libraries","title":"Related Articles"},{"location":"user-guide/add-library/","text":"Add Library \u2693\ufe0e Admin Console helps to create, clone or import a library and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins. Navigate to the Libraries section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear: The Codebase Info Menu The Library Info Menu The Advanced Settings Menu The Codebase Info Menu \u2693\ufe0e In the Codebase Integration Strategy field, select the necessary option that is the configuration strategy for the replication with Gerrit: Create \u2013 creates a project on the pattern in accordance with a code language, a build tool, and a framework. Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well. Import - allows configuring a replication from the Git server. While importing the existing repository, select the Git server and define the respective path to the repository. Note In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page. In the Git Repository URL field, specify the link to the repository that is to be cloned. With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields: Repository Login \u2013 enter your login data. Repository password (or API Token) \u2013 enter your password or indicate the API Token. Note The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials. Click the Proceed button to switch to the next menu. The Library Info Menu \u2693\ufe0e Type the name of the library in the Library Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes. Info If the Import strategy is used, the Library Name field will not be displayed. Specify the name of the default branch where you want the development to be performed. Note The default branch cannot be deleted. To create a library with an empty repository in Gerrit, select the Empty project check box. Note The empty repository option is available only for the Create strategy. Select any of the supported code languages in the Library Code Language block: Java \u2013 selecting Java allows specify Java 8 or Java 11, and further usage of the Gradle or Maven tool. JavaScript - selecting JavaScript allows using the NPM tool. DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1. Groovy-pipeline - selecting Groovy-pipeline allows having the ability to customize a stages logic. For details, please refer to the Customize CD Pipeline page. Python - selecting Python allows using the Python v.3.8. Terraform - selecting Terraform allows using the Terraform different versions via the Terraform version manager ( tfenv ). EDP supports all actions available in Terraform, thus providing the ability to modify the virtual infrastructure and launch some checks with the help of linters. For details, please refer to the Use Terraform Library in EDP page. Rego - this option allows using Rego code language with an Open Policy Agent (OPA) Library. For details, please refer to the Use Open Policy Agent page. Other - selecting Other allows extending the default code languages when creating a codebase with the Clone/Import strategy. To add another code language, inspect the Add Other Code Language page. Note The Create strategy does not allow to customize the default code language set. The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language. Click the Proceed button to switch to the next menu. The Advanced Settings Menu \u2693\ufe0e Select the CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner. Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent. Select the necessary codebase versioning type: default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually . edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml). When selecting the edp versioning type, the extra field will appear: a. Type the version number from which you want the artifacts to be versioned. Note The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details. In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page. Note The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable. Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field. Note To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira . Pay attention that the Jira integration feature is not available when using the GitLab CI tool. As soon as the Jira server is set, select it in the Select Jira Server field. Indicate the pattern using any character, which is followed on the project, to validate a commit message. Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message. In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed. a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s , Component/s and Labels . b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value. For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT . Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira; For the Component/s field select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator ; For the Labels field select the EDP_GITTAG variable that defines a tag assigned to the commit in Git Hub. For example, build/2.7.0-SNAPSHOT.59 . c. Click the plus icon to add more Jira field names. d. Click the delete icon to remove the Jira field name. Select the Integrate with Perf Server check box to enable the integration with the PERF Board ( Project Performance Board ) for monitoring the overall team performance and setting up necessary metrics. Note If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu. In the Select Perf Server field, select the name of the Perf server with which the integration should be performed. Click the Proceed button to switch to the next menu. Select the necessary DataSource ( Jenkins/GitLab, Sonar ) from which the data should be transferred to the Project Performance Board. Click the Create button, check the CONFIRMATION summary, and click Continue to add the library to the Libraries list. Note After the complete adding of the library, inspect the Library Overview part. Related Articles \u2693\ufe0e Library Overview Delivery Dashboard Diagram Add CD Pipeline Add Other Code Language Adjust GitLab CI Tool Adjust Jira Integration Adjust VCS Integration With Jira Enable VCS Import Strategy Manage Jenkins CI Pipeline Job Provisioner Manage Jenkins Agent Perf Server Integration Use Terraform Library in EDP Use Open Policy Agent Library in EDP","title":"Add Library"},{"location":"user-guide/add-library/#add-library","text":"Admin Console helps to create, clone or import a library and add it to the environment. It can also be deployed in Gerrit (if the Clone or Create strategy is used) with the Code Review and Build pipelines built in Jenkins. Navigate to the Libraries section on the left-side navigation bar and click the Create button. Once clicked, the three-step menu will appear: The Codebase Info Menu The Library Info Menu The Advanced Settings Menu","title":"Add Library"},{"location":"user-guide/add-library/#the-codebase-info-menu","text":"In the Codebase Integration Strategy field, select the necessary option that is the configuration strategy for the replication with Gerrit: Create \u2013 creates a project on the pattern in accordance with a code language, a build tool, and a framework. Clone \u2013 clones the indicated repository into EPAM Delivery Platform. While cloning the existing repository, it is required to fill in the additional fields as well. Import - allows configuring a replication from the Git server. While importing the existing repository, select the Git server and define the respective path to the repository. Note In order to use the Import strategy, make sure to adjust it by following the Enable VCS Import Strategy page. In the Git Repository URL field, specify the link to the repository that is to be cloned. With the Clone strategy, select the Codebase Authentication check box and fill in the requested fields: Repository Login \u2013 enter your login data. Repository password (or API Token) \u2013 enter your password or indicate the API Token. Note The Codebase Authentication check box should be selected only in case you clone the private repository. If you define the public repository, there is no need to enter credentials. Click the Proceed button to switch to the next menu.","title":"The Codebase Info Menu"},{"location":"user-guide/add-library/#the-library-info-menu","text":"Type the name of the library in the Library Name field by entering at least two characters and by using the lower-case letters, numbers and inner dashes. Info If the Import strategy is used, the Library Name field will not be displayed. Specify the name of the default branch where you want the development to be performed. Note The default branch cannot be deleted. To create a library with an empty repository in Gerrit, select the Empty project check box. Note The empty repository option is available only for the Create strategy. Select any of the supported code languages in the Library Code Language block: Java \u2013 selecting Java allows specify Java 8 or Java 11, and further usage of the Gradle or Maven tool. JavaScript - selecting JavaScript allows using the NPM tool. DotNet - selecting DotNet allows using the DotNet v.2.1 and DotNet v.3.1. Groovy-pipeline - selecting Groovy-pipeline allows having the ability to customize a stages logic. For details, please refer to the Customize CD Pipeline page. Python - selecting Python allows using the Python v.3.8. Terraform - selecting Terraform allows using the Terraform different versions via the Terraform version manager ( tfenv ). EDP supports all actions available in Terraform, thus providing the ability to modify the virtual infrastructure and launch some checks with the help of linters. For details, please refer to the Use Terraform Library in EDP page. Rego - this option allows using Rego code language with an Open Policy Agent (OPA) Library. For details, please refer to the Use Open Policy Agent page. Other - selecting Other allows extending the default code languages when creating a codebase with the Clone/Import strategy. To add another code language, inspect the Add Other Code Language page. Note The Create strategy does not allow to customize the default code language set. The Select Build Tool field disposes of the default tools and can be changed in accordance with the selected code language. Click the Proceed button to switch to the next menu.","title":"The Library Info Menu"},{"location":"user-guide/add-library/#the-advanced-settings-menu","text":"Select the CI pipeline provisioner that will be used to handle a codebase. For details, refer to the Manage Jenkins CI Pipeline Job Provisioner instruction and become familiar with the main steps to add an additional job provisioner. Select Jenkins agent that will be used to handle a codebase. For details, refer to the Manage Jenkins Agent instruction and inspect the steps that should be done to add a new Jenkins agent. Select the necessary codebase versioning type: default - the previous versioning logic that is realized in EDP Admin Console 2.2.0 and lower versions. Using the default versioning type, in order to specify the version of the current artifacts, images, and tags in the Version Control System, a developer should navigate to the corresponding file and change the version manually . edp - the new versioning logic that is available in EDP Admin Console 2.3.0 and subsequent versions. Using the edp versioning type, a developer indicates the version number from which all the artifacts will be versioned and, as a result, automatically registered in the corresponding file (e.g. pom.xml). When selecting the edp versioning type, the extra field will appear: a. Type the version number from which you want the artifacts to be versioned. Note The Start Version From field should be filled out in compliance with the semantic versioning rules, e.g. 1.2.3 or 10.10.10. Please refer to the Semantic Versioning page for details. In the Select CI Tool field, choose the necessary tool: Jenkins or GitLab CI, where Jenkins is the default tool and the GitLab CI tool can be additionally adjusted. For details, please refer to the Adjust GitLab CI Tool page. Note The GitLab CI tool is available only with the Import strategy and makes the Jira integration feature unavailable. Select the Integrate with Jira Server check box in case it is required to connect Jira tickets with the commits and have a respective label in the Fix Version field. Note To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration page, and Adjust VCS Integration With Jira . Pay attention that the Jira integration feature is not available when using the GitLab CI tool. As soon as the Jira server is set, select it in the Select Jira Server field. Indicate the pattern using any character, which is followed on the project, to validate a commit message. Indicate the pattern using any character, which is followed on the project, to find a Jira ticket number in a commit message. In the Advanced Mapping section, specify the names of the Jira fields that should be filled in with attributes from EDP. Upon clicking the question mark icon, observe the tips on how to indicate and combine variables necessary for identifying the format of values to be displayed. a. Select the name of the field in a Jira ticket. The available fields are the following: Fix Version/s , Component/s and Labels . b. Select the pattern of predefined variables, based on which the value from EDP will be displayed in Jira. Combine several variables to obtain the desired value. For the Fix Version/s field, select the EDP_VERSION variable that represents an EDP upgrade version, as in 2.7.0-SNAPSHOT . Combine variables to make the value more informative. For example, the pattern EDP_VERSION-EDP_COMPONENT will be displayed as 2.7.0-SNAPSHOT-nexus-operator in Jira; For the Component/s field select the EDP_COMPONENT variable that defines the name of the existing repository. For example, nexus-operator ; For the Labels field select the EDP_GITTAG variable that defines a tag assigned to the commit in Git Hub. For example, build/2.7.0-SNAPSHOT.59 . c. Click the plus icon to add more Jira field names. d. Click the delete icon to remove the Jira field name. Select the Integrate with Perf Server check box to enable the integration with the PERF Board ( Project Performance Board ) for monitoring the overall team performance and setting up necessary metrics. Note If this option is needed, please refer to the Perf Server Integration to adjust the integration. After the integration is adjusted, the Integrate with Perf Server check box will appear in the Advanced Settings menu. In the Select Perf Server field, select the name of the Perf server with which the integration should be performed. Click the Proceed button to switch to the next menu. Select the necessary DataSource ( Jenkins/GitLab, Sonar ) from which the data should be transferred to the Project Performance Board. Click the Create button, check the CONFIRMATION summary, and click Continue to add the library to the Libraries list. Note After the complete adding of the library, inspect the Library Overview part.","title":"The Advanced Settings Menu"},{"location":"user-guide/add-library/#related-articles","text":"Library Overview Delivery Dashboard Diagram Add CD Pipeline Add Other Code Language Adjust GitLab CI Tool Adjust Jira Integration Adjust VCS Integration With Jira Enable VCS Import Strategy Manage Jenkins CI Pipeline Job Provisioner Manage Jenkins Agent Perf Server Integration Use Terraform Library in EDP Use Open Policy Agent Library in EDP","title":"Related Articles"},{"location":"user-guide/application/","text":"Application \u2693\ufe0e This section describes the subsequent possible actions that can be performed with the newly added or existing applications. Check and Remove Application \u2693\ufe0e As soon as the application is successfully provisioned, the following will be created: Code Review and Build pipelines in Jenkins for this application. The Build pipeline will be triggered automatically if at least one environment is already added. A new project in Gerrit or another VCS. SonarQube integration will be available after the Build pipeline in Jenkins is passed. Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well. Info To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link. The added application will be listed in the Applications list allowing you to do the following: Create another application by clicking the Create button and performing the same steps as described in the Add Applications section. Open application data by clicking its link name. Once clicked, the following blocks will be displayed: General Info - displays common information about the created/cloned/imported application. Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type). Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields: Build Number - indicates the current build number; Last Successful Build - indicates the last successful build number. Status Info - displays all the actions that were performed during the creation/cloning/importing process. Edit the application codebase by clicking the pencil icon. For details see the Edit Existing Codebase section. Remove application with the corresponding database and Jenkins pipelines: Click the delete icon next to the application name; Type the required application name; Confirm the deletion by clicking the Delete button. Note The application that is used in a CD pipeline cannot be removed. Select a number of existing applications to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page. Sort the existing applications in a list by clicking the Name title. The applications will be displayed in alphabetical order. Search the necessary application by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the application name, language or a build tool. Navigate between pages if the number of applications exceeds the capacity of a single page. Add a New Branch \u2693\ufe0e When adding an application, the default branch is a master branch. In order to add a new branch, follow the steps below: Navigate to the Branches block and click the Create button:] Fill in the required fields: a. Release Branch - select the Release Branch check box if you need to create a release branch; b. Branch Name - type the branch name. Pay attention that this field remains static if you create a release branch. c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used. d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number. e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number; f. Click the Proceed button and wait until the new branch will be added to the list. Info Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer here . The default application repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version. Edit Existing Codebase \u2693\ufe0e The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for applications via the Edit Codebase page. Perform the editing from one of the following sections on the Admin Console interface: Navigate to the codebase overview page and click the pencil icon, or Navigate to the codebase list page and click the pencil icon. To enable Jira integration, on the Edit Codebase page do the following: mark the Integrate with Jira server check box and fill in the necessary fields; click the Proceed button to apply the changes; navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline. To disable Jira integration, on the Edit Codebase page do the following: unmark the Integrate with Jira server check box; click the Proceed button to apply the changes; navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline. As a result, the necessary changes will be applied. Remove Branch \u2693\ufe0e In order to remove the added branch with the corresponding record in the Admin Console database, do the following: Navigate to the Branches block by clicking the application name link in the Applications list; Click the delete icon related to the necessary branch: Enter the branch name and click the Delete button; Note The default master branch cannot be removed. Related Articles \u2693\ufe0e Add Application Promote Application in CD Pipeline","title":"Overview"},{"location":"user-guide/application/#application","text":"This section describes the subsequent possible actions that can be performed with the newly added or existing applications.","title":"Application"},{"location":"user-guide/application/#check-and-remove-application","text":"As soon as the application is successfully provisioned, the following will be created: Code Review and Build pipelines in Jenkins for this application. The Build pipeline will be triggered automatically if at least one environment is already added. A new project in Gerrit or another VCS. SonarQube integration will be available after the Build pipeline in Jenkins is passed. Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well. Info To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link. The added application will be listed in the Applications list allowing you to do the following: Create another application by clicking the Create button and performing the same steps as described in the Add Applications section. Open application data by clicking its link name. Once clicked, the following blocks will be displayed: General Info - displays common information about the created/cloned/imported application. Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type). Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields: Build Number - indicates the current build number; Last Successful Build - indicates the last successful build number. Status Info - displays all the actions that were performed during the creation/cloning/importing process. Edit the application codebase by clicking the pencil icon. For details see the Edit Existing Codebase section. Remove application with the corresponding database and Jenkins pipelines: Click the delete icon next to the application name; Type the required application name; Confirm the deletion by clicking the Delete button. Note The application that is used in a CD pipeline cannot be removed. Select a number of existing applications to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page. Sort the existing applications in a list by clicking the Name title. The applications will be displayed in alphabetical order. Search the necessary application by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the application name, language or a build tool. Navigate between pages if the number of applications exceeds the capacity of a single page.","title":"Check and Remove Application"},{"location":"user-guide/application/#add-a-new-branch","text":"When adding an application, the default branch is a master branch. In order to add a new branch, follow the steps below: Navigate to the Branches block and click the Create button:] Fill in the required fields: a. Release Branch - select the Release Branch check box if you need to create a release branch; b. Branch Name - type the branch name. Pay attention that this field remains static if you create a release branch. c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used. d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number. e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number; f. Click the Proceed button and wait until the new branch will be added to the list. Info Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer here . The default application repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.","title":"Add a New Branch"},{"location":"user-guide/application/#edit-existing-codebase","text":"The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for applications via the Edit Codebase page. Perform the editing from one of the following sections on the Admin Console interface: Navigate to the codebase overview page and click the pencil icon, or Navigate to the codebase list page and click the pencil icon. To enable Jira integration, on the Edit Codebase page do the following: mark the Integrate with Jira server check box and fill in the necessary fields; click the Proceed button to apply the changes; navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline. To disable Jira integration, on the Edit Codebase page do the following: unmark the Integrate with Jira server check box; click the Proceed button to apply the changes; navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline. As a result, the necessary changes will be applied.","title":"Edit Existing Codebase"},{"location":"user-guide/application/#remove-branch","text":"In order to remove the added branch with the corresponding record in the Admin Console database, do the following: Navigate to the Branches block by clicking the application name link in the Applications list; Click the delete icon related to the necessary branch: Enter the branch name and click the Delete button; Note The default master branch cannot be removed.","title":"Remove Branch"},{"location":"user-guide/application/#related-articles","text":"Add Application Promote Application in CD Pipeline","title":"Related Articles"},{"location":"user-guide/autotest/","text":"Autotest \u2693\ufe0e This section describes the subsequent possible actions that can be performed with the newly added or existing autotests. Check and Remove Autotest \u2693\ufe0e As soon as the autotest is successfully provisioned, the following will be created: Code Review and Build pipelines in Jenkins for this autotest. The Build pipeline will be triggered automatically if at least one environment is already added. A new project in Gerrit or another VCS. SonarQube integration will be available after the Build pipeline in Jenkins is passed. Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well. Info To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link. The added autotest will be listed in the Autotests list allowing you to do the following: Add another autotest by clicking the Create button and performing the same steps as described at the Add Autotest page. Open autotest data by clicking its link name. Once clicked, the following blocks will be displayed: General Info - displays common information about the cloned/imported autotest. Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type). Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields: Build Number - indicates the current build number; Last Successful Build - indicates the number of the last successful build. Status Info - displays all the actions that were performed during the cloning/importing process. Edit the autotest codebase by clicking the pencil icon. For details see the Edit Existing Codebase section. Remove autotest with the corresponding database and Jenkins pipelines: Click the delete icon next to the autotest name; Type the required autotest name; Confirm the deletion by clicking the Delete button. Note The autotest that is used in a CD pipeline cannot be removed. Select a number of existing autotests to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page. Sort the existing autotests in a list by clicking the Name title. The autotests will be displayed in alphabetical order. Search the necessary autotest by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the autotest name, language or a build tool. Navigate between pages, if the number of autotests exceeds the capacity of a single page. Edit Existing Codebase \u2693\ufe0e The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for autotests via the Edit Codebase page. Perform the editing from one of the following sections on the Admin Console interface: Navigate to the codebase overview page and click the pencil icon, or Navigate to the codebase list page and click the pencil icon. To enable Jira integration, on the Edit Codebase page do the following: mark the Integrate with Jira server check box and fill in the necessary fields; click the Proceed button to apply the changes; navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code-Review pipeline. Note Pay attention that the Jira integration feature is not available when using the GitLab CI tool. Note To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration and Adjust VCS Integration With Jira pages. To disable Jira integration, on the Edit Codebase page do the following: unmark the Integrate with Jira server check box; click the Proceed button to apply the changes; navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline. As a result, the necessary changes will be applied. Add a New Branch \u2693\ufe0e When adding an autotest, the default branch is a master branch. In order to add a new branch, follow the steps below: Navigate to the Branches block and click the Create button: Fill in the required fields: a. Release Branch - select the Release Branch check box if you need to create a release branch; b. Branch Name - type the branch name. Pay attention that this field remains static if you create a release branch. c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used. d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number. e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number; f. Click the Proceed button and wait until the new branch will be added to the list. Info Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer to the Add Autotest instruction. The default autotest repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version. Remove Branch \u2693\ufe0e In order to remove the added branch with the corresponding record in the Admin Console database, do the following: Navigate to the Branches block by clicking the autotest name link in the Autotests list; Click the delete icon related to the necessary branch: Enter the branch name and click the Delete button; Note The default master branch cannot be removed. Add Autotest as a Quality Gate \u2693\ufe0e In order to add an autotest as a quality gate to a newly added CD pipeline, do the following: Create a CD pipeline with the necessary parameters. Please refer to the Add CD Pipeline section for the details. In the Stages menu, select the Autotest quality gate type. It means the promoting process should be confirmed by the successful passing of the autotests. In the additional fields, select the previously created autotest name and specify its branch. After filling in all the necessary fields, click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new namespace containing the stage name will be created in Kubernetes (in OpenShift, a new project will be created) with the following name pattern: [cluster name]-[cd pipeline name]-[stage name] Configure Autotest Launch at Specific Stage \u2693\ufe0e In order to configure the added autotest launch at the specific stage with necessary parameters, do the following: Add the necessary stage to the CD pipeline. Please refer to the Add CD Pipeline documentation for the details. Navigate to the run.json file and add the stage name and the specific parameters. Launch Autotest Locally \u2693\ufe0e There is an ability to run the autotests locally using the IDEA (Integrated Development Environment Application, such as IntelliJ, NetBeans etc.). To launch the autotest project for the local verification, perform the following steps: Clone the project to the local machine. Open the project in IDEA and find the run.json file to copy out the necessary command value. Paste the copied command value into the Command line field and run it with the necessary values and namespace. As a result, all launched tests will be executed. Related Articles \u2693\ufe0e Add Application Add Autotests Add CD Pipeline Adjust Jira Integration Adjust VCS Integration With Jira","title":"Overview"},{"location":"user-guide/autotest/#autotest","text":"This section describes the subsequent possible actions that can be performed with the newly added or existing autotests.","title":"Autotest"},{"location":"user-guide/autotest/#check-and-remove-autotest","text":"As soon as the autotest is successfully provisioned, the following will be created: Code Review and Build pipelines in Jenkins for this autotest. The Build pipeline will be triggered automatically if at least one environment is already added. A new project in Gerrit or another VCS. SonarQube integration will be available after the Build pipeline in Jenkins is passed. Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well. Info To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link. The added autotest will be listed in the Autotests list allowing you to do the following: Add another autotest by clicking the Create button and performing the same steps as described at the Add Autotest page. Open autotest data by clicking its link name. Once clicked, the following blocks will be displayed: General Info - displays common information about the cloned/imported autotest. Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type). Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields: Build Number - indicates the current build number; Last Successful Build - indicates the number of the last successful build. Status Info - displays all the actions that were performed during the cloning/importing process. Edit the autotest codebase by clicking the pencil icon. For details see the Edit Existing Codebase section. Remove autotest with the corresponding database and Jenkins pipelines: Click the delete icon next to the autotest name; Type the required autotest name; Confirm the deletion by clicking the Delete button. Note The autotest that is used in a CD pipeline cannot be removed. Select a number of existing autotests to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page. Sort the existing autotests in a list by clicking the Name title. The autotests will be displayed in alphabetical order. Search the necessary autotest by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the autotest name, language or a build tool. Navigate between pages, if the number of autotests exceeds the capacity of a single page.","title":"Check and Remove Autotest"},{"location":"user-guide/autotest/#edit-existing-codebase","text":"The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for autotests via the Edit Codebase page. Perform the editing from one of the following sections on the Admin Console interface: Navigate to the codebase overview page and click the pencil icon, or Navigate to the codebase list page and click the pencil icon. To enable Jira integration, on the Edit Codebase page do the following: mark the Integrate with Jira server check box and fill in the necessary fields; click the Proceed button to apply the changes; navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code-Review pipeline. Note Pay attention that the Jira integration feature is not available when using the GitLab CI tool. Note To adjust the Jira integration functionality, first apply the necessary changes described on the Adjust Jira Integration and Adjust VCS Integration With Jira pages. To disable Jira integration, on the Edit Codebase page do the following: unmark the Integrate with Jira server check box; click the Proceed button to apply the changes; navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline. As a result, the necessary changes will be applied.","title":"Edit Existing Codebase"},{"location":"user-guide/autotest/#add-a-new-branch","text":"When adding an autotest, the default branch is a master branch. In order to add a new branch, follow the steps below: Navigate to the Branches block and click the Create button: Fill in the required fields: a. Release Branch - select the Release Branch check box if you need to create a release branch; b. Branch Name - type the branch name. Pay attention that this field remains static if you create a release branch. c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used. d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number. e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number; f. Click the Proceed button and wait until the new branch will be added to the list. Info Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer to the Add Autotest instruction. The default autotest repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.","title":"Add a New Branch"},{"location":"user-guide/autotest/#remove-branch","text":"In order to remove the added branch with the corresponding record in the Admin Console database, do the following: Navigate to the Branches block by clicking the autotest name link in the Autotests list; Click the delete icon related to the necessary branch: Enter the branch name and click the Delete button; Note The default master branch cannot be removed.","title":"Remove Branch"},{"location":"user-guide/autotest/#add-autotest-as-a-quality-gate","text":"In order to add an autotest as a quality gate to a newly added CD pipeline, do the following: Create a CD pipeline with the necessary parameters. Please refer to the Add CD Pipeline section for the details. In the Stages menu, select the Autotest quality gate type. It means the promoting process should be confirmed by the successful passing of the autotests. In the additional fields, select the previously created autotest name and specify its branch. After filling in all the necessary fields, click the Create button to start the provisioning of the pipeline. After the CD pipeline is added, the new namespace containing the stage name will be created in Kubernetes (in OpenShift, a new project will be created) with the following name pattern: [cluster name]-[cd pipeline name]-[stage name]","title":"Add Autotest as a Quality Gate"},{"location":"user-guide/autotest/#configure-autotest-launch-at-specific-stage","text":"In order to configure the added autotest launch at the specific stage with necessary parameters, do the following: Add the necessary stage to the CD pipeline. Please refer to the Add CD Pipeline documentation for the details. Navigate to the run.json file and add the stage name and the specific parameters.","title":"Configure Autotest Launch at Specific Stage"},{"location":"user-guide/autotest/#launch-autotest-locally","text":"There is an ability to run the autotests locally using the IDEA (Integrated Development Environment Application, such as IntelliJ, NetBeans etc.). To launch the autotest project for the local verification, perform the following steps: Clone the project to the local machine. Open the project in IDEA and find the run.json file to copy out the necessary command value. Paste the copied command value into the Command line field and run it with the necessary values and namespace. As a result, all launched tests will be executed.","title":"Launch Autotest Locally"},{"location":"user-guide/autotest/#related-articles","text":"Add Application Add Autotests Add CD Pipeline Adjust Jira Integration Adjust VCS Integration With Jira","title":"Related Articles"},{"location":"user-guide/build-pipeline/","text":"Build Pipeline \u2693\ufe0e This section provides details on the Build pipeline of the EDP CI/CD pipeline framework. Explore below the pipeline purpose, stages and possible actions to perform. Build Pipeline Purpose \u2693\ufe0e The purpose of the Build pipeline contains the following points: Check out, test, tag and build an image from the mainstream branch after a patch set is submitted in order to inspect whether the integrated with the mainstream code fits all quality gates, can be built and tested; Be triggered if any new patch set is submitted; Tag a specific commit in Gerrit in case the build is successful; Build a Docker image with an application that can be afterward deployed using the Jenkins Deploy pipeline. Find below the functional diagram of the Build pipeline with the default stages: Build Pipeline for Application and Library \u2693\ufe0e The Build pipeline is triggered automatically after the Code Review pipeline is completed and the changes are submitted. To review the Build pipeline, take the following steps: Open Jenkins via the created link in Gerrit or via the Admin Console Overview page. Click the Build pipeline link to open its stages for the application and library codebases: Init - initialization of the Code Review pipeline inputs; Checkout - checkout of the application code; Get-version - get the version from the pom.XML file and add the build number; Compile - code compilation; Tests - tests execution; Sonar - Sonar launch that checks the whole code; Build - artifact building and adding to Nexus; Build-image - docker image building and adding to Docker Registry. The Build pipeline for the library has the same stages as the application except the Build-image stage, i.e. the Docker image is not building. Push - artifact docker image pushing to Nexus and Docker Registry; Ecr-to-docker - the docker image, after being built, is copied from the ECR project registry to DockerHub via the Crane tool. The stage is not the default and can be set for the application codebase type. To set this stage, please refer to the EcrToDocker.groovy file and to the Promote Docker Images From ECR to Docker Hub page. Git-tag - adding of the corresponding Git tag of the current commit to relate with the image, artifact, and build version. Note For more details on stages, please refer to the Pipeline Stages documentation. After the Build pipeline runs all the stages successfully, the corresponding tag numbers will be created in Kubernetes/OpenShift and Nexus. Check the Tag in Kubernetes/OpenShift and Nexus \u2693\ufe0e After the Build pipeline is completed, check the tag name and the same with the commit revision. Simply navigate to Gerrit \u2192 Projects \u2192 List \u2192 select the project \u2192 Tags. Note For the Import strategy, navigate to the repository from which a codebase is imported \u2192 Tags. It is actual both for GitHub and GitLab. Open the Kubernetes/OpenShift Overview page and click the link to Nexus and check the build of a new version. Switch to Kubernetes \u2192 CodebaseImageStream (or OpenShift \u2192 Builds \u2192 Images) \u2192 click the image stream that will be used for deployment. Check the corresponding tag. Configure and Start Pipeline Manually \u2693\ufe0e The Build pipeline can be started manually. To set the necessary stages and trigger the pipeline manually, take the following steps: Open the Build pipeline for the created library. Click the Build with parameters option from the left-side menu. Modify the stages by removing the whole objects massive: {\"name\". \"tests\"} where name is a key and tests is a stage name that should be executed. Open Jenkins and check the successful execution of all stages. Related Articles \u2693\ufe0e Add Application Add Autotest Add Library Adjust Jira Integration Adjust VCS Integration With Jira Autotest as Quality Gate Pipeline Stages","title":"Build Pipeline"},{"location":"user-guide/build-pipeline/#build-pipeline","text":"This section provides details on the Build pipeline of the EDP CI/CD pipeline framework. Explore below the pipeline purpose, stages and possible actions to perform.","title":"Build Pipeline"},{"location":"user-guide/build-pipeline/#build-pipeline-purpose","text":"The purpose of the Build pipeline contains the following points: Check out, test, tag and build an image from the mainstream branch after a patch set is submitted in order to inspect whether the integrated with the mainstream code fits all quality gates, can be built and tested; Be triggered if any new patch set is submitted; Tag a specific commit in Gerrit in case the build is successful; Build a Docker image with an application that can be afterward deployed using the Jenkins Deploy pipeline. Find below the functional diagram of the Build pipeline with the default stages:","title":"Build Pipeline Purpose"},{"location":"user-guide/build-pipeline/#build-pipeline-for-application-and-library","text":"The Build pipeline is triggered automatically after the Code Review pipeline is completed and the changes are submitted. To review the Build pipeline, take the following steps: Open Jenkins via the created link in Gerrit or via the Admin Console Overview page. Click the Build pipeline link to open its stages for the application and library codebases: Init - initialization of the Code Review pipeline inputs; Checkout - checkout of the application code; Get-version - get the version from the pom.XML file and add the build number; Compile - code compilation; Tests - tests execution; Sonar - Sonar launch that checks the whole code; Build - artifact building and adding to Nexus; Build-image - docker image building and adding to Docker Registry. The Build pipeline for the library has the same stages as the application except the Build-image stage, i.e. the Docker image is not building. Push - artifact docker image pushing to Nexus and Docker Registry; Ecr-to-docker - the docker image, after being built, is copied from the ECR project registry to DockerHub via the Crane tool. The stage is not the default and can be set for the application codebase type. To set this stage, please refer to the EcrToDocker.groovy file and to the Promote Docker Images From ECR to Docker Hub page. Git-tag - adding of the corresponding Git tag of the current commit to relate with the image, artifact, and build version. Note For more details on stages, please refer to the Pipeline Stages documentation. After the Build pipeline runs all the stages successfully, the corresponding tag numbers will be created in Kubernetes/OpenShift and Nexus.","title":"Build Pipeline for Application and Library"},{"location":"user-guide/build-pipeline/#check-the-tag-in-kubernetesopenshift-and-nexus","text":"After the Build pipeline is completed, check the tag name and the same with the commit revision. Simply navigate to Gerrit \u2192 Projects \u2192 List \u2192 select the project \u2192 Tags. Note For the Import strategy, navigate to the repository from which a codebase is imported \u2192 Tags. It is actual both for GitHub and GitLab. Open the Kubernetes/OpenShift Overview page and click the link to Nexus and check the build of a new version. Switch to Kubernetes \u2192 CodebaseImageStream (or OpenShift \u2192 Builds \u2192 Images) \u2192 click the image stream that will be used for deployment. Check the corresponding tag.","title":"Check the Tag in Kubernetes/OpenShift and Nexus"},{"location":"user-guide/build-pipeline/#configure-and-start-pipeline-manually","text":"The Build pipeline can be started manually. To set the necessary stages and trigger the pipeline manually, take the following steps: Open the Build pipeline for the created library. Click the Build with parameters option from the left-side menu. Modify the stages by removing the whole objects massive: {\"name\". \"tests\"} where name is a key and tests is a stage name that should be executed. Open Jenkins and check the successful execution of all stages.","title":"Configure and Start Pipeline Manually"},{"location":"user-guide/build-pipeline/#related-articles","text":"Add Application Add Autotest Add Library Adjust Jira Integration Adjust VCS Integration With Jira Autotest as Quality Gate Pipeline Stages","title":"Related Articles"},{"location":"user-guide/cd-pipeline-details/","text":"CD Pipeline Details \u2693\ufe0e CD Pipeline (Continuous Delivery Pipeline) - an EDP business entity that describes the whole delivery process of the selected application set via the respective stages. The main idea of the CD pipeline is to promote the application build version between the stages by applying the sequential verification (i.e. the second stage will be available if the verification on the first stage is successfully completed). The CD pipeline can include the essential set of applications with its specific stages as well. In other words, the CD pipeline allows the selected image stream (Docker container in Kubernetes terms) to pass a set of stages for the verification process (SIT - system integration testing with the automatic type of a quality gate, QA - quality assurance, UAT - user acceptance testing with the manual testing). Note It is possible to change the image stream for the application in the CD pipeline. Please refer to the Edit CD Pipeline section for the details. A CI/CD pipeline helps to automate steps in a software delivery process, such as the code build initialization, automated tests running, and deploying to a staging or production environment. Automated pipelines remove manual errors, provide standardized development feedback cycle, and enable the fast product iterations. To get more information on the CI pipeline, please refer to the CI Pipeline Details chapter. The codebase stream is used as a holder for the output of the stage, i.e. after the Docker container (or an image stream in OpenShift terms) passes the stage verification, it will be placed to the new codebase stream. Every codebase has a branch that has its own codebase stream - a Docker container that is an output of the build for the corresponding branch. Note For more information on the main terms used in EPAM Delivery Platform, please refer to the EDP Glossary Explore the details of the CD pipeline below. Deploy Pipeline \u2693\ufe0e The Deploy pipeline is used by default on any stage of the Continuous Delivery pipeline. It addresses the following concerns: Deploying the application(s) to the main STAGE (SIT, QA, UAT) environment in order to run autotests and to promote image build versions to the next environments afterwards. Deploying the application(s) to a custom STAGE environment in order to run autotests and check manually that everything is ok with the application. Deploying the latest or a stable and some particular numeric version of an image build that exists in Docker registry. Promoting the image build versions from the main STAGE (SIT, QA, UAT) environment. Find below the functional diagram of the Deploy pipeline with the default stages: Related Articles \u2693\ufe0e Add Application Add Autotest Add CD Pipeline Add Library CI Pipeline Details CI/CD Overview EDP Glossary EDP Pipeline Framework EDP Pipeline Stages Prepare for Release","title":"CD Pipeline Details"},{"location":"user-guide/cd-pipeline-details/#cd-pipeline-details","text":"CD Pipeline (Continuous Delivery Pipeline) - an EDP business entity that describes the whole delivery process of the selected application set via the respective stages. The main idea of the CD pipeline is to promote the application build version between the stages by applying the sequential verification (i.e. the second stage will be available if the verification on the first stage is successfully completed). The CD pipeline can include the essential set of applications with its specific stages as well. In other words, the CD pipeline allows the selected image stream (Docker container in Kubernetes terms) to pass a set of stages for the verification process (SIT - system integration testing with the automatic type of a quality gate, QA - quality assurance, UAT - user acceptance testing with the manual testing). Note It is possible to change the image stream for the application in the CD pipeline. Please refer to the Edit CD Pipeline section for the details. A CI/CD pipeline helps to automate steps in a software delivery process, such as the code build initialization, automated tests running, and deploying to a staging or production environment. Automated pipelines remove manual errors, provide standardized development feedback cycle, and enable the fast product iterations. To get more information on the CI pipeline, please refer to the CI Pipeline Details chapter. The codebase stream is used as a holder for the output of the stage, i.e. after the Docker container (or an image stream in OpenShift terms) passes the stage verification, it will be placed to the new codebase stream. Every codebase has a branch that has its own codebase stream - a Docker container that is an output of the build for the corresponding branch. Note For more information on the main terms used in EPAM Delivery Platform, please refer to the EDP Glossary Explore the details of the CD pipeline below.","title":"CD Pipeline Details"},{"location":"user-guide/cd-pipeline-details/#deploy-pipeline","text":"The Deploy pipeline is used by default on any stage of the Continuous Delivery pipeline. It addresses the following concerns: Deploying the application(s) to the main STAGE (SIT, QA, UAT) environment in order to run autotests and to promote image build versions to the next environments afterwards. Deploying the application(s) to a custom STAGE environment in order to run autotests and check manually that everything is ok with the application. Deploying the latest or a stable and some particular numeric version of an image build that exists in Docker registry. Promoting the image build versions from the main STAGE (SIT, QA, UAT) environment. Find below the functional diagram of the Deploy pipeline with the default stages:","title":"Deploy Pipeline"},{"location":"user-guide/cd-pipeline-details/#related-articles","text":"Add Application Add Autotest Add CD Pipeline Add Library CI Pipeline Details CI/CD Overview EDP Glossary EDP Pipeline Framework EDP Pipeline Stages Prepare for Release","title":"Related Articles"},{"location":"user-guide/ci-pipeline-details/","text":"CI Pipeline Details \u2693\ufe0e CI Pipeline (Continuous Integration Pipeline) - an EDP business entity that describes the integration of changes made to a codebase into a single project. The main idea of the CI pipeline is to review the changes in the code submitted through a Version Control System (VCS) and build a new codebase version so that it can be transmitted to the Continuous Delivery Pipeline for the rest of the delivery process. There are three codebase types in EPAM Delivery Platform: Applications - a codebase that is developed in the Version Control System, has the full lifecycle starting from the Code Review stage to its deployment to the environment; Libraries - this codebase is similar to the Application type, but it is not deployed and stored in the Artifactory. The library can be connected to other applications/libraries; Autotests - a codebase that inspects the code and can be used as a quality gate for the CD pipeline stage. The autotest only has the Code Review pipeline and is launched for the stage verification. Note For more information on the above mentioned codebase types, please refer to the Add Application , Add Library , Add Autotests and Autotest as Quality Gate pages. Related Articles \u2693\ufe0e Add Application Add Autotest Add Library Adjust Jira Integration Adjust VCS Integration With Jira Autotest as Quality Gate Build Pipeline Code Review Pipeline Pipeline Stages","title":"CI Pipeline Details"},{"location":"user-guide/ci-pipeline-details/#ci-pipeline-details","text":"CI Pipeline (Continuous Integration Pipeline) - an EDP business entity that describes the integration of changes made to a codebase into a single project. The main idea of the CI pipeline is to review the changes in the code submitted through a Version Control System (VCS) and build a new codebase version so that it can be transmitted to the Continuous Delivery Pipeline for the rest of the delivery process. There are three codebase types in EPAM Delivery Platform: Applications - a codebase that is developed in the Version Control System, has the full lifecycle starting from the Code Review stage to its deployment to the environment; Libraries - this codebase is similar to the Application type, but it is not deployed and stored in the Artifactory. The library can be connected to other applications/libraries; Autotests - a codebase that inspects the code and can be used as a quality gate for the CD pipeline stage. The autotest only has the Code Review pipeline and is launched for the stage verification. Note For more information on the above mentioned codebase types, please refer to the Add Application , Add Library , Add Autotests and Autotest as Quality Gate pages.","title":"CI Pipeline Details"},{"location":"user-guide/ci-pipeline-details/#related-articles","text":"Add Application Add Autotest Add Library Adjust Jira Integration Adjust VCS Integration With Jira Autotest as Quality Gate Build Pipeline Code Review Pipeline Pipeline Stages","title":"Related Articles"},{"location":"user-guide/cicd-overview/","text":"EDP CI/CD Overview \u2693\ufe0e This chapter provides information on CI/CD basic definitions and flow, as well as its components and process. CI/CD Basic Definitions \u2693\ufe0e The Continuous Integration part means the following: all components of the application development are in the same place and perform the same processes for running; the results are published in one place and replicated into EPAM GitLab or VCS (version control system); the repository also includes a storage tool (e.g. Nexus) for all binary artifacts that are produced by the Jenkins CI server after submitting changes from Code Review tool into VCS; The Code Review and Build pipelines are used before the code is delivered. An important part of both of them is the integration tests that are launched during the testing stage. Many applications (SonarQube, Gerrit, etc,) used by the project need databases for their performance. The Continuous Delivery comprises an approach allowing to produce an application in short cycles so that it can be reliably released at any time point. This part is tightly bound with the usage of the Code Review , Build , and Deploy pipelines. The Deploy pipelines deploy the applications configuration and their specific versions, launch automated tests and control quality gates for the specified environment. As a result of the successfully completed process, the specific versions of images are promoted to the next environment. All environments are sequential and promote the build versions of applications one-by-one. The logic of each stage is described as a code of Jenkins pipelines and stored in the VCS. During the CI/CD, there are several continuous processes that run in the repository, find below the list of possible actions: Review the code with the help of Gerrit tool; Run the static analysis using SonarQube to control the quality of the source code and keep the historical data which helps to understand the trend and effectivity of particular teams and members; Analyze application source code using SAST, byte code, and binaries for coding/design conditions that are indicative of security vulnerabilities; Build the code with Jenkins and run automated tests that are written to make sure the applied changes will not break any functionality. Note For the details on autotests, please refer to the Autotest , Add Autotest , and Autotest as Quality Gate pages. The release process is divided into cycles and provides regular delivery of completed pieces of functionality while continuing the development and integration of new functionality into the product mainline. Explore the main flow that is displayed on the diagram below: Related Articles \u2693\ufe0e Add Application Add Library Add CD Pipeline CI Pipeline Details CD Pipeline Details Customize CI Pipeline EDP Pipeline Framework Customize CD Pipeline EDP Stages Glossary Use Terraform Library in EDP","title":"EDP CI/CD Overview"},{"location":"user-guide/cicd-overview/#edp-cicd-overview","text":"This chapter provides information on CI/CD basic definitions and flow, as well as its components and process.","title":"EDP CI/CD Overview"},{"location":"user-guide/cicd-overview/#cicd-basic-definitions","text":"The Continuous Integration part means the following: all components of the application development are in the same place and perform the same processes for running; the results are published in one place and replicated into EPAM GitLab or VCS (version control system); the repository also includes a storage tool (e.g. Nexus) for all binary artifacts that are produced by the Jenkins CI server after submitting changes from Code Review tool into VCS; The Code Review and Build pipelines are used before the code is delivered. An important part of both of them is the integration tests that are launched during the testing stage. Many applications (SonarQube, Gerrit, etc,) used by the project need databases for their performance. The Continuous Delivery comprises an approach allowing to produce an application in short cycles so that it can be reliably released at any time point. This part is tightly bound with the usage of the Code Review , Build , and Deploy pipelines. The Deploy pipelines deploy the applications configuration and their specific versions, launch automated tests and control quality gates for the specified environment. As a result of the successfully completed process, the specific versions of images are promoted to the next environment. All environments are sequential and promote the build versions of applications one-by-one. The logic of each stage is described as a code of Jenkins pipelines and stored in the VCS. During the CI/CD, there are several continuous processes that run in the repository, find below the list of possible actions: Review the code with the help of Gerrit tool; Run the static analysis using SonarQube to control the quality of the source code and keep the historical data which helps to understand the trend and effectivity of particular teams and members; Analyze application source code using SAST, byte code, and binaries for coding/design conditions that are indicative of security vulnerabilities; Build the code with Jenkins and run automated tests that are written to make sure the applied changes will not break any functionality. Note For the details on autotests, please refer to the Autotest , Add Autotest , and Autotest as Quality Gate pages. The release process is divided into cycles and provides regular delivery of completed pieces of functionality while continuing the development and integration of new functionality into the product mainline. Explore the main flow that is displayed on the diagram below:","title":"CI/CD Basic Definitions"},{"location":"user-guide/cicd-overview/#related-articles","text":"Add Application Add Library Add CD Pipeline CI Pipeline Details CD Pipeline Details Customize CI Pipeline EDP Pipeline Framework Customize CD Pipeline EDP Stages Glossary Use Terraform Library in EDP","title":"Related Articles"},{"location":"user-guide/code-review-pipeline/","text":"Code Review Pipeline \u2693\ufe0e This section provides details on the Code Review pipeline of the EDP CI/CD framework. Explore below the pipeline purpose, stages and possible actions to perform. Code Review Pipeline Purpose \u2693\ufe0e The purpose of the Code Review pipeline contains the following points: Check out and test a particular developer's change (Patch Set) in order to inspect whether the code fits all the quality gates and can be built and tested; Be triggered if any new Patch Set appears in Gerrit; Send feedback about the build process in Jenkins to review the card in Gerrit; Send feedback about Sonar violations that have been found during the Sonar stage. Find below the functional diagram of the Code Review pipeline with the default stages: Code Review Pipeline for Applications and Libraries \u2693\ufe0e Note Make sure the necessary applications or libraries are added to the Admin Console. For the details on how to add a codebase, please refer to the Add Application or Add Library pages accordingly. To discover the Code Review pipeline, apply changes that will trigger the Code Review pipeline automatically and take the following steps: Navigate to Jenkins. In Admin Console, go to the Overview section on the left-side navigation bar and click the link to Jenkins. or In Gerrit, go to the Patch Set page and click the CI Jenkins link in the Change Log section Note The Code Review pipeline starts automatically for every codebase type (Application, Autotests, Library). Check the Code Review pipeline for the application of for the library . Click the application name in Jenkins and switch to the additional release-01 branch that is created with the respective Code Review and Build pipelines. Click the Code Review pipeline link to open the Code Review pipeline stages for the application: Init - initialization of the codebase information and loading of the common libraries gerrit-checkout / checkout - the checkout of patch sets from Gerrit. The stage is called gerrit-checkout for the Create and Clone strategies of adding a codebase and checkout for the Import strategy. compile - the source code compilation tests - the launch of the tests sonar - the launch of the static code analyzer that checks the whole code helm-lint - the launch of the linting tests for deployment charts dockerfile-lint - the launch of the linting tests for Dockerfile commit-validate - the stage is optional and appears under enabled integration with Jira. Please refer to the Adjust Jira Integration and Adjust VCS Integration With Jira sections for the details. Note For more details on EDP pipeline stages, please refer to the Pipeline Stages section. Code Review Pipeline for Autotests \u2693\ufe0e To discover the Code Review pipeline for autotests, first, apply changes to a codebase that will trigger the Code Review pipeline automatically. The flow for the autotest is similar for that for applications and libraries, however, there are some differences. Explore them below. Open the run.json file for the created autotest. Note Please refer to the Add Autotest page for the details on how to create an autotest. The run.json file keeps a command that is executed on this stage. Open the Code Review pipeline in Jenkins (via the link in Gerrit or via the Admin Console Overview page) and click the Configure option from the left side. There are only four stages available: Initialization - Gerrit-checkout - tests - sonar (the launch of the static code analyzer that checks the whole code). Open the Code Review pipeline in Jenkins with the successfully passed stages. Retrigger Code Review Pipeline \u2693\ufe0e The Code Review pipeline can be retriggered manually, especially if the pipeline failed before. To retrigger it, take the following steps: In Jenkins, click the Retrigger option from the drop-down menu for the specific Code Review pipeline version number. Alternatively, click the Jenkins main page and select the Query and Trigger Gerrit Patches option. Click Search and select the check box of the necessary change and patch set and then click Trigger Selected . As a result, the Code Review pipeline will be retriggered. Configure Code Review Pipeline \u2693\ufe0e The Configure option allows adding/removing the stage from the Code Review pipeline if needed. To configure the Code Review pipeline, take the following steps: Being in Jenkins, click the Configure option from the left-side menu. Define the stages set that will be executed for the current pipeline. To remove a stage, select and remove the whole objects massive: {\"name\".\"tests\" }, where name is a key and tests is a stage name that should be executed. To add a stage, define the objects massive: {\"name\".\"tests\" }, where name is a key and tests is a stage name that should be added. Note All stages are launched from the shared library on GitHub. The list of libraries is located in the edp-library-stages repository. To apply the new stage process, retrigger the Code Review pipeline. For details, please refer to the Retrigger Code Review Pipeline section. Open Jenkins and check that there is no removed stage in the Code Review pipeline. Related Articles \u2693\ufe0e Add Application Add Autotest Add Library Adjust Jira Integration Adjust VCS Integration With Jira Autotest as Quality Gate Pipeline Stages","title":"Code Review Pipeline"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline","text":"This section provides details on the Code Review pipeline of the EDP CI/CD framework. Explore below the pipeline purpose, stages and possible actions to perform.","title":"Code Review Pipeline"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline-purpose","text":"The purpose of the Code Review pipeline contains the following points: Check out and test a particular developer's change (Patch Set) in order to inspect whether the code fits all the quality gates and can be built and tested; Be triggered if any new Patch Set appears in Gerrit; Send feedback about the build process in Jenkins to review the card in Gerrit; Send feedback about Sonar violations that have been found during the Sonar stage. Find below the functional diagram of the Code Review pipeline with the default stages:","title":"Code Review Pipeline Purpose"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline-for-applications-and-libraries","text":"Note Make sure the necessary applications or libraries are added to the Admin Console. For the details on how to add a codebase, please refer to the Add Application or Add Library pages accordingly. To discover the Code Review pipeline, apply changes that will trigger the Code Review pipeline automatically and take the following steps: Navigate to Jenkins. In Admin Console, go to the Overview section on the left-side navigation bar and click the link to Jenkins. or In Gerrit, go to the Patch Set page and click the CI Jenkins link in the Change Log section Note The Code Review pipeline starts automatically for every codebase type (Application, Autotests, Library). Check the Code Review pipeline for the application of for the library . Click the application name in Jenkins and switch to the additional release-01 branch that is created with the respective Code Review and Build pipelines. Click the Code Review pipeline link to open the Code Review pipeline stages for the application: Init - initialization of the codebase information and loading of the common libraries gerrit-checkout / checkout - the checkout of patch sets from Gerrit. The stage is called gerrit-checkout for the Create and Clone strategies of adding a codebase and checkout for the Import strategy. compile - the source code compilation tests - the launch of the tests sonar - the launch of the static code analyzer that checks the whole code helm-lint - the launch of the linting tests for deployment charts dockerfile-lint - the launch of the linting tests for Dockerfile commit-validate - the stage is optional and appears under enabled integration with Jira. Please refer to the Adjust Jira Integration and Adjust VCS Integration With Jira sections for the details. Note For more details on EDP pipeline stages, please refer to the Pipeline Stages section.","title":"Code Review Pipeline for Applications and Libraries"},{"location":"user-guide/code-review-pipeline/#code-review-pipeline-for-autotests","text":"To discover the Code Review pipeline for autotests, first, apply changes to a codebase that will trigger the Code Review pipeline automatically. The flow for the autotest is similar for that for applications and libraries, however, there are some differences. Explore them below. Open the run.json file for the created autotest. Note Please refer to the Add Autotest page for the details on how to create an autotest. The run.json file keeps a command that is executed on this stage. Open the Code Review pipeline in Jenkins (via the link in Gerrit or via the Admin Console Overview page) and click the Configure option from the left side. There are only four stages available: Initialization - Gerrit-checkout - tests - sonar (the launch of the static code analyzer that checks the whole code). Open the Code Review pipeline in Jenkins with the successfully passed stages.","title":"Code Review Pipeline for Autotests"},{"location":"user-guide/code-review-pipeline/#retrigger-code-review-pipeline","text":"The Code Review pipeline can be retriggered manually, especially if the pipeline failed before. To retrigger it, take the following steps: In Jenkins, click the Retrigger option from the drop-down menu for the specific Code Review pipeline version number. Alternatively, click the Jenkins main page and select the Query and Trigger Gerrit Patches option. Click Search and select the check box of the necessary change and patch set and then click Trigger Selected . As a result, the Code Review pipeline will be retriggered.","title":"Retrigger Code Review Pipeline"},{"location":"user-guide/code-review-pipeline/#configure-code-review-pipeline","text":"The Configure option allows adding/removing the stage from the Code Review pipeline if needed. To configure the Code Review pipeline, take the following steps: Being in Jenkins, click the Configure option from the left-side menu. Define the stages set that will be executed for the current pipeline. To remove a stage, select and remove the whole objects massive: {\"name\".\"tests\" }, where name is a key and tests is a stage name that should be executed. To add a stage, define the objects massive: {\"name\".\"tests\" }, where name is a key and tests is a stage name that should be added. Note All stages are launched from the shared library on GitHub. The list of libraries is located in the edp-library-stages repository. To apply the new stage process, retrigger the Code Review pipeline. For details, please refer to the Retrigger Code Review Pipeline section. Open Jenkins and check that there is no removed stage in the Code Review pipeline.","title":"Configure Code Review Pipeline"},{"location":"user-guide/code-review-pipeline/#related-articles","text":"Add Application Add Autotest Add Library Adjust Jira Integration Adjust VCS Integration With Jira Autotest as Quality Gate Pipeline Stages","title":"Related Articles"},{"location":"user-guide/customize-cd-pipeline/","text":"Customize CD Pipeline \u2693\ufe0e Apart from running CD pipeline stages with the default logic, there is the ability to perform the following: Create your own logic for stages; Redefine the default EDP stages of a CD pipeline. In order to have the ability to customize a stage logic, create a CD pipeline stage source as a Library: Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language: Note If you clone the library, make sure that the correct source branch is selected. Select the required fields to build your library: Go to the Continuous Delivery section of the Admin Console and create a CD pipeline with the library stage source and its branch: Add New Stage \u2693\ufe0e Follow the steps below to add a new stage: Clone the repository with the added library; Create a \"stages\" directory in the root; Create a Jenkinsfile with default content: @Library ( [ 'edp-library-stages', 'edp-library-pipelines' ] ) _ Deploy () Create a groovy file with a meaningful name, e.g. NotificationStage.groovy; Put the required construction and your own logic into the file: import com.epam.edp.stages.impl.cd.Stage @Stage ( name = \"notify\" ) class Notify { Script script void run ( context ) { --------------- Put your own logic here ------------------ script . println ( \"Send notification logic\" ) --------------- Put your own logic here ------------------ } } return Notify Add a new stage to the STAGES parameter of the Jenkins job of your CD pipeline: Warning To make this stage permanently present, please modify the job provisioner . Run the job to check that your new stage has been run during the execution. Redefine Existing Stage \u2693\ufe0e By default, the following stages are implemented in EDP pipeline framework: deploy, deploy-helm, autotests, manual (Manual approve), promote-images. Using one of these names for annotation in your own class will lead to redefining the default logic with your own. Find below a sample of the possible flow of the redefining deploy stage: Clone the repository with the added library; Create a \"stages\" directory in the root; Create a Jenkinsfile with default content: @Library ( [ 'edp-library-stages', 'edp-library-pipelines' ] ) _ Deploy () Create a groovy file with a meaningful name, e.g. CustomDeployStage.groovy; Put the required construction and your own logic into the file: import com.epam.edp.stages.impl.cd.Stage @Stage ( name = \"deploy\" ) class CustomDeployStage { Script script void run ( context ) { --------------- Put your own logic here ------------------ script . println ( \"Custom deploy stage logic\" ) --------------- Put your own logic here ------------------ } } return CustomDeployStage Add a New Stage Using Shared Library via Custom Global Pipeline Libraries \u2693\ufe0e Note To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page. To redefine any stage and add custom logic using global pipeline libraries, perform the steps below: Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language: Select the required fields to build your library: Clone the repository with the added library; Create a directory with the name src/com/epam/edp/customStages/impl/cd/impl/ in the library repository, for instance: src/com/epam/edp/customStages/impl/cd/impl/EmailNotify.groovy ; Add a Groovy file with another name to the same stages catalog, for instance \u2013 EmailNotify.groovy : package com . epam . edp . customStages . impl . cd . impl import com.epam.edp.stages.impl.cd.Stage @Stage ( name = \"notify\" ) class Notify { Script script void run ( context ) { --------------- Put your own logic here ------------------ script . println ( \"Send notification logic\" ) --------------- Put your own logic here ------------------ } } Create a Jenkinsfile with default content and the added custom library to Jenkins: @Library ( [ 'edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name' ] ) _ Deploy () Note edp-custom-shared-library-name is the name of your Custom Global Pipeline Library that should be added to the Jenkins Global Settings. Add a new stage to the STAGES parameter of the Jenkins job of your CD pipeline: Warning To make this stage permanently present, please modify the job provisioner . Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ). Run the job to check that the new stage has been running during the execution. Redefine a Default Stage Logic via Custom Global Pipeline Libraries \u2693\ufe0e Note To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page. By default, the following stages are implemented in EDP pipeline framework: deploy, deploy-helm, autotests, manual (Manual approve), promote-images. Using one of these names for annotation in your own class will lead to redefining the default logic with your own. To redefine any stage and add custom logic using global pipeline libraries, perform the steps below: Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language: Select the required fields to build your library: Clone the repository with the added library; Create a directory with the name src/com/epam/edp/customStages/impl/cd/impl/ in the library repository, for instance: src/com/epam/edp/customStages/impl/cd/impl/CustomDeployStage.groovy; ; Add a Groovy file with another name to the same stages catalog, for instance \u2013 CustomDeployStage.groovy : package com . epam . edp . customStages . impl . cd . impl import com.epam.edp.stages.impl.cd.Stage @Stage ( name = \"deploy\" ) class CustomDeployStage { Script script void run ( context ) { --------------- Put your own logic here ------------------ script . println ( \"Custom deploy stage logic\" ) --------------- Put your own logic here ------------------ } } Create a Jenkinsfile with default content and the added custom library to Jenkins: @Library ( [ 'edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name' ] ) _ Deploy () Note edp-custom-shared-library-name is the name of your Custom Global Pipeline Library that should be added to the Jenkins Global Settings. Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ). Related Articles \u2693\ufe0e Add a New Custom Global Pipeline Library Manage Jenkins CD Pipeline Job Provisioner","title":"Customize CD Pipeline"},{"location":"user-guide/customize-cd-pipeline/#customize-cd-pipeline","text":"Apart from running CD pipeline stages with the default logic, there is the ability to perform the following: Create your own logic for stages; Redefine the default EDP stages of a CD pipeline. In order to have the ability to customize a stage logic, create a CD pipeline stage source as a Library: Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language: Note If you clone the library, make sure that the correct source branch is selected. Select the required fields to build your library: Go to the Continuous Delivery section of the Admin Console and create a CD pipeline with the library stage source and its branch:","title":"Customize CD Pipeline"},{"location":"user-guide/customize-cd-pipeline/#add-new-stage","text":"Follow the steps below to add a new stage: Clone the repository with the added library; Create a \"stages\" directory in the root; Create a Jenkinsfile with default content: @Library ( [ 'edp-library-stages', 'edp-library-pipelines' ] ) _ Deploy () Create a groovy file with a meaningful name, e.g. NotificationStage.groovy; Put the required construction and your own logic into the file: import com.epam.edp.stages.impl.cd.Stage @Stage ( name = \"notify\" ) class Notify { Script script void run ( context ) { --------------- Put your own logic here ------------------ script . println ( \"Send notification logic\" ) --------------- Put your own logic here ------------------ } } return Notify Add a new stage to the STAGES parameter of the Jenkins job of your CD pipeline: Warning To make this stage permanently present, please modify the job provisioner . Run the job to check that your new stage has been run during the execution.","title":"Add New Stage"},{"location":"user-guide/customize-cd-pipeline/#redefine-existing-stage","text":"By default, the following stages are implemented in EDP pipeline framework: deploy, deploy-helm, autotests, manual (Manual approve), promote-images. Using one of these names for annotation in your own class will lead to redefining the default logic with your own. Find below a sample of the possible flow of the redefining deploy stage: Clone the repository with the added library; Create a \"stages\" directory in the root; Create a Jenkinsfile with default content: @Library ( [ 'edp-library-stages', 'edp-library-pipelines' ] ) _ Deploy () Create a groovy file with a meaningful name, e.g. CustomDeployStage.groovy; Put the required construction and your own logic into the file: import com.epam.edp.stages.impl.cd.Stage @Stage ( name = \"deploy\" ) class CustomDeployStage { Script script void run ( context ) { --------------- Put your own logic here ------------------ script . println ( \"Custom deploy stage logic\" ) --------------- Put your own logic here ------------------ } } return CustomDeployStage","title":"Redefine Existing Stage"},{"location":"user-guide/customize-cd-pipeline/#add-a-new-stage-using-shared-library-via-custom-global-pipeline-libraries","text":"Note To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page. To redefine any stage and add custom logic using global pipeline libraries, perform the steps below: Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language: Select the required fields to build your library: Clone the repository with the added library; Create a directory with the name src/com/epam/edp/customStages/impl/cd/impl/ in the library repository, for instance: src/com/epam/edp/customStages/impl/cd/impl/EmailNotify.groovy ; Add a Groovy file with another name to the same stages catalog, for instance \u2013 EmailNotify.groovy : package com . epam . edp . customStages . impl . cd . impl import com.epam.edp.stages.impl.cd.Stage @Stage ( name = \"notify\" ) class Notify { Script script void run ( context ) { --------------- Put your own logic here ------------------ script . println ( \"Send notification logic\" ) --------------- Put your own logic here ------------------ } } Create a Jenkinsfile with default content and the added custom library to Jenkins: @Library ( [ 'edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name' ] ) _ Deploy () Note edp-custom-shared-library-name is the name of your Custom Global Pipeline Library that should be added to the Jenkins Global Settings. Add a new stage to the STAGES parameter of the Jenkins job of your CD pipeline: Warning To make this stage permanently present, please modify the job provisioner . Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ). Run the job to check that the new stage has been running during the execution.","title":"Add a New Stage Using Shared Library via Custom Global Pipeline Libraries"},{"location":"user-guide/customize-cd-pipeline/#redefine-a-default-stage-logic-via-custom-global-pipeline-libraries","text":"Note To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page. By default, the following stages are implemented in EDP pipeline framework: deploy, deploy-helm, autotests, manual (Manual approve), promote-images. Using one of these names for annotation in your own class will lead to redefining the default logic with your own. To redefine any stage and add custom logic using global pipeline libraries, perform the steps below: Navigate to the Libraries section of the Admin Console and create a library with the Groovy-pipeline code language: Select the required fields to build your library: Clone the repository with the added library; Create a directory with the name src/com/epam/edp/customStages/impl/cd/impl/ in the library repository, for instance: src/com/epam/edp/customStages/impl/cd/impl/CustomDeployStage.groovy; ; Add a Groovy file with another name to the same stages catalog, for instance \u2013 CustomDeployStage.groovy : package com . epam . edp . customStages . impl . cd . impl import com.epam.edp.stages.impl.cd.Stage @Stage ( name = \"deploy\" ) class CustomDeployStage { Script script void run ( context ) { --------------- Put your own logic here ------------------ script . println ( \"Custom deploy stage logic\" ) --------------- Put your own logic here ------------------ } } Create a Jenkinsfile with default content and the added custom library to Jenkins: @Library ( [ 'edp-library-stages', 'edp-library-pipelines', 'edp-custom-shared-library-name' ] ) _ Deploy () Note edp-custom-shared-library-name is the name of your Custom Global Pipeline Library that should be added to the Jenkins Global Settings. Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ).","title":"Redefine a Default Stage Logic via Custom Global Pipeline Libraries"},{"location":"user-guide/customize-cd-pipeline/#related-articles","text":"Add a New Custom Global Pipeline Library Manage Jenkins CD Pipeline Job Provisioner","title":"Related Articles"},{"location":"user-guide/customize-ci-pipeline/","text":"Customize CI Pipeline \u2693\ufe0e This chapter describes the main steps that should be followed when customizing a CI pipeline. Redefine a Default Stage Logic for a Particular Application \u2693\ufe0e To redefine any stage and add custom logic, perform the steps below: Open the GitHub repository: Create a directory with the name \u201cstages\u201d in the application repository; Create a Groovy file with a meaningful name for a custom stage description, for instance: CustomSonar.groovy . Paste the copied skeleton from the reference stage and insert the necessary logic. Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ). The stage logic structure is the following: CustomSonar.groovy import com.epam.edp.stages.impl.ci.ProjectType import com.epam.edp.stages.impl.ci.Stage @Stage ( name = \"sonar\" , buildTool = [ \"maven\" ], type = [ ProjectType . APPLICATION , ProjectType . AUTOTESTS , ProjectType . LIBRARY ]) class CustomSonar { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return CustomSonar Info There is the ability to redefine the predefined EDP stage as well as to create it from scratch, it depends on the name that is used in the @Stage annotation. For example, using name = \"sonar\" will redefine an existing sonar stage with the same name, but using name=\"new-sonar\" will create a new stage. By default, the following stages are implemented in EDP: build build-image-from-dockerfile build-image build-image-kaniko checkout compile create-branch gerrit-checkout get-version git-tag push sonar sonar-cleanup tests trigger-job Mandatory points: Importing classes com.epam.edp.stages.impl.ci.ProjectType and com.epam.edp.stages.impl.ci.Stage; Annotating \"Stage\" for class - @Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]); Property with the type \"Script\"; Void the \"run\" method with the \"context input parameter\" value; Bring the custom class back to the end of the file: return CustomSonar. Open Jenkins and make sure that all the changes are correct after the completion of the customized pipeline. Add a New Stage for a Particular Application \u2693\ufe0e To add a new stage for a particular application, perform the steps below: In the GitHub repository, add a Groovy file with another name to the same stages catalog. Copy the part of a pipeline framework logic that cannot be predefined; The stage logic structure is the following: EmailNotify.groovy import com.epam.edp.stages.impl.ci.ProjectType import com.epam.edp.stages.impl.ci.Stage @Stage ( name = \"email-notify\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class EmailNotify { Script script void run ( context ) { ------------------- 'Your custom logic here' } } return EmailNotify Open the default set of stages and add a new one into the Default Value field by saving the respective type {\"name\": \"email-notify\"}, save the changes: Open Jenkins to check the pipeline; as soon as the checkout stage is passed, the new stage will appear in the pipeline: Warning To make this stage permanently present, please modify the job provisioner . Redefine a Default Stage Logic via Custom Global Pipeline Libraries \u2693\ufe0e Note To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page. To redefine any stage and add custom logic using global pipeline libraries, perform the steps below: Open the GitHub repository: Create a directory with the name /src/com/epam/edp/customStages/impl/ci/impl/stageName/ in the library repository, for instance: /src/com/epam/edp/customStages/impl/ci/impl/sonar/ ; Create a Groovy file with a meaningful name for a custom stage description, for instance \u2013 CustomSonar.groovy . Paste the copied skeleton from the reference stage and insert the necessary logic. Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ). The stage logic structure is the following: CustomSonar.groovy package com . epam . edp . customStages . impl . ci . impl . sonar import com.epam.edp.stages.impl.ci.ProjectType import com.epam.edp.stages.impl.ci.Stage @Stage ( name = \"sonar\" , buildTool = [ \"maven\" ], type = [ ProjectType . APPLICATION , ProjectType . AUTOTESTS , ProjectType . LIBRARY ]) class CustomSonar { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return CustomSonar Info There is the ability to redefine the predefined EDP stage as well as to create it from scratch, it depends on the name that is used in the @Stage annotation. For example, using name = \"sonar\" will redefine an existing sonar stage with the same name, but using name=\"new-sonar\" will create a new stage. By default, the following stages are implemented in EDP: build build-image-from-dockerfile build-image build-image-kaniko checkout compile create-branch gerrit-checkout get-version git-tag push sonar sonar-cleanup tests trigger-job Mandatory points: Defining a package com.epam.edp.customStages.impl.ci.impl.stageName; Importing classes com.epam.edp.stages.impl.ci.ProjectType and com.epam.edp.stages.impl.ci.Stage; Annotating \"Stage\" for class - @Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]); Property with the type \"Script\"; Void the \"run\" method with the \"context input parameter\" value; Bring the custom class back to the end of the file: return CustomSonar. 3.Open Jenkins and make sure that all the changes are correct after the completion of the customized pipeline. Add a New Stage Using Shared Library via Custom Global Pipeline Libraries \u2693\ufe0e Note To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page. To redefine any stage and add custom logic using global pipeline libraries, perform the steps below: Open the GitHub repository: Create a directory with the name /src/com/epam/edp/customStages/impl/ci/impl/stageName/ in the library repository, for instance: /src/com/epam/edp/customStages/impl/ci/impl/email-notify/ ; Add a Groovy file with another name to the same stages catalog, for instance \u2013 EmailNotify.groovy . Copy the part of a pipeline framework logic that cannot be predefined; Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ). The stage logic structure is the following: EmailNotify.groovy package com . epam . edp . customStages . impl . ci . impl . emailNotify import com.epam.edp.stages.impl.ci.ProjectType import com.epam.edp.stages.impl.ci.Stage @Stage ( name = \"email-notify\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class EmailNotify { Script script void run ( context ) { ------------------- 'Your custom logic here' } } return EmailNotify Open the default set of stages and add a new one into the Default Value field by saving the respective type {\"name\": \"email-notify\"}, save the changes: Open Jenkins to check the pipeline; as soon as the checkout stage is passed, the new stage will appear in the pipeline: Warning To make this stage permanently present, please modify the job provisioner . Related Articles \u2693\ufe0e Add a New Custom Global Pipeline Library Manage Jenkins CI Pipeline Job Provisioner","title":"Customize CI Pipeline"},{"location":"user-guide/customize-ci-pipeline/#customize-ci-pipeline","text":"This chapter describes the main steps that should be followed when customizing a CI pipeline.","title":"Customize CI Pipeline"},{"location":"user-guide/customize-ci-pipeline/#redefine-a-default-stage-logic-for-a-particular-application","text":"To redefine any stage and add custom logic, perform the steps below: Open the GitHub repository: Create a directory with the name \u201cstages\u201d in the application repository; Create a Groovy file with a meaningful name for a custom stage description, for instance: CustomSonar.groovy . Paste the copied skeleton from the reference stage and insert the necessary logic. Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ). The stage logic structure is the following: CustomSonar.groovy import com.epam.edp.stages.impl.ci.ProjectType import com.epam.edp.stages.impl.ci.Stage @Stage ( name = \"sonar\" , buildTool = [ \"maven\" ], type = [ ProjectType . APPLICATION , ProjectType . AUTOTESTS , ProjectType . LIBRARY ]) class CustomSonar { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return CustomSonar Info There is the ability to redefine the predefined EDP stage as well as to create it from scratch, it depends on the name that is used in the @Stage annotation. For example, using name = \"sonar\" will redefine an existing sonar stage with the same name, but using name=\"new-sonar\" will create a new stage. By default, the following stages are implemented in EDP: build build-image-from-dockerfile build-image build-image-kaniko checkout compile create-branch gerrit-checkout get-version git-tag push sonar sonar-cleanup tests trigger-job Mandatory points: Importing classes com.epam.edp.stages.impl.ci.ProjectType and com.epam.edp.stages.impl.ci.Stage; Annotating \"Stage\" for class - @Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]); Property with the type \"Script\"; Void the \"run\" method with the \"context input parameter\" value; Bring the custom class back to the end of the file: return CustomSonar. Open Jenkins and make sure that all the changes are correct after the completion of the customized pipeline.","title":"Redefine a Default Stage Logic for a Particular Application"},{"location":"user-guide/customize-ci-pipeline/#add-a-new-stage-for-a-particular-application","text":"To add a new stage for a particular application, perform the steps below: In the GitHub repository, add a Groovy file with another name to the same stages catalog. Copy the part of a pipeline framework logic that cannot be predefined; The stage logic structure is the following: EmailNotify.groovy import com.epam.edp.stages.impl.ci.ProjectType import com.epam.edp.stages.impl.ci.Stage @Stage ( name = \"email-notify\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class EmailNotify { Script script void run ( context ) { ------------------- 'Your custom logic here' } } return EmailNotify Open the default set of stages and add a new one into the Default Value field by saving the respective type {\"name\": \"email-notify\"}, save the changes: Open Jenkins to check the pipeline; as soon as the checkout stage is passed, the new stage will appear in the pipeline: Warning To make this stage permanently present, please modify the job provisioner .","title":"Add a New Stage for a Particular Application"},{"location":"user-guide/customize-ci-pipeline/#redefine-a-default-stage-logic-via-custom-global-pipeline-libraries","text":"Note To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page. To redefine any stage and add custom logic using global pipeline libraries, perform the steps below: Open the GitHub repository: Create a directory with the name /src/com/epam/edp/customStages/impl/ci/impl/stageName/ in the library repository, for instance: /src/com/epam/edp/customStages/impl/ci/impl/sonar/ ; Create a Groovy file with a meaningful name for a custom stage description, for instance \u2013 CustomSonar.groovy . Paste the copied skeleton from the reference stage and insert the necessary logic. Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ). The stage logic structure is the following: CustomSonar.groovy package com . epam . edp . customStages . impl . ci . impl . sonar import com.epam.edp.stages.impl.ci.ProjectType import com.epam.edp.stages.impl.ci.Stage @Stage ( name = \"sonar\" , buildTool = [ \"maven\" ], type = [ ProjectType . APPLICATION , ProjectType . AUTOTESTS , ProjectType . LIBRARY ]) class CustomSonar { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return CustomSonar Info There is the ability to redefine the predefined EDP stage as well as to create it from scratch, it depends on the name that is used in the @Stage annotation. For example, using name = \"sonar\" will redefine an existing sonar stage with the same name, but using name=\"new-sonar\" will create a new stage. By default, the following stages are implemented in EDP: build build-image-from-dockerfile build-image build-image-kaniko checkout compile create-branch gerrit-checkout get-version git-tag push sonar sonar-cleanup tests trigger-job Mandatory points: Defining a package com.epam.edp.customStages.impl.ci.impl.stageName; Importing classes com.epam.edp.stages.impl.ci.ProjectType and com.epam.edp.stages.impl.ci.Stage; Annotating \"Stage\" for class - @Stage(name = \"sonar\", buildTool = [\"maven\"], type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY]); Property with the type \"Script\"; Void the \"run\" method with the \"context input parameter\" value; Bring the custom class back to the end of the file: return CustomSonar. 3.Open Jenkins and make sure that all the changes are correct after the completion of the customized pipeline.","title":"Redefine a Default Stage Logic via Custom Global Pipeline Libraries"},{"location":"user-guide/customize-ci-pipeline/#add-a-new-stage-using-shared-library-via-custom-global-pipeline-libraries","text":"Note To add a new Custom Global Pipeline Library, please refer to the Add a New Custom Global Pipeline Library page. To redefine any stage and add custom logic using global pipeline libraries, perform the steps below: Open the GitHub repository: Create a directory with the name /src/com/epam/edp/customStages/impl/ci/impl/stageName/ in the library repository, for instance: /src/com/epam/edp/customStages/impl/ci/impl/email-notify/ ; Add a Groovy file with another name to the same stages catalog, for instance \u2013 EmailNotify.groovy . Copy the part of a pipeline framework logic that cannot be predefined; Note Pay attention to the appropriate annotation (EDP versions of all stages can be found on GitHub ). The stage logic structure is the following: EmailNotify.groovy package com . epam . edp . customStages . impl . ci . impl . emailNotify import com.epam.edp.stages.impl.ci.ProjectType import com.epam.edp.stages.impl.ci.Stage @Stage ( name = \"email-notify\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class EmailNotify { Script script void run ( context ) { ------------------- 'Your custom logic here' } } return EmailNotify Open the default set of stages and add a new one into the Default Value field by saving the respective type {\"name\": \"email-notify\"}, save the changes: Open Jenkins to check the pipeline; as soon as the checkout stage is passed, the new stage will appear in the pipeline: Warning To make this stage permanently present, please modify the job provisioner .","title":"Add a New Stage Using Shared Library via Custom Global Pipeline Libraries"},{"location":"user-guide/customize-ci-pipeline/#related-articles","text":"Add a New Custom Global Pipeline Library Manage Jenkins CI Pipeline Job Provisioner","title":"Related Articles"},{"location":"user-guide/d-d-diagram/","text":"Delivery Dashboard Diagram \u2693\ufe0e Admin Console allows getting the general visualization of all the relations between CD pipeline, stages, codebases, branches, and image streams that are elements with the specific icon. To open the current project diagram, navigate to the Delivery Dashboard Diagram section on the navigation bar: Info All the requested changes (deletion, creation, adding) are displayed immediately on the Delivery Dashboard Diagram. Possible actions when using dashboard: To zoom in or zoom out the diagram scale, scroll up / down. To move the diagram, click and drag. To move an element, click it and drag to the necessary place. To see the relations for one element, click this element. To see the whole diagram, click the empty space. Related Articles \u2693\ufe0e EDP Admin Console","title":"Delivery Dashboard Diagram"},{"location":"user-guide/d-d-diagram/#delivery-dashboard-diagram","text":"Admin Console allows getting the general visualization of all the relations between CD pipeline, stages, codebases, branches, and image streams that are elements with the specific icon. To open the current project diagram, navigate to the Delivery Dashboard Diagram section on the navigation bar: Info All the requested changes (deletion, creation, adding) are displayed immediately on the Delivery Dashboard Diagram. Possible actions when using dashboard: To zoom in or zoom out the diagram scale, scroll up / down. To move the diagram, click and drag. To move an element, click it and drag to the necessary place. To see the relations for one element, click this element. To see the whole diagram, click the empty space.","title":"Delivery Dashboard Diagram"},{"location":"user-guide/d-d-diagram/#related-articles","text":"EDP Admin Console","title":"Related Articles"},{"location":"user-guide/dockerfile-stages/","text":"Use Dockerfile Linters for Code Review Pipeline \u2693\ufe0e This section contains the description of dockerbuild-verify , dockerfile-lint stages which one can use in Code Review pipeline. These stages help to obtain a quick response on the validity of the code in the Code Review pipeline in Kubernetes for all types of applications supported by EDP out of the box. Inspect the functions performed by the following stages: dockerbuild-verify stage collects artifacts and builds an image from the Dockerfile without push to registry. This stage is intended to check if the image is built. dockerfile-lint stage launches the hadolint command in order to check the Dockerfile. Related Articles \u2693\ufe0e Use Terraform Library in EDP EDP Pipeline Framework Promote Docker Images From ECR to Docker Hub","title":"Dockerfile"},{"location":"user-guide/dockerfile-stages/#use-dockerfile-linters-for-code-review-pipeline","text":"This section contains the description of dockerbuild-verify , dockerfile-lint stages which one can use in Code Review pipeline. These stages help to obtain a quick response on the validity of the code in the Code Review pipeline in Kubernetes for all types of applications supported by EDP out of the box. Inspect the functions performed by the following stages: dockerbuild-verify stage collects artifacts and builds an image from the Dockerfile without push to registry. This stage is intended to check if the image is built. dockerfile-lint stage launches the hadolint command in order to check the Dockerfile.","title":"Use Dockerfile Linters for Code Review Pipeline"},{"location":"user-guide/dockerfile-stages/#related-articles","text":"Use Terraform Library in EDP EDP Pipeline Framework Promote Docker Images From ECR to Docker Hub","title":"Related Articles"},{"location":"user-guide/ecr-to-docker-stages/","text":"Promote Docker Images From ECR to Docker Hub \u2693\ufe0e This section contains the description of the ecr-to-docker stage, available in the Build pipeline. The ecr-to-docker stage is intended to perform the push of Docker images collected from the Amazon ECR cluster storage to Docker Hub repositories, where the image becomes accessible to everyone who wants to use it. This stage is optional and is designed for working with various EDP components. Note When pushing the image from ECR to Docker Hub using crane , the SHA-256 value remains unchanged. The ecr-to-docker stage contains a specific script that launches the following actions: Performs authorization in AWS ECR in the EDP private storage via awsv2 . Performs authorization in the Docker Hub. Checks whether a similar image exists in the Docker Hub in order to avoid its overwriting. If a similar image exists in the Docker Hub, the script will return the message about it and stop the execution. The ecr-to-docker stage in the Build pipeline will be marked in red. If there is no similar image, the script will proceed to promote the image using crane . EDP expects authorization credentials to be added in Jenkins under the following names dockerCredentialsId and repoCredentialsID . To get more information on how to create credentials, see the section Create Credentials for ECR-to-Docker Stage below. Create Credentials for ECR-to-Docker Stage \u2693\ufe0e The dockerCredentialsId and repoCredentialsID credentials are expected to be set in Jenkins in order to use the ecr-to-docker stage. Inspect below the instructions on how to create the required credentials. dockerCredentialsId \u2693\ufe0e In order to create the dockerCredentialsId value, perform the following steps: Go to Jenkins -> Manage Jenkins \u2013> Manage Credentials section. Click the Add Credentials button and select Username with password in the Kind field. In the Username field, enter the login of the account from which the push will be made and add the password field. Specify the ID and description fields. Pay attention to add the dockerCredentialsId value in both fields. Click the Save button. repoCredentialsId \u2693\ufe0e The repoCredentialsId value is created in order to indicate the name of the repository that does not match the login of the Docker account. Due to the fact that the repository can be an Enterprise solution and, accordingly, users can push images to the repository from other accounts connected within the Docker Hub Organization. To create the repoCredentialsID value, follow the steps below: Go to Jenkins -> Manage Jenkins \u2013> Manage Credentials section. Click the Add Credentials button and select Secret text in the Kind field. Enter the text that will be encrypted by Jenkins, in the Secret field. Specify the ID and description fields. Pay attention to add the repoCredentialsID value in both fields. Click the Save button. As a result, the created credentials will appear in Jenkins in the Global credentials section. Related Articles \u2693\ufe0e EDP Pipeline Framework","title":"ECR-to-DockerHub"},{"location":"user-guide/ecr-to-docker-stages/#promote-docker-images-from-ecr-to-docker-hub","text":"This section contains the description of the ecr-to-docker stage, available in the Build pipeline. The ecr-to-docker stage is intended to perform the push of Docker images collected from the Amazon ECR cluster storage to Docker Hub repositories, where the image becomes accessible to everyone who wants to use it. This stage is optional and is designed for working with various EDP components. Note When pushing the image from ECR to Docker Hub using crane , the SHA-256 value remains unchanged. The ecr-to-docker stage contains a specific script that launches the following actions: Performs authorization in AWS ECR in the EDP private storage via awsv2 . Performs authorization in the Docker Hub. Checks whether a similar image exists in the Docker Hub in order to avoid its overwriting. If a similar image exists in the Docker Hub, the script will return the message about it and stop the execution. The ecr-to-docker stage in the Build pipeline will be marked in red. If there is no similar image, the script will proceed to promote the image using crane . EDP expects authorization credentials to be added in Jenkins under the following names dockerCredentialsId and repoCredentialsID . To get more information on how to create credentials, see the section Create Credentials for ECR-to-Docker Stage below.","title":"Promote Docker Images From ECR to Docker Hub"},{"location":"user-guide/ecr-to-docker-stages/#create-credentials-for-ecr-to-docker-stage","text":"The dockerCredentialsId and repoCredentialsID credentials are expected to be set in Jenkins in order to use the ecr-to-docker stage. Inspect below the instructions on how to create the required credentials.","title":"Create Credentials for ECR-to-Docker Stage"},{"location":"user-guide/ecr-to-docker-stages/#dockercredentialsid","text":"In order to create the dockerCredentialsId value, perform the following steps: Go to Jenkins -> Manage Jenkins \u2013> Manage Credentials section. Click the Add Credentials button and select Username with password in the Kind field. In the Username field, enter the login of the account from which the push will be made and add the password field. Specify the ID and description fields. Pay attention to add the dockerCredentialsId value in both fields. Click the Save button.","title":"dockerCredentialsId"},{"location":"user-guide/ecr-to-docker-stages/#repocredentialsid","text":"The repoCredentialsId value is created in order to indicate the name of the repository that does not match the login of the Docker account. Due to the fact that the repository can be an Enterprise solution and, accordingly, users can push images to the repository from other accounts connected within the Docker Hub Organization. To create the repoCredentialsID value, follow the steps below: Go to Jenkins -> Manage Jenkins \u2013> Manage Credentials section. Click the Add Credentials button and select Secret text in the Kind field. Enter the text that will be encrypted by Jenkins, in the Secret field. Specify the ID and description fields. Pay attention to add the repoCredentialsID value in both fields. Click the Save button. As a result, the created credentials will appear in Jenkins in the Global credentials section.","title":"repoCredentialsId"},{"location":"user-guide/ecr-to-docker-stages/#related-articles","text":"EDP Pipeline Framework","title":"Related Articles"},{"location":"user-guide/helm-stages/","text":"Use Chart Testing Tool for Code Review Pipeline \u2693\ufe0e This section contains the description of helm-lint stage which one can use in the Code Review pipeline. This stage helps to obtain a quick response on the validity of the code in the Code Review pipeline for all types of applications supported by EDP out of the box. Inspect the functions performed by the following stages: helm-lint stage launches the ct lint --charts-deploy-templates/ command in order to validate the chart. Related Articles \u2693\ufe0e EDP Pipeline Framework","title":"Helm"},{"location":"user-guide/helm-stages/#use-chart-testing-tool-for-code-review-pipeline","text":"This section contains the description of helm-lint stage which one can use in the Code Review pipeline. This stage helps to obtain a quick response on the validity of the code in the Code Review pipeline for all types of applications supported by EDP out of the box. Inspect the functions performed by the following stages: helm-lint stage launches the ct lint --charts-deploy-templates/ command in order to validate the chart.","title":"Use Chart Testing Tool for Code Review Pipeline"},{"location":"user-guide/helm-stages/#related-articles","text":"EDP Pipeline Framework","title":"Related Articles"},{"location":"user-guide/library/","text":"Library \u2693\ufe0e This section describes the subsequent possible actions that can be performed with the newly added or existing libraries. Check and Remove Library \u2693\ufe0e As soon as the library is successfully provisioned, the following will be created: Code Review and Build pipelines in Jenkins for this library. The Build pipeline will be triggered automatically if at least one environment is already added. A new project in Gerrit or another VCS. SonarQube integration will be available after the Build pipeline in Jenkins is passed. Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well. Info To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link. The added library will be listed in the Libraries list allowing to do the following: Create another library by clicking the Create button and performing the same steps as described on the Add Library page; Open library data by clicking its link name. Once clicked, the following blocks will be displayed: General Info - displays common information about the created/cloned/imported library. Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type). Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields: Build Number - indicates the current build number; Last Successful Build - indicates the last successful build number. Status Info - displays all the actions that were performed during the creation/cloning/importing process. Edit the library codebase by clicking the pencil icon. For details see the Edit Existing Codebase section. Remove library with the corresponding database and Jenkins pipelines: Click the delete icon next to the library name; Type the required library name; Confirm the deletion by clicking the Delete button. Note The library that is used in a CD pipeline cannot be removed. Select a number of existing libraries to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page. Sort the existing libraries in a list by clicking the Name title. The libraries will be displayed in an alphabetical order. Search the necessary application by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the library name, language or a build tool. Navigate between pages, if the number of libraries exceeds the capacity of a single page. Edit Existing Codebase \u2693\ufe0e The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for applications via the Edit Codebase page. Perform the editing from one of the following sections on the Admin Console interface: Navigate to the codebase overview page and click the pencil icon, or Navigate to the codebase list page and click the pencil icon. To enable Jira integration, on the Edit Codebase page do the following: mark the Integrate with Jira server check box and fill in the necessary fields; click the Proceed button to apply the changes; navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline. To disable Jira integration, on the Edit Codebase page do the following: unmark the Integrate with Jira server check box; click the Proceed button to apply the changes; navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline. As a result, the necessary changes will be applied. Add a New Branch \u2693\ufe0e When adding a library, the default branch is a master branch. In order to add a new branch, follow the steps below: Navigate to the Branches block and click the Create button: Fill in the required fields: a. Release Branch - select the Release Branch check box if you need to create a release branch; b. Branch Name - type the branch name. Pay attention that this field remain static if you create a release branch. c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used. d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number. e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number; f. Click the Proceed button and wait until the new branch will be added to the list. Info Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer to Advanced Settings Menu section of the Admin Console user guide. The default library repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version. Remove Branch \u2693\ufe0e In order to remove the added branch with the corresponding record in the Admin Console database, do the following: Navigate to the Branches block by clicking the library name link in the Libraries list; Click the delete icon related to the necessary branch: Enter the branch name and click the Delete button; Note The default master branch cannot be removed. Related Articles \u2693\ufe0e Add Library","title":"Overview"},{"location":"user-guide/library/#library","text":"This section describes the subsequent possible actions that can be performed with the newly added or existing libraries.","title":"Library"},{"location":"user-guide/library/#check-and-remove-library","text":"As soon as the library is successfully provisioned, the following will be created: Code Review and Build pipelines in Jenkins for this library. The Build pipeline will be triggered automatically if at least one environment is already added. A new project in Gerrit or another VCS. SonarQube integration will be available after the Build pipeline in Jenkins is passed. Nexus Repository Manager will be available after the Build pipeline in Jenkins is passed as well. Info To navigate quickly to OpenShift, Jenkins, Gerrit, SonarQube, Nexus, and other resources, click the Overview section on the navigation bar and hit the necessary link. The added library will be listed in the Libraries list allowing to do the following: Create another library by clicking the Create button and performing the same steps as described on the Add Library page; Open library data by clicking its link name. Once clicked, the following blocks will be displayed: General Info - displays common information about the created/cloned/imported library. Advanced Settings - displays the specified job provisioner, Jenkins agent, deployment script, and the versioning type with the start versioning from number (the latter two fields appear in case of edp versioning type). Branches - displays the status and name of the deployment branch, keeps the additional links to Jenkins and Gerrit. In case of edp versioning type, there are two additional fields: Build Number - indicates the current build number; Last Successful Build - indicates the last successful build number. Status Info - displays all the actions that were performed during the creation/cloning/importing process. Edit the library codebase by clicking the pencil icon. For details see the Edit Existing Codebase section. Remove library with the corresponding database and Jenkins pipelines: Click the delete icon next to the library name; Type the required library name; Confirm the deletion by clicking the Delete button. Note The library that is used in a CD pipeline cannot be removed. Select a number of existing libraries to be displayed on one page in the Show entries field. The filter allows to show 10, 25, 50 or 100 entries per page. Sort the existing libraries in a list by clicking the Name title. The libraries will be displayed in an alphabetical order. Search the necessary application by entering the corresponding name, language or the build tool into the Search field. The search can be performed by the library name, language or a build tool. Navigate between pages, if the number of libraries exceeds the capacity of a single page.","title":"Check and Remove Library"},{"location":"user-guide/library/#edit-existing-codebase","text":"The EDP Admin Console provides the ability to enable, disable or edit the Jira Integration functionality for applications via the Edit Codebase page. Perform the editing from one of the following sections on the Admin Console interface: Navigate to the codebase overview page and click the pencil icon, or Navigate to the codebase list page and click the pencil icon. To enable Jira integration, on the Edit Codebase page do the following: mark the Integrate with Jira server check box and fill in the necessary fields; click the Proceed button to apply the changes; navigate to Jenkins and add the create-jira-issue-metadata stage in the Build pipeline. Also add the commit-validate stage in the Code Review pipeline. To disable Jira integration, on the Edit Codebase page do the following: unmark the Integrate with Jira server check box; click the Proceed button to apply the changes; navigate to Jenkins and remove the create-jira-issue-metadata stage in the Build pipeline. Also remove the commit-validate stage in the Code Review pipeline. As a result, the necessary changes will be applied.","title":"Edit Existing Codebase"},{"location":"user-guide/library/#add-a-new-branch","text":"When adding a library, the default branch is a master branch. In order to add a new branch, follow the steps below: Navigate to the Branches block and click the Create button: Fill in the required fields: a. Release Branch - select the Release Branch check box if you need to create a release branch; b. Branch Name - type the branch name. Pay attention that this field remain static if you create a release branch. c. From Commit Hash - paste the commit hash from which the new branch will be created. Note that if the From Commit Hash field is empty, the latest commit from the branch name will be used. d. Branch Version - enter the necessary branch version for the artifact. The Release Candidate (RC) postfix is concatenated to the branch version number. e. Master Branch Version - type the branch version that will be used in a master branch after the release creation. The Snapshot postfix is concatenated to the master branch version number; f. Click the Proceed button and wait until the new branch will be added to the list. Info Adding of a new branch is indicated in the context of the edp versioning type. To get more detailed information on how to add a branch using the default versioning type, please refer to Advanced Settings Menu section of the Admin Console user guide. The default library repository is cloned and changed to the new indicated version before the build, i.e. the new indicated version will not be committed to the repository; thus, the existing repository will keep the default version.","title":"Add a New Branch"},{"location":"user-guide/library/#remove-branch","text":"In order to remove the added branch with the corresponding record in the Admin Console database, do the following: Navigate to the Branches block by clicking the library name link in the Libraries list; Click the delete icon related to the necessary branch: Enter the branch name and click the Delete button; Note The default master branch cannot be removed.","title":"Remove Branch"},{"location":"user-guide/library/#related-articles","text":"Add Library","title":"Related Articles"},{"location":"user-guide/opa-stages/","text":"Use Open Policy Agent \u2693\ufe0e Open Policy Agent (OPA) is a policy engine that provides: High-level declarative policy language Rego ; API and tooling for policy execution. EPAM Delivery Platform ensures the implemented Open Policy Agent support allowing to work with Open Policy Agent bundles that is processed by means of stages in the Code Review and Build pipelines. These pipelines are expected to be created after the Rego OPA Library is added. Code Review Pipeline Stages \u2693\ufe0e In the Code Review pipeline, the following stages are available: checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository. tests stage containing a script that performs the following actions: 2.1. Runs policy tests . 2.2. Converts OPA test results into JUnit format. 2.3. Publishes JUnit-formatted results to Jenkins. Build Pipeline Stages \u2693\ufe0e In the Build pipeline, the following stages are available: checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository. get-version optional stage, a step where library version is determined either via: 2.1. Standard EDP versioning functionality. 2.2. Manually specified version. In this case .manifest file in a root directory MUST be provided. File must contain a JSON document with revision field. Minimal example: { \"revision\": \"1.0.0\" }\" . tests stage containing a script that performs the following actions: 3.1. Runs policy tests . 3.2. Converts OPA test results into JUnit format. 3.3. Publishes JUnit-formatted results to Jenkins. git-tag stage, a standard step where git branch is tagged with a version. Related Articles \u2693\ufe0e EDP Pipeline Framework","title":"Open Policy Agent"},{"location":"user-guide/opa-stages/#use-open-policy-agent","text":"Open Policy Agent (OPA) is a policy engine that provides: High-level declarative policy language Rego ; API and tooling for policy execution. EPAM Delivery Platform ensures the implemented Open Policy Agent support allowing to work with Open Policy Agent bundles that is processed by means of stages in the Code Review and Build pipelines. These pipelines are expected to be created after the Rego OPA Library is added.","title":"Use Open Policy Agent"},{"location":"user-guide/opa-stages/#code-review-pipeline-stages","text":"In the Code Review pipeline, the following stages are available: checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository. tests stage containing a script that performs the following actions: 2.1. Runs policy tests . 2.2. Converts OPA test results into JUnit format. 2.3. Publishes JUnit-formatted results to Jenkins.","title":"Code Review Pipeline Stages"},{"location":"user-guide/opa-stages/#build-pipeline-stages","text":"In the Build pipeline, the following stages are available: checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository. get-version optional stage, a step where library version is determined either via: 2.1. Standard EDP versioning functionality. 2.2. Manually specified version. In this case .manifest file in a root directory MUST be provided. File must contain a JSON document with revision field. Minimal example: { \"revision\": \"1.0.0\" }\" . tests stage containing a script that performs the following actions: 3.1. Runs policy tests . 3.2. Converts OPA test results into JUnit format. 3.3. Publishes JUnit-formatted results to Jenkins. git-tag stage, a standard step where git branch is tagged with a version.","title":"Build Pipeline Stages"},{"location":"user-guide/opa-stages/#related-articles","text":"EDP Pipeline Framework","title":"Related Articles"},{"location":"user-guide/pipeline-framework/","text":"EDP Pipeline Framework \u2693\ufe0e This chapter provides detailed information about the EDP pipeline framework concepts and parts, as well as the accurate data about the Code Review , Build and Deploy pipelines with the respective stages. EDP Pipeline Framework Overview \u2693\ufe0e Note The whole logic is applied to Jenkins as it is the main tool for the CI/CD processes organization. The general EDP Pipeline Framework consists of several parts: Jenkinsfile - a text file that keeps the definition of a Jenkins Pipeline and is checked into source control. Every Job has its Jenkinsfile stored in the specific application repository and in Jenkins as the plain text. The behavior logic of the pipelines can be customized easily by modifying a source code which is always copied to the EDP repository after the EDP installation. Loading Shared Libraries - a part where every job loads libraries with the help of the shared libraries mechanism for Jenkins that allows to create reproducible pipelines, write them uniformly, and manage the update process. There are two main libraries: EDP Pipelines with the common logic described for the main pipelines Code Review, Build, Deploy pipelines and EDP Stages library that keeps the description of the stages for every pipeline. Run Stages - a part where the predefined default stages are launched. CI/CD Jobs Comparison \u2693\ufe0e Explore the CI and CD job comparison. Please note that the dynamic stages order can be changed, meanwhile, the predefined stages order in the reference pipeline cannot be changed, i.e. only the predefined stages set can be run. Context \u2693\ufe0e Context - a variable that stores and transfers all necessary parameters between stages that are used by pipeline during performing. The context type is \"Map\". Each stage has input and output context. Each stage has a mandatory input context. Note If the input context isn't transferred, the stage will be failed. Annotations for CI/CD Stages \u2693\ufe0e Annotation for CI Stages: The annotation type is \"Map\"; The annotation consists of the name, buildTool, and codebaseType. Annotation for CD Stages: The annotation type is \"Map\"; The annotation consists of a name. Code Review Pipeline \u2693\ufe0e CodeReview() \u2013 a function that allows using the EDP implementation for the Code Review pipeline. Note All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context. The Code Review pipeline consists of several steps: On the master: Initialization of all objects (Platform, Job, Gerrit, Nexus, Sonar, Application, StageFactory) and loading of the default implementations of EDP stages. On a particular Jenkins agent that depends on the build tool: Creating workdir for application sources; Loading build tool implementation for a particular application; Run in a loop all stages (From) and run them either in parallel or one by one. Code Review Pipeline Overview \u2693\ufe0e Using in pipelines - @Library(['edp-library-pipelines@version']) The corresponding enums, interfaces, classes, and their methods can be used separately from the EDP Pipelines library function (please refer to Table 1 and Table 2 ). Table 1. Enums and Interfaces with the respective properties, methods, and examples. Enums Interfaces PlatformType: - OPENSHIFT - KUBERNETES JobType: - CODEREVIEW - BUILD - DEPLOY BuildToolType: - MAVEN - GRADLE - NPM - DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Methods : getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example : context.platform.getJsonPathValue(''cm'', ''project-settings'', ''.data.username'') . BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. Should be invoked on Jenkins build agents. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus. Methods : init: return parameters of buildTool that are needed for running stages. Example : context.buildTool = new BuildToolFactory(). getBuildToolImpl (context.application.config.build_tool, this, context.nexus) context.buildTool.init() . Table 2. Classes with the respective properties, methods, and examples. Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting an implementation of CLI of the platform. At the moment OpenShift and Kubernetes are supported. Methods : getPlatformImpl(PlatformType platform, Script script): return Class Platform . Example : context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this) . Application(String name, Platform platform, Script script) - Class that describes the application object. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). String name - Name for the application for creating an object. Map config - Map of configuration settings for the particular application that is loaded from config map project-settings. String version - Application version, initially empty. Is set on the get-version step. String deployableModule - The name of the deployable module for multi-module applications, initially empty. String buildVersion - Version of the built artifact, contains build number of Job initially empty. String deployableModuleDir - The name of deployable module directory for multi-module applications, initially empty. Array imageBuildArgs - List of arguments for building an application Docker image. Methods : setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map. Example : context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project) Job(type: JobType.value, platform: Platform, script: Script) - Class that describes the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). JobType.value type. String deployTemplatesDirectory - The name of the directory in application repository where deploy templates are located. It can be set for a particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter. String edpName - The name of the EDP Project. Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable. String envToPromote - The name of the environment for promoting images. Boolean promoteImages - Defines whether images should be promoted or not. Methods : getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of the Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to the existing description of the Jenkins job. printDebugInfo(Map context): print context info to the log of Jenkins' job. runStage(String stage_name, Map context): run the particular stage according to its name. Example : context.job = new Job(JobType.CODEREVIEW.value, context.platform, this) context.job.init() context.job.printDebugInfo(context) context.job.setDisplayName(\"test\") context.job.setDescription(\"Name: ${context.application.config.name}\") Gerrit(Job job, Platform platform, Script script) - Class that describes the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String credentialsId - Credential Id in Jenkins for Gerrit. String autouser - Username of an auto user in Gerrit for integration with Jenkins. String host - Gerrit host. String project - the project name of the built application. String branch - branch to build the application from. String changeNumber - change number of Gerrit commit. String changeName - change name of Gerrit commit. String refspecName - refspecName of Gerrit commit. String sshPort - Gerrit ssh port number. String patchsetNumber - patchsetNumber of Gerrit commit. Methods : init(): set all the properties of Gerrit object. Example : context.gerrit = new Gerrit(context.job, context.platform, this) context.gerrit.init() Nexus(Job job, Platform platform, Script script) - Class that describes the Nexus tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String autouser - Username of an auto user in Nexus for integration with Jenkins. String credentialsId - Credential Id in Jenkins for Nexus. String host - Nexus host. String port - Nexus http(s) port. String repositoriesUrl - Base URL of repositories in Nexus. String restUrl - URL of Rest API. Methods : init(): set all the properties of Nexus object Example : context.nexus = new Nexus(context.job, context.platform, this) context.nexus.init() Sonar(Job job, Platform platform, Script script) - Class that describes the Sonar tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String route - External route of the sonar application. Methods : init(): set all the properties of Sonar object Example : context.sonar = new Sonar(context.job, context.platform, this) context.sonar.init() Code Review Pipeline Stages \u2693\ufe0e Each EDP stage implementation has run method that is as input parameter required to pass the \"Map\" context with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific. The Code Review pipeline includes the following default stages: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Tests \u2192 Sonar . Info To get the full description of every stage, please refer to the EDP Stages Framework section. How to Redefine or Extend the EDP Pipeline Stages Library \u2693\ufe0e Inspect the points below to redefine or extend the EDP Pipeline Stages Library: Create \u201cstage\u201d folder in your App repository. Create a Groovy file with a meaningful name for the custom stage description. For instance \u2013 CustomBuildMavenApplication.groovy. Describe the stage logic. Redefinition: import com.epam.edp.stages.ProjectType import com.epam.edp.stages.Stage @Stage ( name = \"compile\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class CustomBuildMavenApplication { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return CustomBuildMavenApplication Extension: import com.epam.edp.stages.ProjectType import com.epam.edp.stages.Stage @Stage ( name = \"new-stage\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class NewStageMavenApplication { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return NewStageMavenApplication Using EDP Stages Library in the Pipeline \u2693\ufe0e In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following: import library - @Library(['edp-library-stages']) import StageFactory class - import com.epam.edp.stages.StageFactory define context Map \u2013 context = [:] define stagesFactory instance and load EDP stages: context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } After that, there is the ability to run any EDP stage beforehand by defining a necessary context: context.factory.getStage(\"checkout\",\"maven\",\"application\").run(context) For instance, the pipeline can look like : @Library ( [ ' edp - library - stages ' ] ) _ import com.epam.edp.stages.StageFactory import org.apache.commons.lang.RandomStringUtils context = [ : ] node ( ' maven ' ) { context . workDir = new File ( \"/tmp/${RandomStringUtils.random(10, true, true)}\" ) context . workDir . deleteDir () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . gerrit = [ : ] context . application = [ : ] context . application . config = [ : ] context . buildTool = [ : ] context . nexus = [ : ] stage ( \"checkout\" ) { context . gerrit . branch = \"master\" context . gerrit . credentialsId = \"jenkins\" context . application . config . cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\" context . factory . getStage ( \"checkout\" , \"maven\" , \"application\" ). run ( context ) } stage ( \"compile\" ) { context . buildTool . command = \"mvn\" context . nexus . credentialsId = \"nexus\" context . factory . getStage ( \"compile\" , \"maven\" , \"application\" ). run ( context ) } } Or in a declarative way : @Library ( [ ' edp - library - stages ' ] ) _ import com.epam.edp.stages.StageFactory import org.apache.commons.lang.RandomStringUtils context = [ : ] pipeline { agent { label ' maven ' } stages { stage ( ' Init ' ){ steps { script { context . workDir = new File ( \"/tmp/${RandomStringUtils.random(10, true, true)}\" ) context . workDir . deleteDir () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . gerrit = [ : ] context . application = [ : ] context . application . config = [ : ] context . buildTool = [ : ] context . nexus = [ : ] } } } stage ( \"Checkout\" ) { steps { script { context . gerrit . branch = \"master\" context . gerrit . credentialsId = \"jenkins\" context . application . config . cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\" context . factory . getStage ( \"checkout\" , \"maven\" , \"application\" ). run ( context ) } } } stage ( ' Compile ' ) { steps { script { context . buildTool . command = \"mvn\" context . nexus . credentialsId = \"nexus\" context . factory . getStage ( \"compile\" , \"maven\" , \"application\" ). run ( context ) } } } } } Build Pipeline \u2693\ufe0e Build() \u2013 a function that allows using the EDP implementation for the Build pipeline. All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context. The Build pipeline consists of several steps: On the master: Initialization of all objects (Platform, Job, Gerrit, Nexus, Sonar, Application, StageFactory) and loading default implementations of EDP stages. On a particular Jenkins agent that depends on the build tool: Creating workdir for application sources; Loading build tool implementation for a particular application; Run in a loop all stages (From) and run them either in parallel or one by one. Build Pipeline Overview \u2693\ufe0e Using in pipelines - @Library(['edp-library-pipelines@version']) The corresponding enums, interfaces, classes, and their methods can be used separately from the EDP Pipelines library function (please refer to Table 3 and Table 4 ). Table 3. Enums and Interfaces with the respective properties, methods, and examples. Enums Interfaces PlatformType: - OPENSHIFT - KUBERNETES JobType: - CODEREVIEW - BUILD - DEPLOY BuildToolType : - MAVEN - GRADLE - NPM - DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Methods : getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example : context.platform.getJsonPathValue(\"cm\",\"project-settings\", \".data.username\") BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. Should be invoked on Jenkins build agents. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus. See description below: Methods : init: return parameters of buildTool that are needed for running stages. Example : context.buildTool = new BuildToolFactory().getBuildToolImpl (context.application.config.build_tool, this, context.nexus)context.buildTool.init() Table 4. Classes with the respective properties, methods, and examples. Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting an implementation of CLI of the platform. At the moment OpenShift and Kubernetes are supported. Methods : getPlatformImpl(PlatformType platform, Script script): return Class Platform Example : context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this) Application(String name, Platform platform, Script script) - Class that describes the application object. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). String name - Name for the application for creating an object. Map config - Map of configuration settings for the particular application that is loaded from config map project-settings. String version - Application version, initially empty. Is set on the get-version step. String deployableModule - The name of the deployable module for multi-module applications, initially empty. String buildVersion - Version of the built artifact, contains build number of Job initially empty. String deployableModuleDir - The name of deployable module directory for multi-module applications, initially empty. Array imageBuildArgs - List of arguments for building the application Docker image. Methods : setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map. Example : context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project) Job(type: JobType.value, platform: Platform, script: Script) - Class that describes the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). JobType.value type. String deployTemplatesDirectory - The name of the directory in application repository, where deploy templates are located. It can be set for a particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter. String edpName - The name of the EDP Project. Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable. String envToPromote - The name of the environment for promoting images. Boolean promoteImages - Defines whether images should be promoted or not. Methods : getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of the Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to the existing description of the Jenkins job. printDebugInfo(Map context): print context info to the log of Jenkins' job. runStage(String stage_name, Map context): run the particular stage according to its name. Example : context.job = new Job(JobType.CODEREVIEW.value, context.platform, this) context.job.init() context.job.printDebugInfo(context) context.job.setDisplayName(\"test\") context.job.setDescription(\"Name: ${context.application.config.name}\") Gerrit(Job job, Platform platform, Script script) - Class that describes the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String credentialsId - Credentials Id in Jenkins for Gerrit. String autouser - Username of an auto user in Gerrit for integration with Jenkins. String host - Gerrit host. String project - the project name of the built application. String branch - branch to build an application from. String changeNumber - change number of Gerrit commit. String changeName - change name of Gerrit commit. String refspecName - refspecName of Gerrit commit. String sshPort - Gerrit ssh port number. String patchsetNumber - patchsetNumber of Gerrit commit. Methods : init(): set all the properties of Gerrit object Example : context.gerrit = new Gerrit(context.job, context.platform, this) context.gerrit.init() Nexus(Job job, Platform platform, Script script) - Class that describes the Nexus tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String autouser - Username of an auto user in Nexus for integration with Jenkins. String credentialsId - Credentials Id in Jenkins for Nexus. String host - Nexus host. String port - Nexus http(s) port. String repositoriesUrl - Base URL of repositories in Nexus. String restUrl - URL of Rest API. Methods : init(): set all the properties of the Nexus object. Example : context.nexus = new Nexus(context.job, context.platform, this) context.nexus.init() Sonar(Job job, Platform platform, Script script) - Class that describes the Sonar tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String route - External route of the sonar application. Methods : init(): set all the properties of Sonar object. Example : context.sonar = new Sonar(context.job, context.platform, this) context.sonar.init() Build Pipeline Stages \u2693\ufe0e Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific. The Build pipeline includes the following default stages: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Get version \u2192 Tests \u2192 Sonar \u2192 Build \u2192 Build Docker Image \u2192 Push \u2192 Git tag . Info To get the full description of every stage, please refer to the EDP Stages Framework section. How to Redefine or Extend EDP Pipeline Stages Library \u2693\ufe0e Inspect the points below to redefine or extend the EDP Pipeline Stages Library: Create a \u201cstage\u201d folder in the App repository. Create a Groovy file with a meaningful name for the custom stage description. For instance \u2013 CustomBuildMavenApplication.groovy Describe stage logic. Redefinition: import com.epam.edp.stages.ProjectType import com.epam.edp.stages.Stage @Stage ( name = \"compile\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class CustomBuildMavenApplication { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return CustomBuildMavenApplication Extension: import com.epam.edp.stages.ProjectType import com.epam.edp.stages.Stage @Stage ( name = \"new-stage\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class NewStageMavenApplication { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return NewStageMavenApplication Using EDP Stages Library in the Pipeline \u2693\ufe0e In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following: import library - @Library(['edp-library-stages']) import StageFactory class - import com.epam.edp.stages.StageFactory define context Map \u2013 context = [:] define stagesFactory instance and load EDP stages: context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } After that, there is the ability to run any EDP stage beforehand by defining a requirement context context.factory.getStage(\"checkout\",\"maven\",\"application\").run(context) For instance, the pipeline can look like : @Library ( [ ' edp - library - stages ' ] ) _ import com.epam.edp.stages.StageFactory import org.apache.commons.lang.RandomStringUtils context = [ : ] node ( ' maven ' ) { context . workDir = new File ( \"/tmp/${RandomStringUtils.random(10, true, true)}\" ) context . workDir . deleteDir () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . gerrit = [ : ] context . application = [ : ] context . application . config = [ : ] context . buildTool = [ : ] context . nexus = [ : ] stage ( \"checkout\" ) { context . gerrit . branch = \"master\" context . gerrit . credentialsId = \"jenkins\" context . application . config . cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\" context . factory . getStage ( \"checkout\" , \"maven\" , \"application\" ). run ( context ) } stage ( \"compile\" ) { context . buildTool . command = \"mvn\" context . nexus . credentialsId = \"nexus\" context . factory . getStage ( \"compile\" , \"maven\" , \"application\" ). run ( context ) } } Or in a declarative way : @Library ( [ ' edp - library - stages ' ] ) _ import com.epam.edp.stages.StageFactory import org.apache.commons.lang.RandomStringUtils context = [ : ] pipeline { agent { label ' maven ' } stages { stage ( ' Init ' ){ steps { script { context . workDir = new File ( \"/tmp/${RandomStringUtils.random(10, true, true)}\" ) context . workDir . deleteDir () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . gerrit = [ : ] context . application = [ : ] context . application . config = [ : ] context . buildTool = [ : ] context . nexus = [ : ] } } } stage ( \"Checkout\" ) { steps { script { context . gerrit . branch = \"master\" context . gerrit . credentialsId = \"jenkins\" context . application . config . cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\" context . factory . getStage ( \"checkout\" , \"maven\" , \"application\" ). run ( context ) } } } stage ( ' Compile ' ) { steps { script { context . buildTool . command = \"mvn\" context . nexus . credentialsId = \"nexus\" context . factory . getStage ( \"compile\" , \"maven\" , \"application\" ). run ( context ) } } } } } EDP Library Stages Description \u2693\ufe0e Using in pipelines - @Library(['edp-library-stages@version']) The corresponding enums, classes, interfaces and their methods can be used separately from the EDP Stages library function (please refer to Table 5 ). Table 5. Enums and Classes with the respective properties, methods, and examples. Enums Classes ProjectType : - APPLICATION - AUTOTESTS - LIBRARY StageFactory() - Class that contains methods getting an implementation of the particular stage either EDP from shared library or custom from application repository. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Map stages - Map of stages implementations. Methods : loadEdpStages(): return a list of Classes that describes EDP stages implementations. loadCustomStages(String directory): return a list of Classes that describes EDP custom stages from application repository from \"directory\". The \"directory\" should have an absolute path to files with classes of custom stages implementations. Should be run from a Jenkins agent. add(Class clazz): register class for some particular stage in stages map of StageFactory class. getStage(String name, String buildTool, String type): return an object of the class for a particular stage from stages property based on stage name and buildTool, type of application. Example : context.factory = new StageFactory(script: this) context.factory.loadEdpStages().each() { context.factory.add(it) } context.factory.loadCustomStages(\"${context.workDir}/stages\").each() { context.factory.add(it) } context.factory.getStage(stageName.toLowerCase(),context.application.config.build_tool.toLowerCase(), context.application.config.type).run(context) EDP Stages Framework \u2693\ufe0e Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific. Inspect the Table 6 and Table 7 that contain the full description of every stage that can be included in Code Review and Build pipelines: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Get version \u2192 Tests \u2192 Sonar \u2192 Build \u2192 Build Docker Image \u2192 Push \u2192 Git tag . Table 6. The Checkout, Gerrit Checkout, Compile, Get version, and Tests stages description. Checkout Gerrit Checkout Compile Get version Tests name = \"checkout\", buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - StageFactory context.factory - String context.gerrit.branch - String context.gerrit.credentialsId - String context.application.config.cloneUrl name = \"gerrit-checkout\", buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"] type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY] context required: - String context.workDir - StageFactory context.factory - String context.gerrit.changeName - String context.gerrit.refspecName - String context.gerrit.credentialsId - String context.application.config.cloneUrl name = \"compile\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.sln_filename output: - String context.buildTool.sln_filename buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command - String context.nexus.credentialsId buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command - String context.nexus.credentialsId buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.groupRepository name = \"get-version\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - Map(empty) context.application - String context.gerrit.branch - Job context.job output: -String context.application.deplyableModule - String context.application.deplyableModuleDir - String context.application.version - String context.application.buildVersion buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.command - Job context.job - String context.gerrit.branch output: - String context.application.deplyableModuleDir - String context.application.version - String context.application.buildVersion buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.command - Job context.job - String context.gerrit.branch output: - String context.application.deplyableModule - String context.application.deplyableModuleDir - String context.application.version - String context.application.buildVersion buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - Job context.job - String context.gerrit.branch output: - String context.application.deplyableModuleDir - String context.application.version - String context.application.buildVersion name = \"tests\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.command buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command type = [ProjectType.AUTOTESTS] context required: - String context.workDir - String context.buildTool.command - String context.application.config.report_framework buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir Table 7. The Sonar, Build, Build Docker Image, Push, and Git tag stages description. Sonar Build Build Docker Image Push Git tag name = \"sonar\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.job.type - String context.application.name - String context.buildTool.sln_filename - String context.sonar.route - String context.gerrit.changeName(Only for codereview pipeline) - String context.gerrit.branch(Only for build pipeline) buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.job.type - String context.nexus.credentialsId - String context.buildTool.command - String context.application.name - String context.sonarRoute - String context.gerrit.changeName(Only for codereview pipeline) - String context.gerrit.branch(Only for build pipeline) buildTool = [\"maven\"] type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY] context required: - String context.workDir - String context.job.type - String context.nexus.credentialsId - String context.application.name - String context.buildTool.command - String context.sonar.route - String context.gerrit.changeName(Only for codereview pipeline) - String context.gerrit.branch(Only for build pipeline) buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.job.type - String context.sonar.route - String context.application.name - String context.gerrit.changeName(Only for codereview pipeline) - String context.gerrit.branch(Only for build pipeline) name = \"build\" buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command - String context.nexus.credentialsId buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command - String context.nexus.credentialsId buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.groupRepository name = \"build-image\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.application.deployableModule - String context.application.deployableModuleDir - String context.application.name - String context.application.config.language - String context.application.buildVersion - Boolean context.job.promoteImages - String context.job.envToPromote buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.application.deployableModule - String context.application.deployableModuleDir - String context.application.name - String context.application.config.language - String context.application.buildVersion - Boolean context.job.promoteImages - String context.job.envToPromote buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.application.deployableModule - String context.application.deployableModuleDir - String context.application.name - String context.application.config.language - String context.application.buildVersion - Boolean context.job.promoteImages - String context.job.envToPromote buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.application.deployableModule - String context.application.deployableModuleDir - String context.application.name - String context.application.config.language - String context.application.buildVersion - Boolean context.job.promoteImages - String context.job.envToPromote name = \"push\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.gerrit.project - String context.buildTool.sln_filename - String context.buildTool.snugetApiKey - String context.buildTool.hostedRepository buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.application.version - String context.buildTool.hostedRepository - String context. buildTool.settings buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.application.version - String context.buildTool.hostedRepository - String context.buildTool.command buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.hostedRepository - String context.gerrit.autouser name = \"git-tag\" buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.gerrit.credentialsId - String context.gerrit.sshPort - String context.gerrit.host - String context.gerrit.autouser - String context.application.buildVersion Deploy Pipeline \u2693\ufe0e Deploy() \u2013 a function that allows using the EDP implementation for the deploy pipeline. All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context. The deploy pipeline consists of several steps: On the master: Initialization of all objects (Platform, Job, Gerrit, Nexus, StageFactory) and loading the default implementations of EDP stages; Creating an environment if it doesn`t exist; Deploying the last versions of the applications; Run predefined manual gates. On a particular autotest Jenkins agent that depends on the build tool: Creating workdir for autotest sources; Run predefined autotests. EDP Library Pipelines Description \u2693\ufe0e _Using in pipelines - @Library(['edp-library-pipelines@version']) _ The corresponding enums and interfaces with their methods can be used separately from the EDP Pipelines library function (please refer to Table 8 and Table 9 ). Table 8. Enums and Interfaces with the respective properties, methods, and examples. Enums Interfaces PlatformType : - OPENSHIFT - KUBERNETES JobType : - CODEREVIEW - BUILD - DEPLOY BuildToolType : - MAVEN - GRADLE - NPM - DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Methods : getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example : context.platform.getJsonPathValue(\"cm\",\"project-settings\", \".data.username\") BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. (Should be invoked on Jenkins build agents) Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus. Methods : init: return parameters of buildTool that are needed for running stages. Example : context.buildTool = new BuildToolFactory().getBuildToolImpl (context.application.config.build_tool, this, context.nexus) context.buildTool.init() Table 9. Classes with the respective properties, methods, and examples. Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting implementation of CLI of platform. At the moment OpenShift and Kubernetes are supported. Methods : getPlatformImpl(PlatformType platform, Script script): return Class Platform Example : context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this) Application(String name, Platform platform, Script script) - Class that describe the application object. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform() String name - Name for the application for creating object Map config - Map of configuration settings for particular application that is loaded from config map project-settings String version - Application version, initially empty. Is set on get-version step. String deployableModule - The name of deployable module for multi module applications, initially empty. String buildVersion - Version of built artifact, contains build number of Job initially empty String deployableModuleDir - The name of deployable module directory for multi module applications, initially empty. Array imageBuildArgs - List of arguments for building application Docker image Methods : setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map Example : context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project) Job(type: JobType.value, platform: Platform, script: Script) - Class that describe the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\" Platform platform - Object of a class Platform(). JobType.value type. String deployTemplatesDirectory - The name of the directory in application repository, where deploy templates are located. Can be set for particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter. String edpName - The name of the EDP Project. Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable. String envToPromote - The name of the environment for promoting images. Boolean promoteImages - Defines whether images should be promoted or not. Methods : getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to existing description of the Jenkins job. printDebugInfo(Map context): print context info to log of Jenkins job. runStage(String stage_name, Map context): run the particular stage according to its name. Example : context.job = new Job(JobType.DEPLOY.value, context.platform, this) context.job.init() context.job.printDebugInfo(context) context.job.setDisplayName(\"test\") context.job.setDescription(\"Name: ${context.application.config.name}\") Gerrit(Job job, Platform platform, Script script) - Class that describe the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String credentialsId - Credential Id in Jenkins for Gerrit. String autouser - Username of autouser in Gerrit for integration with Jenkins. String host - Gerrit host. String project - project name of built application. String branch - branch to build application from. String changeNumber - change number of Gerrit commit. String changeName - change name of Gerrit commit. String refspecName - refspecName of Gerrit commit. String sshPort - gerrit ssh port number. String patchsetNumber - patchsetNumber of Gerrit commit. Methods : init(): set all the properties of Gerrit object. Example : context.gerrit = new Gerrit(context.job, context.platform, this) context.gerrit.init() . Nexus(Job job, Platform platform, Script script) - Class that describe the Nexus tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String autouser - Username of autouser in Nexus for integration with Jenkins. String credentialsId - Credential Id in Jenkins for Nexus. String host - Nexus host. String port - Nexus http(s) port. String repositoriesUrl - Base URL of repositories in Nexus. String restUrl - URL of Rest API. Methods : init(): set all the properties of Nexus object. Example : context.nexus = new Nexus(context.job, context.platform, this) context.nexus.init() . EDP Library Stages Description \u2693\ufe0e Using in pipelines - @Library(['edp-library-stages@version']) _ The corresponding classes with methods can be used separately from the EDP Pipelines library function (please refer to Table 10 ). Table 10. Classes with the respective properties, methods, and examples. Classes Description (properties, methods, and examples) StageFactory() - Class that contains methods getting implementation of particular stage either EDP from shared library or custom from application repository. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\" Map stages - Map of stages implementations Methods : loadEdpStages(): return list of Classes that describes EDP stages implementations loadCustomStages(String directory): return list of Classes that describes EDP custom stages from application repository from \"directory\". The \"directory\" should be absolute path to files with classes of custom stages implementations. Should be run from Jenkins agent. add(Class clazz): register class for some particular stage in stages map of StageFactory class getStage(String name, String buildTool, String type): return object of the class for particular stage from stages property based on stage name and buildTool, type of application Example : context.factory = new StageFactory(script: this) context.factory.loadEdpStages().each() { context.factory.add(it) } context.factory.loadCustomStages(\"${context.workDir}/stages\").each() { context.factory.add(it) } context.factory.getStage(stageName.toLowerCase(),context.application.config.build_tool.toLowerCase(), context.application.config.type).run(context) . Deploy Pipeline Stages \u2693\ufe0e Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific. The stages for the deploy pipeline are independent of the build tool and application type. Find below (see Table 11 ) the full description of every stage: Deploy \u2192 Automated tests \u2192 Promote Images . Table 11. The Deploy, Automated tests, and Promote Images stages description. Deploy Automated tests Promote Images name = \"deploy\" buildTool = null type = null context required: \u2022 String context.workDir \u2022 StageFactory context.factory \u2022 String context.gerrit.autouser \u2022 String context.gerrit.host \u2022 String context.application.config.cloneUrl \u2022 String context.jenkins.token \u2022 String context.job.edpName \u2022 String context.job.buildUrl \u2022 String context.job.jenkinsUrl \u2022 String context.job.metaProject \u2022 List context.job.applicationsList [['name':'application1_name','version':'application1_version],...] \u2022 String context.job.deployTemplatesDirectory output: \u2022 List context.job.updatedApplicaions [['name':'application1_name','version':'application1_version],...] name = \"automation-tests\", buildTool = null, type = null context required: - String context.workDir - StageFactory context.factory - String context.gerrit.credentialsId - String context.autotest.config.cloneUrl - String context.autotest.name - String context.job.stageWithoutPrefixName - String context.buildTool.settings - String context.autotest.config.report_framework name = \"promote-images\" buildTool = null type = null context required: - String context.workDir - String context.buildTool.sln_filename - List context.job.updatedApplicaions [['name':'application1_name','version':'application1_version],...] How to Redefine or Extend EDP Pipeline Stages Library \u2693\ufe0e Info Currently, the redefinition of Deploy pipeline stages is prohibited. Using EDP Library Stages in the Pipeline \u2693\ufe0e In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following: import libraries - @Library(['edp-library-stages', 'edp-library-pipelines']) _ import reference EDP classes(See example below) define context Map \u2013 context = [:] define reference \"init\" stage After that, there is the ability to run any EDP stage beforehand by defining requirement context context.job.runStage(\"Deploy\", context) . For instance, the pipeline can look like : @Library ( [ ' edp - library - stages ' , ' edp - library - pipelines ' ] ) _ import com.epam.edp.stages.StageFactory import com.epam.edp.platform.PlatformFactory import com.epam.edp.platform.PlatformType import com.epam.edp.JobType context = [ : ] node ( ' master ' ) { stage ( \"Init\" ) { context . platform = new PlatformFactory (). getPlatformImpl ( PlatformType . OPENSHIFT , this ) context . job = new com . epam . edp . Job ( JobType . DEPLOY . value , context . platform , this ) context . job . init () context . job . initDeployJob () println ( \"[JENKINS][DEBUG] Created object job with type - ${context.job.type}\" ) context . nexus = new com . epam . edp . Nexus ( context . job , context . platform , this ) context . nexus . init () context . jenkins = new com . epam . edp . Jenkins ( context . job , context . platform , this ) context . jenkins . init () context . gerrit = new com . epam . edp . Gerrit ( context . job , context . platform , this ) context . gerrit . init () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . environment = new com . epam . edp . Environment ( context . job . deployProject , context . platform , this ) context . job . printDebugInfo ( context ) context . job . setDisplayName ( \"${currentBuild.displayName}-${context.job.deployProject}\" ) context . job . generateInputDataForDeployJob () } stage ( \"Pre Deploy Custom stage\" ) { println ( \"Some custom pre deploy logic\" ) } context . job . runStage ( \"Deploy\" , context ) stage ( \"Post Deploy Custom stage\" ) { println ( \"Some custom post deploy logic\" ) } } Or in a declarative way : @Library ( [ ' edp - library - stages ' , ' edp - library - pipelines ' ] ) _ import com.epam.edp.stages.StageFactory import com.epam.edp.platform.PlatformFactory import com.epam.edp.platform.PlatformType import com.epam.edp.JobType context = [ : ] pipeline { agent { label ' master ' } stages { stage ( ' Init ' ) { steps { script { context . platform = new PlatformFactory (). getPlatformImpl ( PlatformType . OPENSHIFT , this ) context . job = new com . epam . edp . Job ( JobType . DEPLOY . value , context . platform , this ) context . job . init () context . job . initDeployJob () println ( \"[JENKINS][DEBUG] Created object job with type - ${context.job.type}\" ) context . nexus = new com . epam . edp . Nexus ( context . job , context . platform , this ) context . nexus . init () context . jenkins = new com . epam . edp . Jenkins ( context . job , context . platform , this ) context . jenkins . init () context . gerrit = new com . epam . edp . Gerrit ( context . job , context . platform , this ) context . gerrit . init () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . environment = new com . epam . edp . Environment ( context . job . deployProject , context . platform , this ) context . job . printDebugInfo ( context ) context . job . setDisplayName ( \"${currentBuild.displayName}-${context.job.deployProject}\" ) context . job . generateInputDataForDeployJob () } } } stage ( ' Deploy ' ) { steps { script { context . factory . getStage ( \"deploy\" ). run ( context ) } } } stage ( ' Custom stage ' ) { steps { println ( \"Some custom logic\" ) } } } } Related Articles \u2693\ufe0e Add Application Add Library Add CD Pipeline CI Pipeline Details CD Pipeline Details Customize CI Pipeline Customize CD Pipeline EDP Stages Glossary Use Terraform Library in EDP","title":"EDP Pipeline Framework"},{"location":"user-guide/pipeline-framework/#edp-pipeline-framework","text":"This chapter provides detailed information about the EDP pipeline framework concepts and parts, as well as the accurate data about the Code Review , Build and Deploy pipelines with the respective stages.","title":"EDP Pipeline Framework"},{"location":"user-guide/pipeline-framework/#edp-pipeline-framework-overview","text":"Note The whole logic is applied to Jenkins as it is the main tool for the CI/CD processes organization. The general EDP Pipeline Framework consists of several parts: Jenkinsfile - a text file that keeps the definition of a Jenkins Pipeline and is checked into source control. Every Job has its Jenkinsfile stored in the specific application repository and in Jenkins as the plain text. The behavior logic of the pipelines can be customized easily by modifying a source code which is always copied to the EDP repository after the EDP installation. Loading Shared Libraries - a part where every job loads libraries with the help of the shared libraries mechanism for Jenkins that allows to create reproducible pipelines, write them uniformly, and manage the update process. There are two main libraries: EDP Pipelines with the common logic described for the main pipelines Code Review, Build, Deploy pipelines and EDP Stages library that keeps the description of the stages for every pipeline. Run Stages - a part where the predefined default stages are launched.","title":"EDP Pipeline Framework Overview"},{"location":"user-guide/pipeline-framework/#cicd-jobs-comparison","text":"Explore the CI and CD job comparison. Please note that the dynamic stages order can be changed, meanwhile, the predefined stages order in the reference pipeline cannot be changed, i.e. only the predefined stages set can be run.","title":"CI/CD Jobs Comparison"},{"location":"user-guide/pipeline-framework/#context","text":"Context - a variable that stores and transfers all necessary parameters between stages that are used by pipeline during performing. The context type is \"Map\". Each stage has input and output context. Each stage has a mandatory input context. Note If the input context isn't transferred, the stage will be failed.","title":"Context"},{"location":"user-guide/pipeline-framework/#annotations-for-cicd-stages","text":"Annotation for CI Stages: The annotation type is \"Map\"; The annotation consists of the name, buildTool, and codebaseType. Annotation for CD Stages: The annotation type is \"Map\"; The annotation consists of a name.","title":"Annotations for CI/CD Stages"},{"location":"user-guide/pipeline-framework/#code-review-pipeline","text":"CodeReview() \u2013 a function that allows using the EDP implementation for the Code Review pipeline. Note All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context. The Code Review pipeline consists of several steps: On the master: Initialization of all objects (Platform, Job, Gerrit, Nexus, Sonar, Application, StageFactory) and loading of the default implementations of EDP stages. On a particular Jenkins agent that depends on the build tool: Creating workdir for application sources; Loading build tool implementation for a particular application; Run in a loop all stages (From) and run them either in parallel or one by one.","title":"Code Review Pipeline"},{"location":"user-guide/pipeline-framework/#code-review-pipeline-overview","text":"Using in pipelines - @Library(['edp-library-pipelines@version']) The corresponding enums, interfaces, classes, and their methods can be used separately from the EDP Pipelines library function (please refer to Table 1 and Table 2 ). Table 1. Enums and Interfaces with the respective properties, methods, and examples. Enums Interfaces PlatformType: - OPENSHIFT - KUBERNETES JobType: - CODEREVIEW - BUILD - DEPLOY BuildToolType: - MAVEN - GRADLE - NPM - DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Methods : getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example : context.platform.getJsonPathValue(''cm'', ''project-settings'', ''.data.username'') . BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. Should be invoked on Jenkins build agents. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus. Methods : init: return parameters of buildTool that are needed for running stages. Example : context.buildTool = new BuildToolFactory(). getBuildToolImpl (context.application.config.build_tool, this, context.nexus) context.buildTool.init() . Table 2. Classes with the respective properties, methods, and examples. Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting an implementation of CLI of the platform. At the moment OpenShift and Kubernetes are supported. Methods : getPlatformImpl(PlatformType platform, Script script): return Class Platform . Example : context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this) . Application(String name, Platform platform, Script script) - Class that describes the application object. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). String name - Name for the application for creating an object. Map config - Map of configuration settings for the particular application that is loaded from config map project-settings. String version - Application version, initially empty. Is set on the get-version step. String deployableModule - The name of the deployable module for multi-module applications, initially empty. String buildVersion - Version of the built artifact, contains build number of Job initially empty. String deployableModuleDir - The name of deployable module directory for multi-module applications, initially empty. Array imageBuildArgs - List of arguments for building an application Docker image. Methods : setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map. Example : context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project) Job(type: JobType.value, platform: Platform, script: Script) - Class that describes the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). JobType.value type. String deployTemplatesDirectory - The name of the directory in application repository where deploy templates are located. It can be set for a particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter. String edpName - The name of the EDP Project. Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable. String envToPromote - The name of the environment for promoting images. Boolean promoteImages - Defines whether images should be promoted or not. Methods : getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of the Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to the existing description of the Jenkins job. printDebugInfo(Map context): print context info to the log of Jenkins' job. runStage(String stage_name, Map context): run the particular stage according to its name. Example : context.job = new Job(JobType.CODEREVIEW.value, context.platform, this) context.job.init() context.job.printDebugInfo(context) context.job.setDisplayName(\"test\") context.job.setDescription(\"Name: ${context.application.config.name}\") Gerrit(Job job, Platform platform, Script script) - Class that describes the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String credentialsId - Credential Id in Jenkins for Gerrit. String autouser - Username of an auto user in Gerrit for integration with Jenkins. String host - Gerrit host. String project - the project name of the built application. String branch - branch to build the application from. String changeNumber - change number of Gerrit commit. String changeName - change name of Gerrit commit. String refspecName - refspecName of Gerrit commit. String sshPort - Gerrit ssh port number. String patchsetNumber - patchsetNumber of Gerrit commit. Methods : init(): set all the properties of Gerrit object. Example : context.gerrit = new Gerrit(context.job, context.platform, this) context.gerrit.init() Nexus(Job job, Platform platform, Script script) - Class that describes the Nexus tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String autouser - Username of an auto user in Nexus for integration with Jenkins. String credentialsId - Credential Id in Jenkins for Nexus. String host - Nexus host. String port - Nexus http(s) port. String repositoriesUrl - Base URL of repositories in Nexus. String restUrl - URL of Rest API. Methods : init(): set all the properties of Nexus object Example : context.nexus = new Nexus(context.job, context.platform, this) context.nexus.init() Sonar(Job job, Platform platform, Script script) - Class that describes the Sonar tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String route - External route of the sonar application. Methods : init(): set all the properties of Sonar object Example : context.sonar = new Sonar(context.job, context.platform, this) context.sonar.init()","title":"Code Review Pipeline Overview"},{"location":"user-guide/pipeline-framework/#code-review-pipeline-stages","text":"Each EDP stage implementation has run method that is as input parameter required to pass the \"Map\" context with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific. The Code Review pipeline includes the following default stages: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Tests \u2192 Sonar . Info To get the full description of every stage, please refer to the EDP Stages Framework section.","title":"Code Review Pipeline Stages"},{"location":"user-guide/pipeline-framework/#how-to-redefine-or-extend-the-edp-pipeline-stages-library","text":"Inspect the points below to redefine or extend the EDP Pipeline Stages Library: Create \u201cstage\u201d folder in your App repository. Create a Groovy file with a meaningful name for the custom stage description. For instance \u2013 CustomBuildMavenApplication.groovy. Describe the stage logic. Redefinition: import com.epam.edp.stages.ProjectType import com.epam.edp.stages.Stage @Stage ( name = \"compile\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class CustomBuildMavenApplication { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return CustomBuildMavenApplication Extension: import com.epam.edp.stages.ProjectType import com.epam.edp.stages.Stage @Stage ( name = \"new-stage\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class NewStageMavenApplication { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return NewStageMavenApplication","title":"How to Redefine or Extend the EDP Pipeline Stages Library"},{"location":"user-guide/pipeline-framework/#using-edp-stages-library-in-the-pipeline","text":"In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following: import library - @Library(['edp-library-stages']) import StageFactory class - import com.epam.edp.stages.StageFactory define context Map \u2013 context = [:] define stagesFactory instance and load EDP stages: context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } After that, there is the ability to run any EDP stage beforehand by defining a necessary context: context.factory.getStage(\"checkout\",\"maven\",\"application\").run(context) For instance, the pipeline can look like : @Library ( [ ' edp - library - stages ' ] ) _ import com.epam.edp.stages.StageFactory import org.apache.commons.lang.RandomStringUtils context = [ : ] node ( ' maven ' ) { context . workDir = new File ( \"/tmp/${RandomStringUtils.random(10, true, true)}\" ) context . workDir . deleteDir () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . gerrit = [ : ] context . application = [ : ] context . application . config = [ : ] context . buildTool = [ : ] context . nexus = [ : ] stage ( \"checkout\" ) { context . gerrit . branch = \"master\" context . gerrit . credentialsId = \"jenkins\" context . application . config . cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\" context . factory . getStage ( \"checkout\" , \"maven\" , \"application\" ). run ( context ) } stage ( \"compile\" ) { context . buildTool . command = \"mvn\" context . nexus . credentialsId = \"nexus\" context . factory . getStage ( \"compile\" , \"maven\" , \"application\" ). run ( context ) } } Or in a declarative way : @Library ( [ ' edp - library - stages ' ] ) _ import com.epam.edp.stages.StageFactory import org.apache.commons.lang.RandomStringUtils context = [ : ] pipeline { agent { label ' maven ' } stages { stage ( ' Init ' ){ steps { script { context . workDir = new File ( \"/tmp/${RandomStringUtils.random(10, true, true)}\" ) context . workDir . deleteDir () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . gerrit = [ : ] context . application = [ : ] context . application . config = [ : ] context . buildTool = [ : ] context . nexus = [ : ] } } } stage ( \"Checkout\" ) { steps { script { context . gerrit . branch = \"master\" context . gerrit . credentialsId = \"jenkins\" context . application . config . cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\" context . factory . getStage ( \"checkout\" , \"maven\" , \"application\" ). run ( context ) } } } stage ( ' Compile ' ) { steps { script { context . buildTool . command = \"mvn\" context . nexus . credentialsId = \"nexus\" context . factory . getStage ( \"compile\" , \"maven\" , \"application\" ). run ( context ) } } } } }","title":"Using EDP Stages Library in the Pipeline"},{"location":"user-guide/pipeline-framework/#build-pipeline","text":"Build() \u2013 a function that allows using the EDP implementation for the Build pipeline. All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context. The Build pipeline consists of several steps: On the master: Initialization of all objects (Platform, Job, Gerrit, Nexus, Sonar, Application, StageFactory) and loading default implementations of EDP stages. On a particular Jenkins agent that depends on the build tool: Creating workdir for application sources; Loading build tool implementation for a particular application; Run in a loop all stages (From) and run them either in parallel or one by one.","title":"Build Pipeline"},{"location":"user-guide/pipeline-framework/#build-pipeline-overview","text":"Using in pipelines - @Library(['edp-library-pipelines@version']) The corresponding enums, interfaces, classes, and their methods can be used separately from the EDP Pipelines library function (please refer to Table 3 and Table 4 ). Table 3. Enums and Interfaces with the respective properties, methods, and examples. Enums Interfaces PlatformType: - OPENSHIFT - KUBERNETES JobType: - CODEREVIEW - BUILD - DEPLOY BuildToolType : - MAVEN - GRADLE - NPM - DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Methods : getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example : context.platform.getJsonPathValue(\"cm\",\"project-settings\", \".data.username\") BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. Should be invoked on Jenkins build agents. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus. See description below: Methods : init: return parameters of buildTool that are needed for running stages. Example : context.buildTool = new BuildToolFactory().getBuildToolImpl (context.application.config.build_tool, this, context.nexus)context.buildTool.init() Table 4. Classes with the respective properties, methods, and examples. Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting an implementation of CLI of the platform. At the moment OpenShift and Kubernetes are supported. Methods : getPlatformImpl(PlatformType platform, Script script): return Class Platform Example : context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this) Application(String name, Platform platform, Script script) - Class that describes the application object. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). String name - Name for the application for creating an object. Map config - Map of configuration settings for the particular application that is loaded from config map project-settings. String version - Application version, initially empty. Is set on the get-version step. String deployableModule - The name of the deployable module for multi-module applications, initially empty. String buildVersion - Version of the built artifact, contains build number of Job initially empty. String deployableModuleDir - The name of deployable module directory for multi-module applications, initially empty. Array imageBuildArgs - List of arguments for building the application Docker image. Methods : setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map. Example : context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project) Job(type: JobType.value, platform: Platform, script: Script) - Class that describes the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). JobType.value type. String deployTemplatesDirectory - The name of the directory in application repository, where deploy templates are located. It can be set for a particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter. String edpName - The name of the EDP Project. Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable. String envToPromote - The name of the environment for promoting images. Boolean promoteImages - Defines whether images should be promoted or not. Methods : getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of the Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to the existing description of the Jenkins job. printDebugInfo(Map context): print context info to the log of Jenkins' job. runStage(String stage_name, Map context): run the particular stage according to its name. Example : context.job = new Job(JobType.CODEREVIEW.value, context.platform, this) context.job.init() context.job.printDebugInfo(context) context.job.setDisplayName(\"test\") context.job.setDescription(\"Name: ${context.application.config.name}\") Gerrit(Job job, Platform platform, Script script) - Class that describes the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String credentialsId - Credentials Id in Jenkins for Gerrit. String autouser - Username of an auto user in Gerrit for integration with Jenkins. String host - Gerrit host. String project - the project name of the built application. String branch - branch to build an application from. String changeNumber - change number of Gerrit commit. String changeName - change name of Gerrit commit. String refspecName - refspecName of Gerrit commit. String sshPort - Gerrit ssh port number. String patchsetNumber - patchsetNumber of Gerrit commit. Methods : init(): set all the properties of Gerrit object Example : context.gerrit = new Gerrit(context.job, context.platform, this) context.gerrit.init() Nexus(Job job, Platform platform, Script script) - Class that describes the Nexus tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String autouser - Username of an auto user in Nexus for integration with Jenkins. String credentialsId - Credentials Id in Jenkins for Nexus. String host - Nexus host. String port - Nexus http(s) port. String repositoriesUrl - Base URL of repositories in Nexus. String restUrl - URL of Rest API. Methods : init(): set all the properties of the Nexus object. Example : context.nexus = new Nexus(context.job, context.platform, this) context.nexus.init() Sonar(Job job, Platform platform, Script script) - Class that describes the Sonar tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String route - External route of the sonar application. Methods : init(): set all the properties of Sonar object. Example : context.sonar = new Sonar(context.job, context.platform, this) context.sonar.init()","title":"Build Pipeline Overview"},{"location":"user-guide/pipeline-framework/#build-pipeline-stages","text":"Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific. The Build pipeline includes the following default stages: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Get version \u2192 Tests \u2192 Sonar \u2192 Build \u2192 Build Docker Image \u2192 Push \u2192 Git tag . Info To get the full description of every stage, please refer to the EDP Stages Framework section.","title":"Build Pipeline Stages"},{"location":"user-guide/pipeline-framework/#how-to-redefine-or-extend-edp-pipeline-stages-library","text":"Inspect the points below to redefine or extend the EDP Pipeline Stages Library: Create a \u201cstage\u201d folder in the App repository. Create a Groovy file with a meaningful name for the custom stage description. For instance \u2013 CustomBuildMavenApplication.groovy Describe stage logic. Redefinition: import com.epam.edp.stages.ProjectType import com.epam.edp.stages.Stage @Stage ( name = \"compile\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class CustomBuildMavenApplication { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return CustomBuildMavenApplication Extension: import com.epam.edp.stages.ProjectType import com.epam.edp.stages.Stage @Stage ( name = \"new-stage\" , buildTool = \"maven\" , type = ProjectType . APPLICATION ) class NewStageMavenApplication { Script script void run ( context ) { script . sh \"echo 'Your custom logic of the stage'\" } } return NewStageMavenApplication","title":"How to Redefine or Extend EDP Pipeline Stages Library"},{"location":"user-guide/pipeline-framework/#using-edp-stages-library-in-the-pipeline_1","text":"In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following: import library - @Library(['edp-library-stages']) import StageFactory class - import com.epam.edp.stages.StageFactory define context Map \u2013 context = [:] define stagesFactory instance and load EDP stages: context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } After that, there is the ability to run any EDP stage beforehand by defining a requirement context context.factory.getStage(\"checkout\",\"maven\",\"application\").run(context) For instance, the pipeline can look like : @Library ( [ ' edp - library - stages ' ] ) _ import com.epam.edp.stages.StageFactory import org.apache.commons.lang.RandomStringUtils context = [ : ] node ( ' maven ' ) { context . workDir = new File ( \"/tmp/${RandomStringUtils.random(10, true, true)}\" ) context . workDir . deleteDir () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . gerrit = [ : ] context . application = [ : ] context . application . config = [ : ] context . buildTool = [ : ] context . nexus = [ : ] stage ( \"checkout\" ) { context . gerrit . branch = \"master\" context . gerrit . credentialsId = \"jenkins\" context . application . config . cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\" context . factory . getStage ( \"checkout\" , \"maven\" , \"application\" ). run ( context ) } stage ( \"compile\" ) { context . buildTool . command = \"mvn\" context . nexus . credentialsId = \"nexus\" context . factory . getStage ( \"compile\" , \"maven\" , \"application\" ). run ( context ) } } Or in a declarative way : @Library ( [ ' edp - library - stages ' ] ) _ import com.epam.edp.stages.StageFactory import org.apache.commons.lang.RandomStringUtils context = [ : ] pipeline { agent { label ' maven ' } stages { stage ( ' Init ' ){ steps { script { context . workDir = new File ( \"/tmp/${RandomStringUtils.random(10, true, true)}\" ) context . workDir . deleteDir () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . gerrit = [ : ] context . application = [ : ] context . application . config = [ : ] context . buildTool = [ : ] context . nexus = [ : ] } } } stage ( \"Checkout\" ) { steps { script { context . gerrit . branch = \"master\" context . gerrit . credentialsId = \"jenkins\" context . application . config . cloneUrl = \"ssh://jenkins@gerrit:32092/sit-718-cloned-java-maven-project\" context . factory . getStage ( \"checkout\" , \"maven\" , \"application\" ). run ( context ) } } } stage ( ' Compile ' ) { steps { script { context . buildTool . command = \"mvn\" context . nexus . credentialsId = \"nexus\" context . factory . getStage ( \"compile\" , \"maven\" , \"application\" ). run ( context ) } } } } }","title":"Using EDP Stages Library in the Pipeline"},{"location":"user-guide/pipeline-framework/#edp-library-stages-description","text":"Using in pipelines - @Library(['edp-library-stages@version']) The corresponding enums, classes, interfaces and their methods can be used separately from the EDP Stages library function (please refer to Table 5 ). Table 5. Enums and Classes with the respective properties, methods, and examples. Enums Classes ProjectType : - APPLICATION - AUTOTESTS - LIBRARY StageFactory() - Class that contains methods getting an implementation of the particular stage either EDP from shared library or custom from application repository. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Map stages - Map of stages implementations. Methods : loadEdpStages(): return a list of Classes that describes EDP stages implementations. loadCustomStages(String directory): return a list of Classes that describes EDP custom stages from application repository from \"directory\". The \"directory\" should have an absolute path to files with classes of custom stages implementations. Should be run from a Jenkins agent. add(Class clazz): register class for some particular stage in stages map of StageFactory class. getStage(String name, String buildTool, String type): return an object of the class for a particular stage from stages property based on stage name and buildTool, type of application. Example : context.factory = new StageFactory(script: this) context.factory.loadEdpStages().each() { context.factory.add(it) } context.factory.loadCustomStages(\"${context.workDir}/stages\").each() { context.factory.add(it) } context.factory.getStage(stageName.toLowerCase(),context.application.config.build_tool.toLowerCase(), context.application.config.type).run(context)","title":"EDP Library Stages Description"},{"location":"user-guide/pipeline-framework/#edp-stages-framework","text":"Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific. Inspect the Table 6 and Table 7 that contain the full description of every stage that can be included in Code Review and Build pipelines: Checkout \u2192 Gerrit Checkout \u2192 Compile \u2192 Get version \u2192 Tests \u2192 Sonar \u2192 Build \u2192 Build Docker Image \u2192 Push \u2192 Git tag . Table 6. The Checkout, Gerrit Checkout, Compile, Get version, and Tests stages description. Checkout Gerrit Checkout Compile Get version Tests name = \"checkout\", buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - StageFactory context.factory - String context.gerrit.branch - String context.gerrit.credentialsId - String context.application.config.cloneUrl name = \"gerrit-checkout\", buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"] type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY] context required: - String context.workDir - StageFactory context.factory - String context.gerrit.changeName - String context.gerrit.refspecName - String context.gerrit.credentialsId - String context.application.config.cloneUrl name = \"compile\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.sln_filename output: - String context.buildTool.sln_filename buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command - String context.nexus.credentialsId buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command - String context.nexus.credentialsId buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.groupRepository name = \"get-version\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - Map(empty) context.application - String context.gerrit.branch - Job context.job output: -String context.application.deplyableModule - String context.application.deplyableModuleDir - String context.application.version - String context.application.buildVersion buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.command - Job context.job - String context.gerrit.branch output: - String context.application.deplyableModuleDir - String context.application.version - String context.application.buildVersion buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.command - Job context.job - String context.gerrit.branch output: - String context.application.deplyableModule - String context.application.deplyableModuleDir - String context.application.version - String context.application.buildVersion buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - Job context.job - String context.gerrit.branch output: - String context.application.deplyableModuleDir - String context.application.version - String context.application.buildVersion name = \"tests\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.command buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command type = [ProjectType.AUTOTESTS] context required: - String context.workDir - String context.buildTool.command - String context.application.config.report_framework buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir Table 7. The Sonar, Build, Build Docker Image, Push, and Git tag stages description. Sonar Build Build Docker Image Push Git tag name = \"sonar\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.job.type - String context.application.name - String context.buildTool.sln_filename - String context.sonar.route - String context.gerrit.changeName(Only for codereview pipeline) - String context.gerrit.branch(Only for build pipeline) buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.job.type - String context.nexus.credentialsId - String context.buildTool.command - String context.application.name - String context.sonarRoute - String context.gerrit.changeName(Only for codereview pipeline) - String context.gerrit.branch(Only for build pipeline) buildTool = [\"maven\"] type = [ProjectType.APPLICATION, ProjectType.AUTOTESTS, ProjectType.LIBRARY] context required: - String context.workDir - String context.job.type - String context.nexus.credentialsId - String context.application.name - String context.buildTool.command - String context.sonar.route - String context.gerrit.changeName(Only for codereview pipeline) - String context.gerrit.branch(Only for build pipeline) buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.job.type - String context.sonar.route - String context.application.name - String context.gerrit.changeName(Only for codereview pipeline) - String context.gerrit.branch(Only for build pipeline) name = \"build\" buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command - String context.nexus.credentialsId buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.buildTool.command - String context.nexus.credentialsId buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.groupRepository name = \"build-image\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.application.deployableModule - String context.application.deployableModuleDir - String context.application.name - String context.application.config.language - String context.application.buildVersion - Boolean context.job.promoteImages - String context.job.envToPromote buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.application.deployableModule - String context.application.deployableModuleDir - String context.application.name - String context.application.config.language - String context.application.buildVersion - Boolean context.job.promoteImages - String context.job.envToPromote buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.application.deployableModule - String context.application.deployableModuleDir - String context.application.name - String context.application.config.language - String context.application.buildVersion - Boolean context.job.promoteImages - String context.job.envToPromote buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.application.deployableModule - String context.application.deployableModuleDir - String context.application.name - String context.application.config.language - String context.application.buildVersion - Boolean context.job.promoteImages - String context.job.envToPromote name = \"push\" buildTool = [\"dotnet\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.gerrit.project - String context.buildTool.sln_filename - String context.buildTool.snugetApiKey - String context.buildTool.hostedRepository buildTool = [\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.application.version - String context.buildTool.hostedRepository - String context. buildTool.settings buildTool = [\"maven\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.application.version - String context.buildTool.hostedRepository - String context.buildTool.command buildTool = [\"npm\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.nexus.credentialsId - String context.buildTool.hostedRepository - String context.gerrit.autouser name = \"git-tag\" buildTool = [\"maven\", \"npm\", \"dotnet\",\"gradle\"] type = [ProjectType.APPLICATION] context required: - String context.workDir - String context.gerrit.credentialsId - String context.gerrit.sshPort - String context.gerrit.host - String context.gerrit.autouser - String context.application.buildVersion","title":"EDP Stages Framework"},{"location":"user-guide/pipeline-framework/#deploy-pipeline","text":"Deploy() \u2013 a function that allows using the EDP implementation for the deploy pipeline. All values of different parameters that are used during the pipeline execution are stored in the \"Map\" context. The deploy pipeline consists of several steps: On the master: Initialization of all objects (Platform, Job, Gerrit, Nexus, StageFactory) and loading the default implementations of EDP stages; Creating an environment if it doesn`t exist; Deploying the last versions of the applications; Run predefined manual gates. On a particular autotest Jenkins agent that depends on the build tool: Creating workdir for autotest sources; Run predefined autotests.","title":"Deploy Pipeline"},{"location":"user-guide/pipeline-framework/#edp-library-pipelines-description","text":"_Using in pipelines - @Library(['edp-library-pipelines@version']) _ The corresponding enums and interfaces with their methods can be used separately from the EDP Pipelines library function (please refer to Table 8 and Table 9 ). Table 8. Enums and Interfaces with the respective properties, methods, and examples. Enums Interfaces PlatformType : - OPENSHIFT - KUBERNETES JobType : - CODEREVIEW - BUILD - DEPLOY BuildToolType : - MAVEN - GRADLE - NPM - DOTNET Platform() - contains methods for working with platform CLI. At the moment only OpenShift is supported. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Methods : getJsonPathValue(String k8s_kind, String k8s_kind_name, String jsonPath): return String value of specific parameter of particular object using jsonPath utility. Example : context.platform.getJsonPathValue(\"cm\",\"project-settings\", \".data.username\") BuildTool() - contains methods for working with different buildTool from ENUM BuildToolType. (Should be invoked on Jenkins build agents) Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Nexus object - Object of class Nexus. Methods : init: return parameters of buildTool that are needed for running stages. Example : context.buildTool = new BuildToolFactory().getBuildToolImpl (context.application.config.build_tool, this, context.nexus) context.buildTool.init() Table 9. Classes with the respective properties, methods, and examples. Classes Description (properties, methods, and examples) PlatformFactory() - Class that contains methods getting implementation of CLI of platform. At the moment OpenShift and Kubernetes are supported. Methods : getPlatformImpl(PlatformType platform, Script script): return Class Platform Example : context.platform = new PlatformFactory().getPlatformImpl(PlatformType.OPENSHIFT, this) Application(String name, Platform platform, Script script) - Class that describe the application object. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform() String name - Name for the application for creating object Map config - Map of configuration settings for particular application that is loaded from config map project-settings String version - Application version, initially empty. Is set on get-version step. String deployableModule - The name of deployable module for multi module applications, initially empty. String buildVersion - Version of built artifact, contains build number of Job initially empty String deployableModuleDir - The name of deployable module directory for multi module applications, initially empty. Array imageBuildArgs - List of arguments for building application Docker image Methods : setConfig(String gerrit_autouser, String gerrit_host, String gerrit_sshPort, String gerrit_project): set the config property with values from config map Example : context.application = new Application(context.job, context.gerrit.project, context.platform, this) context.application.setConfig(context.gerrit.autouser, context.gerrit.host, context.gerrit.sshPort, context.gerrit.project) Job(type: JobType.value, platform: Platform, script: Script) - Class that describe the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\" Platform platform - Object of a class Platform(). JobType.value type. String deployTemplatesDirectory - The name of the directory in application repository, where deploy templates are located. Can be set for particular Job through DEPLOY_TEMPLATES_DIRECTORY parameter. String edpName - The name of the EDP Project. Map stages - Contains all stages in JSON format that is retrieved from Jenkins job env variable. String envToPromote - The name of the environment for promoting images. Boolean promoteImages - Defines whether images should be promoted or not. Methods : getParameterValue(String parameter, String defaultValue = null): return parameter of ENV variable of Jenkins job. init(): set all the properties of Job object. setDisplayName(String displayName): set display name of the Jenkins job. setDescription(String description, Boolean addDescription = false): set new or add to existing description of the Jenkins job. printDebugInfo(Map context): print context info to log of Jenkins job. runStage(String stage_name, Map context): run the particular stage according to its name. Example : context.job = new Job(JobType.DEPLOY.value, context.platform, this) context.job.init() context.job.printDebugInfo(context) context.job.setDisplayName(\"test\") context.job.setDescription(\"Name: ${context.application.config.name}\") Gerrit(Job job, Platform platform, Script script) - Class that describe the Gerrit tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String credentialsId - Credential Id in Jenkins for Gerrit. String autouser - Username of autouser in Gerrit for integration with Jenkins. String host - Gerrit host. String project - project name of built application. String branch - branch to build application from. String changeNumber - change number of Gerrit commit. String changeName - change name of Gerrit commit. String refspecName - refspecName of Gerrit commit. String sshPort - gerrit ssh port number. String patchsetNumber - patchsetNumber of Gerrit commit. Methods : init(): set all the properties of Gerrit object. Example : context.gerrit = new Gerrit(context.job, context.platform, this) context.gerrit.init() . Nexus(Job job, Platform platform, Script script) - Class that describe the Nexus tool. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\". Platform platform - Object of a class Platform(). Job job - Object of a class Job(). String autouser - Username of autouser in Nexus for integration with Jenkins. String credentialsId - Credential Id in Jenkins for Nexus. String host - Nexus host. String port - Nexus http(s) port. String repositoriesUrl - Base URL of repositories in Nexus. String restUrl - URL of Rest API. Methods : init(): set all the properties of Nexus object. Example : context.nexus = new Nexus(context.job, context.platform, this) context.nexus.init() .","title":"EDP Library Pipelines Description"},{"location":"user-guide/pipeline-framework/#edp-library-stages-description_1","text":"Using in pipelines - @Library(['edp-library-stages@version']) _ The corresponding classes with methods can be used separately from the EDP Pipelines library function (please refer to Table 10 ). Table 10. Classes with the respective properties, methods, and examples. Classes Description (properties, methods, and examples) StageFactory() - Class that contains methods getting implementation of particular stage either EDP from shared library or custom from application repository. Properties : Script script - Object with type script, in most cases if class created from Jenkins pipelines it is \"this\" Map stages - Map of stages implementations Methods : loadEdpStages(): return list of Classes that describes EDP stages implementations loadCustomStages(String directory): return list of Classes that describes EDP custom stages from application repository from \"directory\". The \"directory\" should be absolute path to files with classes of custom stages implementations. Should be run from Jenkins agent. add(Class clazz): register class for some particular stage in stages map of StageFactory class getStage(String name, String buildTool, String type): return object of the class for particular stage from stages property based on stage name and buildTool, type of application Example : context.factory = new StageFactory(script: this) context.factory.loadEdpStages().each() { context.factory.add(it) } context.factory.loadCustomStages(\"${context.workDir}/stages\").each() { context.factory.add(it) } context.factory.getStage(stageName.toLowerCase(),context.application.config.build_tool.toLowerCase(), context.application.config.type).run(context) .","title":"EDP Library Stages Description"},{"location":"user-guide/pipeline-framework/#deploy-pipeline-stages","text":"Each EDP stage implementation has run method that is as input parameter required to pass a context map with different keys. Some stages can implement the logic for several build tools and application types, some of them are specific. The stages for the deploy pipeline are independent of the build tool and application type. Find below (see Table 11 ) the full description of every stage: Deploy \u2192 Automated tests \u2192 Promote Images . Table 11. The Deploy, Automated tests, and Promote Images stages description. Deploy Automated tests Promote Images name = \"deploy\" buildTool = null type = null context required: \u2022 String context.workDir \u2022 StageFactory context.factory \u2022 String context.gerrit.autouser \u2022 String context.gerrit.host \u2022 String context.application.config.cloneUrl \u2022 String context.jenkins.token \u2022 String context.job.edpName \u2022 String context.job.buildUrl \u2022 String context.job.jenkinsUrl \u2022 String context.job.metaProject \u2022 List context.job.applicationsList [['name':'application1_name','version':'application1_version],...] \u2022 String context.job.deployTemplatesDirectory output: \u2022 List context.job.updatedApplicaions [['name':'application1_name','version':'application1_version],...] name = \"automation-tests\", buildTool = null, type = null context required: - String context.workDir - StageFactory context.factory - String context.gerrit.credentialsId - String context.autotest.config.cloneUrl - String context.autotest.name - String context.job.stageWithoutPrefixName - String context.buildTool.settings - String context.autotest.config.report_framework name = \"promote-images\" buildTool = null type = null context required: - String context.workDir - String context.buildTool.sln_filename - List context.job.updatedApplicaions [['name':'application1_name','version':'application1_version],...]","title":"Deploy Pipeline Stages"},{"location":"user-guide/pipeline-framework/#how-to-redefine-or-extend-edp-pipeline-stages-library_1","text":"Info Currently, the redefinition of Deploy pipeline stages is prohibited.","title":"How to Redefine or Extend EDP Pipeline Stages Library"},{"location":"user-guide/pipeline-framework/#using-edp-library-stages-in-the-pipeline","text":"In order to use the EDP stages, the created pipeline should fit some requirements, that`s why a developer has to do the following: import libraries - @Library(['edp-library-stages', 'edp-library-pipelines']) _ import reference EDP classes(See example below) define context Map \u2013 context = [:] define reference \"init\" stage After that, there is the ability to run any EDP stage beforehand by defining requirement context context.job.runStage(\"Deploy\", context) . For instance, the pipeline can look like : @Library ( [ ' edp - library - stages ' , ' edp - library - pipelines ' ] ) _ import com.epam.edp.stages.StageFactory import com.epam.edp.platform.PlatformFactory import com.epam.edp.platform.PlatformType import com.epam.edp.JobType context = [ : ] node ( ' master ' ) { stage ( \"Init\" ) { context . platform = new PlatformFactory (). getPlatformImpl ( PlatformType . OPENSHIFT , this ) context . job = new com . epam . edp . Job ( JobType . DEPLOY . value , context . platform , this ) context . job . init () context . job . initDeployJob () println ( \"[JENKINS][DEBUG] Created object job with type - ${context.job.type}\" ) context . nexus = new com . epam . edp . Nexus ( context . job , context . platform , this ) context . nexus . init () context . jenkins = new com . epam . edp . Jenkins ( context . job , context . platform , this ) context . jenkins . init () context . gerrit = new com . epam . edp . Gerrit ( context . job , context . platform , this ) context . gerrit . init () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . environment = new com . epam . edp . Environment ( context . job . deployProject , context . platform , this ) context . job . printDebugInfo ( context ) context . job . setDisplayName ( \"${currentBuild.displayName}-${context.job.deployProject}\" ) context . job . generateInputDataForDeployJob () } stage ( \"Pre Deploy Custom stage\" ) { println ( \"Some custom pre deploy logic\" ) } context . job . runStage ( \"Deploy\" , context ) stage ( \"Post Deploy Custom stage\" ) { println ( \"Some custom post deploy logic\" ) } } Or in a declarative way : @Library ( [ ' edp - library - stages ' , ' edp - library - pipelines ' ] ) _ import com.epam.edp.stages.StageFactory import com.epam.edp.platform.PlatformFactory import com.epam.edp.platform.PlatformType import com.epam.edp.JobType context = [ : ] pipeline { agent { label ' master ' } stages { stage ( ' Init ' ) { steps { script { context . platform = new PlatformFactory (). getPlatformImpl ( PlatformType . OPENSHIFT , this ) context . job = new com . epam . edp . Job ( JobType . DEPLOY . value , context . platform , this ) context . job . init () context . job . initDeployJob () println ( \"[JENKINS][DEBUG] Created object job with type - ${context.job.type}\" ) context . nexus = new com . epam . edp . Nexus ( context . job , context . platform , this ) context . nexus . init () context . jenkins = new com . epam . edp . Jenkins ( context . job , context . platform , this ) context . jenkins . init () context . gerrit = new com . epam . edp . Gerrit ( context . job , context . platform , this ) context . gerrit . init () context . factory = new StageFactory ( script : this ) context . factory . loadEdpStages (). each () { context . factory . add ( it ) } context . environment = new com . epam . edp . Environment ( context . job . deployProject , context . platform , this ) context . job . printDebugInfo ( context ) context . job . setDisplayName ( \"${currentBuild.displayName}-${context.job.deployProject}\" ) context . job . generateInputDataForDeployJob () } } } stage ( ' Deploy ' ) { steps { script { context . factory . getStage ( \"deploy\" ). run ( context ) } } } stage ( ' Custom stage ' ) { steps { println ( \"Some custom logic\" ) } } } }","title":"Using EDP Library Stages in the Pipeline"},{"location":"user-guide/pipeline-framework/#related-articles","text":"Add Application Add Library Add CD Pipeline CI Pipeline Details CD Pipeline Details Customize CI Pipeline Customize CD Pipeline EDP Stages Glossary Use Terraform Library in EDP","title":"Related Articles"},{"location":"user-guide/pipeline-stages/","text":"Pipeline Stages \u2693\ufe0e Get acquainted with EDP CI/CD workflow and stages description. EDP CI/CD Workflow \u2693\ufe0e Within EDP, the pipeline framework comprises the following pipelines: Code Review; Build; Deploy. Note Please refer to the EDP Pipeline Framework page for details. The diagram below shows the delivery path through these pipelines and the respective stages. Please be aware that stages may differ for different codebase types. Stages Description \u2693\ufe0e The table below provides the details on all the stages in the EDP pipeline framework: Name Dependency Description Pipeline Application Library Autotest Source code Documentation init Initiates information gathering Create Release, Code Review, Build + + Build.groovy checkout Performs for all files the checkout from a selected branch of the Git repository. For the main branch - from HEAD, for code review - from the commit Create Release, Build + + Checkout.groovy compile Compiles the code, includes individual groovy files for each type of app or lib (NPM, DotNet, Python, Maven, Gradle) Code Review, Build + + Compile tests Launches testing procedure, includes individual groovy files for each type of app or lib Code Review, Build + + + Tests sonar Launches testing via SonarQube scanner and includes individual groovy files for each type of app or lib Code Review, Build + + Sonar build Builds the application, includes individual groovy files for each type of app or lib (Go, Maven, Gradle, NPM) Code Review, Build + Build create-branch EDP create-release process Creates default branch in Gerrit during create and clone strategies Create Release + + + CreateBranch.groovy trigger-job EDP create-release process Triggers \"build\" job Create Release + + + TriggerJob.groovy gerrit-checkout Performs checkout to the current project branch in Gerrit Code Review + + + GerritCheckout.groovy commit-validate Optional in EDP Admin Console Takes Jira parameters, when \"Jira Integration\" is enabled for the project in the Admin Console. Code Review + + CommitValidate.groovy dockerfile-lint Launches linting tests for Dockerfile Code Review + LintDockerApplicationLibrary.groovy Use Dockerfile Linters for Code Review dockerbuild-verify \"Build\" stage (if there are no \"COPY\" layers in Dockerfile) Launches build procedure for Dockerfile without pushing an image to the repository Code Review + BuildDockerfileApplicationLibrary.groovy Use Dockerfile Linters for Code Review helm-lint Launches linting tests for deployment charts Code Review + LintHelmApplicationLibrary.groovy Use Dockerfile Linters for Code Review get-version Defines the versioning of the project depending on the versioning schema selected in Admin Console Build + + GetVersion terraform-plan AWS credentials added to Jenkins Checks Terraform version, and installs default version if necessary, and launches terraform init, returns AWS username which used for action, and terraform plan command is called with an output of results to .tfplan file Build + TerraformPlan.groovy Use Terraform library in EDP terraform-apply AWS credentials added to Jenkins, the \"Terraform-plan\" stage Checks Terraform version, and installs default version if necessary, and launches terraform init, launches terraform plan from saves before .tfplan file, asks to approve, and run terraform apply from .tfplan file Build + TerraformApply.groovy Use Terraform library in EDP build-image-from-dockerfile Platform: OpenShift Builds Dockerfile Build + + .groovy files for building Dockerfile image build-image-kaniko Platform: k8s Builds Dockerfile using the Kaniko tool Build + BuildImageKaniko.groovy push Pushes an artifact to the Nexus repository Build + + Push create-Jira-issue-metadata \"get-version\" stage Creates a temporary CR in the namespace and after that pushes Jira Integration data to Jira ticket, and delete CR Build + + JiraIssueMetadata.groovy ecr-to-docker DockerHub credentials added to Jenkins Copies the docker image from the ECR project registry to DockerHub via the Crane tool after it is built Build + EcrToDocker.groovy Promote Docker Images From ECR to Docker Hub git-tag \"Get-version\" stage Creates a tag in SCM for the current build Build + + GitTagApplicationLibrary.groovy deploy Deploys the application Deploy + Deploy.groovy manual Works with the manual approve to proceed Deploy + ManualApprove.groovy promote-images Promotes docker images to the registry Deploy + PromoteImage.groovy Note The Create Release pipeline is an internal EDP mechanism for adding, importing or cloning a codebase. It is not a part of the pipeline framework. Related Articles \u2693\ufe0e Manage Jenkins CI Job Provisioner GitLab Integration GitHub Integration","title":"Overview"},{"location":"user-guide/pipeline-stages/#pipeline-stages","text":"Get acquainted with EDP CI/CD workflow and stages description.","title":"Pipeline Stages"},{"location":"user-guide/pipeline-stages/#edp-cicd-workflow","text":"Within EDP, the pipeline framework comprises the following pipelines: Code Review; Build; Deploy. Note Please refer to the EDP Pipeline Framework page for details. The diagram below shows the delivery path through these pipelines and the respective stages. Please be aware that stages may differ for different codebase types.","title":"EDP CI/CD Workflow"},{"location":"user-guide/pipeline-stages/#stages-description","text":"The table below provides the details on all the stages in the EDP pipeline framework: Name Dependency Description Pipeline Application Library Autotest Source code Documentation init Initiates information gathering Create Release, Code Review, Build + + Build.groovy checkout Performs for all files the checkout from a selected branch of the Git repository. For the main branch - from HEAD, for code review - from the commit Create Release, Build + + Checkout.groovy compile Compiles the code, includes individual groovy files for each type of app or lib (NPM, DotNet, Python, Maven, Gradle) Code Review, Build + + Compile tests Launches testing procedure, includes individual groovy files for each type of app or lib Code Review, Build + + + Tests sonar Launches testing via SonarQube scanner and includes individual groovy files for each type of app or lib Code Review, Build + + Sonar build Builds the application, includes individual groovy files for each type of app or lib (Go, Maven, Gradle, NPM) Code Review, Build + Build create-branch EDP create-release process Creates default branch in Gerrit during create and clone strategies Create Release + + + CreateBranch.groovy trigger-job EDP create-release process Triggers \"build\" job Create Release + + + TriggerJob.groovy gerrit-checkout Performs checkout to the current project branch in Gerrit Code Review + + + GerritCheckout.groovy commit-validate Optional in EDP Admin Console Takes Jira parameters, when \"Jira Integration\" is enabled for the project in the Admin Console. Code Review + + CommitValidate.groovy dockerfile-lint Launches linting tests for Dockerfile Code Review + LintDockerApplicationLibrary.groovy Use Dockerfile Linters for Code Review dockerbuild-verify \"Build\" stage (if there are no \"COPY\" layers in Dockerfile) Launches build procedure for Dockerfile without pushing an image to the repository Code Review + BuildDockerfileApplicationLibrary.groovy Use Dockerfile Linters for Code Review helm-lint Launches linting tests for deployment charts Code Review + LintHelmApplicationLibrary.groovy Use Dockerfile Linters for Code Review get-version Defines the versioning of the project depending on the versioning schema selected in Admin Console Build + + GetVersion terraform-plan AWS credentials added to Jenkins Checks Terraform version, and installs default version if necessary, and launches terraform init, returns AWS username which used for action, and terraform plan command is called with an output of results to .tfplan file Build + TerraformPlan.groovy Use Terraform library in EDP terraform-apply AWS credentials added to Jenkins, the \"Terraform-plan\" stage Checks Terraform version, and installs default version if necessary, and launches terraform init, launches terraform plan from saves before .tfplan file, asks to approve, and run terraform apply from .tfplan file Build + TerraformApply.groovy Use Terraform library in EDP build-image-from-dockerfile Platform: OpenShift Builds Dockerfile Build + + .groovy files for building Dockerfile image build-image-kaniko Platform: k8s Builds Dockerfile using the Kaniko tool Build + BuildImageKaniko.groovy push Pushes an artifact to the Nexus repository Build + + Push create-Jira-issue-metadata \"get-version\" stage Creates a temporary CR in the namespace and after that pushes Jira Integration data to Jira ticket, and delete CR Build + + JiraIssueMetadata.groovy ecr-to-docker DockerHub credentials added to Jenkins Copies the docker image from the ECR project registry to DockerHub via the Crane tool after it is built Build + EcrToDocker.groovy Promote Docker Images From ECR to Docker Hub git-tag \"Get-version\" stage Creates a tag in SCM for the current build Build + + GitTagApplicationLibrary.groovy deploy Deploys the application Deploy + Deploy.groovy manual Works with the manual approve to proceed Deploy + ManualApprove.groovy promote-images Promotes docker images to the registry Deploy + PromoteImage.groovy Note The Create Release pipeline is an internal EDP mechanism for adding, importing or cloning a codebase. It is not a part of the pipeline framework.","title":"Stages Description"},{"location":"user-guide/pipeline-stages/#related-articles","text":"Manage Jenkins CI Job Provisioner GitLab Integration GitHub Integration","title":"Related Articles"},{"location":"user-guide/prepare-for-release/","text":"Prepare for Release \u2693\ufe0e After the necessary applications are added to EDP, they can be managed via the Admin Console. To prepare for the release, create a new branch from a selected commit with a set of CI pipelines (Code Review and Build pipelines), launch the Build pipeline, and add a new CD pipeline as well. Note Please refer to the Add Application and Add CD Pipeline for the details on how to add an application or a CD pipeline. Become familiar with the following preparation steps for release and a CD pipeline structure: Create a new branch Launch the Build pipeline Add a new CD pipeline Check CD pipeline structure Create a New Branch \u2693\ufe0e Open Gerrit via the Admin Console Overview page to have this tab available in a web browser. Being in Admin Console, open the Applications section and click an application from the list to create a new branch. Once clicked the application name, scroll down to the Branches menu and click the Create button to open the Create New Branch dialog box, fill in the Branch Name field by typing a branch name. Open the Gerrit tab in the web browser, navigate to Projects \u2192 List \u2192 select the application \u2192 Branches \u2192 gitweb for a necessary branch. Select the commit that will be the last included to a new branch commit. Copy to clipboard the commit hash. Paste the copied hash to the From Commit Hash field and click Proceed. Note If the commit hash is not added to the From Commit Hash field, the new branch will be created from the head of the master branch. Launch the Build Pipeline \u2693\ufe0e After the new branches are added, open the details page of every application and click the CI link that refers to Jenkins. Note The adding of a new branch may take some time. As soon as the new branch is created, it will be displayed in the list of the Branches menu. To build a new version of a corresponding Docker container (an image stream in OpenShift terms) for the new branch, start the Build pipeline. Being in Jenkins, select the new branch tab and click the link to the Build pipeline. Navigate to the Build with Parameters option and click the Build button to launch the Build pipeline. Warning The predefined default parameters should not be changed when triggering the Build pipeline, otherwise, it will lead to the pipeline failure. Add a New CD Pipeline \u2693\ufe0e Add a new CD pipeline and indicate the new release branch using the Admin console tool. Pay attention to the Applications menu, the necessary application(s) should be selected there, as well as the necessary branch(es) from the drop-down list. Note For the details on how to add a CD pipeline, please refer to the Add CD Pipeline page. As soon as the Build pipelines are successfully passed in Jenkins, the Docker Registry, which is used in EDP by default, will have the new image streams (Docker container in Kubernetes terms) version that corresponds to the current branch. Open the Kubernetes/OpenShift page of the project via the Admin Console Overview page \u2192 go to CodebaseImageStream (in OpenShift, go to Builds \u2192 Images) \u2192 check whether the image streams are created under the specific name (the combination of the application and branch names) and the specific tags are added. Click every image stream link. Check CD Pipeline Structure \u2693\ufe0e When the CD pipeline is added through the Admin Console, it becomes available in the CD pipelines list. Every pipeline has the details page with the additional information. To explore the CD pipeline structure, follow the steps below: Open Admin Console and navigate to Continuous Delivery section, click the newly created CD pipeline name. Discover the CD pipeline components: Applications - the list of applications with the image streams and links to Jenkins for the respective branch; Stages - a set of stages with the defined characteristics and links to Kubernetes/OpenShift project; Note Initially, an environment is empty and does not have any deployment unit. When deploying the subsequent stages, the artifacts of the selected versions will be deployed to the current project and the environment will display the current stage status. The project has a standard pattern: \u2039edp-name\u203a-\u2039pipeline-name\u203a-\u2039stage-name\u203a. Deployed Versions - the deployment status of the specific application and the predefined stage. Launch CD Pipeline Manually \u2693\ufe0e Follow the steps below to deploy the QA and UAT application stages: As soon as the Build pipelines for both applications are successfully passed, the new version of the Docker container will appear, thus allowing to launch the CD pipeline. Simply navigate to Continuous Delivery and click the pipeline name to open it in Jenkins. Click the QA stage link. Deploy the QA stage by clicking the Build Now option. After the initialization step starts, in case another menu is opened, the Pause for Input option will appear. Select the application version in the drop-down list and click Proceed. The pipeline passes the following stages: Init - initialization of the Jenkins pipeline outputs with the stages that are the Groovy scripts that execute the current code; Deploy - the deployment of the selected versions of the docker container and third-party services. As soon as the Deployed pipeline stage is completed, the respective environment will be deployed. Approve - the verification stage that enables to Proceed or Abort this stage; Promote-images - the creation of the new image streams for the current versions with the pattern combination: [pipeline name]-[stage name]-[application name]-[verified]; After all the stages are passed, the new image streams will be created in the Kubernetes/OpenShift with the new names. Deploy the UAT stage, which takes the versions that were verified during the QA stage, by clicking the Build Now option, and select the necessary application versions. The launch process is the same as for all the deploy pipelines. To get the status of the pipeline deployment, open the CD pipeline details page and check the Deployed versions state. CD Pipeline as a Team Environment \u2693\ufe0e Admin Console allows creating a CD pipeline with a part of the application set as a team environment. To do this, perform the following steps; Open the Continuous Delivery section \u2192 click the Create button \u2192 enter the pipeline name (e.g. team-a) \u2192 select ONE application and choose the master branch for it \u2192 add one DEV stage. As soon as the CD pipeline is added to the CD pipelines list, its details page will display the links to Jenkins and Kubernetes/OpenShift. Open Jenkins and deploy the DEV stage by clicking the Build Now option. Kubernetes/OpenShift keeps an independent environment that allows checking the new versions, thus speeding up the developing process when working with several microservices. As a result, the team will have the same abilities to verify the code changes when developing and during the release. Related Articles \u2693\ufe0e Add Application Add CD Pipeline Autotest as Qulity Gate Build Pipeline CD Pipeline Details Customize CD Pipeline","title":"Prepare for Release"},{"location":"user-guide/prepare-for-release/#prepare-for-release","text":"After the necessary applications are added to EDP, they can be managed via the Admin Console. To prepare for the release, create a new branch from a selected commit with a set of CI pipelines (Code Review and Build pipelines), launch the Build pipeline, and add a new CD pipeline as well. Note Please refer to the Add Application and Add CD Pipeline for the details on how to add an application or a CD pipeline. Become familiar with the following preparation steps for release and a CD pipeline structure: Create a new branch Launch the Build pipeline Add a new CD pipeline Check CD pipeline structure","title":"Prepare for Release"},{"location":"user-guide/prepare-for-release/#create-a-new-branch","text":"Open Gerrit via the Admin Console Overview page to have this tab available in a web browser. Being in Admin Console, open the Applications section and click an application from the list to create a new branch. Once clicked the application name, scroll down to the Branches menu and click the Create button to open the Create New Branch dialog box, fill in the Branch Name field by typing a branch name. Open the Gerrit tab in the web browser, navigate to Projects \u2192 List \u2192 select the application \u2192 Branches \u2192 gitweb for a necessary branch. Select the commit that will be the last included to a new branch commit. Copy to clipboard the commit hash. Paste the copied hash to the From Commit Hash field and click Proceed. Note If the commit hash is not added to the From Commit Hash field, the new branch will be created from the head of the master branch.","title":"Create a New Branch"},{"location":"user-guide/prepare-for-release/#launch-the-build-pipeline","text":"After the new branches are added, open the details page of every application and click the CI link that refers to Jenkins. Note The adding of a new branch may take some time. As soon as the new branch is created, it will be displayed in the list of the Branches menu. To build a new version of a corresponding Docker container (an image stream in OpenShift terms) for the new branch, start the Build pipeline. Being in Jenkins, select the new branch tab and click the link to the Build pipeline. Navigate to the Build with Parameters option and click the Build button to launch the Build pipeline. Warning The predefined default parameters should not be changed when triggering the Build pipeline, otherwise, it will lead to the pipeline failure.","title":"Launch the Build Pipeline"},{"location":"user-guide/prepare-for-release/#add-a-new-cd-pipeline","text":"Add a new CD pipeline and indicate the new release branch using the Admin console tool. Pay attention to the Applications menu, the necessary application(s) should be selected there, as well as the necessary branch(es) from the drop-down list. Note For the details on how to add a CD pipeline, please refer to the Add CD Pipeline page. As soon as the Build pipelines are successfully passed in Jenkins, the Docker Registry, which is used in EDP by default, will have the new image streams (Docker container in Kubernetes terms) version that corresponds to the current branch. Open the Kubernetes/OpenShift page of the project via the Admin Console Overview page \u2192 go to CodebaseImageStream (in OpenShift, go to Builds \u2192 Images) \u2192 check whether the image streams are created under the specific name (the combination of the application and branch names) and the specific tags are added. Click every image stream link.","title":"Add a New CD Pipeline"},{"location":"user-guide/prepare-for-release/#check-cd-pipeline-structure","text":"When the CD pipeline is added through the Admin Console, it becomes available in the CD pipelines list. Every pipeline has the details page with the additional information. To explore the CD pipeline structure, follow the steps below: Open Admin Console and navigate to Continuous Delivery section, click the newly created CD pipeline name. Discover the CD pipeline components: Applications - the list of applications with the image streams and links to Jenkins for the respective branch; Stages - a set of stages with the defined characteristics and links to Kubernetes/OpenShift project; Note Initially, an environment is empty and does not have any deployment unit. When deploying the subsequent stages, the artifacts of the selected versions will be deployed to the current project and the environment will display the current stage status. The project has a standard pattern: \u2039edp-name\u203a-\u2039pipeline-name\u203a-\u2039stage-name\u203a. Deployed Versions - the deployment status of the specific application and the predefined stage.","title":"Check CD Pipeline Structure"},{"location":"user-guide/prepare-for-release/#launch-cd-pipeline-manually","text":"Follow the steps below to deploy the QA and UAT application stages: As soon as the Build pipelines for both applications are successfully passed, the new version of the Docker container will appear, thus allowing to launch the CD pipeline. Simply navigate to Continuous Delivery and click the pipeline name to open it in Jenkins. Click the QA stage link. Deploy the QA stage by clicking the Build Now option. After the initialization step starts, in case another menu is opened, the Pause for Input option will appear. Select the application version in the drop-down list and click Proceed. The pipeline passes the following stages: Init - initialization of the Jenkins pipeline outputs with the stages that are the Groovy scripts that execute the current code; Deploy - the deployment of the selected versions of the docker container and third-party services. As soon as the Deployed pipeline stage is completed, the respective environment will be deployed. Approve - the verification stage that enables to Proceed or Abort this stage; Promote-images - the creation of the new image streams for the current versions with the pattern combination: [pipeline name]-[stage name]-[application name]-[verified]; After all the stages are passed, the new image streams will be created in the Kubernetes/OpenShift with the new names. Deploy the UAT stage, which takes the versions that were verified during the QA stage, by clicking the Build Now option, and select the necessary application versions. The launch process is the same as for all the deploy pipelines. To get the status of the pipeline deployment, open the CD pipeline details page and check the Deployed versions state.","title":"Launch CD Pipeline Manually"},{"location":"user-guide/prepare-for-release/#cd-pipeline-as-a-team-environment","text":"Admin Console allows creating a CD pipeline with a part of the application set as a team environment. To do this, perform the following steps; Open the Continuous Delivery section \u2192 click the Create button \u2192 enter the pipeline name (e.g. team-a) \u2192 select ONE application and choose the master branch for it \u2192 add one DEV stage. As soon as the CD pipeline is added to the CD pipelines list, its details page will display the links to Jenkins and Kubernetes/OpenShift. Open Jenkins and deploy the DEV stage by clicking the Build Now option. Kubernetes/OpenShift keeps an independent environment that allows checking the new versions, thus speeding up the developing process when working with several microservices. As a result, the team will have the same abilities to verify the code changes when developing and during the release.","title":"CD Pipeline as a Team Environment"},{"location":"user-guide/prepare-for-release/#related-articles","text":"Add Application Add CD Pipeline Autotest as Qulity Gate Build Pipeline CD Pipeline Details Customize CD Pipeline","title":"Related Articles"},{"location":"user-guide/terraform-stages/","text":"CI Pipeline for Terraform \u2693\ufe0e EPAM Delivery Platform ensures the implemented Terraform support allowing to work with Terraform code that is processed by means of stages in the Code-Review and Build pipelines. These pipelines are expected to be created after the Terraform Library is added. Code Review Pipeline Stages \u2693\ufe0e In the Code Review pipeline, the following stages are available: checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository. terraform-lint stage containing a script that performs the following actions: 2.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager . 2.2. Launches the terraform init command that initializes backend. 2.3. Launches the linters described below. Pay attention that if at least one of these checks is not true (returns with an error), the Code Review pipeline will fail on this step and will be displayed in red. * terraform fmt linter checks the formatting of the Terraform code; * tflint linter checks Terraform linters for possible errors and deprecated syntax; * terraform validate linter validates the Terraform code. Build Pipeline Stages \u2693\ufe0e In the Build pipeline, the following stages are available: checkout stage is a standard step during which all files are checked out from a master branch of Git repository. Note With the default versioning, in the base directory of the project, create a file named 'VERSION' with a proper Terraform version (e.g.1.0.0). terraform-lint stage containing a script that performs the same actions as in the Code Review pipeline, namely: 2.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager . 2.2. Launches the terraform init stage that initializes backend. 2.3. Launches the linters described below. Pay attention that if at least one of these checks is not true (returns with an error), the Build pipeline will fail on this step and will be displayed in red. - terraform fmt linter checks the formatting of the Terraform code; - tflint linter checks Terraform linters for possible errors and deprecated syntax; - terraform validate linter validates the Terraform code. terraform-plan stage containing a script that performs the following actions: 3.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager . 3.2. Launches the terraform init command that initializes backend. 3.3. Returns the name of the user, on behalf of whom the actions will be performed, with the help of awscliv2 . 3.4. Launches the terraform-plan command saving the results in the .tfplan file. Note EDP expects AWS credentials to be added in Jenkins under the name aws.user . To learn how to create credentials for the terraform-plan and terraform-apply stages, see the section Create AWS Credentials . terraform-apply stage containing a script that performs the following actions: 4.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager . 4.2. Launches the terraform init command that initializes backend. 4.3. Launches the terraform-plan command saving the results in the tfplan file. 4.4. Approves the application of Terraform code in your project by manually clicking the Proceed button. To decline the Terraform code, click the Abort button. If none of the buttons is selected within 30 minutes, by default the terraform-plan command will not be applied. 4.5. Launches the terraform-apply command. Create AWS Credentials \u2693\ufe0e To create credentials that will be used in terraform-plan and terraform-apply stages, perform the following steps: 1. Go to Jenkins -> Manage Jenkins -> Manage Credentials . In the Store scoped to Jenkins section select global as Domains . 2. Click the Add Credentials tab and select AWS Credentials in the Kind dropdown. 3. Enter the ID name. By default, EDP expects AWS credentials to be under the ID aws.user . 4. Enter values into the Access Key ID and Secret Access Key fields (credentials should belong to a user in AWS). 5. Click OK to save these credentials. Now the ID of the credentials is visible in the Global credentials table in Jenkins. Use Existing AWS Credentials \u2693\ufe0e To use other existing credentials (e.g. from other accounts) instead of the expected ones in the Build pipeline and in the terraform-plan and terraform-apply stages, perform the following steps: Navigate to the Build pipeline and select the Configure tab. Click the Add Parameter button and select the String Parameter option. Fill in the respective fields with the variable name AWS_CREDENTIALS , description, and the default value (e.g., aws.user , used previously in pipelines). Now during the launch of the Build pipeline, it is possible to select the desired credentials, added in Jenkins, in the AWS_CREDENTIALS field of the Build pipeline settings. Related Articles \u2693\ufe0e EDP Pipeline Framework Associate IAM Roles With Service Accounts","title":"Terraform"},{"location":"user-guide/terraform-stages/#ci-pipeline-for-terraform","text":"EPAM Delivery Platform ensures the implemented Terraform support allowing to work with Terraform code that is processed by means of stages in the Code-Review and Build pipelines. These pipelines are expected to be created after the Terraform Library is added.","title":"CI Pipeline for Terraform"},{"location":"user-guide/terraform-stages/#code-review-pipeline-stages","text":"In the Code Review pipeline, the following stages are available: checkout stage, a standard step during which all files are checked out from a selected branch of the Git repository. terraform-lint stage containing a script that performs the following actions: 2.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager . 2.2. Launches the terraform init command that initializes backend. 2.3. Launches the linters described below. Pay attention that if at least one of these checks is not true (returns with an error), the Code Review pipeline will fail on this step and will be displayed in red. * terraform fmt linter checks the formatting of the Terraform code; * tflint linter checks Terraform linters for possible errors and deprecated syntax; * terraform validate linter validates the Terraform code.","title":"Code Review Pipeline Stages"},{"location":"user-guide/terraform-stages/#build-pipeline-stages","text":"In the Build pipeline, the following stages are available: checkout stage is a standard step during which all files are checked out from a master branch of Git repository. Note With the default versioning, in the base directory of the project, create a file named 'VERSION' with a proper Terraform version (e.g.1.0.0). terraform-lint stage containing a script that performs the same actions as in the Code Review pipeline, namely: 2.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager . 2.2. Launches the terraform init stage that initializes backend. 2.3. Launches the linters described below. Pay attention that if at least one of these checks is not true (returns with an error), the Build pipeline will fail on this step and will be displayed in red. - terraform fmt linter checks the formatting of the Terraform code; - tflint linter checks Terraform linters for possible errors and deprecated syntax; - terraform validate linter validates the Terraform code. terraform-plan stage containing a script that performs the following actions: 3.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager . 3.2. Launches the terraform init command that initializes backend. 3.3. Returns the name of the user, on behalf of whom the actions will be performed, with the help of awscliv2 . 3.4. Launches the terraform-plan command saving the results in the .tfplan file. Note EDP expects AWS credentials to be added in Jenkins under the name aws.user . To learn how to create credentials for the terraform-plan and terraform-apply stages, see the section Create AWS Credentials . terraform-apply stage containing a script that performs the following actions: 4.1. Checks whether the repository contains the .terraform-version file, where the information about the Terraform version is stored. If there is no .terraform-version file, the default Terraform version (0.14.5) will be used on this stage. In order to install different versions of Terraform, use the Terraform version manager . 4.2. Launches the terraform init command that initializes backend. 4.3. Launches the terraform-plan command saving the results in the tfplan file. 4.4. Approves the application of Terraform code in your project by manually clicking the Proceed button. To decline the Terraform code, click the Abort button. If none of the buttons is selected within 30 minutes, by default the terraform-plan command will not be applied. 4.5. Launches the terraform-apply command.","title":"Build Pipeline Stages"},{"location":"user-guide/terraform-stages/#create-aws-credentials","text":"To create credentials that will be used in terraform-plan and terraform-apply stages, perform the following steps: 1. Go to Jenkins -> Manage Jenkins -> Manage Credentials . In the Store scoped to Jenkins section select global as Domains . 2. Click the Add Credentials tab and select AWS Credentials in the Kind dropdown. 3. Enter the ID name. By default, EDP expects AWS credentials to be under the ID aws.user . 4. Enter values into the Access Key ID and Secret Access Key fields (credentials should belong to a user in AWS). 5. Click OK to save these credentials. Now the ID of the credentials is visible in the Global credentials table in Jenkins.","title":"Create AWS Credentials"},{"location":"user-guide/terraform-stages/#use-existing-aws-credentials","text":"To use other existing credentials (e.g. from other accounts) instead of the expected ones in the Build pipeline and in the terraform-plan and terraform-apply stages, perform the following steps: Navigate to the Build pipeline and select the Configure tab. Click the Add Parameter button and select the String Parameter option. Fill in the respective fields with the variable name AWS_CREDENTIALS , description, and the default value (e.g., aws.user , used previously in pipelines). Now during the launch of the Build pipeline, it is possible to select the desired credentials, added in Jenkins, in the AWS_CREDENTIALS field of the Build pipeline settings.","title":"Use Existing AWS Credentials"},{"location":"user-guide/terraform-stages/#related-articles","text":"EDP Pipeline Framework Associate IAM Roles With Service Accounts","title":"Related Articles"}]}